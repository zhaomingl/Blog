{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme-pure/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/css/style.min.css","path":"css/style.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/README.md","path":"fonts/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.eot","path":"fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.woff","path":"fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.ttf","path":"fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.svg","path":"fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/xingqiu-qrcode.jpg","path":"images/xingqiu-qrcode.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/thumb-default.png","path":"images/thumb-default.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/application.js","path":"js/application.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/application.min.js","path":"js/application.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/plugin.js.map","path":"js/plugin.js.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/plugin.js","path":"js/plugin.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/js/plugin.min.js","path":"js/plugin.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/donate/alipayimg.png","path":"images/donate/alipayimg.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/donate/wechatpayimg.png","path":"images/donate/wechatpayimg.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/favatar/SzsFox-logo.png","path":"images/favatar/SzsFox-logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/favatar/chuangzaoshi-logo.png","path":"images/favatar/chuangzaoshi-logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-pure/source/images/favatar/idesign-logo.png","path":"images/favatar/idesign-logo.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/BEM命名规范.md","hash":"c5ce36a06f172a0a1389bdcd84e1fb3eead631cd","modified":1675858829690},{"_id":"source/_posts/CSS2D转换.md","hash":"c6dfa25468c372298d4942316ef417cea0ffe4e0","modified":1673265405457},{"_id":"source/_posts/CSS中的定位.md","hash":"83ad839e34164ceeac38161f35e1efa103bddc70","modified":1673265782649},{"_id":"source/_posts/CSS三大特性.md","hash":"0f3c2d6959bc4165440ef736028217c2d4765828","modified":1673265662814},{"_id":"source/_posts/CSS中的浮动.md","hash":"24b55dcd59672c1a13b7632cb0620711f6937106","modified":1673265802945},{"_id":"source/_posts/CSS动画.md","hash":"8b8a67db22f5726d632455a60a6d05303f8989fc","modified":1673265499915},{"_id":"source/_posts/Jquery中的动画.md","hash":"8e827b7ac31d6d9684522c3e999e60e276538362","modified":1673266630385},{"_id":"source/_posts/MARKDOWN基本语法.md","hash":"934069daf27c48d4b0480bc2edebbfe5da3895ea","modified":1673316687790},{"_id":"source/_posts/Vue中数据驱动.md","hash":"3f1b16d72e63fc7652b2e39b3374872ad72f9dbd","modified":1673317053380},{"_id":"source/_posts/Vue中的列表循环.md","hash":"285466c41593744069c7caeb5a2093e6204795fd","modified":1673316976179},{"_id":"source/_posts/OOCSS.md","hash":"60f1a26f2fe3f75aaf120f57b2957005d73012b4","modified":1676736271094},{"_id":"source/_posts/css实现一个简单的加载动画.md","hash":"a860509d67fbe8994bf293e6b142e4b6f2bafcb8","modified":1673265731128},{"_id":"source/_posts/css里面的盒模型.md","hash":"6cdac562b776295748bec24e16705372981907e9","modified":1673265560225},{"_id":"source/_posts/es6的提升.md","hash":"0a455c931750af948f3b062765d67e618dcf0bad","modified":1673265931227},{"_id":"source/_posts/jQuery中自定义动画.md","hash":"ac88a989ce3da9fdd43fafd414e743b6010e2f83","modified":1673268527602},{"_id":"source/_posts/flex布局.md","hash":"b10689c66ae428896e30bc1b5632317e27209fe9","modified":1673266041078},{"_id":"source/_posts/v-if与v-show的使用方法以及区别.md","hash":"5e6633d73fa1fd17df915b375bec2ac05a1aabac","modified":1673316899920},{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1673165742758},{"_id":"source/_posts/jQuery选择器.md","hash":"3de6787a58ea9368351f01bc38f4dc08837f00c6","modified":1673266601393},{"_id":"source/_posts/vue中计算属性.md","hash":"1a92d6befbfaf3b8438da652dfbf9a19d324435c","modified":1673317024132},{"_id":"source/_posts/vue监视属性.md","hash":"7ca56871fc83cf91a4fb09e1a8c886e61feee6fc","modified":1673316951977},{"_id":"source/_posts/vue中的事件.md","hash":"31521404264bf2c61f871f2279c46ead3d40bb51","modified":1673316999373},{"_id":"source/_posts/一个商务简约的登陆界面.md","hash":"b94d2290e825a426b6202730d848872c7b1bccd6","modified":1673264680985},{"_id":"source/_posts/vue绑定样式.md","hash":"870474b210dc29bac5b880fe46cfd9b0707b87e6","modified":1673316921399},{"_id":"source/_posts/抽象类与抽象方法.md","hash":"0abb97d8205a346fea0fbef51e4b9f6be5b77254","modified":1673317463492},{"_id":"source/_posts/我的2020年终总结.md","hash":"abb07e5c61f5bfa602db66ac811910053a3df066","modified":1673179947622},{"_id":"source/_posts/ES6/Set.md","hash":"75059d85873d9b3cb7857b80fdb73eec27bd27f6","modified":1678881472202},{"_id":"source/_posts/纯CSS实现跑马灯效果.md","hash":"4dd3ca3d22d18ef5d6776f6ce2389dff31719d2d","modified":1673176308375},{"_id":"source/_posts/跳动小球加载动画.md","hash":"28cb5688c7e727eeaccc4466b372235326b6b21f","modified":1673179709977},{"_id":"source/_posts/青训营-快乐出发.md","hash":"46900ffac369ce8823a59f88ebb27db3fc3d9389","modified":1673177995179},{"_id":"source/_posts/JavaScript/# 内置对象Date.md","hash":"cebfb125a0194d1a651642733c3b4eed487318e8","modified":1673176234460},{"_id":"source/_posts/ES6/map.md","hash":"a5f01f21fc3f6ac8ee6338fa69a2d50db141fc67","modified":1678951193191},{"_id":"source/_posts/JavaScript/AJAX常见一些问题的处理.md","hash":"fa8f1e84ebcd291afbc7f91dce7c909e388083a7","modified":1673265080757},{"_id":"source/_posts/JavaScript/#DOM事件流.md","hash":"db2fec5e4a7ed42b688822b03c719df021f63acc","modified":1673176251912},{"_id":"source/_posts/JavaScript/AJAX的基本使用.md","hash":"fac1d6486d73f5efa49a9700476502e6c5ee450b","modified":1673265134782},{"_id":"source/_posts/JavaScript/BOM基础.md","hash":"c4f828a3ca8ed7089c220308e222f66050b7b625","modified":1673265325804},{"_id":"source/_posts/ES6/Symbol.md","hash":"57ec3db739439225fc68a2b00850bc06afd02a15","modified":1678410697009},{"_id":"source/_posts/JavaScript/JSON对象.md","hash":"648a1c83ca764a96379b4de9523c3dabf8eaf137","modified":1673324996437},{"_id":"source/_posts/JavaScript/BOM常见的方法.md","hash":"5afc62d10ab1ec6ad7812050386fb66b210efc0d","modified":1673319338176},{"_id":"source/_posts/JavaScript/JavaScriptES6第二弹.md","hash":"a9a0e87f1d006a687df76213d0d00c559ea56f14","modified":1684830977244},{"_id":"source/_posts/JavaScript/DOM事件.md","hash":"3b4b3868105b919ea4739b41712a143dc7063162","modified":1673265860942},{"_id":"source/_posts/JavaScript/JavaScriptES6中的继承.md","hash":"2fb2a954671f3f64a11ba4bbfcbe2164bc73994e","modified":1684830964082},{"_id":"source/_posts/JavaScript/JS的执行机制.md","hash":"749daf932306d7d53fa3646d4894e286e9dcd705","modified":1673266680151},{"_id":"source/_posts/JavaScript/JavaScript中的块级作用域.md","hash":"2831da881f8b794f53fa242bba7dfe71fcb9900b","modified":1684755604578},{"_id":"source/_posts/JavaScript/JavaScriptES5中的继承.md","hash":"6ffc8b967bd122e90b45624f7604432e8fc1a9fc","modified":1684755497029},{"_id":"source/_posts/JavaScript/JavaScript中原型.md","hash":"52857ca92f3519e5f78154a64f5723b2a706a670","modified":1673266550849},{"_id":"source/_posts/JavaScript/JavaScript内存管理和闭包.md","hash":"4ab292b812c68271119764429fda00e7cbcbb5b8","modified":1684119042231},{"_id":"source/_posts/JavaScript/JavaScript函数的增强知识.md","hash":"53c84bbee403e7750ebefed75cc359ca4a10d3fe","modified":1684204218878},{"_id":"source/_posts/JavaScript/JavaScript的浅拷贝与深拷贝.md","hash":"cef27c638bae259397016a85fbb139f5767a0fef","modified":1673266520393},{"_id":"source/_posts/JavaScript/JavaScript对象的增强知识.md","hash":"aa8010dec3c62905e61d7fddd50ceefa98afe1b6","modified":1684204375555},{"_id":"source/_posts/JavaScript/Js中的回调函数.md","hash":"1f5cbd1893169f3e75c1d8a63b65bac5ed1e77cb","modified":1673266724632},{"_id":"source/_posts/JavaScript/MAP基础.md","hash":"ed4a475066b205c979b492b9fc3b1f9113c8963b","modified":1673314237511},{"_id":"source/_posts/JavaScript/MATH常用方法.md","hash":"f87bd4cff6c681512d47506a6f5a97ac95d3e227","modified":1673316754363},{"_id":"source/_posts/JavaScript/eventEmitter.md","hash":"7b7c89430cc25b9f4b9e33b3499c6cf4d1fe2e98","modified":1673317318509},{"_id":"source/_posts/JavaScript/new 关键字.md","hash":"c1bbc53e2d2a459606bf1b20323e64ae8a4263a1","modified":1673316797247},{"_id":"source/_posts/JavaScript/事件对象详细解析.md","hash":"74d17b225776e6f049ad6ea8c382a9afef417d41","modified":1683688157808},{"_id":"source/_posts/JavaScript/三种动态创建元素的区别.md","hash":"4e4092a7dc352750d898035fe2ee584540809b45","modified":1673178948072},{"_id":"source/_posts/JavaScript/函数.md","hash":"417fdadb55abbceca610fcb6d0a13145ba6675f9","modified":1673177670640},{"_id":"source/_posts/JavaScript/函数中的this.md","hash":"b9cd271cc56d4d431d2fde3d577ccb896996a496","modified":1683688139598},{"_id":"source/_posts/JavaScript/函数表达式和函数声明的区别.md","hash":"a9eedebbfbee35163b523d02f84763d5f7503b37","modified":1673177968121},{"_id":"source/_posts/JavaScript/事件对象.md","hash":"b51ac99adc4eea03dcec540f2a75738d364fabc2","modified":1673179387502},{"_id":"source/_posts/JavaScript/如何提高写作水平.md","hash":"5273a57ff7b73ee6c4795f32d64b6fd20c0e3271","modified":1673178816402},{"_id":"source/_posts/JavaScript/删除事件（解绑事件）.md","hash":"e7bca45495d8ace39d9eed85ef7a7893bdbf689f","modified":1673179077638},{"_id":"source/_posts/JavaScript/原始值与引用值.md","hash":"04b63fa2a7e6c64bd40f2c4cbf614c7ec7bfd9fd","modified":1673264710665},{"_id":"source/_posts/JavaScript/可选链.md","hash":"ce4a5bc6e3db465a063df5fc63d53775c8927347","modified":1673177993684},{"_id":"source/_posts/JavaScript/字符串常用方法.md","hash":"1b723e0307fda3c53619067f9c8971346fca5b63","modified":1673264866433},{"_id":"source/_posts/JavaScript/字符串常用方法第二弹.md","hash":"f498dc2f93ab18f169a02b534656e893dc67c79c","modified":1673264996812},{"_id":"source/_posts/JavaScript/对象.md","hash":"071458097f74015d66d0034c4f2bfb8eb3ebc777","modified":1673175967112},{"_id":"source/_posts/JavaScript/数字、字符串、数组的相互转换.md","hash":"b6cdc5535edba32fc1e325d2330240f801e84fbc","modified":1673179444259},{"_id":"source/_posts/JavaScript/数组常用方法.md","hash":"f09aebf4617baf2f16ff4f93b95bafdf50f82be8","modified":1673179514718},{"_id":"source/_posts/JavaScript/操作元素.md","hash":"6536dda6eff28c930c6168e878d2ed306acd65a1","modified":1673176284686},{"_id":"source/_posts/JavaScript/数组常用方法2.0.md","hash":"3b402d6bd1d2dc846e5a2b7e296566ca07df37d4","modified":1673179744166},{"_id":"source/_posts/JavaScript/数组常用方法3.0.md","hash":"d75bb291a0cc55a53b2f4025a0d6528e83add668","modified":1673179547254},{"_id":"source/_posts/JavaScript/注册事件（绑定事件）.md","hash":"a585a4211f5b1df18b00abdf86aa1a60761cba70","modified":1673264805205},{"_id":"source/_posts/JavaScript/日期与时间.md","hash":"dbcd872a368ee487a4f31691d6cedc6d11660584","modified":1673324921824},{"_id":"source/_posts/JavaScript/箭头函数.md","hash":"7b821e6b31d8ce330902090a79c7679a2fa1d60d","modified":1673177972610},{"_id":"source/_posts/JavaScript/深入浏览器渲染原理.md","hash":"4bd82c0197166cb3ab6f105936917c15ba4ece0d","modified":1683809223229},{"_id":"source/_posts/JavaScript/节点操作之创建节点.md","hash":"8e6cae1efea99230b19806db5d9869318a51cc80","modified":1673177982692},{"_id":"source/_posts/JavaScript/节点操作之复制节点.md","hash":"6fa173e733098aeee45897790748f112f2166f71","modified":1673177985629},{"_id":"source/_posts/JavaScript/节点操作.md","hash":"dcdfcba748b89b775e12e808f55fae283b631407","modified":1673177979720},{"_id":"source/_posts/JavaScript/节点操作之删除节点.md","hash":"3c01b6f0241182df0f42c167af4f8d2edf33e5ab","modified":1673177988320},{"_id":"source/_posts/JavaScript/闭包.md","hash":"aecb3041d91c5b0392c4754fada9dfc981a5d7f5","modified":1673176278378},{"_id":"source/_posts/Vue3/Setup.md","hash":"7df6bac072476d31b426627b13bf54324e2987cd","modified":1679470663402},{"_id":"source/_posts/JavaScript/解构赋值.md","hash":"736eaae7466f88ede3e6a4c1b86679c4b230e4c5","modified":1673318263508},{"_id":"source/_posts/Vue3/Mixin.md","hash":"5ca7f8783b2b231c8d70ff830e2d19925d18d6ad","modified":1679469143156},{"_id":"source/_posts/Vue3/Vue3组件化开发（一）.md","hash":"dfa90492dc3b6649914a189bc54bb1546d195e4b","modified":1676941231559},{"_id":"source/_posts/Vue3/Vue3中的动画.md","hash":"6eb4dd5361dfbce0bb76b0daa5570188c1ef5702","modified":1678706128161},{"_id":"source/_posts/Vue3/vue3的Options-API.md","hash":"4a6d78a2eb4f19c830650df3b49e7900e234b330","modified":1674787211356},{"_id":"source/_posts/Vue3/Vue中的插槽.md","hash":"18926fb7c44ec9c0baf69e1ecde467e3d6031596","modified":1677589407296},{"_id":"source/_posts/Vue3/vue3的表单开发和开发模式.md","hash":"a085f0236c6d41b8302836627a7b42a9e0336218","modified":1675946873393},{"_id":"source/_posts/Vue3/vue基本指令.md","hash":"52568551788cc43c2e9bc1f9abdbd836918b38dd","modified":1674538653035},{"_id":"source/_posts/node学习/eventEmitter.md","hash":"7b7c89430cc25b9f4b9e33b3499c6cf4d1fe2e98","modified":1673317318509},{"_id":"source/_posts/Vue3/webpack基础打包.md","hash":"db0ade1e02a2330c7f8f44e43dc1cbb040e2c906","modified":1676981690077},{"_id":"source/_posts/canvas/1.canvas入门.md","hash":"099d14a8036021c71f14780fd2bbc12500098b57","modified":1673680132922},{"_id":"source/_posts/双体web/HTML列表标签.md","hash":"4bd8c635381bf8c61fdcaf7b734508329c8f5acc","modified":1680509871337},{"_id":"source/_posts/Vue3/vue基础之模板语法2.md","hash":"87c7ed77502f494f7c28a385f464d96324a62dab","modified":1674704397240},{"_id":"source/_posts/node学习/fs中路径动态拼接问题.md","hash":"99f285612afd5600ef4f8e768e9a9a82d4c1d32d","modified":1673317374275},{"_id":"source/_posts/node学习/path路径模块.md","hash":"303443273d74a764629d73ea54327106181cf5bb","modified":1673317393919},{"_id":"source/_posts/复习笔记/01.md","hash":"280765abae3a8bc1b4e3a2ea83c98cbb1fba8308","modified":1674812049440},{"_id":"source/_posts/node学习/fs文件系统模块.md","hash":"319f9c5782243669cc1bd1a76d51e5c40a8c7f7a","modified":1673317355053},{"_id":"source/_posts/node学习/require函数.md","hash":"c6603e590e0792491069cc3f453a255f9542ac96","modified":1678241444191},{"_id":"source/_posts/复习笔记/安卓.md","hash":"1111919e0eff01f85f0e74cc4cee02b0cb88db3b","modified":1675149672234},{"_id":"source/_posts/双体web/CSS.md","hash":"b05ecf3f6767cecf0304394943bf2b90b2219385","modified":1680762435602},{"_id":"source/_posts/双体web/HTML基本标签的使用.md","hash":"d03dd74d53b3c5964a55dc3d8cd972cc34692566","modified":1680161183229},{"_id":"source/_posts/javaLearn/java中的方法.md","hash":"cdaff8e93eb7a8fb41f7a7bcb9054fee9cb1628c","modified":1678951065602},{"_id":"source/_posts/复习笔记/操作系统复习指导.md","hash":"c343551c340c6fc6d6f6628d6eec46ef342697eb","modified":1675149598279},{"_id":"source/_posts/javaLearn/内部类.md","hash":"937606cbec2d70a934cc0bee17c7bbb381199636","modified":1673333977430},{"_id":"source/_posts/javaLearn/static关键字.md","hash":"5b65fa98053ebe51c27d83fa70abb111195701bd","modified":1678245378363},{"_id":"source/_posts/javaLearn/常用API-Math.md","hash":"e9fe5ec947cc34b5a875dacb2ca17040d709e334","modified":1673338885910},{"_id":"source/_posts/javaLearn/包、final与修饰符.md","hash":"fafc1b97144a5f0d38452f9c58bb73210b6307be","modified":1673317447832},{"_id":"source/_posts/复习笔记/组织行为学.md","hash":"e6fe69266651e739320ff1fb4efbca02a5eb4fe0","modified":1675312555448},{"_id":"source/_posts/javaLearn/封装..md","hash":"8a84eb707e44ec2e03e11a1cf94bcae2c9e6a549","modified":1678950905744},{"_id":"source/_posts/javaLearn/多态.md","hash":"d65d513d867a234205f537d9c6c01be370575e68","modified":1673317486156},{"_id":"source/_posts/javaLearn/异常.md","hash":"0585b8d58a34fd1b77ad8a00b73f32b5ad6d02c9","modified":1678950892783},{"_id":"source/_posts/javaLearn/接口.md","hash":"62604468bb91466e952d9131e54ff130f4ac1ed6","modified":1673317540706},{"_id":"source/_posts/javaLearn/抽象类与抽象方法.md","hash":"0abb97d8205a346fea0fbef51e4b9f6be5b77254","modified":1673317463492},{"_id":"source/_posts/javaLearn/面向对象编程.md","hash":"c7231d2d495e7fb447c06ad7e66f39ecf33e394a","modified":1678950921703},{"_id":"source/_posts/javaLearn/继承.md","hash":"241e001273e836f7fe98ada0b94494530f81807a","modified":1678764120191},{"_id":"source/_posts/javaLearn/类和对象.md","hash":"8ae2cc5fc941f61c13792142314be28b5b9914b2","modified":1678951076960},{"_id":"source/_posts/青训营笔记/HTTP.md","hash":"0cd1d6b642d13ff062e49ac53165a8cae39c1e21","modified":1674616584242},{"_id":"source/_posts/青训营笔记/前端与HTML.md","hash":"21ce30d72532ec3e214cbeea2613887a6c4766b2","modified":1674221873877},{"_id":"source/_posts/青训营笔记/青训营码上掘金.md","hash":"d15a158538c36542e1afd10e5a750f5e033a0bf0","modified":1676209705777},{"_id":"source/_posts/javaLearn/数据库/E-R图.md","hash":"c03260d28b37a42ea6e8db8e241df9d35b92bbfe","modified":1679907964762},{"_id":"source/_posts/青训营笔记/TS基本语法.md","hash":"213f93bf67fd874f966e0057e97e6749062b3e70","modified":1674992010612},{"_id":"source/_posts/javaLearn/数据库/SQL语言准备工作.md","hash":"da38152a23d2ae82ae90ccbcddc8a1a3ed3de894","modified":1679377565542},{"_id":"source/_posts/javaLearn/数据库/JDBC.md","hash":"013f1098f016a19dfd5fd7bf6079ac71ee493116","modified":1679918439233},{"_id":"source/_posts/javaLearn/数据库/操作数据库.md","hash":"7a4b9ab557d6ba20aa0a3c6245ad11fbab773275","modified":1680010602443},{"_id":"themes/hexo-theme-pure/.gitignore","hash":"204766bf9e2d6fe1fce5b9b02b8edfac2d235830","modified":1673173663642},{"_id":"themes/hexo-theme-pure/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1673173663643},{"_id":"themes/hexo-theme-pure/README.cn.md","hash":"c14beac2aa2b6e6deb5359600b215d0ae348c0a4","modified":1673173663643},{"_id":"themes/hexo-theme-pure/README.md","hash":"94fe451bf920cec6152e7bf9cbff4ccf0af0febc","modified":1673173663644},{"_id":"themes/hexo-theme-pure/package.json","hash":"d5bad0f074925c46e8ee5a75d385346d2fcea850","modified":1673173663697},{"_id":"themes/hexo-theme-pure/_config.yml.example","hash":"a3b55d01598967db40da6f740b38cdba4f17d7bc","modified":1673173663646},{"_id":"themes/hexo-theme-pure/layout/about.ejs","hash":"4b64515ccc801cc9eba637a1e1909c6c4dd203f6","modified":1673173663692},{"_id":"themes/hexo-theme-pure/languages/zh-CN.yml","hash":"399061d959807b41e333808b4c7851ca290a82fe","modified":1673173663656},{"_id":"themes/hexo-theme-pure/languages/zh-TW.yml","hash":"387ad2ca1b2a01dac36f768a6116a2033c3ac142","modified":1673173663657},{"_id":"themes/hexo-theme-pure/languages/default.yml","hash":"ed342f9158f13fafaf51baa4cc89df4d8aa31720","modified":1673173663655},{"_id":"themes/hexo-theme-pure/_config.yml","hash":"d573f8ad9d1610c31fbfab1af801807601cdef64","modified":1673324848489},{"_id":"themes/hexo-theme-pure/layout/books.ejs","hash":"75cbd31d3551c730e8a683bd5b08562881a95b51","modified":1673173663693},{"_id":"themes/hexo-theme-pure/languages/en.yml","hash":"ed342f9158f13fafaf51baa4cc89df4d8aa31720","modified":1673173663656},{"_id":"themes/hexo-theme-pure/layout/archive.ejs","hash":"62847ac8ce2562908c01d69f7f6886e24a6ded40","modified":1673173663692},{"_id":"themes/hexo-theme-pure/layout/categories.ejs","hash":"9cc7b5f5af40fd7ec641bf0f5a5f8f1ce1ac22d5","modified":1673173663693},{"_id":"themes/hexo-theme-pure/layout/category.ejs","hash":"b3f7a96fbaf201a65ed64d509edc29976542fbfb","modified":1673173663694},{"_id":"themes/hexo-theme-pure/layout/index.ejs","hash":"44418dbf1fb82392b8e1e4cc910d16a383190433","modified":1673173663694},{"_id":"themes/hexo-theme-pure/layout/links.ejs","hash":"ee90a5f2a9d19bc02682ea3a59177b947f7f7284","modified":1673173663695},{"_id":"themes/hexo-theme-pure/layout/post.ejs","hash":"fbfed3c882059e757b23ff57924400683631594b","modified":1673173663696},{"_id":"themes/hexo-theme-pure/layout/page.ejs","hash":"fbfed3c882059e757b23ff57924400683631594b","modified":1673173663695},{"_id":"themes/hexo-theme-pure/layout/layout.ejs","hash":"71bdeba7b8be0c4f56a87ad05da2c6d4254da55e","modified":1673173663695},{"_id":"themes/hexo-theme-pure/layout/repository.ejs","hash":"0ecad33b6c1ec741eb3b02bb47a3824ac3749d09","modified":1673173663696},{"_id":"themes/hexo-theme-pure/layout/tags.ejs","hash":"76bc71f3dfd8a5b1aa14b09dec7b460b14f5028a","modified":1673173663697},{"_id":"themes/hexo-theme-pure/layout/tag.ejs","hash":"30d8ddd84c9aa87dff1be02af308097cf4e72448","modified":1673173663696},{"_id":"themes/hexo-theme-pure/scripts/thumbnail.js","hash":"4a7385e533f3567758bc995a8be5eb3e7839ac9c","modified":1673173663716},{"_id":"themes/hexo-theme-pure/.github/ISSUE_TEMPLATE/custom.md","hash":"a3b49dff53b405dbafe2e96834313fc329710007","modified":1673173663641},{"_id":"themes/hexo-theme-pure/source/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1673173663721},{"_id":"themes/hexo-theme-pure/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1673173663642},{"_id":"themes/hexo-theme-pure/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16dbe91b392ef9debb7abeffde473668d3337eb2","modified":1673173663641},{"_id":"themes/hexo-theme-pure/_source/404/index.md","hash":"16638b081d796638565ca462f3c87339b9a0577e","modified":1673173663647},{"_id":"themes/hexo-theme-pure/_source/about/index.md","hash":"b72470146e8244886e15715e0cae79b4130305e8","modified":1673173663650},{"_id":"themes/hexo-theme-pure/_source/_data/links.yml","hash":"a5e31f35ebb8e1e8811f2e3d957cf4d4835aa2f9","modified":1673173663649},{"_id":"themes/hexo-theme-pure/_source/_data/gallery.yml","hash":"eef9b025c2a81fdc714967d0c7b21bed9d55cff5","modified":1673173663648},{"_id":"themes/hexo-theme-pure/_source/categories/index.md","hash":"435a3f8c3fe4f41feea8e4294e2281576d658fe9","modified":1673180502026},{"_id":"themes/hexo-theme-pure/_source/tags/index.md","hash":"c35ba8af5acf41102909a9f9c1349a24d89f97a6","modified":1673173663655},{"_id":"themes/hexo-theme-pure/_source/books/index.md","hash":"d913d58987f539ac2ca4cca366ebf42f8b1a03d1","modified":1673173663651},{"_id":"themes/hexo-theme-pure/_source/links/index.md","hash":"d768332d0d322fe39267dbbda05b931488c27d7e","modified":1673173663653},{"_id":"themes/hexo-theme-pure/_source/repository/index.md","hash":"bf2bec13066d7d53fc05a334876eb482e6f95825","modified":1673173663653},{"_id":"themes/hexo-theme-pure/layout/_common/footer.ejs","hash":"caec54ce31577207e1fd31aefa017bde99a8027c","modified":1673173663658},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-book.ejs","hash":"944913dcabd09c10d3014c844abf851f4dfdba8d","modified":1673173663661},{"_id":"themes/hexo-theme-pure/layout/_common/script.ejs","hash":"3045da0c1979946694b628fbef39c01cc98b6e75","modified":1673173663660},{"_id":"themes/hexo-theme-pure/layout/_common/social.ejs","hash":"2bcdc7b0ee3905e724b01c2efa1ca6b47a846e1f","modified":1673173663660},{"_id":"themes/hexo-theme-pure/layout/_common/header.ejs","hash":"c05070274965692a270c7e07ad9f4dad6f2c5888","modified":1673173663659},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-list.ejs","hash":"15ebb5d7cc3f07e6bf5ffa783c3d2feabd252fc1","modified":1673173663663},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-category.ejs","hash":"4be88eec64fd40c7e1b74df8ccb6c8cdfa3e7a17","modified":1673173663662},{"_id":"themes/hexo-theme-pure/layout/_common/head.ejs","hash":"4135b80c40cc970f9dc30fdd02e4f3e0a8b0af67","modified":1673173663659},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-tag.ejs","hash":"db8cba32bf6655a8d21fe8c8ccd0695b049e1d4c","modified":1673173663665},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-link.ejs","hash":"a8a387f9e7289a6524cf46d7ab76c34fff37f4bf","modified":1673173663662},{"_id":"themes/hexo-theme-pure/layout/_partial/article-about.ejs","hash":"47bbb53fe9cca05928c45782c6897c8a94d597ff","modified":1673173663666},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-post.ejs","hash":"513892fae41de4e68963c95a9358285714274bb4","modified":1673173663664},{"_id":"themes/hexo-theme-pure/layout/_partial/archive-repository.ejs","hash":"01fabc035fe48a494581f5680ed23f355e0e59ce","modified":1673173663664},{"_id":"themes/hexo-theme-pure/layout/_partial/item-post.ejs","hash":"c5d1add53ce45df5f851f19023b2e4f16dad43ef","modified":1673173663667},{"_id":"themes/hexo-theme-pure/layout/_partial/archive.ejs","hash":"c196b54f92eff017a48e02bacc029dd82edc8cf9","modified":1673173663666},{"_id":"themes/hexo-theme-pure/layout/_partial/article.ejs","hash":"8af3bcfc07c344cefa0655dbe83f3c1a55954899","modified":1673173663666},{"_id":"themes/hexo-theme-pure/layout/_partial/sidebar-toc.ejs","hash":"1d90de80d5eb2b10be6cad6fa0bfb465cbc5c9f1","modified":1673173663674},{"_id":"themes/hexo-theme-pure/layout/_partial/sidebar.ejs","hash":"a6662f79f7fd6f1cc9b5180672ba8e1d0192fbe2","modified":1673173663675},{"_id":"themes/hexo-theme-pure/layout/_partial/pagination.ejs","hash":"cc450ee5638f180332b3c4b747c5337b89d5a0c8","modified":1673173663667},{"_id":"themes/hexo-theme-pure/layout/_script/analytics.ejs","hash":"db2967c6902ceb67caa70364935ef3441b10432f","modified":1673173663683},{"_id":"themes/hexo-theme-pure/layout/_partial/sidebar-about.ejs","hash":"17787edc304543c8658c7f51076022bda6ad227d","modified":1673173663674},{"_id":"themes/hexo-theme-pure/layout/_script/douban.ejs","hash":"6e671c659b282b690a5d61e842b5d5f38dced6d7","modified":1673173663684},{"_id":"themes/hexo-theme-pure/layout/_script/comment.ejs","hash":"d5c98ab345952bb11d9ee69a9c1e3432b6760c55","modified":1673173663684},{"_id":"themes/hexo-theme-pure/layout/_script/mathjax.ejs","hash":"7a64d98212769423425102a441fca52eb6930fff","modified":1673173663685},{"_id":"themes/hexo-theme-pure/layout/_script/repository.ejs","hash":"42b6602f478c9afa4e462716dcfcc76875c0df7d","modified":1673173663686},{"_id":"themes/hexo-theme-pure/layout/_script/fancybox.ejs","hash":"4558b5713926735d874deb14d8b21ed2e597b714","modified":1673173663685},{"_id":"themes/hexo-theme-pure/layout/_script/search.ejs","hash":"2b784d15581df4309f56682896b725da7d44fcdd","modified":1673173663686},{"_id":"themes/hexo-theme-pure/layout/_search/baidu.ejs","hash":"89848cc8e0190ca76cc26d42c6880a23e370702e","modified":1673173663687},{"_id":"themes/hexo-theme-pure/layout/_script/pv.ejs","hash":"a464706b7a903e25d34b104bdfb298b260abc132","modified":1673173663686},{"_id":"themes/hexo-theme-pure/layout/_search/index-mobile.ejs","hash":"5e9a5cc9bdc05fabf939db494c3937cc0df48a72","modified":1673173663687},{"_id":"themes/hexo-theme-pure/layout/_search/insight.ejs","hash":"14b1ec0bdb911ab6d92046c78d371264afc4fb19","modified":1673173663688},{"_id":"themes/hexo-theme-pure/layout/_search/index.ejs","hash":"2c1f06dac5710e5fd073f3e5739545f3f6a0a56f","modified":1673173663688},{"_id":"themes/hexo-theme-pure/layout/_search/swiftype.ejs","hash":"dc548a83c33b5a598683bf2e1cb723bc3be4a76b","modified":1673173663689},{"_id":"themes/hexo-theme-pure/layout/_widget/board.ejs","hash":"9811bab46dcf436c6d05ae78acd62bc25751df78","modified":1673173663690},{"_id":"themes/hexo-theme-pure/layout/_widget/category.ejs","hash":"83c8ce4b099951d58b2be5006f6963afbbe7d4e9","modified":1673173663690},{"_id":"themes/hexo-theme-pure/layout/_widget/archive.ejs","hash":"b250fb0f63286f9648cd8bf428bed6a88901b481","modified":1673173663689},{"_id":"themes/hexo-theme-pure/layout/_widget/recent_posts.ejs","hash":"8932ce5283a7e6a356c6840104a7d6984f2ea986","modified":1673173663690},{"_id":"themes/hexo-theme-pure/layout/_widget/tag.ejs","hash":"24823a881a6c15fd846c7f4780eb90fe869a813b","modified":1673173663691},{"_id":"themes/hexo-theme-pure/layout/_widget/tagcloud.ejs","hash":"e6967ec160b93a5f466a73a36745833e644d04c0","modified":1673173663691},{"_id":"themes/hexo-theme-pure/source/fonts/README.md","hash":"b5b2aac1b36a86dac2217d242d650e026c5a3b0c","modified":1673173663722},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1673173663723},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1673173663726},{"_id":"themes/hexo-theme-pure/source/images/avatar.jpg","hash":"f86eafc318f3900319b25057811720168f24d248","modified":1673173663727},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1673173663726},{"_id":"themes/hexo-theme-pure/source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1673173663731},{"_id":"themes/hexo-theme-pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1673173663734},{"_id":"themes/hexo-theme-pure/source/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1673173663732},{"_id":"themes/hexo-theme-pure/source/js/application.js","hash":"c29f52f5ed2d1a5d8185b115f2962d22e707e19e","modified":1673173663733},{"_id":"themes/hexo-theme-pure/source/js/insight.js","hash":"a1b773d9ce470bf0e2f8fdca1b6fac2ac3d31aeb","modified":1673173663734},{"_id":"themes/hexo-theme-pure/layout/_partial/post/category.ejs","hash":"20ef0d47ec3d2de7d94db9778ddac092dc2bd4b5","modified":1673173663668},{"_id":"themes/hexo-theme-pure/layout/_partial/post/date.ejs","hash":"8cbaef422bd7f3d1581d1198dd1c36e4c0e1e46e","modified":1673173663669},{"_id":"themes/hexo-theme-pure/layout/_partial/post/comment.ejs","hash":"0ef132fc45042b28411e3334e77b6e2a7f47fae2","modified":1673173663668},{"_id":"themes/hexo-theme-pure/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1673173663670},{"_id":"themes/hexo-theme-pure/layout/_partial/post/copyright.ejs","hash":"c690e62e930ac7e66a5982aa95e146324e9b1e7f","modified":1673173663669},{"_id":"themes/hexo-theme-pure/layout/_partial/post/donate.ejs","hash":"bdef9836ca91b3e45498a9d98bcaec69e6627ced","modified":1673173663670},{"_id":"themes/hexo-theme-pure/layout/_partial/post/thumbnail.ejs","hash":"0d8b9a3aeaed95b74e292c593f0a8225711bfdca","modified":1673173663672},{"_id":"themes/hexo-theme-pure/layout/_partial/post/tag.ejs","hash":"8fd470b8d52606a90d475f7da9dbbed32742b1c9","modified":1673173663672},{"_id":"themes/hexo-theme-pure/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1673173663673},{"_id":"themes/hexo-theme-pure/layout/_partial/post/nav.ejs","hash":"5b4119092b890c156a4e85e15be2cbcebf89fcbd","modified":1673173663671},{"_id":"themes/hexo-theme-pure/layout/_partial/post/pv.ejs","hash":"946f4bcfa5e5dc4d60c05916c8187bd2c06d1a95","modified":1673173663672},{"_id":"themes/hexo-theme-pure/layout/_partial/post/wordcount.ejs","hash":"81e9a89734505f54fef83dc74d2e277dab1bfa75","modified":1673173663673},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/livere.ejs","hash":"2cc7b1cb7bdf157fe6470eb34a613963df75afa3","modified":1673173663679},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/disqus.ejs","hash":"98dac12a9cbf47098b49183893d714355e2e5999","modified":1673173663677},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/youyan.ejs","hash":"96fcc36560a8367e6c4ba9ec1e82d0c5a730b1b4","modified":1673173663680},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/gitalk.ejs","hash":"d6bf1cfaa9167dcfb9ffab20c6670c53a008e838","modified":1673173663678},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/valine.ejs","hash":"19120669bfea521e0b9d2df5bf3a34f0ecb8bb68","modified":1673173663679},{"_id":"themes/hexo-theme-pure/layout/_script/_comment/gitment.ejs","hash":"0af71b5b354fdddd576fbd55c3aeb0221af71e7d","modified":1673173663678},{"_id":"themes/hexo-theme-pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"829778c19025882fe73cf1b297a36a9d0eff39a1","modified":1673173663675},{"_id":"themes/hexo-theme-pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"19585fc666e13a2816d74a8046998ac7fd36f75c","modified":1673173663677},{"_id":"themes/hexo-theme-pure/layout/_script/_analytics/google-analytics.ejs","hash":"4557389e499b89982eb005a821208fdd3dbac627","modified":1673173663676},{"_id":"themes/hexo-theme-pure/layout/_script/_repository/github.ejs","hash":"4df2172813297fcfb9ab894f668f21230f2e9e77","modified":1673173663681},{"_id":"themes/hexo-theme-pure/layout/_script/_repository/gitee.ejs","hash":"be7fed016f5332b597af6a5d5de262cc4fe939a0","modified":1673173663680},{"_id":"themes/hexo-theme-pure/layout/_script/_repository/legacy.ejs","hash":"9ed1e7de79bd661065b9c071957c54e58c38827c","modified":1673173663681},{"_id":"themes/hexo-theme-pure/layout/_script/_search/insight.ejs","hash":"f95c3289c03fa084afce64e3c399cb5127707f56","modified":1673173663683},{"_id":"themes/hexo-theme-pure/layout/_script/_search/baidu.ejs","hash":"72b48dcaab830b615c71f6e810e96100b715c682","modified":1673173663682},{"_id":"themes/hexo-theme-pure/source/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1673173663728},{"_id":"themes/hexo-theme-pure/source/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1673173663729},{"_id":"themes/hexo-theme-pure/source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1673173663730},{"_id":"themes/hexo-theme-pure/source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1673173663730},{"_id":"themes/hexo-theme-pure/source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1673173663730},{"_id":"themes/hexo-theme-pure/screenshot/pure-theme-black.png","hash":"10b40f398af7eb7e8ba2bf2f2a959d8779fc1fe1","modified":1673173663699},{"_id":"themes/hexo-theme-pure/screenshot/pure-theme-blue.png","hash":"6146890a68d5ea9d343c48d50151ddd5a2a1872c","modified":1673173663700},{"_id":"themes/hexo-theme-pure/screenshot/pure-theme-green.png","hash":"12ec0c6033cb2762839fdf75434bbb4fbf946022","modified":1673173663702},{"_id":"themes/hexo-theme-pure/screenshot/pure-theme-purple.png","hash":"9855d2eb0acd23370209354f232471df8f4f72e2","modified":1673173663703},{"_id":"themes/hexo-theme-pure/screenshot/pure.png","hash":"8f4cfd8d7edfa4fbffdf375291302d9807f5cc1c","modified":1673173663704},{"_id":"themes/hexo-theme-pure/source/js/jquery.min.js","hash":"dacc1f76630a9708add066819b1aabf8dce01056","modified":1673173663735},{"_id":"themes/hexo-theme-pure/source/js/plugin.min.js","hash":"4eded164f8b6f5187fbf10065873ebeee5ab8787","modified":1673173663740},{"_id":"themes/hexo-theme-pure/source/css/style.css","hash":"fca937c3b6b2c631dc48d7bf2db062c425c3a084","modified":1673173663719},{"_id":"themes/hexo-theme-pure/source/css/style.min.css","hash":"4e46cbfadf9f0c5c236239a163058a3f525492ce","modified":1673173663720},{"_id":"themes/hexo-theme-pure/source/fonts/iconfont.svg","hash":"1af91521f1c29c231ffc19d7f64696ddcd71470b","modified":1673173663725},{"_id":"themes/hexo-theme-pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1673173663738},{"_id":"themes/hexo-theme-pure/source/js/plugin.js","hash":"59cb2985d8d21653f0f80ef327517eca86af0ac6","modified":1673173663737},{"_id":"themes/hexo-theme-pure/screenshot/pure.psd","hash":"a31cea40b45bdc31f051fca2f1e2f4ecbaee1a94","modified":1673173663715},{"_id":"public/20223/05/16/JavaScript/JavaScript函数的增强知识/index.html","hash":"59ec564612bbc6437cd5c48637766e5798f85e75","modified":1684831002739},{"_id":"public/2023/05/22/JavaScript/JavaScript中的块级作用域/index.html","hash":"6e28ead5098ea4a448ceed6b900f5b330eb0c264","modified":1684831002739},{"_id":"public/2023/05/22/JavaScript/JavaScriptES6第二弹/index.html","hash":"d507aeb36cdf08c8af3124410e7b4f817b25141d","modified":1684831002739},{"_id":"public/2023/05/19/JavaScript/JavaScriptES6中的继承/index.html","hash":"01dcb0ee192ebbacd6cb4036ad636e561eb3d8e1","modified":1684831002739},{"_id":"public/2023/05/18/JavaScript/JavaScriptES5中的继承/index.html","hash":"32adb36e6f3da5e30f48631afef2951e4802b8b3","modified":1684831002739},{"_id":"public/2023/05/16/JavaScript/JavaScript对象的增强知识/index.html","hash":"560f43b58cd1ed6848776f8d9cd77353dde5a940","modified":1684831002739},{"_id":"public/2023/05/15/JavaScript/JavaScript内存管理和闭包/index.html","hash":"0c67a76deea60137f0f55f57f1a7eac83d406f19","modified":1684831002739},{"_id":"public/2023/05/11/JavaScript/深入浏览器渲染原理/index.html","hash":"c8c11194ab09856873b45e23e6bbd9e818b5603f","modified":1684831002739},{"_id":"public/2023/05/09/JavaScript/函数中的this/index.html","hash":"d6c1c79eba947eb51c7a8be618e0ef791ae19381","modified":1684831002739},{"_id":"public/2023/05/08/JavaScript/事件对象详细解析/index.html","hash":"12f3566674886316ef26ca8029b999a45cbd1600","modified":1684831002739},{"_id":"public/2023/04/04/双体web/CSS/index.html","hash":"0ac0c3422d1bdbce7dd50ed1d59e202377f9bcdf","modified":1684831002739},{"_id":"public/2023/04/03/双体web/HTML列表标签/index.html","hash":"6cc332e120bde3c48268d81bca129389fb150842","modified":1684831002739},{"_id":"public/2023/03/30/双体web/HTML基本标签的使用/index.html","hash":"7414cbaa179b0db61d0b9f46624ce009b6a30357","modified":1684831002739},{"_id":"public/2023/03/27/javaLearn/数据库/JDBC/index.html","hash":"e0c5b605500a19745f1d17639d9ccec35401dc58","modified":1684831002739},{"_id":"public/2023/03/22/Vue3/Setup/index.html","hash":"b933c9f762095322dec7329a6a3ffffcfc9d032d","modified":1684831002739},{"_id":"public/2023/03/21/Vue3/Mixin/index.html","hash":"abdec9944781d66e4ec5d64597c1b3b828784cae","modified":1684831002739},{"_id":"public/2023/03/21/javaLearn/数据库/SQL语言准备工作/index.html","hash":"f0183516224b22dd468c76482e3b869de38d949f","modified":1684831002739},{"_id":"public/2023/03/21/javaLearn/数据库/操作数据库/index.html","hash":"40337b843153b8e11a4fa176fc2355cf4565e3c7","modified":1684831002739},{"_id":"public/2023/03/21/javaLearn/数据库/E-R图/index.html","hash":"b0902492f151720d657cd63643c38f07924033b7","modified":1684831002739},{"_id":"public/2023/03/15/ES6/Set/index.html","hash":"d1afab3d627b5adbeda2256044e13775a603deb3","modified":1684831002739},{"_id":"public/2023/03/15/javaLearn/异常/index.html","hash":"05ca01982c3fc33af25b67b92e9ed175861bb170","modified":1684831002739},{"_id":"public/2023/03/14/ES6/map/index.html","hash":"5cdddc1de6fa8846673091c9bec9ff32867eb13c","modified":1684831002739},{"_id":"public/2023/03/13/Vue3/Vue3中的动画/index.html","hash":"99eb262664035b1369febfc651df11f75cbc1b61","modified":1684831002739},{"_id":"public/2023/03/13/javaLearn/封装./index.html","hash":"9ae2179e3b24a2ca79b8e1c4aef786759583512f","modified":1684831002739},{"_id":"public/2023/03/10/javaLearn/面向对象编程/index.html","hash":"d2da5a37c9f7b003b33d002838fdbaf69cf4384e","modified":1684831002739},{"_id":"public/2023/03/09/ES6/Symbol/index.html","hash":"d44f26667ad43c60d8a10de925e935c8c1d8808f","modified":1684831002739},{"_id":"public/2023/03/08/javaLearn/类和对象/index.html","hash":"b8a6a75e13db6120909587cf28e66aa6f7c21fc8","modified":1684831002739},{"_id":"public/2023/03/05/node学习/require函数/index.html","hash":"2c8328571d2b664f9ebb2b17f6cff93df99a7658","modified":1684831002739},{"_id":"public/2023/03/01/javaLearn/java中的方法/index.html","hash":"e8d9a39fe7cbf06ae8d98de6a681f21a79e1b679","modified":1684831002739},{"_id":"public/2023/02/28/Vue3/Vue中的插槽/index.html","hash":"39acb7c9328e43b64d26e21d7b8473b555bbe61f","modified":1684831002739},{"_id":"public/2023/02/21/Vue3/webpack基础打包/index.html","hash":"f57358ca976fed2193e4c4cefcbd1e099a0357f2","modified":1684831002739},{"_id":"public/2023/02/20/Vue3/Vue3组件化开发（一）/index.html","hash":"a37b68e48d1666064ffb2c7b72e54da329eae70e","modified":1684831002739},{"_id":"public/2023/02/18/OOCSS/index.html","hash":"f35bb3cf97a45f66d53f93f30c6ef0fa821d9ab2","modified":1684831002739},{"_id":"public/2023/02/12/青训营笔记/青训营码上掘金/index.html","hash":"d1a8b5ef4b222ab7139d437e4055ae5df8a9b36c","modified":1684831002739},{"_id":"public/2023/02/08/BEM命名规范/index.html","hash":"cd5ae4863d134b205c33cea03def97d1f21a0d8e","modified":1684831002739},{"_id":"public/2023/02/02/复习笔记/组织行为学/index.html","hash":"ca04992588686dfdb83c789bbcc4e00cebdd83cc","modified":1684831002739},{"_id":"public/2023/01/31/复习笔记/安卓/index.html","hash":"af1a837bcdc8f4d359f61937f2ba3fc6765de179","modified":1684831002739},{"_id":"public/2023/01/27/复习笔记/操作系统复习指导/index.html","hash":"ec9ff8a4d2b7cda9c117d41bc7626bc32d8a568c","modified":1684831002739},{"_id":"public/2023/01/29/青训营笔记/TS基本语法/index.html","hash":"8261eecfe832eceea9c305917c113c660dc79bc0","modified":1684831002739},{"_id":"public/2023/01/27/复习笔记/01/index.html","hash":"a5f340bdefbf12cbbed6d6e198a9e83302776ae9","modified":1684831002739},{"_id":"public/2023/01/27/Vue3/vue3的表单开发和开发模式/index.html","hash":"28802c79f02116ee5cf63191c58453b597876cff","modified":1684831002739},{"_id":"public/2023/01/26/Vue3/vue3的Options-API/index.html","hash":"2dd4c5b268190b4bce73526738d15a77d8eea71b","modified":1684831002739},{"_id":"public/2023/01/24/青训营笔记/HTTP/index.html","hash":"889fd3f6bc9707661b9e94e3c3dbb966a819d460","modified":1684831002739},{"_id":"public/2023/01/24/Vue3/vue基础之模板语法2/index.html","hash":"dd966671854cb2cc9dabf5deabf2d7e5ff9443ce","modified":1684831002739},{"_id":"public/2023/01/23/Vue3/vue基本指令/index.html","hash":"6223dc01987c928a4b872ca2ad57bc8a1bb3e6c5","modified":1684831002739},{"_id":"public/2023/01/15/青训营笔记/前端与HTML/index.html","hash":"0fa0f6ecce002cb9a9aa77db547731ef7068dae4","modified":1684831002739},{"_id":"public/2023/01/14/canvas/1.canvas入门/index.html","hash":"5989e6a2a23c4ee9a88af1c9c613b7a65b5bf89c","modified":1684831002739},{"_id":"public/2023/01/10/javaLearn/内部类/index.html","hash":"2b7bdf194151700b510abf418da451e749d33499","modified":1684831002739},{"_id":"public/2023/01/10/javaLearn/常用API-Math/index.html","hash":"90ecbd3d4d4d8541ef7f8bc159aaa5624a145637","modified":1684831002739},{"_id":"public/2023/01/09/我的2020年终总结/index.html","hash":"5376b0abd0a8aeb56bd73e2ccf30979a24766a65","modified":1684831002739},{"_id":"public/2023/01/09/JavaScript/可选链/index.html","hash":"51b7eca4a3fd597df16dd4d537daa2ae610be796","modified":1684831002739},{"_id":"public/2023/01/09/JavaScript/JSON对象/index.html","hash":"d2c204417489f6a56dc5f345b5750853b641557f","modified":1684831002739},{"_id":"public/2023/01/09/hello-world/index.html","hash":"655969ab57799d041caf2f1f2dc63f3a74dc0512","modified":1684831002739},{"_id":"public/2023/01/08/javaLearn/接口/index.html","hash":"77e273c68165255763e7fba467520d7e6e578b4b","modified":1684831002739},{"_id":"public/2023/01/07/抽象类与抽象方法/index.html","hash":"5d7ab6fbb1c6cb39c5dbe43cede14d4f4bf722bc","modified":1684831002739},{"_id":"public/2023/01/07/javaLearn/包、final与修饰符/index.html","hash":"0477f3d9e3caba5bca19efbd5647237e53686b33","modified":1684831002739},{"_id":"public/2023/01/07/javaLearn/多态/index.html","hash":"4a1feaef921ec3f0e4e188e6db14ee92045631ef","modified":1684831002739},{"_id":"public/2023/01/07/javaLearn/抽象类与抽象方法/index.html","hash":"ca30b5dc1af86ac8446f466c3f4650df4e92ba96","modified":1684831002739},{"_id":"public/2023/01/06/javaLearn/继承/index.html","hash":"5d2520bb7867419f7d3cf39cfe4724215886cb6d","modified":1684831002739},{"_id":"public/2023/01/04/javaLearn/static关键字/index.html","hash":"fb5f0a32fb1bffd274651f5ea21ae87048c915bc","modified":1684831002739},{"_id":"public/2023/01/01/JavaScript/闭包/index.html","hash":"2f478773ece3b50956863e6b14dd2848abe067a6","modified":1684831002739},{"_id":"public/2022/12/17/node学习/fs中路径动态拼接问题/index.html","hash":"d9af3c3ece2ea21ed5a860d13a707465c9ff8a1c","modified":1684831002739},{"_id":"public/2022/12/17/node学习/fs文件系统模块/index.html","hash":"f149ea09ea0c017c4c86e9aa9df8bdc9528bed91","modified":1684831002739},{"_id":"public/2022/12/17/node学习/path路径模块/index.html","hash":"98516a9fe05525bb009fb68adbc289979c87d45b","modified":1684831002739},{"_id":"public/2022/12/16/JavaScript/eventEmitter/index.html","hash":"1587488d61a73082e8c28f03c60cc58ba80735bb","modified":1684831002739},{"_id":"public/2022/12/16/node学习/eventEmitter/index.html","hash":"03284452b603cb61d9d3b61f909c36891fdc07ac","modified":1684831002739},{"_id":"public/2022/12/11/Vue中数据驱动/index.html","hash":"655defc2f0b2b5469fffe3e40167437705dc5b10","modified":1684831002739},{"_id":"public/2022/12/03/纯CSS实现跑马灯效果/index.html","hash":"cd29b0b7f82f46694b617f0704da2b1a0adfd9c8","modified":1684831002739},{"_id":"public/2022/11/15/一个商务简约的登陆界面/index.html","hash":"0f803ba1c2458ce4a3b3d409103ff018eef73e6d","modified":1684831002739},{"_id":"public/2022/11/13/跳动小球加载动画/index.html","hash":"7044c9adbc5da40e7db0a3a2abd3ecac750c40c8","modified":1684831002739},{"_id":"public/2022/10/30/Vue中的列表循环/index.html","hash":"a96d1a22d9d8f91e8dc9e21702be93f7774bc22a","modified":1684831002739},{"_id":"public/2022/10/27/css实现一个简单的加载动画/index.html","hash":"0d68228197b4111dddca5a7a0f3c24c5b887374f","modified":1684831002739},{"_id":"public/2022/10/24/jQuery中自定义动画/index.html","hash":"a5d69a0392494b5e548239769b9059475783a75a","modified":1684831002739},{"_id":"public/2022/10/23/Jquery中的动画/index.html","hash":"354a466f3130e9d70516166eb355dd1fe49df1fc","modified":1684831002739},{"_id":"public/2022/10/23/JavaScript/AJAX常见一些问题的处理/index.html","hash":"cd96e48e438651c11bd25095ea17dbcefa050143","modified":1684831002739},{"_id":"public/2022/10/22/JavaScript/AJAX的基本使用/index.html","hash":"67a7988aaedf2d8557e08f9ece2826a3b798bcf6","modified":1684831002739},{"_id":"public/2022/10/19/v-if与v-show的使用方法以及区别/index.html","hash":"181907fbb72bea509e69bbd11defe1bc03b080d4","modified":1684831002739},{"_id":"public/2022/10/19/vue绑定样式/index.html","hash":"d82b8773b31865574504fe0c5c601f78c75e3bf6","modified":1684831002739},{"_id":"public/2022/10/17/MARKDOWN基本语法/index.html","hash":"e8b43682631217f8a283dcc636a9c5fa4b81281d","modified":1684831002739},{"_id":"public/2022/10/17/css里面的盒模型/index.html","hash":"14fc64922796afc92b837ec3553f8cadc4baac86","modified":1684831002739},{"_id":"public/2022/10/16/es6的提升/index.html","hash":"9f19c6421f8236456f6cdfb377136e8051bad9e5","modified":1684831002739},{"_id":"public/2022/10/15/CSS中的定位/index.html","hash":"0b1a4c4cb7a0d4399971a8dad2ad91e7d50fb0d0","modified":1684831002739},{"_id":"public/2022/10/15/CSS中的浮动/index.html","hash":"b6862acd10e44c66a7c6b57eb4cf9eb73f0af1fc","modified":1684831002739},{"_id":"public/2022/10/12/JavaScript/MAP基础/index.html","hash":"6a3ff24d3864d3e668d4a15318822e5151f72d4d","modified":1684831002739},{"_id":"public/2022/10/11/vue监视属性/index.html","hash":"44fd77fefcdc825108f2069517125665767f594e","modified":1684831002739},{"_id":"public/2022/10/10/vue中计算属性/index.html","hash":"5128d4939808009fb5e7bff88bb0ad88c5bb69f3","modified":1684831002739},{"_id":"public/2022/10/09/CSS2D转换/index.html","hash":"3a078db65dbe6e0f99a640edbc404bd7b2d4f9f7","modified":1684831002739},{"_id":"public/2022/10/09/vue中的事件/index.html","hash":"e1d70168eb57ff2ec1e1953733cdc73459753151","modified":1684831002739},{"_id":"public/2022/10/07/JavaScript/箭头函数/index.html","hash":"13d0ebf375e4ebd78b47d25789da1c2b105b482f","modified":1684831002739},{"_id":"public/2022/10/06/CSS动画/index.html","hash":"e078e13675c8bfc7d1151b1605cab6b098290570","modified":1684831002739},{"_id":"public/2022/10/04/JavaScript/Js中的回调函数/index.html","hash":"865ee1aad19bd6013e9d1654871d0dd287ddfa67","modified":1684831002739},{"_id":"public/2022/10/03/JavaScript/JavaScript中原型/index.html","hash":"bf12af4d433e608c1187665fea821cafc8bdb836","modified":1684831002739},{"_id":"public/2022/10/01/JavaScript/数字、字符串、数组的相互转换/index.html","hash":"dbe2f6fec5d0c87a91cf10fb14c3dbc265fc43f3","modified":1684831002739},{"_id":"public/2022/09/30/jQuery选择器/index.html","hash":"2e992500ed6c8abb428380b5bf12c7c7d86c78e2","modified":1684831002739},{"_id":"public/2022/09/29/JavaScript/解构赋值/index.html","hash":"e929519e38b6b5d3ba9518565f35e48058fdbcbf","modified":1684831002739},{"_id":"public/2022/09/28/JavaScript/# 内置对象Date/index.html","hash":"081377f70918e3594d6a6d02fbedec1dff36b1bd","modified":1684831002739},{"_id":"public/2022/09/28/JavaScript/MATH常用方法/index.html","hash":"ab9a0184a0c5e71c6bd2deaf9d00a2348908a80d","modified":1684831002739},{"_id":"public/2022/09/28/JavaScript/字符串常用方法/index.html","hash":"6a9216645156ca058db8b4c07440ea05a422ad2e","modified":1684831002739},{"_id":"public/2022/09/28/JavaScript/字符串常用方法第二弹/index.html","hash":"1e977b8d2edaf4f9e1da941e4adf82d58513bfe5","modified":1684831002739},{"_id":"public/2022/09/26/JavaScript/如何提高写作水平/index.html","hash":"fd78a1b23f09c24ba14201fddeba38eac4e01ccd","modified":1684831002739},{"_id":"public/2022/09/23/JavaScript/BOM基础/index.html","hash":"883c02f959597fb23063b154e0d4a32da1be2500","modified":1684831002739},{"_id":"public/2022/09/22/JavaScript/BOM常见的方法/index.html","hash":"4bc7a3de41392c0605c4ed0e59ade3b018579aa9","modified":1684831002739},{"_id":"public/2022/09/22/JavaScript/JS的执行机制/index.html","hash":"17d3bd611c53133c95e341301ea394531197e8fb","modified":1684831002739},{"_id":"public/2022/09/22/JavaScript/删除事件（解绑事件）/index.html","hash":"cc2190ec4be47f0abd15f2975e5890265df94d27","modified":1684831002739},{"_id":"public/2022/09/20/JavaScript/事件对象/index.html","hash":"253d7855f62095b72e539a631573a399906f4d7f","modified":1684831002739},{"_id":"public/2022/09/19/JavaScript/#DOM事件流/index.html","hash":"a618f452e7511ab2b16bfa3ca2eebf6c5fb77ccb","modified":1684831002739},{"_id":"public/2022/09/19/JavaScript/三种动态创建元素的区别/index.html","hash":"3a94ed1f0a3f0c8a708acd76ab0b9cc02de1c1ad","modified":1684831002739},{"_id":"public/2022/09/19/JavaScript/注册事件（绑定事件）/index.html","hash":"335bf8290dc74854a34ede4786a5df957836e992","modified":1684831002739},{"_id":"public/2022/09/17/JavaScript/节点操作之复制节点/index.html","hash":"c1da0fa9c26aa70f1a58dfef00bd9a0fc077ec8a","modified":1684831002739},{"_id":"public/2022/09/14/JavaScript/节点操作之删除节点/index.html","hash":"be9b6e5cbf75f00007ead03cd24a47f4b0c4afde","modified":1684831002739},{"_id":"public/2022/09/14/JavaScript/节点操作之创建节点/index.html","hash":"4e76349fe1b3e63a7ba21c6d3e2d9f8597d1ec43","modified":1684831002739},{"_id":"public/2022/09/14/青训营-快乐出发/index.html","hash":"82aba285c308dc6277927e17e1eb76639d578595","modified":1684831002739},{"_id":"public/2022/09/13/JavaScript/节点操作/index.html","hash":"4ca996d3eb6c3da96a24591123706ed13407d832","modified":1684831002739},{"_id":"public/2022/09/09/JavaScript/DOM事件/index.html","hash":"af11765c94d77556f1d2444e943677d8e26cc207","modified":1684831002739},{"_id":"public/2022/09/09/JavaScript/操作元素/index.html","hash":"1b7bc6f5f941011d418cf0d55ff92fc2d6d05d3e","modified":1684831002739},{"_id":"public/2022/08/31/JavaScript/数组常用方法3.0/index.html","hash":"759df26e7b82d64f96c058efab8ba311012ec07f","modified":1684831002739},{"_id":"public/2022/08/30/CSS三大特性/index.html","hash":"2bce65aba5fd8d052247768214e10bf72c1ed5f0","modified":1684831002739},{"_id":"public/2022/08/30/JavaScript/new 关键字/index.html","hash":"e9492e200356782a6062debfc89d74c6aa48b6d0","modified":1684831002739},{"_id":"public/2022/08/29/JavaScript/数组常用方法/index.html","hash":"2cd6b24512b3ec438dc267e1fbd0a104375b4fb8","modified":1684831002739},{"_id":"public/2022/08/29/JavaScript/日期与时间/index.html","hash":"1a0798e0a59ce7e43e4090fa8bfd901871d8829d","modified":1684831002739},{"_id":"public/2022/08/26/JavaScript/JavaScript的浅拷贝与深拷贝/index.html","hash":"5b23eb9f3abc475ea96f8a8b971b178c925e81c0","modified":1684831002739},{"_id":"public/2022/08/22/flex布局/index.html","hash":"67745f1c4399039c6c32e9233f8ac58f9f6935ec","modified":1684831002739},{"_id":"public/2022/08/21/JavaScript/函数表达式和函数声明的区别/index.html","hash":"e4a4c5d34a75b4deaea7067a62f191cb7be40a38","modified":1684831002739},{"_id":"public/2022/08/21/JavaScript/对象/index.html","hash":"992de81e13c6a9423ae68130f9dbae1be675a015","modified":1684831002739},{"_id":"public/2022/08/20/JavaScript/函数/index.html","hash":"2ef85e884083f791a8aa01f24125d27bb5f82b19","modified":1684831002739},{"_id":"public/2022/08/20/JavaScript/原始值与引用值/index.html","hash":"20d4a08e854ecf3961e900a796af862066e4388f","modified":1684831002739},{"_id":"public/2022/08/20/JavaScript/数组常用方法2.0/index.html","hash":"4c929ce40b10eb5408d447fb4778cc480d878ac8","modified":1684831002739},{"_id":"public/archives/index.html","hash":"8102d0a32955dbb8b1747530331f7e718b20363b","modified":1684831002739},{"_id":"public/archives/page/2/index.html","hash":"7b54cbb4ab39d8e483ad10dbbb60f40c267a012b","modified":1684831002739},{"_id":"public/archives/page/3/index.html","hash":"48723ca52dbc36381c84b12cece4a0059e1396d1","modified":1684831002739},{"_id":"public/archives/page/4/index.html","hash":"af0bd54a6ca9075bd076c90168471f39a7228cd2","modified":1684831002739},{"_id":"public/archives/page/5/index.html","hash":"dc30853c566282f9fc183d2a4a891cd95963d8fb","modified":1684831002739},{"_id":"public/archives/page/6/index.html","hash":"4f31f10492f5c7dadbbc95404c247887795c2abd","modified":1684831002739},{"_id":"public/archives/page/7/index.html","hash":"ff605b354f3a7c724ef33d0eb2209fd6a9c93b81","modified":1684831002739},{"_id":"public/archives/page/8/index.html","hash":"e26b51762c8698ca0678ee6f352373ce4278005d","modified":1684831002739},{"_id":"public/archives/page/9/index.html","hash":"3e7d123afd06de9f1c02034dde410ca8dd18638b","modified":1684831002739},{"_id":"public/archives/page/10/index.html","hash":"66dad46f0b7720628023664e1fbb96dee4a1de4d","modified":1684831002739},{"_id":"public/archives/page/11/index.html","hash":"cf2cc7ddead8911238374582af14db3dcafc4ab5","modified":1684831002739},{"_id":"public/archives/page/12/index.html","hash":"8e9ad47cb4e042c1552ad73d5a5624114714b07f","modified":1684831002739},{"_id":"public/archives/page/13/index.html","hash":"5f73647b16e2ba16d1f1bcb9d1e4fe0fac2ffb45","modified":1684831002739},{"_id":"public/archives/2022/index.html","hash":"c19629202b166aa6e691b88c06cac17e292a7c6e","modified":1684831002739},{"_id":"public/archives/2022/page/2/index.html","hash":"f63a6ed26b88807377476a8c5d47e4f586edcdda","modified":1684831002739},{"_id":"public/archives/2022/page/3/index.html","hash":"cbc84ae8bb8b00bd26ed52ae12fbae00ab454453","modified":1684831002739},{"_id":"public/archives/2022/page/4/index.html","hash":"194686422c3a0e8692e320e3f6e55ccdec8b8fad","modified":1684831002739},{"_id":"public/archives/2022/page/5/index.html","hash":"f7fe29a58e1240b831213fa3a09d0c239fa783fb","modified":1684831002739},{"_id":"public/archives/2022/page/6/index.html","hash":"a1a21af20964053f4cb77d465064501aaa683fc2","modified":1684831002739},{"_id":"public/archives/2022/page/7/index.html","hash":"d04ed907d433f9ae00e7f64b50636dd9e9e92286","modified":1684831002739},{"_id":"public/archives/2022/08/index.html","hash":"6d4710042e5bb51ab522dd6e38dcef57be24d2fb","modified":1684831002739},{"_id":"public/archives/2022/08/page/2/index.html","hash":"eaba1e4543da36f673bfe9bee008f32ab4d2235f","modified":1684831002739},{"_id":"public/archives/2022/09/index.html","hash":"b513efcd1ff936f0c6cedaa28af112d46b4e95a9","modified":1684831002739},{"_id":"public/archives/2022/09/page/2/index.html","hash":"5fc45c21090f662f4d9b5230db799c507864e6c4","modified":1684831002739},{"_id":"public/archives/2022/09/page/3/index.html","hash":"4c4f445dda25646ec24d16d27c4f3298ba510377","modified":1684831002739},{"_id":"public/archives/2022/10/index.html","hash":"2a388a1a3047dc7cee887513fdf71a0c482ef1b4","modified":1684831002739},{"_id":"public/archives/2022/10/page/2/index.html","hash":"8e3b82d65449bd8520fccd9b411e9be114029a3a","modified":1684831002739},{"_id":"public/archives/2022/10/page/3/index.html","hash":"a437c40c62672e1728bb92cec03f93a212aea654","modified":1684831002739},{"_id":"public/archives/2022/11/index.html","hash":"9abbd0f9d580869d499a434632af7d2e15698574","modified":1684831002739},{"_id":"public/archives/2022/12/index.html","hash":"182bc5ff18f7fe2fbe1947b8e57b5419156df725","modified":1684831002739},{"_id":"public/archives/2023/index.html","hash":"8077af1f0378c24ddfc758536dc64df89d7a5c15","modified":1684831002739},{"_id":"public/archives/2023/page/2/index.html","hash":"e29696e555a3a1d44011efdd257db0585ed049a6","modified":1684831002739},{"_id":"public/archives/2023/page/3/index.html","hash":"85f17bd7da4015aa6bc7348eb0339b1a4081ceec","modified":1684831002739},{"_id":"public/archives/2023/page/4/index.html","hash":"e869ea233baaab3e7b17fc5533628848013216b3","modified":1684831002739},{"_id":"public/archives/2023/page/5/index.html","hash":"d2ab8c5311b64161a4c63e9cf84c09d6571bec83","modified":1684831002739},{"_id":"public/archives/2023/page/6/index.html","hash":"f131fedd261f64d1e9ac7c8462f9b5252c2348f6","modified":1684831002739},{"_id":"public/archives/2023/01/index.html","hash":"4baf24a87ba2233da34f117ebfe1c9fb2810210d","modified":1684831002739},{"_id":"public/archives/2023/01/page/2/index.html","hash":"e9837ea8a504e4dba491448e623acdfdddf4faab","modified":1684831002739},{"_id":"public/archives/2023/01/page/3/index.html","hash":"93af69ad0a64b9bb2d861ffe15913fbc1e0336ea","modified":1684831002739},{"_id":"public/archives/2023/02/index.html","hash":"192a2e501b9266273b843d817476f5ec6b3a080b","modified":1684831002739},{"_id":"public/archives/2023/03/index.html","hash":"c1f0a566495cce61f4febf8e52a6ace93ed1deb3","modified":1684831002739},{"_id":"public/archives/2023/03/page/2/index.html","hash":"31d53d480161a07e427049ec3544dd842ac5b7cf","modified":1684831002739},{"_id":"public/archives/2023/04/index.html","hash":"9eefc133e5aaa24ddd502a50393981b0a84d05ab","modified":1684831002739},{"_id":"public/archives/2023/05/index.html","hash":"ec22cb7cced7bb19ffca263633da46fbdcccaaa3","modified":1684831002739},{"_id":"public/archives/20223/index.html","hash":"3b326650d2d05a28f2660969cc8e4023a0f3cd9f","modified":1684831002739},{"_id":"public/archives/20223/05/index.html","hash":"1449a79680ea1b625b84173afb1a6e61c82e93cb","modified":1684831002739},{"_id":"public/categories/css/index.html","hash":"a841be98cdae46abb86fe9659a5c4ce04ae4e78a","modified":1684831002739},{"_id":"public/categories/css/page/2/index.html","hash":"e6fc9e56b6c167fd725e4f67f9d59291128448b3","modified":1684831002739},{"_id":"public/categories/jQuery/index.html","hash":"a3bf42e60586748f80a0c8451f35296f332d7905","modified":1684831002739},{"_id":"public/categories/随笔/index.html","hash":"5af506e70e01adfeb9661096dca21b536d11e884","modified":1684831002739},{"_id":"public/categories/Vue/index.html","hash":"ea29bced5a76499018e2ac271f7219326ba0d0a7","modified":1684831002739},{"_id":"public/categories/CSS/index.html","hash":"c2062d7526c8eb00f839d5f2c9b3d78990a65375","modified":1684831002739},{"_id":"public/categories/css/html/index.html","hash":"678adf7c2725f75527f3bc382e73d50f7267e1d9","modified":1684831002739},{"_id":"public/categories/ES6/index.html","hash":"3bb903dab8d601c2a0ccc533e360a44b5be5207e","modified":1684831002739},{"_id":"public/categories/Java/index.html","hash":"a06a4d387c771c4c48352a05d3088623042e477c","modified":1684831002739},{"_id":"public/categories/Java/page/2/index.html","hash":"03febda8d82fad116911e944f541277ec6c91281","modified":1684831002739},{"_id":"public/categories/AJAX/index.html","hash":"e5cd6112959e39222533764aebd7dbb0168cc2af","modified":1684831002739},{"_id":"public/categories/JavaScript/index.html","hash":"2ee97454bfc13e79327fbff8ac6cf26faea62554","modified":1684831002739},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"f11b902486a56d6630031b9da14051703106a2c2","modified":1684831002739},{"_id":"public/categories/JavaScript/page/3/index.html","hash":"586ed094b0d61255bca75094c739b2e5bfde9d91","modified":1684831002739},{"_id":"public/categories/JavaScript/page/4/index.html","hash":"aca7d3d13c7ebcce6c39b26834e61d370889cb31","modified":1684831002739},{"_id":"public/categories/JavaScript/page/5/index.html","hash":"1a61378783fda924d410014cdcfa45f9f2bbf1ce","modified":1684831002739},{"_id":"public/categories/BOM/index.html","hash":"3951e61b52f47083a3fb25a44293987d33ae2172","modified":1684831002739},{"_id":"public/categories/DOM/index.html","hash":"55a31b27f11112628f1b60c2aec7cc925452c919","modified":1684831002739},{"_id":"public/categories/node/index.html","hash":"8aa5c8afdac2b585494246470e71d610c592576c","modified":1684831002739},{"_id":"public/categories/JavaScript/刷题/index.html","hash":"b38457179869fd18f896139435f3133e3838b900","modified":1684831002739},{"_id":"public/categories/JavaScript/DOM/index.html","hash":"decac84a5310ae2fe0dc25e8f1d4c70dde122eb9","modified":1684831002739},{"_id":"public/categories/JavaScript/ES6/index.html","hash":"7ad1fb6bbb3c4b33b2b3f02ea917bc4ec9004c30","modified":1684831002739},{"_id":"public/categories/Vue3/index.html","hash":"d2ea5c3d4f06ea61f6f1532117ce01ccf2d1ac87","modified":1684831002739},{"_id":"public/categories/canvas/index.html","hash":"9e81c8de867b3572b8c3dda137d79f575d8dcc05","modified":1684831002739},{"_id":"public/categories/HTML/index.html","hash":"c3dd1144c73b8130c6081028f3a13e3598235927","modified":1684831002739},{"_id":"public/categories/操作系统/index.html","hash":"2c69cf61909232fd10f2d0672b863d59f76fab50","modified":1684831002739},{"_id":"public/categories/安卓/index.html","hash":"c011731cdbd0b58a1dcffb071a8f44a1b294ccf7","modified":1684831002739},{"_id":"public/categories/后端/index.html","hash":"60addca4820339f968f6fcfb5f850130ccbf6ad4","modified":1684831002739},{"_id":"public/categories/青训营/index.html","hash":"a5b0d12d0a8e3e578a1bd315c4753cdd3e12c5f2","modified":1684831002739},{"_id":"public/index.html","hash":"89cf3c8bcce8f05c7f6be12b75b58062ffa87b97","modified":1684831002739},{"_id":"public/page/2/index.html","hash":"b15887b38bbcd9a043a16e8445cd0fe12fa1b033","modified":1684831002739},{"_id":"public/page/3/index.html","hash":"3b2ab87001a30a7c46adecc8a12f25fe82e720fb","modified":1684831002739},{"_id":"public/page/4/index.html","hash":"175e65f2b8ef540530ea4f51ccaa7b00332e1691","modified":1684831002739},{"_id":"public/page/5/index.html","hash":"c2eacb925c6fc2cd0407823f108c8794e9d2f029","modified":1684831002739},{"_id":"public/page/6/index.html","hash":"fd0eb8e9e04d01e003e35ea7ef0242cdc94d6079","modified":1684831002739},{"_id":"public/page/7/index.html","hash":"619f9564825452a0d209bbf8471d0c1830a061ee","modified":1684831002739},{"_id":"public/page/8/index.html","hash":"2e6a9d85f6c1e3eccf5e277e614285500a7d295c","modified":1684831002739},{"_id":"public/page/9/index.html","hash":"4c1c54102a9d38946e64e78f2b891de0fe64dba3","modified":1684831002739},{"_id":"public/page/10/index.html","hash":"9d859d2f6b09acfdeef7b05c8fee1504928c9ed9","modified":1684831002739},{"_id":"public/page/11/index.html","hash":"0d1c6971ab7c74b24282f55ae5bb54e8f66a5a2e","modified":1684831002739},{"_id":"public/page/12/index.html","hash":"442d8229663e3b4305c527ae0150109d2e10cc63","modified":1684831002739},{"_id":"public/page/13/index.html","hash":"aef4b28e914f9d4340301b74d6bfedda733e614a","modified":1684831002739},{"_id":"public/page/14/index.html","hash":"193b2481f7a3e55c6aed2d502938f6bb96246ad4","modified":1684831002739},{"_id":"public/page/15/index.html","hash":"abd2a79f5511266eef0e5ddef6eec1001526d7f7","modified":1684831002739},{"_id":"public/tags/前端/index.html","hash":"9674aa045172947e1633f6150b8f45e7e053be32","modified":1684831002739},{"_id":"public/tags/前端/page/2/index.html","hash":"dba0c81b62774d15caaa681eef1495ca39d3abd8","modified":1684831002739},{"_id":"public/tags/前端/page/3/index.html","hash":"31c1c3a66db7a1cee0a49ce3279b1198a260c8bd","modified":1684831002739},{"_id":"public/tags/前端/page/4/index.html","hash":"d1985ce3752e7681d2fc831fe0b81cdb08426b61","modified":1684831002739},{"_id":"public/tags/前端/page/5/index.html","hash":"78ef39e5ce541ceaef9a9df12b23a71a3c236aee","modified":1684831002739},{"_id":"public/tags/前端/page/6/index.html","hash":"f99aaf6090cc30f7e02449c3790222806d983816","modified":1684831002739},{"_id":"public/tags/前端/page/7/index.html","hash":"0a2e52449e1a9c7a342e6eba5d087ce793c4695e","modified":1684831002739},{"_id":"public/tags/前端/page/8/index.html","hash":"e530339931ec2f5c37a2a40516657dc360214d7e","modified":1684831002739},{"_id":"public/tags/前端/page/9/index.html","hash":"89e6b674aec491a727a4c26986c86e9e40f5a3cc","modified":1684831002739},{"_id":"public/tags/前端/page/10/index.html","hash":"30cfa5548bdae4bca6c1a9614b56d78b387edc76","modified":1684831002739},{"_id":"public/tags/前端/page/11/index.html","hash":"471f5b643277de71c8c7eb1defa2ad68a69da8d7","modified":1684831002739},{"_id":"public/tags/随笔/index.html","hash":"329b83a2dff4586ed617477de58f0901b7caa33b","modified":1684831002739},{"_id":"public/tags/后端/index.html","hash":"e15627fc32516b1d6a084470ca0fce631ec46710","modified":1684831002739},{"_id":"public/tags/后端/page/2/index.html","hash":"457d54642cb95aea89b3640ec355174176973579","modified":1684831002739},{"_id":"public/tags/计算机/index.html","hash":"33cb296120d0f35de3ada31a65596b10b794b861","modified":1684831002739},{"_id":"public/tags/java/index.html","hash":"d30aeaaad1ff9dc62a8a3952413ad1907debe607","modified":1684831002739},{"_id":"public/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1684831002739},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1684831002739},{"_id":"public/images/avatar.jpg","hash":"f86eafc318f3900319b25057811720168f24d248","modified":1684831002739},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1684831002739},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1684831002739},{"_id":"public/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1684831002739},{"_id":"public/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1684831002739},{"_id":"public/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1684831002739},{"_id":"public/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1684831002739},{"_id":"public/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1684831002739},{"_id":"public/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1684831002739},{"_id":"public/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1684831002739},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1684831002739},{"_id":"public/fonts/README.html","hash":"3b9daaf126709e3bbce5926e15d599f1fe877921","modified":1684831002739},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1684831002739},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1684831002739},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1684831002739},{"_id":"public/css/style.css","hash":"a115348d8810a8d6b608ffc7bb02b915b3f48534","modified":1684831002739},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1684831002739},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1684831002739},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1684831002739},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1684831002739},{"_id":"public/fonts/iconfont.svg","hash":"1af91521f1c29c231ffc19d7f64696ddcd71470b","modified":1684831002739}],"Category":[{"name":"css","_id":"cli00vmgd00029kbm0fm377m0"},{"name":"jQuery","_id":"cli00vmgv000m9kbm129x4qxx"},{"name":"随笔","_id":"cli00vmh0000t9kbm13p0dwkq"},{"name":"Vue","_id":"cli00vmha00109kbm1jwshv6u"},{"name":"CSS","_id":"cli00vmhg001d9kbm106u6jw4"},{"name":"html","parent":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmhi001m9kbma0pebyvo"},{"name":"ES6","_id":"cli00vmhk001t9kbm1h4zatlr"},{"name":"Java","_id":"cli00vmhp002a9kbm2et767fa"},{"name":"AJAX","_id":"cli00vmhv002r9kbmh7xe5hoc"},{"name":"JavaScript","_id":"cli00vmhx00319kbmeiwr54ev"},{"name":"BOM","_id":"cli00vmi1003f9kbm792o8ug8"},{"name":"DOM","_id":"cli00vmi5003t9kbmbe5v6rtq"},{"name":"node","_id":"cli00vmii004u9kbmbydag9eq"},{"name":"刷题","parent":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj000679kbmaueqh1fo"},{"name":"DOM","parent":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj9006z9kbmeu88bqq8"},{"name":"ES6","parent":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmjg007k9kbm20204ejk"},{"name":"Vue3","_id":"cli00vmji007r9kbm3mbj9n9p"},{"name":"canvas","_id":"cli00vmk3008i9kbmhe036pag"},{"name":"HTML","_id":"cli00vmka008s9kbm5xvnht5f"},{"name":"操作系统","_id":"cli00vmki008z9kbm8vpc5z3y"},{"name":"安卓","_id":"cli00vmkn009a9kbmfdiidk47"},{"name":"后端","_id":"cli00vmkv00a29kbmd5gmfksu"},{"name":"青训营","_id":"cli00vml300al9kbm7got0pgw"}],"Data":[],"Page":[],"Post":[{"title":"BEM命名规范","data":"2023-2-8","_content":"# CSS中BEM的命名规范\n\n随着现在前端开发越来越复杂，越来越多的人开始使用BEM命名规范，这里简单介绍一下BEM的命名规范。\n\n## 什么是BEM\n\nBEM是Block Element Modifier的缩写，意思是块、元素、修饰符。\n\n这是为了更好的管理实现开发中对CSS类名的命名，使得后期对代码更好的迭代维护。\n\n## BEM的命名规范\n\nBEM的命名规范是由三部分组成的，分别是块、元素、修饰符。\n\n我们会使用几个特殊的连接词将这三个部分连接起来，然后作为一个完整的CSS类名。\n\n- 对于块与元素之间的连接，我们使用两个下划线`__`连接。（div__span）\n- 对于块与修饰符之间的连接，我们使用两个连字符`--`连接。（div--red）\n- 对于元素与修饰符之间的连接，我们使用两个连字符`--`连接。（div__span--red）\n\n### 块（B）\n\n块是一个独立的实体，可以是一个页面，也可以是一个组件，比如一个按钮，一个导航栏，一个页面等等。\n\n我们可以这样理解，块就是我们CSS里面的父级元素，比如`ul`，它一般会有子元素`li`，这个时候我们就可以把`ul`作为一个块，`li`作为一个元素。\n\n`ul__li`\n\n当我们对块级进行修饰的时候，如果不能只用一个单词进行描述，我们可以使用`-`来进行连接，`button-area`。\n\n### 元素（E）\n\n元素是块的一部分，它是块的子元素，比如块是一个导航栏，那么元素就是导航栏的子元素，比如导航栏的菜单项，导航栏的菜单项的链接等等。\n\n我们可以把元素理解为块的子元素，比如`ul`，它的子元素就是`li`，那么`li`就是`ul`的元素。\n\n`ul__li`\n\n### 修饰符（M）\n\n修饰符是对块或者元素的修饰，比如块的颜色，块的大小，块的状态等等。\n\n比如在ElementUI中，它的按钮有三种颜色，代表三种状态，我们就可以根据它的状态来进行修饰。\n\n`button--primary`\n`button--success`\n\n## BEM的优点\n\n- 有利于代码的复用\n- 代码的可维护性\n- 代码更加便于阅读\n\n## 总结\n\nBEM的命名规范是为了更好的管理实现开发中对CSS类名的命名，使得后期对代码更好的迭代维护。\n\n在日常开发中，我们应该养成良好的命名习惯，这样可以使得我们的代码更加的规范，更加的便于阅读，更加的便于维护。","source":"_posts/BEM命名规范.md","raw":"---\ntitle: BEM命名规范\ndata: 2023-2-8\ntags: [前端]\ncategories: [css]\n---\n# CSS中BEM的命名规范\n\n随着现在前端开发越来越复杂，越来越多的人开始使用BEM命名规范，这里简单介绍一下BEM的命名规范。\n\n## 什么是BEM\n\nBEM是Block Element Modifier的缩写，意思是块、元素、修饰符。\n\n这是为了更好的管理实现开发中对CSS类名的命名，使得后期对代码更好的迭代维护。\n\n## BEM的命名规范\n\nBEM的命名规范是由三部分组成的，分别是块、元素、修饰符。\n\n我们会使用几个特殊的连接词将这三个部分连接起来，然后作为一个完整的CSS类名。\n\n- 对于块与元素之间的连接，我们使用两个下划线`__`连接。（div__span）\n- 对于块与修饰符之间的连接，我们使用两个连字符`--`连接。（div--red）\n- 对于元素与修饰符之间的连接，我们使用两个连字符`--`连接。（div__span--red）\n\n### 块（B）\n\n块是一个独立的实体，可以是一个页面，也可以是一个组件，比如一个按钮，一个导航栏，一个页面等等。\n\n我们可以这样理解，块就是我们CSS里面的父级元素，比如`ul`，它一般会有子元素`li`，这个时候我们就可以把`ul`作为一个块，`li`作为一个元素。\n\n`ul__li`\n\n当我们对块级进行修饰的时候，如果不能只用一个单词进行描述，我们可以使用`-`来进行连接，`button-area`。\n\n### 元素（E）\n\n元素是块的一部分，它是块的子元素，比如块是一个导航栏，那么元素就是导航栏的子元素，比如导航栏的菜单项，导航栏的菜单项的链接等等。\n\n我们可以把元素理解为块的子元素，比如`ul`，它的子元素就是`li`，那么`li`就是`ul`的元素。\n\n`ul__li`\n\n### 修饰符（M）\n\n修饰符是对块或者元素的修饰，比如块的颜色，块的大小，块的状态等等。\n\n比如在ElementUI中，它的按钮有三种颜色，代表三种状态，我们就可以根据它的状态来进行修饰。\n\n`button--primary`\n`button--success`\n\n## BEM的优点\n\n- 有利于代码的复用\n- 代码的可维护性\n- 代码更加便于阅读\n\n## 总结\n\nBEM的命名规范是为了更好的管理实现开发中对CSS类名的命名，使得后期对代码更好的迭代维护。\n\n在日常开发中，我们应该养成良好的命名习惯，这样可以使得我们的代码更加的规范，更加的便于阅读，更加的便于维护。","slug":"BEM命名规范","published":1,"date":"2023-02-08T10:46:21.615Z","updated":"2023-02-08T12:20:29.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmg200009kbmfyb6h1xs","content":"<h1 id=\"CSS中BEM的命名规范\"><a href=\"#CSS中BEM的命名规范\" class=\"headerlink\" title=\"CSS中BEM的命名规范\"></a>CSS中BEM的命名规范</h1><p>随着现在前端开发越来越复杂，越来越多的人开始使用BEM命名规范，这里简单介绍一下BEM的命名规范。</p>\n<h2 id=\"什么是BEM\"><a href=\"#什么是BEM\" class=\"headerlink\" title=\"什么是BEM\"></a>什么是BEM</h2><p>BEM是Block Element Modifier的缩写，意思是块、元素、修饰符。</p>\n<p>这是为了更好的管理实现开发中对CSS类名的命名，使得后期对代码更好的迭代维护。</p>\n<h2 id=\"BEM的命名规范\"><a href=\"#BEM的命名规范\" class=\"headerlink\" title=\"BEM的命名规范\"></a>BEM的命名规范</h2><p>BEM的命名规范是由三部分组成的，分别是块、元素、修饰符。</p>\n<p>我们会使用几个特殊的连接词将这三个部分连接起来，然后作为一个完整的CSS类名。</p>\n<ul>\n<li>对于块与元素之间的连接，我们使用两个下划线<code>__</code>连接。（div__span）</li>\n<li>对于块与修饰符之间的连接，我们使用两个连字符<code>--</code>连接。（div–red）</li>\n<li>对于元素与修饰符之间的连接，我们使用两个连字符<code>--</code>连接。（div__span–red）</li>\n</ul>\n<h3 id=\"块（B）\"><a href=\"#块（B）\" class=\"headerlink\" title=\"块（B）\"></a>块（B）</h3><p>块是一个独立的实体，可以是一个页面，也可以是一个组件，比如一个按钮，一个导航栏，一个页面等等。</p>\n<p>我们可以这样理解，块就是我们CSS里面的父级元素，比如<code>ul</code>，它一般会有子元素<code>li</code>，这个时候我们就可以把<code>ul</code>作为一个块，<code>li</code>作为一个元素。</p>\n<p><code>ul__li</code></p>\n<p>当我们对块级进行修饰的时候，如果不能只用一个单词进行描述，我们可以使用<code>-</code>来进行连接，<code>button-area</code>。</p>\n<h3 id=\"元素（E）\"><a href=\"#元素（E）\" class=\"headerlink\" title=\"元素（E）\"></a>元素（E）</h3><p>元素是块的一部分，它是块的子元素，比如块是一个导航栏，那么元素就是导航栏的子元素，比如导航栏的菜单项，导航栏的菜单项的链接等等。</p>\n<p>我们可以把元素理解为块的子元素，比如<code>ul</code>，它的子元素就是<code>li</code>，那么<code>li</code>就是<code>ul</code>的元素。</p>\n<p><code>ul__li</code></p>\n<h3 id=\"修饰符（M）\"><a href=\"#修饰符（M）\" class=\"headerlink\" title=\"修饰符（M）\"></a>修饰符（M）</h3><p>修饰符是对块或者元素的修饰，比如块的颜色，块的大小，块的状态等等。</p>\n<p>比如在ElementUI中，它的按钮有三种颜色，代表三种状态，我们就可以根据它的状态来进行修饰。</p>\n<p><code>button--primary</code><br><code>button--success</code></p>\n<h2 id=\"BEM的优点\"><a href=\"#BEM的优点\" class=\"headerlink\" title=\"BEM的优点\"></a>BEM的优点</h2><ul>\n<li>有利于代码的复用</li>\n<li>代码的可维护性</li>\n<li>代码更加便于阅读</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>BEM的命名规范是为了更好的管理实现开发中对CSS类名的命名，使得后期对代码更好的迭代维护。</p>\n<p>在日常开发中，我们应该养成良好的命名习惯，这样可以使得我们的代码更加的规范，更加的便于阅读，更加的便于维护。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS中BEM的命名规范\"><a href=\"#CSS中BEM的命名规范\" class=\"headerlink\" title=\"CSS中BEM的命名规范\"></a>CSS中BEM的命名规范</h1><p>随着现在前端开发越来越复杂，越来越多的人开始使用BEM命名规范，这里简单介绍一下BEM的命名规范。</p>\n<h2 id=\"什么是BEM\"><a href=\"#什么是BEM\" class=\"headerlink\" title=\"什么是BEM\"></a>什么是BEM</h2><p>BEM是Block Element Modifier的缩写，意思是块、元素、修饰符。</p>\n<p>这是为了更好的管理实现开发中对CSS类名的命名，使得后期对代码更好的迭代维护。</p>\n<h2 id=\"BEM的命名规范\"><a href=\"#BEM的命名规范\" class=\"headerlink\" title=\"BEM的命名规范\"></a>BEM的命名规范</h2><p>BEM的命名规范是由三部分组成的，分别是块、元素、修饰符。</p>\n<p>我们会使用几个特殊的连接词将这三个部分连接起来，然后作为一个完整的CSS类名。</p>\n<ul>\n<li>对于块与元素之间的连接，我们使用两个下划线<code>__</code>连接。（div__span）</li>\n<li>对于块与修饰符之间的连接，我们使用两个连字符<code>--</code>连接。（div–red）</li>\n<li>对于元素与修饰符之间的连接，我们使用两个连字符<code>--</code>连接。（div__span–red）</li>\n</ul>\n<h3 id=\"块（B）\"><a href=\"#块（B）\" class=\"headerlink\" title=\"块（B）\"></a>块（B）</h3><p>块是一个独立的实体，可以是一个页面，也可以是一个组件，比如一个按钮，一个导航栏，一个页面等等。</p>\n<p>我们可以这样理解，块就是我们CSS里面的父级元素，比如<code>ul</code>，它一般会有子元素<code>li</code>，这个时候我们就可以把<code>ul</code>作为一个块，<code>li</code>作为一个元素。</p>\n<p><code>ul__li</code></p>\n<p>当我们对块级进行修饰的时候，如果不能只用一个单词进行描述，我们可以使用<code>-</code>来进行连接，<code>button-area</code>。</p>\n<h3 id=\"元素（E）\"><a href=\"#元素（E）\" class=\"headerlink\" title=\"元素（E）\"></a>元素（E）</h3><p>元素是块的一部分，它是块的子元素，比如块是一个导航栏，那么元素就是导航栏的子元素，比如导航栏的菜单项，导航栏的菜单项的链接等等。</p>\n<p>我们可以把元素理解为块的子元素，比如<code>ul</code>，它的子元素就是<code>li</code>，那么<code>li</code>就是<code>ul</code>的元素。</p>\n<p><code>ul__li</code></p>\n<h3 id=\"修饰符（M）\"><a href=\"#修饰符（M）\" class=\"headerlink\" title=\"修饰符（M）\"></a>修饰符（M）</h3><p>修饰符是对块或者元素的修饰，比如块的颜色，块的大小，块的状态等等。</p>\n<p>比如在ElementUI中，它的按钮有三种颜色，代表三种状态，我们就可以根据它的状态来进行修饰。</p>\n<p><code>button--primary</code><br><code>button--success</code></p>\n<h2 id=\"BEM的优点\"><a href=\"#BEM的优点\" class=\"headerlink\" title=\"BEM的优点\"></a>BEM的优点</h2><ul>\n<li>有利于代码的复用</li>\n<li>代码的可维护性</li>\n<li>代码更加便于阅读</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>BEM的命名规范是为了更好的管理实现开发中对CSS类名的命名，使得后期对代码更好的迭代维护。</p>\n<p>在日常开发中，我们应该养成良好的命名习惯，这样可以使得我们的代码更加的规范，更加的便于阅读，更加的便于维护。</p>\n"},{"title":"CSS 2D转换","date":"2022-10-08T16:00:00.000Z","_content":"# CSS2D转换\n\n今天给大家带来的是css经常用到的属性，不管是元素旋转还是元素移动，都是用到了css3的transform属性，今天我们就来看看这个属性的用法。\n\n## 2D转换\n\n2D转换顾名思义就是在平面上做一些移动之类改变元素位置的操作。\n\n`transforms`这个属性可以允许我们将元素移动，旋转，缩放，倾斜。下面我将从这四个方面来讲解这个属性。\n\n### 1. 移动\n\n`translate`这个属性可以让我们将元素在水平和垂直方向上移动，这个属性有两个值，第一个值是水平方向上的移动，第二个值是垂直方向上的移动。\n\n```css\ndiv{\n    transform: translate(100px, 100px);\n}\n```\n\n**注意：**\n\n1. 这个属性的值可以是负数，也可以是百分比，也可以是em，rem等单位。\n2. 此种写法，第一个必须为水平(x)方向上的移动，第二个必须为垂直方向(y)上的移动，如果只想移动一个方向，另一个方向上的值必须为0。\n\n要是我们只想要移动一个方法，这样写难免有点麻烦，所以我们可以这样写：\n\n```css\ndiv{\n    transform: translateX(100px);\n    transform: translateY(100px);\n}\n```\n\n这样我们就把水平方向和垂直方向上的移动分开了。分别进行设置。\n\n### 2. 旋转\n\n前面说了移动，接着我们就来说说如何将一个元素进行移动：\n\n```css \ndiv{\n    transform: rotate(45deg);\n}\n```\n\n这个`rotate`参数可以让我们将元素进行旋转，里面跟上我们需要旋转的度数，记得加上单位`deg`,注意：当旋转度数为正数时，表示顺时针旋转；当旋转度数为负数时，表示逆时针旋转。\n\n### 3. 缩放\n\n`scale`这个属性可以让我们将元素进行缩放，这个属性也有两个值，第一个值是水平方向上的缩放，第二个值是垂直方向上的缩放。\n\n```css\ndiv{\n    transform: scale(2, 2);\n}\n```\n\n**注意：**\n\n- 当我们使用`scale`时，里面传的两个参数，第一个代表将元素在水平方向(宽度)上进行缩放，第二个代表将元素在垂直方向(高度)上进行缩放。\n\n同样：如果我们只想要缩放一个方向，我们可以这样写：\n\n```css\ndiv{\n    transform: scaleX(2);\n    transform: scaleY(2);\n}\n```\n\n我们只需要在`scale`后面加上`X`或者`Y`就可以了。代表我们在水平方向缩放还是在垂直方向进行缩放。\n\n### 4. 倾斜\n\n`skew()`这个属性可以让我们将元素进行倾斜，这个属性也有两个值，第一个值是水平方向上的倾斜，第二个值是垂直方向上的倾斜。\n\n```css \ndiv{\n    transform: skew(45deg, 45deg);\n}\n```\n\n上面的代码表示将`div`元素在x轴上旋转45度，y轴上旋转45度。\n\n同样的此方法第一个参数代表的是水平方向上的倾斜，第二个参数代表的是垂直方向上的倾斜。\n\n那么我们如何判断元素的倾斜方向呢？我们可以这样来判断：\n\n1. 右手握紧伸出大指姆，大指姆指向该轴的正方向。\n2. 若是旋转度数为正，那么旋转方向就是剩下四根手指的方向。\n3. 若是旋转度数为负，那么旋转方向就是与四根手指相背的方向。\n\n如果我们只想要朝着一个方向进行倾斜时，上面代码的参数需要将不需要倾斜的轴设置为`0deg`，为了方便我们可以这样写：\n\n```css\ndiv{\n    transform: skewX(45deg);\n    transform: skewY(45deg);\n}\n```\n\n### 5. 组合\n\n如果我们按部就班的来写，那么我们就需要写很多行代码，这样就会显得很麻烦，所以我们可以将这些属性进行组合，这样就可以减少代码量。\n\n\n我们可以将上面的属性进行组合，来实现我们想要的效果。\n\n```css\ndiv{\n    transform: translate(100px, 100px) rotate(45deg) scale(2, 2) skew(45deg, 45deg);\n}\n```\n\n上面的代码表示将`div`元素进行平移、旋转、缩放、倾斜。","source":"_posts/CSS2D转换.md","raw":"---\ntitle: CSS 2D转换\ndate: 2022-10-9\ntags: [前端]\ncategories: [css]\n---\n# CSS2D转换\n\n今天给大家带来的是css经常用到的属性，不管是元素旋转还是元素移动，都是用到了css3的transform属性，今天我们就来看看这个属性的用法。\n\n## 2D转换\n\n2D转换顾名思义就是在平面上做一些移动之类改变元素位置的操作。\n\n`transforms`这个属性可以允许我们将元素移动，旋转，缩放，倾斜。下面我将从这四个方面来讲解这个属性。\n\n### 1. 移动\n\n`translate`这个属性可以让我们将元素在水平和垂直方向上移动，这个属性有两个值，第一个值是水平方向上的移动，第二个值是垂直方向上的移动。\n\n```css\ndiv{\n    transform: translate(100px, 100px);\n}\n```\n\n**注意：**\n\n1. 这个属性的值可以是负数，也可以是百分比，也可以是em，rem等单位。\n2. 此种写法，第一个必须为水平(x)方向上的移动，第二个必须为垂直方向(y)上的移动，如果只想移动一个方向，另一个方向上的值必须为0。\n\n要是我们只想要移动一个方法，这样写难免有点麻烦，所以我们可以这样写：\n\n```css\ndiv{\n    transform: translateX(100px);\n    transform: translateY(100px);\n}\n```\n\n这样我们就把水平方向和垂直方向上的移动分开了。分别进行设置。\n\n### 2. 旋转\n\n前面说了移动，接着我们就来说说如何将一个元素进行移动：\n\n```css \ndiv{\n    transform: rotate(45deg);\n}\n```\n\n这个`rotate`参数可以让我们将元素进行旋转，里面跟上我们需要旋转的度数，记得加上单位`deg`,注意：当旋转度数为正数时，表示顺时针旋转；当旋转度数为负数时，表示逆时针旋转。\n\n### 3. 缩放\n\n`scale`这个属性可以让我们将元素进行缩放，这个属性也有两个值，第一个值是水平方向上的缩放，第二个值是垂直方向上的缩放。\n\n```css\ndiv{\n    transform: scale(2, 2);\n}\n```\n\n**注意：**\n\n- 当我们使用`scale`时，里面传的两个参数，第一个代表将元素在水平方向(宽度)上进行缩放，第二个代表将元素在垂直方向(高度)上进行缩放。\n\n同样：如果我们只想要缩放一个方向，我们可以这样写：\n\n```css\ndiv{\n    transform: scaleX(2);\n    transform: scaleY(2);\n}\n```\n\n我们只需要在`scale`后面加上`X`或者`Y`就可以了。代表我们在水平方向缩放还是在垂直方向进行缩放。\n\n### 4. 倾斜\n\n`skew()`这个属性可以让我们将元素进行倾斜，这个属性也有两个值，第一个值是水平方向上的倾斜，第二个值是垂直方向上的倾斜。\n\n```css \ndiv{\n    transform: skew(45deg, 45deg);\n}\n```\n\n上面的代码表示将`div`元素在x轴上旋转45度，y轴上旋转45度。\n\n同样的此方法第一个参数代表的是水平方向上的倾斜，第二个参数代表的是垂直方向上的倾斜。\n\n那么我们如何判断元素的倾斜方向呢？我们可以这样来判断：\n\n1. 右手握紧伸出大指姆，大指姆指向该轴的正方向。\n2. 若是旋转度数为正，那么旋转方向就是剩下四根手指的方向。\n3. 若是旋转度数为负，那么旋转方向就是与四根手指相背的方向。\n\n如果我们只想要朝着一个方向进行倾斜时，上面代码的参数需要将不需要倾斜的轴设置为`0deg`，为了方便我们可以这样写：\n\n```css\ndiv{\n    transform: skewX(45deg);\n    transform: skewY(45deg);\n}\n```\n\n### 5. 组合\n\n如果我们按部就班的来写，那么我们就需要写很多行代码，这样就会显得很麻烦，所以我们可以将这些属性进行组合，这样就可以减少代码量。\n\n\n我们可以将上面的属性进行组合，来实现我们想要的效果。\n\n```css\ndiv{\n    transform: translate(100px, 100px) rotate(45deg) scale(2, 2) skew(45deg, 45deg);\n}\n```\n\n上面的代码表示将`div`元素进行平移、旋转、缩放、倾斜。","slug":"CSS2D转换","published":1,"updated":"2023-01-09T11:56:45.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmga00019kbm6rwhfvpg","content":"<h1 id=\"CSS2D转换\"><a href=\"#CSS2D转换\" class=\"headerlink\" title=\"CSS2D转换\"></a>CSS2D转换</h1><p>今天给大家带来的是css经常用到的属性，不管是元素旋转还是元素移动，都是用到了css3的transform属性，今天我们就来看看这个属性的用法。</p>\n<h2 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a>2D转换</h2><p>2D转换顾名思义就是在平面上做一些移动之类改变元素位置的操作。</p>\n<p><code>transforms</code>这个属性可以允许我们将元素移动，旋转，缩放，倾斜。下面我将从这四个方面来讲解这个属性。</p>\n<h3 id=\"1-移动\"><a href=\"#1-移动\" class=\"headerlink\" title=\"1. 移动\"></a>1. 移动</h3><p><code>translate</code>这个属性可以让我们将元素在水平和垂直方向上移动，这个属性有两个值，第一个值是水平方向上的移动，第二个值是垂直方向上的移动。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(<span class=\"number\">100px</span>, <span class=\"number\">100px</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ol>\n<li>这个属性的值可以是负数，也可以是百分比，也可以是em，rem等单位。</li>\n<li>此种写法，第一个必须为水平(x)方向上的移动，第二个必须为垂直方向(y)上的移动，如果只想移动一个方向，另一个方向上的值必须为0。</li>\n</ol>\n<p>要是我们只想要移动一个方法，这样写难免有点麻烦，所以我们可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(<span class=\"number\">100px</span>);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(<span class=\"number\">100px</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就把水平方向和垂直方向上的移动分开了。分别进行设置。</p>\n<h3 id=\"2-旋转\"><a href=\"#2-旋转\" class=\"headerlink\" title=\"2. 旋转\"></a>2. 旋转</h3><p>前面说了移动，接着我们就来说说如何将一个元素进行移动：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>rotate</code>参数可以让我们将元素进行旋转，里面跟上我们需要旋转的度数，记得加上单位<code>deg</code>,注意：当旋转度数为正数时，表示顺时针旋转；当旋转度数为负数时，表示逆时针旋转。</p>\n<h3 id=\"3-缩放\"><a href=\"#3-缩放\" class=\"headerlink\" title=\"3. 缩放\"></a>3. 缩放</h3><p><code>scale</code>这个属性可以让我们将元素进行缩放，这个属性也有两个值，第一个值是水平方向上的缩放，第二个值是垂直方向上的缩放。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>当我们使用<code>scale</code>时，里面传的两个参数，第一个代表将元素在水平方向(宽度)上进行缩放，第二个代表将元素在垂直方向(高度)上进行缩放。</li>\n</ul>\n<p>同样：如果我们只想要缩放一个方向，我们可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scaleX</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scaleY</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们只需要在<code>scale</code>后面加上<code>X</code>或者<code>Y</code>就可以了。代表我们在水平方向缩放还是在垂直方向进行缩放。</p>\n<h3 id=\"4-倾斜\"><a href=\"#4-倾斜\" class=\"headerlink\" title=\"4. 倾斜\"></a>4. 倾斜</h3><p><code>skew()</code>这个属性可以让我们将元素进行倾斜，这个属性也有两个值，第一个值是水平方向上的倾斜，第二个值是垂直方向上的倾斜。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(<span class=\"number\">45deg</span>, <span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码表示将<code>div</code>元素在x轴上旋转45度，y轴上旋转45度。</p>\n<p>同样的此方法第一个参数代表的是水平方向上的倾斜，第二个参数代表的是垂直方向上的倾斜。</p>\n<p>那么我们如何判断元素的倾斜方向呢？我们可以这样来判断：</p>\n<ol>\n<li>右手握紧伸出大指姆，大指姆指向该轴的正方向。</li>\n<li>若是旋转度数为正，那么旋转方向就是剩下四根手指的方向。</li>\n<li>若是旋转度数为负，那么旋转方向就是与四根手指相背的方向。</li>\n</ol>\n<p>如果我们只想要朝着一个方向进行倾斜时，上面代码的参数需要将不需要倾斜的轴设置为<code>0deg</code>，为了方便我们可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">skewX</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">skewY</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-组合\"><a href=\"#5-组合\" class=\"headerlink\" title=\"5. 组合\"></a>5. 组合</h3><p>如果我们按部就班的来写，那么我们就需要写很多行代码，这样就会显得很麻烦，所以我们可以将这些属性进行组合，这样就可以减少代码量。</p>\n<p>我们可以将上面的属性进行组合，来实现我们想要的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(<span class=\"number\">100px</span>, <span class=\"number\">100px</span>) <span class=\"built_in\">rotate</span>(<span class=\"number\">45deg</span>) <span class=\"built_in\">scale</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>) <span class=\"built_in\">skew</span>(<span class=\"number\">45deg</span>, <span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码表示将<code>div</code>元素进行平移、旋转、缩放、倾斜。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS2D转换\"><a href=\"#CSS2D转换\" class=\"headerlink\" title=\"CSS2D转换\"></a>CSS2D转换</h1><p>今天给大家带来的是css经常用到的属性，不管是元素旋转还是元素移动，都是用到了css3的transform属性，今天我们就来看看这个属性的用法。</p>\n<h2 id=\"2D转换\"><a href=\"#2D转换\" class=\"headerlink\" title=\"2D转换\"></a>2D转换</h2><p>2D转换顾名思义就是在平面上做一些移动之类改变元素位置的操作。</p>\n<p><code>transforms</code>这个属性可以允许我们将元素移动，旋转，缩放，倾斜。下面我将从这四个方面来讲解这个属性。</p>\n<h3 id=\"1-移动\"><a href=\"#1-移动\" class=\"headerlink\" title=\"1. 移动\"></a>1. 移动</h3><p><code>translate</code>这个属性可以让我们将元素在水平和垂直方向上移动，这个属性有两个值，第一个值是水平方向上的移动，第二个值是垂直方向上的移动。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(<span class=\"number\">100px</span>, <span class=\"number\">100px</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ol>\n<li>这个属性的值可以是负数，也可以是百分比，也可以是em，rem等单位。</li>\n<li>此种写法，第一个必须为水平(x)方向上的移动，第二个必须为垂直方向(y)上的移动，如果只想移动一个方向，另一个方向上的值必须为0。</li>\n</ol>\n<p>要是我们只想要移动一个方法，这样写难免有点麻烦，所以我们可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(<span class=\"number\">100px</span>);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(<span class=\"number\">100px</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就把水平方向和垂直方向上的移动分开了。分别进行设置。</p>\n<h3 id=\"2-旋转\"><a href=\"#2-旋转\" class=\"headerlink\" title=\"2. 旋转\"></a>2. 旋转</h3><p>前面说了移动，接着我们就来说说如何将一个元素进行移动：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>rotate</code>参数可以让我们将元素进行旋转，里面跟上我们需要旋转的度数，记得加上单位<code>deg</code>,注意：当旋转度数为正数时，表示顺时针旋转；当旋转度数为负数时，表示逆时针旋转。</p>\n<h3 id=\"3-缩放\"><a href=\"#3-缩放\" class=\"headerlink\" title=\"3. 缩放\"></a>3. 缩放</h3><p><code>scale</code>这个属性可以让我们将元素进行缩放，这个属性也有两个值，第一个值是水平方向上的缩放，第二个值是垂直方向上的缩放。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>当我们使用<code>scale</code>时，里面传的两个参数，第一个代表将元素在水平方向(宽度)上进行缩放，第二个代表将元素在垂直方向(高度)上进行缩放。</li>\n</ul>\n<p>同样：如果我们只想要缩放一个方向，我们可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scaleX</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scaleY</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们只需要在<code>scale</code>后面加上<code>X</code>或者<code>Y</code>就可以了。代表我们在水平方向缩放还是在垂直方向进行缩放。</p>\n<h3 id=\"4-倾斜\"><a href=\"#4-倾斜\" class=\"headerlink\" title=\"4. 倾斜\"></a>4. 倾斜</h3><p><code>skew()</code>这个属性可以让我们将元素进行倾斜，这个属性也有两个值，第一个值是水平方向上的倾斜，第二个值是垂直方向上的倾斜。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(<span class=\"number\">45deg</span>, <span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码表示将<code>div</code>元素在x轴上旋转45度，y轴上旋转45度。</p>\n<p>同样的此方法第一个参数代表的是水平方向上的倾斜，第二个参数代表的是垂直方向上的倾斜。</p>\n<p>那么我们如何判断元素的倾斜方向呢？我们可以这样来判断：</p>\n<ol>\n<li>右手握紧伸出大指姆，大指姆指向该轴的正方向。</li>\n<li>若是旋转度数为正，那么旋转方向就是剩下四根手指的方向。</li>\n<li>若是旋转度数为负，那么旋转方向就是与四根手指相背的方向。</li>\n</ol>\n<p>如果我们只想要朝着一个方向进行倾斜时，上面代码的参数需要将不需要倾斜的轴设置为<code>0deg</code>，为了方便我们可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">skewX</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">skewY</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-组合\"><a href=\"#5-组合\" class=\"headerlink\" title=\"5. 组合\"></a>5. 组合</h3><p>如果我们按部就班的来写，那么我们就需要写很多行代码，这样就会显得很麻烦，所以我们可以将这些属性进行组合，这样就可以减少代码量。</p>\n<p>我们可以将上面的属性进行组合，来实现我们想要的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(<span class=\"number\">100px</span>, <span class=\"number\">100px</span>) <span class=\"built_in\">rotate</span>(<span class=\"number\">45deg</span>) <span class=\"built_in\">scale</span>(<span class=\"number\">2</span>, <span class=\"number\">2</span>) <span class=\"built_in\">skew</span>(<span class=\"number\">45deg</span>, <span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码表示将<code>div</code>元素进行平移、旋转、缩放、倾斜。</p>\n"},{"title":"CSS中的定位","date":"2022-10-14T16:00:00.000Z","_content":"# CSS中的定位\n\n在页面布局中，我们经常会对一些盒子调整位置，普通的浮动或者一些其他方法，但是这些方法要么达不到我们想要的效果要么就是实现起来太复杂了。  \n今天我们要讲到的定位就可以很好的解决这个问题。\n\n技术发展就是这样的：出现什么问题，过不了多久就会出现新的解决语法。\n\n## position(定位)\n\nposition属性用来设置元素的定位方式，有以下几种：\n\n* static：默认值，元素在正常的流中，top、right、bottom、left和z-index属性无效。\n* relative：元素在正常的流中，相对于其在正常流中的位置进行定位，top、right、bottom、left和z-index属性有效。\n* absolute：元素脱离正常的流，相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于body元素进行定位，top、right、bottom、left和z-index属性有效。\n* fixed：元素脱离正常的流，相对于浏览器窗口进行定位，top、right、bottom、left和z-index属性有效。\n* sticky：当页面滚动或者改变后，该盒子未超出目标区域，它的表现就像absolute;超出目标区域之后，它就表现为fixed定位。\n\n### static \n\nstatic是默认值，元素在正常的流中，top、right、bottom、left和z-index属性无效。\n```js\n    .box{\n    position: static;\n}\n```\n\n### relative\n\nrelative是相对定位，元素在正常的流中，相对于其在正常流中的位置进行定位，top、right、bottom、left和z-index属性有效。\n\n```js\n    .box{\n    position: relative;\n    top: 100px;// 距离顶部100px\n    left: 100px;// 距离左边100px\n}\n```\n\n### absolute\n\nabsolute是绝对定位，元素脱离正常的流，相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于body元素进行定位，top、right、bottom、left和z-index属性有效。\n\n```js\n    .box{\n    position: absolute;\n    top: 100px;// 距离顶部100px\n    left: 100px;// 距离左边100px\n}\n```\n\n这个属性值定位的参考点是最近的已定位的祖先元素，如果没有已定位的祖先元素，则相对于body元素进行定位。\n\n### fixed\n\nfixed是固定定位，元素脱离正常的流，相对于浏览器窗口进行定位，top、right、bottom、left和z-index属性有效。\n\n```js\n    .box{\n    position: fixed;\n    top: 100px;// 距离顶部100px\n    left: 100px;// 距离左边100px\n}\n```\n\n不管这个页面如何滚动（改变），这个盒子都会固定在浏览器窗口的某个位置。\n\n### sticky\n\nsticky是粘性定位，它的特性是当页面滚动或者改变后，该盒子未超出目标区域，它的表现就像absolute;超出目标区域之后，它就表现为fixed定位。\n\n```js\n    .box{\n    position: sticky;\n    top: 100px;// 距离顶部100px\n    left: 100px;// 距离左边100px\n}\n```\n\n这段代码就是让box盒子在滚动到距离上面100px或者左边100px的时候，就固定在浏览器窗口的这个位置。\n\n## z-index(层叠顺序)\n\nz-index属性用来设置元素的层叠顺序，它的值是一个整数，数值越大，层叠顺序越靠上。\n\n```js\n    .box{\n    position: relative;\n    z-index: 1;\n}\n```\n\nz-index可以设置为负值，但是不建议这么做。\n\n## 总结\n\n- 在使用绝对定位的时候，一定要注意定位的参考点，如果没有已定位的祖先元素，则相对于body元素进行定位。（子绝父相）\n- 在使用sticky粘性定位的时候，必须使用top,botton,left,right中的一个或者多个属性，否则不会生效。\n- 使用固定定位的时候，在其父级元素中，如果有overflow:hidden;overflow:auto;overflow:scroll;这些属性，那么这个盒子就会被裁剪掉，所以在使用固定定位的时候，一定要注意这个问题。\n- 父级元素的高度如果没有设置，那么子元素的固定定位是不会生效的，所以在使用固定定位的时候，一定要注意父级元素的高度。（父元素高度 > 子元素高度）\n- 固定定位的生效范围只在父元素内。","source":"_posts/CSS中的定位.md","raw":"---\ntitle: CSS中的定位\ndate: 2022-10-15\ntags: [前端]\ncategories: [css]\n---\n# CSS中的定位\n\n在页面布局中，我们经常会对一些盒子调整位置，普通的浮动或者一些其他方法，但是这些方法要么达不到我们想要的效果要么就是实现起来太复杂了。  \n今天我们要讲到的定位就可以很好的解决这个问题。\n\n技术发展就是这样的：出现什么问题，过不了多久就会出现新的解决语法。\n\n## position(定位)\n\nposition属性用来设置元素的定位方式，有以下几种：\n\n* static：默认值，元素在正常的流中，top、right、bottom、left和z-index属性无效。\n* relative：元素在正常的流中，相对于其在正常流中的位置进行定位，top、right、bottom、left和z-index属性有效。\n* absolute：元素脱离正常的流，相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于body元素进行定位，top、right、bottom、left和z-index属性有效。\n* fixed：元素脱离正常的流，相对于浏览器窗口进行定位，top、right、bottom、left和z-index属性有效。\n* sticky：当页面滚动或者改变后，该盒子未超出目标区域，它的表现就像absolute;超出目标区域之后，它就表现为fixed定位。\n\n### static \n\nstatic是默认值，元素在正常的流中，top、right、bottom、left和z-index属性无效。\n```js\n    .box{\n    position: static;\n}\n```\n\n### relative\n\nrelative是相对定位，元素在正常的流中，相对于其在正常流中的位置进行定位，top、right、bottom、left和z-index属性有效。\n\n```js\n    .box{\n    position: relative;\n    top: 100px;// 距离顶部100px\n    left: 100px;// 距离左边100px\n}\n```\n\n### absolute\n\nabsolute是绝对定位，元素脱离正常的流，相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于body元素进行定位，top、right、bottom、left和z-index属性有效。\n\n```js\n    .box{\n    position: absolute;\n    top: 100px;// 距离顶部100px\n    left: 100px;// 距离左边100px\n}\n```\n\n这个属性值定位的参考点是最近的已定位的祖先元素，如果没有已定位的祖先元素，则相对于body元素进行定位。\n\n### fixed\n\nfixed是固定定位，元素脱离正常的流，相对于浏览器窗口进行定位，top、right、bottom、left和z-index属性有效。\n\n```js\n    .box{\n    position: fixed;\n    top: 100px;// 距离顶部100px\n    left: 100px;// 距离左边100px\n}\n```\n\n不管这个页面如何滚动（改变），这个盒子都会固定在浏览器窗口的某个位置。\n\n### sticky\n\nsticky是粘性定位，它的特性是当页面滚动或者改变后，该盒子未超出目标区域，它的表现就像absolute;超出目标区域之后，它就表现为fixed定位。\n\n```js\n    .box{\n    position: sticky;\n    top: 100px;// 距离顶部100px\n    left: 100px;// 距离左边100px\n}\n```\n\n这段代码就是让box盒子在滚动到距离上面100px或者左边100px的时候，就固定在浏览器窗口的这个位置。\n\n## z-index(层叠顺序)\n\nz-index属性用来设置元素的层叠顺序，它的值是一个整数，数值越大，层叠顺序越靠上。\n\n```js\n    .box{\n    position: relative;\n    z-index: 1;\n}\n```\n\nz-index可以设置为负值，但是不建议这么做。\n\n## 总结\n\n- 在使用绝对定位的时候，一定要注意定位的参考点，如果没有已定位的祖先元素，则相对于body元素进行定位。（子绝父相）\n- 在使用sticky粘性定位的时候，必须使用top,botton,left,right中的一个或者多个属性，否则不会生效。\n- 使用固定定位的时候，在其父级元素中，如果有overflow:hidden;overflow:auto;overflow:scroll;这些属性，那么这个盒子就会被裁剪掉，所以在使用固定定位的时候，一定要注意这个问题。\n- 父级元素的高度如果没有设置，那么子元素的固定定位是不会生效的，所以在使用固定定位的时候，一定要注意父级元素的高度。（父元素高度 > 子元素高度）\n- 固定定位的生效范围只在父元素内。","slug":"CSS中的定位","published":1,"updated":"2023-01-09T12:03:02.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgf00049kbm2eog2czq","content":"<h1 id=\"CSS中的定位\"><a href=\"#CSS中的定位\" class=\"headerlink\" title=\"CSS中的定位\"></a>CSS中的定位</h1><p>在页面布局中，我们经常会对一些盒子调整位置，普通的浮动或者一些其他方法，但是这些方法要么达不到我们想要的效果要么就是实现起来太复杂了。<br>今天我们要讲到的定位就可以很好的解决这个问题。</p>\n<p>技术发展就是这样的：出现什么问题，过不了多久就会出现新的解决语法。</p>\n<h2 id=\"position-定位\"><a href=\"#position-定位\" class=\"headerlink\" title=\"position(定位)\"></a>position(定位)</h2><p>position属性用来设置元素的定位方式，有以下几种：</p>\n<ul>\n<li>static：默认值，元素在正常的流中，top、right、bottom、left和z-index属性无效。</li>\n<li>relative：元素在正常的流中，相对于其在正常流中的位置进行定位，top、right、bottom、left和z-index属性有效。</li>\n<li>absolute：元素脱离正常的流，相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于body元素进行定位，top、right、bottom、left和z-index属性有效。</li>\n<li>fixed：元素脱离正常的流，相对于浏览器窗口进行定位，top、right、bottom、left和z-index属性有效。</li>\n<li>sticky：当页面滚动或者改变后，该盒子未超出目标区域，它的表现就像absolute;超出目标区域之后，它就表现为fixed定位。</li>\n</ul>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><p>static是默认值，元素在正常的流中，top、right、bottom、left和z-index属性无效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: <span class=\"keyword\">static</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a>relative</h3><p>relative是相对定位，元素在正常的流中，相对于其在正常流中的位置进行定位，top、right、bottom、left和z-index属性有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: 100px;<span class=\"comment\">// 距离顶部100px</span></span><br><span class=\"line\">    <span class=\"attr\">left</span>: 100px;<span class=\"comment\">// 距离左边100px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a>absolute</h3><p>absolute是绝对定位，元素脱离正常的流，相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于body元素进行定位，top、right、bottom、left和z-index属性有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: 100px;<span class=\"comment\">// 距离顶部100px</span></span><br><span class=\"line\">    <span class=\"attr\">left</span>: 100px;<span class=\"comment\">// 距离左边100px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个属性值定位的参考点是最近的已定位的祖先元素，如果没有已定位的祖先元素，则相对于body元素进行定位。</p>\n<h3 id=\"fixed\"><a href=\"#fixed\" class=\"headerlink\" title=\"fixed\"></a>fixed</h3><p>fixed是固定定位，元素脱离正常的流，相对于浏览器窗口进行定位，top、right、bottom、left和z-index属性有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: 100px;<span class=\"comment\">// 距离顶部100px</span></span><br><span class=\"line\">    <span class=\"attr\">left</span>: 100px;<span class=\"comment\">// 距离左边100px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不管这个页面如何滚动（改变），这个盒子都会固定在浏览器窗口的某个位置。</p>\n<h3 id=\"sticky\"><a href=\"#sticky\" class=\"headerlink\" title=\"sticky\"></a>sticky</h3><p>sticky是粘性定位，它的特性是当页面滚动或者改变后，该盒子未超出目标区域，它的表现就像absolute;超出目标区域之后，它就表现为fixed定位。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: sticky;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: 100px;<span class=\"comment\">// 距离顶部100px</span></span><br><span class=\"line\">    <span class=\"attr\">left</span>: 100px;<span class=\"comment\">// 距离左边100px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码就是让box盒子在滚动到距离上面100px或者左边100px的时候，就固定在浏览器窗口的这个位置。</p>\n<h2 id=\"z-index-层叠顺序\"><a href=\"#z-index-层叠顺序\" class=\"headerlink\" title=\"z-index(层叠顺序)\"></a>z-index(层叠顺序)</h2><p>z-index属性用来设置元素的层叠顺序，它的值是一个整数，数值越大，层叠顺序越靠上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: relative;</span><br><span class=\"line\">    z-<span class=\"attr\">index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>z-index可以设置为负值，但是不建议这么做。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>在使用绝对定位的时候，一定要注意定位的参考点，如果没有已定位的祖先元素，则相对于body元素进行定位。（子绝父相）</li>\n<li>在使用sticky粘性定位的时候，必须使用top,botton,left,right中的一个或者多个属性，否则不会生效。</li>\n<li>使用固定定位的时候，在其父级元素中，如果有overflow:hidden;overflow:auto;overflow:scroll;这些属性，那么这个盒子就会被裁剪掉，所以在使用固定定位的时候，一定要注意这个问题。</li>\n<li>父级元素的高度如果没有设置，那么子元素的固定定位是不会生效的，所以在使用固定定位的时候，一定要注意父级元素的高度。（父元素高度 &gt; 子元素高度）</li>\n<li>固定定位的生效范围只在父元素内。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS中的定位\"><a href=\"#CSS中的定位\" class=\"headerlink\" title=\"CSS中的定位\"></a>CSS中的定位</h1><p>在页面布局中，我们经常会对一些盒子调整位置，普通的浮动或者一些其他方法，但是这些方法要么达不到我们想要的效果要么就是实现起来太复杂了。<br>今天我们要讲到的定位就可以很好的解决这个问题。</p>\n<p>技术发展就是这样的：出现什么问题，过不了多久就会出现新的解决语法。</p>\n<h2 id=\"position-定位\"><a href=\"#position-定位\" class=\"headerlink\" title=\"position(定位)\"></a>position(定位)</h2><p>position属性用来设置元素的定位方式，有以下几种：</p>\n<ul>\n<li>static：默认值，元素在正常的流中，top、right、bottom、left和z-index属性无效。</li>\n<li>relative：元素在正常的流中，相对于其在正常流中的位置进行定位，top、right、bottom、left和z-index属性有效。</li>\n<li>absolute：元素脱离正常的流，相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于body元素进行定位，top、right、bottom、left和z-index属性有效。</li>\n<li>fixed：元素脱离正常的流，相对于浏览器窗口进行定位，top、right、bottom、left和z-index属性有效。</li>\n<li>sticky：当页面滚动或者改变后，该盒子未超出目标区域，它的表现就像absolute;超出目标区域之后，它就表现为fixed定位。</li>\n</ul>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><p>static是默认值，元素在正常的流中，top、right、bottom、left和z-index属性无效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: <span class=\"keyword\">static</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"relative\"><a href=\"#relative\" class=\"headerlink\" title=\"relative\"></a>relative</h3><p>relative是相对定位，元素在正常的流中，相对于其在正常流中的位置进行定位，top、right、bottom、left和z-index属性有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: 100px;<span class=\"comment\">// 距离顶部100px</span></span><br><span class=\"line\">    <span class=\"attr\">left</span>: 100px;<span class=\"comment\">// 距离左边100px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"absolute\"><a href=\"#absolute\" class=\"headerlink\" title=\"absolute\"></a>absolute</h3><p>absolute是绝对定位，元素脱离正常的流，相对于其最近的已定位祖先元素进行定位，如果没有已定位的祖先元素，则相对于body元素进行定位，top、right、bottom、left和z-index属性有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: 100px;<span class=\"comment\">// 距离顶部100px</span></span><br><span class=\"line\">    <span class=\"attr\">left</span>: 100px;<span class=\"comment\">// 距离左边100px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个属性值定位的参考点是最近的已定位的祖先元素，如果没有已定位的祖先元素，则相对于body元素进行定位。</p>\n<h3 id=\"fixed\"><a href=\"#fixed\" class=\"headerlink\" title=\"fixed\"></a>fixed</h3><p>fixed是固定定位，元素脱离正常的流，相对于浏览器窗口进行定位，top、right、bottom、left和z-index属性有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: 100px;<span class=\"comment\">// 距离顶部100px</span></span><br><span class=\"line\">    <span class=\"attr\">left</span>: 100px;<span class=\"comment\">// 距离左边100px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不管这个页面如何滚动（改变），这个盒子都会固定在浏览器窗口的某个位置。</p>\n<h3 id=\"sticky\"><a href=\"#sticky\" class=\"headerlink\" title=\"sticky\"></a>sticky</h3><p>sticky是粘性定位，它的特性是当页面滚动或者改变后，该盒子未超出目标区域，它的表现就像absolute;超出目标区域之后，它就表现为fixed定位。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: sticky;</span><br><span class=\"line\">    <span class=\"attr\">top</span>: 100px;<span class=\"comment\">// 距离顶部100px</span></span><br><span class=\"line\">    <span class=\"attr\">left</span>: 100px;<span class=\"comment\">// 距离左边100px</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码就是让box盒子在滚动到距离上面100px或者左边100px的时候，就固定在浏览器窗口的这个位置。</p>\n<h2 id=\"z-index-层叠顺序\"><a href=\"#z-index-层叠顺序\" class=\"headerlink\" title=\"z-index(层叠顺序)\"></a>z-index(层叠顺序)</h2><p>z-index属性用来设置元素的层叠顺序，它的值是一个整数，数值越大，层叠顺序越靠上。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .<span class=\"property\">box</span>&#123;</span><br><span class=\"line\">    <span class=\"attr\">position</span>: relative;</span><br><span class=\"line\">    z-<span class=\"attr\">index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>z-index可以设置为负值，但是不建议这么做。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>在使用绝对定位的时候，一定要注意定位的参考点，如果没有已定位的祖先元素，则相对于body元素进行定位。（子绝父相）</li>\n<li>在使用sticky粘性定位的时候，必须使用top,botton,left,right中的一个或者多个属性，否则不会生效。</li>\n<li>使用固定定位的时候，在其父级元素中，如果有overflow:hidden;overflow:auto;overflow:scroll;这些属性，那么这个盒子就会被裁剪掉，所以在使用固定定位的时候，一定要注意这个问题。</li>\n<li>父级元素的高度如果没有设置，那么子元素的固定定位是不会生效的，所以在使用固定定位的时候，一定要注意父级元素的高度。（父元素高度 &gt; 子元素高度）</li>\n<li>固定定位的生效范围只在父元素内。</li>\n</ul>\n"},{"title":"CSS三大特性","date":"2022-08-29T16:00:00.000Z","_content":"# CSS三大特性\n\n在css中，我们在设计样式的时候，经常会出现我们明明写好了样式，但是最后的测试发现我们书写的样式并没有起作用。\n\n除开样式书写错误之外。还有大部分情况就是css样式的三大特性导致的问题。\n\n首先，我们要知道css有哪三大特性：\n\n- 层叠性\n- 继承性\n- 优先级\n\n## 层叠性\n\n**定义：**\n\n层叠性是多种CSS样式的叠加，是浏览器处理样式冲突的方式。在HTML中对于同一个元素可以有多个CSS样式存在，当有相同权重的样式存在时，会根据这些样式出现的先后顺序来决定，处于最后面的CSS样式将会覆盖前面的CSS样式。（也就是就近原则）\n\n    p {\n        color: red;\n    }\n    p {\n        color: blue;\n    }\n    //最后浏览器实现的是：blue\n\n这就是因为层叠性的原因，因为层叠性在权重相同的情况下是根据样式出现先后顺序来决定的，所以最后的样式将会覆盖前面的样式。\n\n注意：\n\n当出现相同样式且权重相同的情况的时候，那么css层叠性就会起作用。简单来说就是：样式不冲突，不会层叠；样式冲突权重相同，遵循就近原则。\n\n## 继承性\n\n我们可以简单的理解为：当我们在一个元素上设置了样式，那么这个样式就会被继承到所有的子元素上。（子承父业）\n\n    div {\n        color: red;\n    }\n\n    <div>\n        <span>我是什么红色</span>\n    </div>\n\n最后代码运行出来 ：`span`标签里面的字体为红色，但是我们并没有单独给`span`写颜色样式，所以它的颜色为父元素的颜色。就是说，`span`标签的颜色是`div`标签的颜色，继承了腹肌元素的属性。\n\n**注意：**\n\n1. 合理使用继承性可以简化代码，减少代码量。在我们设计中，`字体、字号、颜色、行距等有关文本属性的属性`是具有继承性的，我们可以在`body`中统一设置，然后影响整个代码。\n2. 并不是所有的属性都可以继承，`与块元素相关的属性都不可以继承`，例如：边框、外边距、内边距、背景、定位、元素高度等等。\n\n## 优先级\n\n在了解什么是优先级之前，我们要先知道什么是权重，以及权重怎么计算。\n\ncss会根据权重高低来决定执行哪一个属性：\n\n### 权重\n\n|      选择器权重      | 0,0,0,0 |\n| :------------------: | :-----: |\n| 通用选择器（*）/继承 | 0,0,0,0 |\n|      标签选择器      | 0,0,0,1 |\n|    类/伪类选择器     | 0,0,1,0 |\n|       id选择器       | 0,1,0,0 |\n|       行内样式       | 1,0,0,0 |\n|      !important      | 无限大  |\n\n### 权重计算\n\n1.在我们css权重计算中，不会存在什么多少进制的说法，也就是说10个标签选择器的权重等于`0,0,0,10`,并不会等于`0,0,1,0`。也就是说无论多少个标签选择器，最后它的权重也不会比一个类选择器高。\n2.前面我们讲述了层叠性。二者有一些联系：权重用来计算优先级，层叠用来表现优先级。\n\n### 优先级\n\n优先级就是在样式完全相同的情况下，权重高的样式会优先使用。\n\n**最后总结一下优先级的顺序：**\n\n!important > 行内样式 > id选择器 > 类/伪类选择器 > 标签选择器 > 继承/通用选择器","source":"_posts/CSS三大特性.md","raw":"---\ntitle: CSS三大特性\ndate: 2022-8-30\ntags: [前端]\ncategories: [css]\n---\n# CSS三大特性\n\n在css中，我们在设计样式的时候，经常会出现我们明明写好了样式，但是最后的测试发现我们书写的样式并没有起作用。\n\n除开样式书写错误之外。还有大部分情况就是css样式的三大特性导致的问题。\n\n首先，我们要知道css有哪三大特性：\n\n- 层叠性\n- 继承性\n- 优先级\n\n## 层叠性\n\n**定义：**\n\n层叠性是多种CSS样式的叠加，是浏览器处理样式冲突的方式。在HTML中对于同一个元素可以有多个CSS样式存在，当有相同权重的样式存在时，会根据这些样式出现的先后顺序来决定，处于最后面的CSS样式将会覆盖前面的CSS样式。（也就是就近原则）\n\n    p {\n        color: red;\n    }\n    p {\n        color: blue;\n    }\n    //最后浏览器实现的是：blue\n\n这就是因为层叠性的原因，因为层叠性在权重相同的情况下是根据样式出现先后顺序来决定的，所以最后的样式将会覆盖前面的样式。\n\n注意：\n\n当出现相同样式且权重相同的情况的时候，那么css层叠性就会起作用。简单来说就是：样式不冲突，不会层叠；样式冲突权重相同，遵循就近原则。\n\n## 继承性\n\n我们可以简单的理解为：当我们在一个元素上设置了样式，那么这个样式就会被继承到所有的子元素上。（子承父业）\n\n    div {\n        color: red;\n    }\n\n    <div>\n        <span>我是什么红色</span>\n    </div>\n\n最后代码运行出来 ：`span`标签里面的字体为红色，但是我们并没有单独给`span`写颜色样式，所以它的颜色为父元素的颜色。就是说，`span`标签的颜色是`div`标签的颜色，继承了腹肌元素的属性。\n\n**注意：**\n\n1. 合理使用继承性可以简化代码，减少代码量。在我们设计中，`字体、字号、颜色、行距等有关文本属性的属性`是具有继承性的，我们可以在`body`中统一设置，然后影响整个代码。\n2. 并不是所有的属性都可以继承，`与块元素相关的属性都不可以继承`，例如：边框、外边距、内边距、背景、定位、元素高度等等。\n\n## 优先级\n\n在了解什么是优先级之前，我们要先知道什么是权重，以及权重怎么计算。\n\ncss会根据权重高低来决定执行哪一个属性：\n\n### 权重\n\n|      选择器权重      | 0,0,0,0 |\n| :------------------: | :-----: |\n| 通用选择器（*）/继承 | 0,0,0,0 |\n|      标签选择器      | 0,0,0,1 |\n|    类/伪类选择器     | 0,0,1,0 |\n|       id选择器       | 0,1,0,0 |\n|       行内样式       | 1,0,0,0 |\n|      !important      | 无限大  |\n\n### 权重计算\n\n1.在我们css权重计算中，不会存在什么多少进制的说法，也就是说10个标签选择器的权重等于`0,0,0,10`,并不会等于`0,0,1,0`。也就是说无论多少个标签选择器，最后它的权重也不会比一个类选择器高。\n2.前面我们讲述了层叠性。二者有一些联系：权重用来计算优先级，层叠用来表现优先级。\n\n### 优先级\n\n优先级就是在样式完全相同的情况下，权重高的样式会优先使用。\n\n**最后总结一下优先级的顺序：**\n\n!important > 行内样式 > id选择器 > 类/伪类选择器 > 标签选择器 > 继承/通用选择器","slug":"CSS三大特性","published":1,"updated":"2023-01-09T12:01:02.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgh00059kbm01o3boy5","content":"<h1 id=\"CSS三大特性\"><a href=\"#CSS三大特性\" class=\"headerlink\" title=\"CSS三大特性\"></a>CSS三大特性</h1><p>在css中，我们在设计样式的时候，经常会出现我们明明写好了样式，但是最后的测试发现我们书写的样式并没有起作用。</p>\n<p>除开样式书写错误之外。还有大部分情况就是css样式的三大特性导致的问题。</p>\n<p>首先，我们要知道css有哪三大特性：</p>\n<ul>\n<li>层叠性</li>\n<li>继承性</li>\n<li>优先级</li>\n</ul>\n<h2 id=\"层叠性\"><a href=\"#层叠性\" class=\"headerlink\" title=\"层叠性\"></a>层叠性</h2><p><strong>定义：</strong></p>\n<p>层叠性是多种CSS样式的叠加，是浏览器处理样式冲突的方式。在HTML中对于同一个元素可以有多个CSS样式存在，当有相同权重的样式存在时，会根据这些样式出现的先后顺序来决定，处于最后面的CSS样式将会覆盖前面的CSS样式。（也就是就近原则）</p>\n<pre><code>p &#123;\n    color: red;\n&#125;\np &#123;\n    color: blue;\n&#125;\n//最后浏览器实现的是：blue\n</code></pre>\n<p>这就是因为层叠性的原因，因为层叠性在权重相同的情况下是根据样式出现先后顺序来决定的，所以最后的样式将会覆盖前面的样式。</p>\n<p>注意：</p>\n<p>当出现相同样式且权重相同的情况的时候，那么css层叠性就会起作用。简单来说就是：样式不冲突，不会层叠；样式冲突权重相同，遵循就近原则。</p>\n<h2 id=\"继承性\"><a href=\"#继承性\" class=\"headerlink\" title=\"继承性\"></a>继承性</h2><p>我们可以简单的理解为：当我们在一个元素上设置了样式，那么这个样式就会被继承到所有的子元素上。（子承父业）</p>\n<pre><code>div &#123;\n    color: red;\n&#125;\n\n&lt;div&gt;\n    &lt;span&gt;我是什么红色&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n<p>最后代码运行出来 ：<code>span</code>标签里面的字体为红色，但是我们并没有单独给<code>span</code>写颜色样式，所以它的颜色为父元素的颜色。就是说，<code>span</code>标签的颜色是<code>div</code>标签的颜色，继承了腹肌元素的属性。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>合理使用继承性可以简化代码，减少代码量。在我们设计中，<code>字体、字号、颜色、行距等有关文本属性的属性</code>是具有继承性的，我们可以在<code>body</code>中统一设置，然后影响整个代码。</li>\n<li>并不是所有的属性都可以继承，<code>与块元素相关的属性都不可以继承</code>，例如：边框、外边距、内边距、背景、定位、元素高度等等。</li>\n</ol>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><p>在了解什么是优先级之前，我们要先知道什么是权重，以及权重怎么计算。</p>\n<p>css会根据权重高低来决定执行哪一个属性：</p>\n<h3 id=\"权重\"><a href=\"#权重\" class=\"headerlink\" title=\"权重\"></a>权重</h3><table>\n<thead>\n<tr>\n<th align=\"center\">选择器权重</th>\n<th align=\"center\">0,0,0,0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">通用选择器（*）&#x2F;继承</td>\n<td align=\"center\">0,0,0,0</td>\n</tr>\n<tr>\n<td align=\"center\">标签选择器</td>\n<td align=\"center\">0,0,0,1</td>\n</tr>\n<tr>\n<td align=\"center\">类&#x2F;伪类选择器</td>\n<td align=\"center\">0,0,1,0</td>\n</tr>\n<tr>\n<td align=\"center\">id选择器</td>\n<td align=\"center\">0,1,0,0</td>\n</tr>\n<tr>\n<td align=\"center\">行内样式</td>\n<td align=\"center\">1,0,0,0</td>\n</tr>\n<tr>\n<td align=\"center\">!important</td>\n<td align=\"center\">无限大</td>\n</tr>\n</tbody></table>\n<h3 id=\"权重计算\"><a href=\"#权重计算\" class=\"headerlink\" title=\"权重计算\"></a>权重计算</h3><p>1.在我们css权重计算中，不会存在什么多少进制的说法，也就是说10个标签选择器的权重等于<code>0,0,0,10</code>,并不会等于<code>0,0,1,0</code>。也就是说无论多少个标签选择器，最后它的权重也不会比一个类选择器高。<br>2.前面我们讲述了层叠性。二者有一些联系：权重用来计算优先级，层叠用来表现优先级。</p>\n<h3 id=\"优先级-1\"><a href=\"#优先级-1\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>优先级就是在样式完全相同的情况下，权重高的样式会优先使用。</p>\n<p><strong>最后总结一下优先级的顺序：</strong></p>\n<p>!important &gt; 行内样式 &gt; id选择器 &gt; 类&#x2F;伪类选择器 &gt; 标签选择器 &gt; 继承&#x2F;通用选择器</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS三大特性\"><a href=\"#CSS三大特性\" class=\"headerlink\" title=\"CSS三大特性\"></a>CSS三大特性</h1><p>在css中，我们在设计样式的时候，经常会出现我们明明写好了样式，但是最后的测试发现我们书写的样式并没有起作用。</p>\n<p>除开样式书写错误之外。还有大部分情况就是css样式的三大特性导致的问题。</p>\n<p>首先，我们要知道css有哪三大特性：</p>\n<ul>\n<li>层叠性</li>\n<li>继承性</li>\n<li>优先级</li>\n</ul>\n<h2 id=\"层叠性\"><a href=\"#层叠性\" class=\"headerlink\" title=\"层叠性\"></a>层叠性</h2><p><strong>定义：</strong></p>\n<p>层叠性是多种CSS样式的叠加，是浏览器处理样式冲突的方式。在HTML中对于同一个元素可以有多个CSS样式存在，当有相同权重的样式存在时，会根据这些样式出现的先后顺序来决定，处于最后面的CSS样式将会覆盖前面的CSS样式。（也就是就近原则）</p>\n<pre><code>p &#123;\n    color: red;\n&#125;\np &#123;\n    color: blue;\n&#125;\n//最后浏览器实现的是：blue\n</code></pre>\n<p>这就是因为层叠性的原因，因为层叠性在权重相同的情况下是根据样式出现先后顺序来决定的，所以最后的样式将会覆盖前面的样式。</p>\n<p>注意：</p>\n<p>当出现相同样式且权重相同的情况的时候，那么css层叠性就会起作用。简单来说就是：样式不冲突，不会层叠；样式冲突权重相同，遵循就近原则。</p>\n<h2 id=\"继承性\"><a href=\"#继承性\" class=\"headerlink\" title=\"继承性\"></a>继承性</h2><p>我们可以简单的理解为：当我们在一个元素上设置了样式，那么这个样式就会被继承到所有的子元素上。（子承父业）</p>\n<pre><code>div &#123;\n    color: red;\n&#125;\n\n&lt;div&gt;\n    &lt;span&gt;我是什么红色&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n<p>最后代码运行出来 ：<code>span</code>标签里面的字体为红色，但是我们并没有单独给<code>span</code>写颜色样式，所以它的颜色为父元素的颜色。就是说，<code>span</code>标签的颜色是<code>div</code>标签的颜色，继承了腹肌元素的属性。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>合理使用继承性可以简化代码，减少代码量。在我们设计中，<code>字体、字号、颜色、行距等有关文本属性的属性</code>是具有继承性的，我们可以在<code>body</code>中统一设置，然后影响整个代码。</li>\n<li>并不是所有的属性都可以继承，<code>与块元素相关的属性都不可以继承</code>，例如：边框、外边距、内边距、背景、定位、元素高度等等。</li>\n</ol>\n<h2 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h2><p>在了解什么是优先级之前，我们要先知道什么是权重，以及权重怎么计算。</p>\n<p>css会根据权重高低来决定执行哪一个属性：</p>\n<h3 id=\"权重\"><a href=\"#权重\" class=\"headerlink\" title=\"权重\"></a>权重</h3><table>\n<thead>\n<tr>\n<th align=\"center\">选择器权重</th>\n<th align=\"center\">0,0,0,0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">通用选择器（*）&#x2F;继承</td>\n<td align=\"center\">0,0,0,0</td>\n</tr>\n<tr>\n<td align=\"center\">标签选择器</td>\n<td align=\"center\">0,0,0,1</td>\n</tr>\n<tr>\n<td align=\"center\">类&#x2F;伪类选择器</td>\n<td align=\"center\">0,0,1,0</td>\n</tr>\n<tr>\n<td align=\"center\">id选择器</td>\n<td align=\"center\">0,1,0,0</td>\n</tr>\n<tr>\n<td align=\"center\">行内样式</td>\n<td align=\"center\">1,0,0,0</td>\n</tr>\n<tr>\n<td align=\"center\">!important</td>\n<td align=\"center\">无限大</td>\n</tr>\n</tbody></table>\n<h3 id=\"权重计算\"><a href=\"#权重计算\" class=\"headerlink\" title=\"权重计算\"></a>权重计算</h3><p>1.在我们css权重计算中，不会存在什么多少进制的说法，也就是说10个标签选择器的权重等于<code>0,0,0,10</code>,并不会等于<code>0,0,1,0</code>。也就是说无论多少个标签选择器，最后它的权重也不会比一个类选择器高。<br>2.前面我们讲述了层叠性。二者有一些联系：权重用来计算优先级，层叠用来表现优先级。</p>\n<h3 id=\"优先级-1\"><a href=\"#优先级-1\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>优先级就是在样式完全相同的情况下，权重高的样式会优先使用。</p>\n<p><strong>最后总结一下优先级的顺序：</strong></p>\n<p>!important &gt; 行内样式 &gt; id选择器 &gt; 类&#x2F;伪类选择器 &gt; 标签选择器 &gt; 继承&#x2F;通用选择器</p>\n"},{"title":"CSS中的浮动","date":"2022-10-14T16:00:00.000Z","_content":"# css中的浮动以及清除\n\n## 1. 浮动的概念\n\n浮动是网页布局中最古老的方式，但是这种方式最开始并不是为了网页布局而生的。浮动是为了让文字环绕图片而生的。在css中，浮动是通过float属性来实现的，float属性有left和right两个值，分别表示向左浮动和向右浮动。正是因为浮动并不是为网页布局而生的，导致我们在后面在使用的时候会有很多出乎意料的方式。\n\n### 1.1 浮动的使用\n\n浮动的使用非常简单，只需要给需要浮动的元素设置float属性即可。例如：\n\n```html\n<div class = \"bigBox\">\n    123\n    <div class=\"box\">我是一个盒子</div>\n</div>\n```\n\n```css\n.bigBox{\n    background-color: #ccc;\n}\n.box {\n    width: 100px;\n    height: 100px;\n    float: left;\n}\n```\n\n上面的代码块就应用了浮动的特性，我们将此盒子向左浮动了，这样盒子就会向左浮动，而且盒子的宽度会自动变成内容的宽度。\n\n但是在这里我们发现一个问题，就是在外部盒子的高度没有将我们浮动的盒子包含进去。\n\n这是为什么呢？这是因为浮动的元素脱离了文档流，所以在文档流中的元素不会将浮动的元素包含进去。\n\n下面我们使用清除浮动来解决这个问题。\n\n## 2.清除浮动\n\n### 2.1 清除浮动的概念\n\n清除浮动就是将浮动脱离标准文档流导致的高度塌陷问题解决掉。比如上面的例子，我们通过清除浮动，使得外部的盒子可以将浮动的元素包含进去。\n\n清除浮动是为了解决浮动元素脱离文档流导致的高度塌陷问题。清除浮动的方式有很多，但是最常用的就是使用clear属性和伪元素来清除浮动。\n\n### 2.2 clear清除浮动\n\nclear属性是用来清除浮动的，它有四个值，分别是left、right、both、none。其中left和right分别表示清除左浮动和右浮动，both表示清除左右浮动，none表示不清除浮动。\n\n那么如何来使用呢？\n\n- 在装浮动元素的盒子上使用clear属性，例如：\n\n```html\n<div class = \"bigBox\">\n    123\n    <div class=\"box\">我是一个盒子</div>\n    <div style=\"clear:both;\">我是一个盒子</div>\n</div>\n```\n\n在这里我们默认浮动的元素是向左浮动的，所以我们在装浮动元素的盒子上使用clear:both;来清除浮动。\n\n虽然这样可以达到清除浮动的效果，但是这样很不优雅，尤其是在我们实际开发当中，我们需要将html和css分离开来；如果我们将css写在html中，会导致我们的html代码变得很臃肿。  \n这个时候，就需要用到第二种清除浮动的方式，利用伪元素。\n\n### 2.3 伪元素清除浮动\n\n伪元素是一种特殊的选择器，它可以用来选择一些不存在的元素，比如：before、after、first-letter、first-line等。伪元素以`::`开头，但是后面为了更好的兼容性，我们习惯使用`:`开头。\n\n在这里我们使用到`:after`和`:before`，表示在元素的结束和开始处插入一个元素。\n\n于是，上面的清除浮动，我们可以这样写：\n\n```css\n.bigBox:after {\n    content: \"\";// 这里必须要有内容，否则不会生效（必须要有content）\n    display: block;// 这里设置为非inline元素，否则不会生效\n    clear: both;\n}\n```\n","source":"_posts/CSS中的浮动.md","raw":"---\ntitle: CSS中的浮动\ndate: 2022-10-15\ntags: [前端]\ncategories: [css]\n---\n# css中的浮动以及清除\n\n## 1. 浮动的概念\n\n浮动是网页布局中最古老的方式，但是这种方式最开始并不是为了网页布局而生的。浮动是为了让文字环绕图片而生的。在css中，浮动是通过float属性来实现的，float属性有left和right两个值，分别表示向左浮动和向右浮动。正是因为浮动并不是为网页布局而生的，导致我们在后面在使用的时候会有很多出乎意料的方式。\n\n### 1.1 浮动的使用\n\n浮动的使用非常简单，只需要给需要浮动的元素设置float属性即可。例如：\n\n```html\n<div class = \"bigBox\">\n    123\n    <div class=\"box\">我是一个盒子</div>\n</div>\n```\n\n```css\n.bigBox{\n    background-color: #ccc;\n}\n.box {\n    width: 100px;\n    height: 100px;\n    float: left;\n}\n```\n\n上面的代码块就应用了浮动的特性，我们将此盒子向左浮动了，这样盒子就会向左浮动，而且盒子的宽度会自动变成内容的宽度。\n\n但是在这里我们发现一个问题，就是在外部盒子的高度没有将我们浮动的盒子包含进去。\n\n这是为什么呢？这是因为浮动的元素脱离了文档流，所以在文档流中的元素不会将浮动的元素包含进去。\n\n下面我们使用清除浮动来解决这个问题。\n\n## 2.清除浮动\n\n### 2.1 清除浮动的概念\n\n清除浮动就是将浮动脱离标准文档流导致的高度塌陷问题解决掉。比如上面的例子，我们通过清除浮动，使得外部的盒子可以将浮动的元素包含进去。\n\n清除浮动是为了解决浮动元素脱离文档流导致的高度塌陷问题。清除浮动的方式有很多，但是最常用的就是使用clear属性和伪元素来清除浮动。\n\n### 2.2 clear清除浮动\n\nclear属性是用来清除浮动的，它有四个值，分别是left、right、both、none。其中left和right分别表示清除左浮动和右浮动，both表示清除左右浮动，none表示不清除浮动。\n\n那么如何来使用呢？\n\n- 在装浮动元素的盒子上使用clear属性，例如：\n\n```html\n<div class = \"bigBox\">\n    123\n    <div class=\"box\">我是一个盒子</div>\n    <div style=\"clear:both;\">我是一个盒子</div>\n</div>\n```\n\n在这里我们默认浮动的元素是向左浮动的，所以我们在装浮动元素的盒子上使用clear:both;来清除浮动。\n\n虽然这样可以达到清除浮动的效果，但是这样很不优雅，尤其是在我们实际开发当中，我们需要将html和css分离开来；如果我们将css写在html中，会导致我们的html代码变得很臃肿。  \n这个时候，就需要用到第二种清除浮动的方式，利用伪元素。\n\n### 2.3 伪元素清除浮动\n\n伪元素是一种特殊的选择器，它可以用来选择一些不存在的元素，比如：before、after、first-letter、first-line等。伪元素以`::`开头，但是后面为了更好的兼容性，我们习惯使用`:`开头。\n\n在这里我们使用到`:after`和`:before`，表示在元素的结束和开始处插入一个元素。\n\n于是，上面的清除浮动，我们可以这样写：\n\n```css\n.bigBox:after {\n    content: \"\";// 这里必须要有内容，否则不会生效（必须要有content）\n    display: block;// 这里设置为非inline元素，否则不会生效\n    clear: both;\n}\n```\n","slug":"CSS中的浮动","published":1,"updated":"2023-01-09T12:03:22.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgj00069kbmexq3h40e","content":"<h1 id=\"css中的浮动以及清除\"><a href=\"#css中的浮动以及清除\" class=\"headerlink\" title=\"css中的浮动以及清除\"></a>css中的浮动以及清除</h1><h2 id=\"1-浮动的概念\"><a href=\"#1-浮动的概念\" class=\"headerlink\" title=\"1. 浮动的概念\"></a>1. 浮动的概念</h2><p>浮动是网页布局中最古老的方式，但是这种方式最开始并不是为了网页布局而生的。浮动是为了让文字环绕图片而生的。在css中，浮动是通过float属性来实现的，float属性有left和right两个值，分别表示向左浮动和向右浮动。正是因为浮动并不是为网页布局而生的，导致我们在后面在使用的时候会有很多出乎意料的方式。</p>\n<h3 id=\"1-1-浮动的使用\"><a href=\"#1-1-浮动的使用\" class=\"headerlink\" title=\"1.1 浮动的使用\"></a>1.1 浮动的使用</h3><p>浮动的使用非常简单，只需要给需要浮动的元素设置float属性即可。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> = <span class=\"string\">&quot;bigBox&quot;</span>&gt;</span></span><br><span class=\"line\">    123</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;box&quot;</span>&gt;</span>我是一个盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.bigBox</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码块就应用了浮动的特性，我们将此盒子向左浮动了，这样盒子就会向左浮动，而且盒子的宽度会自动变成内容的宽度。</p>\n<p>但是在这里我们发现一个问题，就是在外部盒子的高度没有将我们浮动的盒子包含进去。</p>\n<p>这是为什么呢？这是因为浮动的元素脱离了文档流，所以在文档流中的元素不会将浮动的元素包含进去。</p>\n<p>下面我们使用清除浮动来解决这个问题。</p>\n<h2 id=\"2-清除浮动\"><a href=\"#2-清除浮动\" class=\"headerlink\" title=\"2.清除浮动\"></a>2.清除浮动</h2><h3 id=\"2-1-清除浮动的概念\"><a href=\"#2-1-清除浮动的概念\" class=\"headerlink\" title=\"2.1 清除浮动的概念\"></a>2.1 清除浮动的概念</h3><p>清除浮动就是将浮动脱离标准文档流导致的高度塌陷问题解决掉。比如上面的例子，我们通过清除浮动，使得外部的盒子可以将浮动的元素包含进去。</p>\n<p>清除浮动是为了解决浮动元素脱离文档流导致的高度塌陷问题。清除浮动的方式有很多，但是最常用的就是使用clear属性和伪元素来清除浮动。</p>\n<h3 id=\"2-2-clear清除浮动\"><a href=\"#2-2-clear清除浮动\" class=\"headerlink\" title=\"2.2 clear清除浮动\"></a>2.2 clear清除浮动</h3><p>clear属性是用来清除浮动的，它有四个值，分别是left、right、both、none。其中left和right分别表示清除左浮动和右浮动，both表示清除左右浮动，none表示不清除浮动。</p>\n<p>那么如何来使用呢？</p>\n<ul>\n<li>在装浮动元素的盒子上使用clear属性，例如：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> = <span class=\"string\">&quot;bigBox&quot;</span>&gt;</span></span><br><span class=\"line\">    123</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;box&quot;</span>&gt;</span>我是一个盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;clear:both;&quot;</span>&gt;</span>我是一个盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里我们默认浮动的元素是向左浮动的，所以我们在装浮动元素的盒子上使用clear:both;来清除浮动。</p>\n<p>虽然这样可以达到清除浮动的效果，但是这样很不优雅，尤其是在我们实际开发当中，我们需要将html和css分离开来；如果我们将css写在html中，会导致我们的html代码变得很臃肿。<br>这个时候，就需要用到第二种清除浮动的方式，利用伪元素。</p>\n<h3 id=\"2-3-伪元素清除浮动\"><a href=\"#2-3-伪元素清除浮动\" class=\"headerlink\" title=\"2.3 伪元素清除浮动\"></a>2.3 伪元素清除浮动</h3><p>伪元素是一种特殊的选择器，它可以用来选择一些不存在的元素，比如：before、after、first-letter、first-line等。伪元素以<code>::</code>开头，但是后面为了更好的兼容性，我们习惯使用<code>:</code>开头。</p>\n<p>在这里我们使用到<code>:after</code>和<code>:before</code>，表示在元素的结束和开始处插入一个元素。</p>\n<p>于是，上面的清除浮动，我们可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.bigBox</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;// 这里必须要有内容，否则不会生效（必须要有<span class=\"attribute\">content</span>）</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;// 这里设置为非inline元素，否则不会生效</span><br><span class=\"line\">    <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"css中的浮动以及清除\"><a href=\"#css中的浮动以及清除\" class=\"headerlink\" title=\"css中的浮动以及清除\"></a>css中的浮动以及清除</h1><h2 id=\"1-浮动的概念\"><a href=\"#1-浮动的概念\" class=\"headerlink\" title=\"1. 浮动的概念\"></a>1. 浮动的概念</h2><p>浮动是网页布局中最古老的方式，但是这种方式最开始并不是为了网页布局而生的。浮动是为了让文字环绕图片而生的。在css中，浮动是通过float属性来实现的，float属性有left和right两个值，分别表示向左浮动和向右浮动。正是因为浮动并不是为网页布局而生的，导致我们在后面在使用的时候会有很多出乎意料的方式。</p>\n<h3 id=\"1-1-浮动的使用\"><a href=\"#1-1-浮动的使用\" class=\"headerlink\" title=\"1.1 浮动的使用\"></a>1.1 浮动的使用</h3><p>浮动的使用非常简单，只需要给需要浮动的元素设置float属性即可。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> = <span class=\"string\">&quot;bigBox&quot;</span>&gt;</span></span><br><span class=\"line\">    123</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;box&quot;</span>&gt;</span>我是一个盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.bigBox</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码块就应用了浮动的特性，我们将此盒子向左浮动了，这样盒子就会向左浮动，而且盒子的宽度会自动变成内容的宽度。</p>\n<p>但是在这里我们发现一个问题，就是在外部盒子的高度没有将我们浮动的盒子包含进去。</p>\n<p>这是为什么呢？这是因为浮动的元素脱离了文档流，所以在文档流中的元素不会将浮动的元素包含进去。</p>\n<p>下面我们使用清除浮动来解决这个问题。</p>\n<h2 id=\"2-清除浮动\"><a href=\"#2-清除浮动\" class=\"headerlink\" title=\"2.清除浮动\"></a>2.清除浮动</h2><h3 id=\"2-1-清除浮动的概念\"><a href=\"#2-1-清除浮动的概念\" class=\"headerlink\" title=\"2.1 清除浮动的概念\"></a>2.1 清除浮动的概念</h3><p>清除浮动就是将浮动脱离标准文档流导致的高度塌陷问题解决掉。比如上面的例子，我们通过清除浮动，使得外部的盒子可以将浮动的元素包含进去。</p>\n<p>清除浮动是为了解决浮动元素脱离文档流导致的高度塌陷问题。清除浮动的方式有很多，但是最常用的就是使用clear属性和伪元素来清除浮动。</p>\n<h3 id=\"2-2-clear清除浮动\"><a href=\"#2-2-clear清除浮动\" class=\"headerlink\" title=\"2.2 clear清除浮动\"></a>2.2 clear清除浮动</h3><p>clear属性是用来清除浮动的，它有四个值，分别是left、right、both、none。其中left和right分别表示清除左浮动和右浮动，both表示清除左右浮动，none表示不清除浮动。</p>\n<p>那么如何来使用呢？</p>\n<ul>\n<li>在装浮动元素的盒子上使用clear属性，例如：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> = <span class=\"string\">&quot;bigBox&quot;</span>&gt;</span></span><br><span class=\"line\">    123</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;box&quot;</span>&gt;</span>我是一个盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;clear:both;&quot;</span>&gt;</span>我是一个盒子<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里我们默认浮动的元素是向左浮动的，所以我们在装浮动元素的盒子上使用clear:both;来清除浮动。</p>\n<p>虽然这样可以达到清除浮动的效果，但是这样很不优雅，尤其是在我们实际开发当中，我们需要将html和css分离开来；如果我们将css写在html中，会导致我们的html代码变得很臃肿。<br>这个时候，就需要用到第二种清除浮动的方式，利用伪元素。</p>\n<h3 id=\"2-3-伪元素清除浮动\"><a href=\"#2-3-伪元素清除浮动\" class=\"headerlink\" title=\"2.3 伪元素清除浮动\"></a>2.3 伪元素清除浮动</h3><p>伪元素是一种特殊的选择器，它可以用来选择一些不存在的元素，比如：before、after、first-letter、first-line等。伪元素以<code>::</code>开头，但是后面为了更好的兼容性，我们习惯使用<code>:</code>开头。</p>\n<p>在这里我们使用到<code>:after</code>和<code>:before</code>，表示在元素的结束和开始处插入一个元素。</p>\n<p>于是，上面的清除浮动，我们可以这样写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.bigBox</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;// 这里必须要有内容，否则不会生效（必须要有<span class=\"attribute\">content</span>）</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;// 这里设置为非inline元素，否则不会生效</span><br><span class=\"line\">    <span class=\"attribute\">clear</span>: both;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"CSS动画","date":"2022-10-05T16:00:00.000Z","_content":"# CSS动画\n\n## 1. CSS动画的基本概念\n\n动画是一种使元素从一种样式逐渐转变为另一种样式的效果。CSS动画是通过改变元素的样式来实现的，这些样式可以是元素的位置、大小、颜色、背景、边框等等。\n\nCSS动画包含两个部分：\n\n- 描述动画的样式规则\n- 描述动画开始、中间、结束的关键帧\n\n## 2.动画需要用到`@keyframes`\n\n`@keyframes`是CSS3中新增的一个规则，用来描述动画的关键帧。关键帧是动画的开始、中间、结束的状态。关键帧的名称可以自定义，但是必须以`%`结尾，表示动画的进度。(也可以直接from[起点] to[终点])\n\n```css\n    @keyframes example1 {\n        from {background-color: red;}\n        to {background-color: yellow;}\n    }\n\n    @keyframes example2 {\n        0% {background-color: red;}\n        25% {background-color: yellow;}\n        50% {background-color: blue;}\n        100% {background-color: green;}\n    }\n```\n\n我们使用上面两段代码演示了一下这两种定义动画的方式，一种是from...to...,一种是百分比的方式。\n\n很明显使用百分比的方式可以更加精确的控制动画的效果。\n\n## 3.css动画的属性\n\n- animation-name：动画的名称，必须与`@keyframes`中的名称一致\n- animation-duration：动画的持续时间\n- animation-delay：动画的延迟时间\n- animation-iteration-count：动画的播放次数\n- animation-direction：动画的方向\n- animation-timing-function：动画的速度曲线\n- animation-fill-mode：动画的填充模式\n- animation：设置动画的所有简写属性\n\n### 3.1 animation-duration\n\n动画的持续时间，也就是动画从开始到结束的时间，可以使用`s`或者`ms`来设置，如下：\n\n```css\n    animation-duration: 5s;\n    animation-duration: 5000ms;\n```\n\n### 3.2 animation-delay\n\n动画的延迟时间，也就是动画开始前的延迟时间，同样也是使用`s`或者`ms`来设置，如下：\n\n### 3.3 animation-iteration-count\n\n该属性用于设置动画播放的次数，可以是一个数字，也可以是`infinite`，表示无限次播放，如下：\n\n```css\n    animation-iteration-count: 3;// 只播放三次动画\n    animation-iteration-count: infinite;// 无限循环\n```\n\n### 3.4 animation-direction\n\n该属性可以设置动画的播放方向，可以是`normal`、`reverse`、`alternate`、`alternate-reverse`，如下：\n\n- normal: 正常播放(从0%-->100%)\n- reverse: 反向播放(从100%-->0%)\n- alternate: 交替播放(从0%-->100%-->0%)\n- alternate-reverse: 交替反向播放(从100%-->0%-->100%)\n\n### 3.5 animation-timing-function\n\n该属性用来设置动画的播放速度曲线，可以是`linear`、`ease`、`ease-in`、`ease-out`、`ease-in-out`、`cubic-bezier()`，如下：\n\n- linear: 动画从头到尾的速度是相同的\n- ease: 默认值，动画以低速开始，然后加快，在结束前变慢\n- ease-in: 动画以低速开始\n- ease-out: 动画以低速结束\n- ease-in-out: 动画以低速开始和结束\n- cubic-bezier(n,n,n,n): 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值\n\n### 3.6 animation\n\n前面我们每一个属性就写一行代码的话，显得十分臃肿，这里我们可以使用简写属性的方式来解决问题。\n\n```css\n    animation: name duration timing-function delay iteration-count direction fill-mode;\n```\n\n可以看到，书写的属性顺序为：动画名字、持续时间、速度曲线、延迟时间、播放次数、播放方向、填充模式。\n\n不需要的属性我们可以直接省略，但是顺序不能改变。","source":"_posts/CSS动画.md","raw":"---\ntitle: CSS动画\ndate: 2022-10-6\ntags: [前端]\ncategories: [css]\n---\n# CSS动画\n\n## 1. CSS动画的基本概念\n\n动画是一种使元素从一种样式逐渐转变为另一种样式的效果。CSS动画是通过改变元素的样式来实现的，这些样式可以是元素的位置、大小、颜色、背景、边框等等。\n\nCSS动画包含两个部分：\n\n- 描述动画的样式规则\n- 描述动画开始、中间、结束的关键帧\n\n## 2.动画需要用到`@keyframes`\n\n`@keyframes`是CSS3中新增的一个规则，用来描述动画的关键帧。关键帧是动画的开始、中间、结束的状态。关键帧的名称可以自定义，但是必须以`%`结尾，表示动画的进度。(也可以直接from[起点] to[终点])\n\n```css\n    @keyframes example1 {\n        from {background-color: red;}\n        to {background-color: yellow;}\n    }\n\n    @keyframes example2 {\n        0% {background-color: red;}\n        25% {background-color: yellow;}\n        50% {background-color: blue;}\n        100% {background-color: green;}\n    }\n```\n\n我们使用上面两段代码演示了一下这两种定义动画的方式，一种是from...to...,一种是百分比的方式。\n\n很明显使用百分比的方式可以更加精确的控制动画的效果。\n\n## 3.css动画的属性\n\n- animation-name：动画的名称，必须与`@keyframes`中的名称一致\n- animation-duration：动画的持续时间\n- animation-delay：动画的延迟时间\n- animation-iteration-count：动画的播放次数\n- animation-direction：动画的方向\n- animation-timing-function：动画的速度曲线\n- animation-fill-mode：动画的填充模式\n- animation：设置动画的所有简写属性\n\n### 3.1 animation-duration\n\n动画的持续时间，也就是动画从开始到结束的时间，可以使用`s`或者`ms`来设置，如下：\n\n```css\n    animation-duration: 5s;\n    animation-duration: 5000ms;\n```\n\n### 3.2 animation-delay\n\n动画的延迟时间，也就是动画开始前的延迟时间，同样也是使用`s`或者`ms`来设置，如下：\n\n### 3.3 animation-iteration-count\n\n该属性用于设置动画播放的次数，可以是一个数字，也可以是`infinite`，表示无限次播放，如下：\n\n```css\n    animation-iteration-count: 3;// 只播放三次动画\n    animation-iteration-count: infinite;// 无限循环\n```\n\n### 3.4 animation-direction\n\n该属性可以设置动画的播放方向，可以是`normal`、`reverse`、`alternate`、`alternate-reverse`，如下：\n\n- normal: 正常播放(从0%-->100%)\n- reverse: 反向播放(从100%-->0%)\n- alternate: 交替播放(从0%-->100%-->0%)\n- alternate-reverse: 交替反向播放(从100%-->0%-->100%)\n\n### 3.5 animation-timing-function\n\n该属性用来设置动画的播放速度曲线，可以是`linear`、`ease`、`ease-in`、`ease-out`、`ease-in-out`、`cubic-bezier()`，如下：\n\n- linear: 动画从头到尾的速度是相同的\n- ease: 默认值，动画以低速开始，然后加快，在结束前变慢\n- ease-in: 动画以低速开始\n- ease-out: 动画以低速结束\n- ease-in-out: 动画以低速开始和结束\n- cubic-bezier(n,n,n,n): 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值\n\n### 3.6 animation\n\n前面我们每一个属性就写一行代码的话，显得十分臃肿，这里我们可以使用简写属性的方式来解决问题。\n\n```css\n    animation: name duration timing-function delay iteration-count direction fill-mode;\n```\n\n可以看到，书写的属性顺序为：动画名字、持续时间、速度曲线、延迟时间、播放次数、播放方向、填充模式。\n\n不需要的属性我们可以直接省略，但是顺序不能改变。","slug":"CSS动画","published":1,"updated":"2023-01-09T11:58:19.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgn000a9kbmcidaegzc","content":"<h1 id=\"CSS动画\"><a href=\"#CSS动画\" class=\"headerlink\" title=\"CSS动画\"></a>CSS动画</h1><h2 id=\"1-CSS动画的基本概念\"><a href=\"#1-CSS动画的基本概念\" class=\"headerlink\" title=\"1. CSS动画的基本概念\"></a>1. CSS动画的基本概念</h2><p>动画是一种使元素从一种样式逐渐转变为另一种样式的效果。CSS动画是通过改变元素的样式来实现的，这些样式可以是元素的位置、大小、颜色、背景、边框等等。</p>\n<p>CSS动画包含两个部分：</p>\n<ul>\n<li>描述动画的样式规则</li>\n<li>描述动画开始、中间、结束的关键帧</li>\n</ul>\n<h2 id=\"2-动画需要用到-keyframes\"><a href=\"#2-动画需要用到-keyframes\" class=\"headerlink\" title=\"2.动画需要用到@keyframes\"></a>2.动画需要用到<code>@keyframes</code></h2><p><code>@keyframes</code>是CSS3中新增的一个规则，用来描述动画的关键帧。关键帧是动画的开始、中间、结束的状态。关键帧的名称可以自定义，但是必须以<code>%</code>结尾，表示动画的进度。(也可以直接from[起点] to[终点])</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> example1 &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;<span class=\"attribute\">background-color</span>: red;&#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;<span class=\"attribute\">background-color</span>: yellow;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> example2 &#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span> &#123;<span class=\"attribute\">background-color</span>: red;&#125;</span><br><span class=\"line\">    <span class=\"number\">25%</span> &#123;<span class=\"attribute\">background-color</span>: yellow;&#125;</span><br><span class=\"line\">    <span class=\"number\">50%</span> &#123;<span class=\"attribute\">background-color</span>: blue;&#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span> &#123;<span class=\"attribute\">background-color</span>: green;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用上面两段代码演示了一下这两种定义动画的方式，一种是from…to…,一种是百分比的方式。</p>\n<p>很明显使用百分比的方式可以更加精确的控制动画的效果。</p>\n<h2 id=\"3-css动画的属性\"><a href=\"#3-css动画的属性\" class=\"headerlink\" title=\"3.css动画的属性\"></a>3.css动画的属性</h2><ul>\n<li>animation-name：动画的名称，必须与<code>@keyframes</code>中的名称一致</li>\n<li>animation-duration：动画的持续时间</li>\n<li>animation-delay：动画的延迟时间</li>\n<li>animation-iteration-count：动画的播放次数</li>\n<li>animation-direction：动画的方向</li>\n<li>animation-timing-function：动画的速度曲线</li>\n<li>animation-fill-mode：动画的填充模式</li>\n<li>animation：设置动画的所有简写属性</li>\n</ul>\n<h3 id=\"3-1-animation-duration\"><a href=\"#3-1-animation-duration\" class=\"headerlink\" title=\"3.1 animation-duration\"></a>3.1 animation-duration</h3><p>动画的持续时间，也就是动画从开始到结束的时间，可以使用<code>s</code>或者<code>ms</code>来设置，如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animation-duration</span>: <span class=\"number\">5s</span>;</span><br><span class=\"line\"><span class=\"attribute\">animation-duration</span>: <span class=\"number\">5000ms</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-animation-delay\"><a href=\"#3-2-animation-delay\" class=\"headerlink\" title=\"3.2 animation-delay\"></a>3.2 animation-delay</h3><p>动画的延迟时间，也就是动画开始前的延迟时间，同样也是使用<code>s</code>或者<code>ms</code>来设置，如下：</p>\n<h3 id=\"3-3-animation-iteration-count\"><a href=\"#3-3-animation-iteration-count\" class=\"headerlink\" title=\"3.3 animation-iteration-count\"></a>3.3 animation-iteration-count</h3><p>该属性用于设置动画播放的次数，可以是一个数字，也可以是<code>infinite</code>，表示无限次播放，如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animation-iteration-count</span>: <span class=\"number\">3</span>;// 只播放三次动画</span><br><span class=\"line\"><span class=\"attribute\">animation-iteration-count</span>: infinite;// 无限循环</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-animation-direction\"><a href=\"#3-4-animation-direction\" class=\"headerlink\" title=\"3.4 animation-direction\"></a>3.4 animation-direction</h3><p>该属性可以设置动画的播放方向，可以是<code>normal</code>、<code>reverse</code>、<code>alternate</code>、<code>alternate-reverse</code>，如下：</p>\n<ul>\n<li>normal: 正常播放(从0%–&gt;100%)</li>\n<li>reverse: 反向播放(从100%–&gt;0%)</li>\n<li>alternate: 交替播放(从0%–&gt;100%–&gt;0%)</li>\n<li>alternate-reverse: 交替反向播放(从100%–&gt;0%–&gt;100%)</li>\n</ul>\n<h3 id=\"3-5-animation-timing-function\"><a href=\"#3-5-animation-timing-function\" class=\"headerlink\" title=\"3.5 animation-timing-function\"></a>3.5 animation-timing-function</h3><p>该属性用来设置动画的播放速度曲线，可以是<code>linear</code>、<code>ease</code>、<code>ease-in</code>、<code>ease-out</code>、<code>ease-in-out</code>、<code>cubic-bezier()</code>，如下：</p>\n<ul>\n<li>linear: 动画从头到尾的速度是相同的</li>\n<li>ease: 默认值，动画以低速开始，然后加快，在结束前变慢</li>\n<li>ease-in: 动画以低速开始</li>\n<li>ease-out: 动画以低速结束</li>\n<li>ease-in-out: 动画以低速开始和结束</li>\n<li>cubic-bezier(n,n,n,n): 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值</li>\n</ul>\n<h3 id=\"3-6-animation\"><a href=\"#3-6-animation\" class=\"headerlink\" title=\"3.6 animation\"></a>3.6 animation</h3><p>前面我们每一个属性就写一行代码的话，显得十分臃肿，这里我们可以使用简写属性的方式来解决问题。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animation</span>: name duration timing-function delay iteration-count direction fill-mode;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，书写的属性顺序为：动画名字、持续时间、速度曲线、延迟时间、播放次数、播放方向、填充模式。</p>\n<p>不需要的属性我们可以直接省略，但是顺序不能改变。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS动画\"><a href=\"#CSS动画\" class=\"headerlink\" title=\"CSS动画\"></a>CSS动画</h1><h2 id=\"1-CSS动画的基本概念\"><a href=\"#1-CSS动画的基本概念\" class=\"headerlink\" title=\"1. CSS动画的基本概念\"></a>1. CSS动画的基本概念</h2><p>动画是一种使元素从一种样式逐渐转变为另一种样式的效果。CSS动画是通过改变元素的样式来实现的，这些样式可以是元素的位置、大小、颜色、背景、边框等等。</p>\n<p>CSS动画包含两个部分：</p>\n<ul>\n<li>描述动画的样式规则</li>\n<li>描述动画开始、中间、结束的关键帧</li>\n</ul>\n<h2 id=\"2-动画需要用到-keyframes\"><a href=\"#2-动画需要用到-keyframes\" class=\"headerlink\" title=\"2.动画需要用到@keyframes\"></a>2.动画需要用到<code>@keyframes</code></h2><p><code>@keyframes</code>是CSS3中新增的一个规则，用来描述动画的关键帧。关键帧是动画的开始、中间、结束的状态。关键帧的名称可以自定义，但是必须以<code>%</code>结尾，表示动画的进度。(也可以直接from[起点] to[终点])</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> example1 &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;<span class=\"attribute\">background-color</span>: red;&#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;<span class=\"attribute\">background-color</span>: yellow;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> example2 &#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span> &#123;<span class=\"attribute\">background-color</span>: red;&#125;</span><br><span class=\"line\">    <span class=\"number\">25%</span> &#123;<span class=\"attribute\">background-color</span>: yellow;&#125;</span><br><span class=\"line\">    <span class=\"number\">50%</span> &#123;<span class=\"attribute\">background-color</span>: blue;&#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span> &#123;<span class=\"attribute\">background-color</span>: green;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用上面两段代码演示了一下这两种定义动画的方式，一种是from…to…,一种是百分比的方式。</p>\n<p>很明显使用百分比的方式可以更加精确的控制动画的效果。</p>\n<h2 id=\"3-css动画的属性\"><a href=\"#3-css动画的属性\" class=\"headerlink\" title=\"3.css动画的属性\"></a>3.css动画的属性</h2><ul>\n<li>animation-name：动画的名称，必须与<code>@keyframes</code>中的名称一致</li>\n<li>animation-duration：动画的持续时间</li>\n<li>animation-delay：动画的延迟时间</li>\n<li>animation-iteration-count：动画的播放次数</li>\n<li>animation-direction：动画的方向</li>\n<li>animation-timing-function：动画的速度曲线</li>\n<li>animation-fill-mode：动画的填充模式</li>\n<li>animation：设置动画的所有简写属性</li>\n</ul>\n<h3 id=\"3-1-animation-duration\"><a href=\"#3-1-animation-duration\" class=\"headerlink\" title=\"3.1 animation-duration\"></a>3.1 animation-duration</h3><p>动画的持续时间，也就是动画从开始到结束的时间，可以使用<code>s</code>或者<code>ms</code>来设置，如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animation-duration</span>: <span class=\"number\">5s</span>;</span><br><span class=\"line\"><span class=\"attribute\">animation-duration</span>: <span class=\"number\">5000ms</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-animation-delay\"><a href=\"#3-2-animation-delay\" class=\"headerlink\" title=\"3.2 animation-delay\"></a>3.2 animation-delay</h3><p>动画的延迟时间，也就是动画开始前的延迟时间，同样也是使用<code>s</code>或者<code>ms</code>来设置，如下：</p>\n<h3 id=\"3-3-animation-iteration-count\"><a href=\"#3-3-animation-iteration-count\" class=\"headerlink\" title=\"3.3 animation-iteration-count\"></a>3.3 animation-iteration-count</h3><p>该属性用于设置动画播放的次数，可以是一个数字，也可以是<code>infinite</code>，表示无限次播放，如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animation-iteration-count</span>: <span class=\"number\">3</span>;// 只播放三次动画</span><br><span class=\"line\"><span class=\"attribute\">animation-iteration-count</span>: infinite;// 无限循环</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-animation-direction\"><a href=\"#3-4-animation-direction\" class=\"headerlink\" title=\"3.4 animation-direction\"></a>3.4 animation-direction</h3><p>该属性可以设置动画的播放方向，可以是<code>normal</code>、<code>reverse</code>、<code>alternate</code>、<code>alternate-reverse</code>，如下：</p>\n<ul>\n<li>normal: 正常播放(从0%–&gt;100%)</li>\n<li>reverse: 反向播放(从100%–&gt;0%)</li>\n<li>alternate: 交替播放(从0%–&gt;100%–&gt;0%)</li>\n<li>alternate-reverse: 交替反向播放(从100%–&gt;0%–&gt;100%)</li>\n</ul>\n<h3 id=\"3-5-animation-timing-function\"><a href=\"#3-5-animation-timing-function\" class=\"headerlink\" title=\"3.5 animation-timing-function\"></a>3.5 animation-timing-function</h3><p>该属性用来设置动画的播放速度曲线，可以是<code>linear</code>、<code>ease</code>、<code>ease-in</code>、<code>ease-out</code>、<code>ease-in-out</code>、<code>cubic-bezier()</code>，如下：</p>\n<ul>\n<li>linear: 动画从头到尾的速度是相同的</li>\n<li>ease: 默认值，动画以低速开始，然后加快，在结束前变慢</li>\n<li>ease-in: 动画以低速开始</li>\n<li>ease-out: 动画以低速结束</li>\n<li>ease-in-out: 动画以低速开始和结束</li>\n<li>cubic-bezier(n,n,n,n): 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值</li>\n</ul>\n<h3 id=\"3-6-animation\"><a href=\"#3-6-animation\" class=\"headerlink\" title=\"3.6 animation\"></a>3.6 animation</h3><p>前面我们每一个属性就写一行代码的话，显得十分臃肿，这里我们可以使用简写属性的方式来解决问题。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">animation</span>: name duration timing-function delay iteration-count direction fill-mode;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，书写的属性顺序为：动画名字、持续时间、速度曲线、延迟时间、播放次数、播放方向、填充模式。</p>\n<p>不需要的属性我们可以直接省略，但是顺序不能改变。</p>\n"},{"title":"jQuery中的自带动画","date":"2022-10-22T16:00:00.000Z","_content":"# jQuery中的自带动画\n\njQuery是一个非常强大的JavaScript库，它提供了很多非常有用的功能，其中包括动画。\n\n在前端的实际开发中，我们经常会遇到一些动画效果，比如：鼠标移入移出，点击，滚动等等。这些动画效果，我们可以使用jQuery来实现。下面我们就来看看jQuery中的动画。\n\n## jQuery自带的动画\n\n在jQuery中内置了一些动画，比如元素的隐藏与显示、淡入淡出、滑动等等。这些动画都是通过jQuery提供的方法来实现的。\n\n### 1. 隐藏与显示\n\n语法：\n`$(selector).hide(speed,callback);`隐藏元素\n`$(selector).show(speed,callback);`显示元素\n`$(selector).toggle(speed,callback);`切换元素的显示与隐藏\n\n根据语法，我们不难看出，这两个方法都是通过选择器来选择元素，然后通过speed参数来设置动画的速度，最后通过callback参数来设置动画完成后的回调函数。\n\n代码演示：\n\n```js\n$(document).ready(function(){\n    $(\"#btn1\").click(function(){\n        $(\"p\").hide();\n    });\n    $(\"#btn2\").click(function(){\n        $(\"p\").show();\n    });\n});\n```\n\n上面我们获取了两个按钮，第一个按钮控制元素的隐藏，第二个按钮控制元素的显示。\n\n### 2. 淡入淡出\n\n在jQuery中，有四种方法来实现淡入淡出的效果，分别是：\n\n1. `fadeIn()`：淡入\n2. `fadeOut()`：淡出\n3. `fadeToggle()`：淡入淡出切换\n4. `fadeTO()`：淡入淡出到指定的不透明度\n\n上面的前种方法都支持speed和callback两个参数，其中speed参数用来设置动画的速度，callback参数用来设置动画完成后的回调函数。\n\n其中第三种方法可以切换元素淡入淡出的效果，如果元素是隐藏的，那么就会淡入，如果元素是显示的，那么就会淡出。\n\n`$(selector).fadeIn(speed,callback);`\n`$(selector).fadeOut(speed,callback);`\n`$(selector).fadeToggle(speed,callback);`\n\n\n\n代码演示：\n\n```js\n$(document).ready(function(){\n    $(\"#btn1\").click(function(){\n        $(\"#div1\").fadeIn();\n        $(\"#div2\").fadeIn(\"slow\");\n        $(\"#div3\").fadeIn(3000);\n    });\n});\n```\n\n第四种方法呢：参数与前面三种有点区别，它除了speed和callback两个参数外，还有一个参数：opacity，用来设置元素淡入淡出到指定的不透明度。\n\n`$(selector).fadeTo(speed,opacity,callback);`\n\n代码演示：\n\n```js\n$(document).ready(function(){\n    $(\"#btn1\").click(function(){\n        $(\"#div1\").fadeTo(\"slow\",0.15,1000);\n    });\n});\n```\n\n### 3. 滑动\n\n在jQuery中，我们还可以通过其自带的方法实现滑动的效果。\n\njQuery实现滑动的方法也有三种：\n\n1. slideDown()：向下滑动\n2. slideUP()：向上滑动\n3. slideToggle()：向上向下滑动切换\n\n`$(selector).slideDown(speed,callback);`\n`$(selector).slideUp(speed,callback);`\n`$(selector).slideToggle(speed,callback);`\n\n参数：\n\n在这三种方法中，speed和callback参数的含义与前面的方法是一样的。都是定义动画的速度有完成动画之后的回调函数.\n\n代码演示：\n\n```js\n$(document).ready(function(){\n    $(\"#btn3\").click(function(){\n        $(\"#div1\").slideToggle();\n        $(\"#div2\").slideToggle(\"slow\");\n        $(\"#div3\").slideToggle(3000);\n    });\n});\n```\n\n这里我们只展示了`slideToggle()`方法，其他两种方法的使用方法与`slideToggle()`方法是一样的。","source":"_posts/Jquery中的动画.md","raw":"---\ntitle: jQuery中的自带动画\ndate: 2022-10-23\ntags: [前端]\ncategories: [jQuery]\n---\n# jQuery中的自带动画\n\njQuery是一个非常强大的JavaScript库，它提供了很多非常有用的功能，其中包括动画。\n\n在前端的实际开发中，我们经常会遇到一些动画效果，比如：鼠标移入移出，点击，滚动等等。这些动画效果，我们可以使用jQuery来实现。下面我们就来看看jQuery中的动画。\n\n## jQuery自带的动画\n\n在jQuery中内置了一些动画，比如元素的隐藏与显示、淡入淡出、滑动等等。这些动画都是通过jQuery提供的方法来实现的。\n\n### 1. 隐藏与显示\n\n语法：\n`$(selector).hide(speed,callback);`隐藏元素\n`$(selector).show(speed,callback);`显示元素\n`$(selector).toggle(speed,callback);`切换元素的显示与隐藏\n\n根据语法，我们不难看出，这两个方法都是通过选择器来选择元素，然后通过speed参数来设置动画的速度，最后通过callback参数来设置动画完成后的回调函数。\n\n代码演示：\n\n```js\n$(document).ready(function(){\n    $(\"#btn1\").click(function(){\n        $(\"p\").hide();\n    });\n    $(\"#btn2\").click(function(){\n        $(\"p\").show();\n    });\n});\n```\n\n上面我们获取了两个按钮，第一个按钮控制元素的隐藏，第二个按钮控制元素的显示。\n\n### 2. 淡入淡出\n\n在jQuery中，有四种方法来实现淡入淡出的效果，分别是：\n\n1. `fadeIn()`：淡入\n2. `fadeOut()`：淡出\n3. `fadeToggle()`：淡入淡出切换\n4. `fadeTO()`：淡入淡出到指定的不透明度\n\n上面的前种方法都支持speed和callback两个参数，其中speed参数用来设置动画的速度，callback参数用来设置动画完成后的回调函数。\n\n其中第三种方法可以切换元素淡入淡出的效果，如果元素是隐藏的，那么就会淡入，如果元素是显示的，那么就会淡出。\n\n`$(selector).fadeIn(speed,callback);`\n`$(selector).fadeOut(speed,callback);`\n`$(selector).fadeToggle(speed,callback);`\n\n\n\n代码演示：\n\n```js\n$(document).ready(function(){\n    $(\"#btn1\").click(function(){\n        $(\"#div1\").fadeIn();\n        $(\"#div2\").fadeIn(\"slow\");\n        $(\"#div3\").fadeIn(3000);\n    });\n});\n```\n\n第四种方法呢：参数与前面三种有点区别，它除了speed和callback两个参数外，还有一个参数：opacity，用来设置元素淡入淡出到指定的不透明度。\n\n`$(selector).fadeTo(speed,opacity,callback);`\n\n代码演示：\n\n```js\n$(document).ready(function(){\n    $(\"#btn1\").click(function(){\n        $(\"#div1\").fadeTo(\"slow\",0.15,1000);\n    });\n});\n```\n\n### 3. 滑动\n\n在jQuery中，我们还可以通过其自带的方法实现滑动的效果。\n\njQuery实现滑动的方法也有三种：\n\n1. slideDown()：向下滑动\n2. slideUP()：向上滑动\n3. slideToggle()：向上向下滑动切换\n\n`$(selector).slideDown(speed,callback);`\n`$(selector).slideUp(speed,callback);`\n`$(selector).slideToggle(speed,callback);`\n\n参数：\n\n在这三种方法中，speed和callback参数的含义与前面的方法是一样的。都是定义动画的速度有完成动画之后的回调函数.\n\n代码演示：\n\n```js\n$(document).ready(function(){\n    $(\"#btn3\").click(function(){\n        $(\"#div1\").slideToggle();\n        $(\"#div2\").slideToggle(\"slow\");\n        $(\"#div3\").slideToggle(3000);\n    });\n});\n```\n\n这里我们只展示了`slideToggle()`方法，其他两种方法的使用方法与`slideToggle()`方法是一样的。","slug":"Jquery中的动画","published":1,"updated":"2023-01-09T12:17:10.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgo000c9kbm7iw55t95","content":"<h1 id=\"jQuery中的自带动画\"><a href=\"#jQuery中的自带动画\" class=\"headerlink\" title=\"jQuery中的自带动画\"></a>jQuery中的自带动画</h1><p>jQuery是一个非常强大的JavaScript库，它提供了很多非常有用的功能，其中包括动画。</p>\n<p>在前端的实际开发中，我们经常会遇到一些动画效果，比如：鼠标移入移出，点击，滚动等等。这些动画效果，我们可以使用jQuery来实现。下面我们就来看看jQuery中的动画。</p>\n<h2 id=\"jQuery自带的动画\"><a href=\"#jQuery自带的动画\" class=\"headerlink\" title=\"jQuery自带的动画\"></a>jQuery自带的动画</h2><p>在jQuery中内置了一些动画，比如元素的隐藏与显示、淡入淡出、滑动等等。这些动画都是通过jQuery提供的方法来实现的。</p>\n<h3 id=\"1-隐藏与显示\"><a href=\"#1-隐藏与显示\" class=\"headerlink\" title=\"1. 隐藏与显示\"></a>1. 隐藏与显示</h3><p>语法：<br><code>$(selector).hide(speed,callback);</code>隐藏元素<br><code>$(selector).show(speed,callback);</code>显示元素<br><code>$(selector).toggle(speed,callback);</code>切换元素的显示与隐藏</p>\n<p>根据语法，我们不难看出，这两个方法都是通过选择器来选择元素，然后通过speed参数来设置动画的速度，最后通过callback参数来设置动画完成后的回调函数。</p>\n<p>代码演示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn1&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;p&quot;</span>).<span class=\"title function_\">hide</span>();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn2&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;p&quot;</span>).<span class=\"title function_\">show</span>();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面我们获取了两个按钮，第一个按钮控制元素的隐藏，第二个按钮控制元素的显示。</p>\n<h3 id=\"2-淡入淡出\"><a href=\"#2-淡入淡出\" class=\"headerlink\" title=\"2. 淡入淡出\"></a>2. 淡入淡出</h3><p>在jQuery中，有四种方法来实现淡入淡出的效果，分别是：</p>\n<ol>\n<li><code>fadeIn()</code>：淡入</li>\n<li><code>fadeOut()</code>：淡出</li>\n<li><code>fadeToggle()</code>：淡入淡出切换</li>\n<li><code>fadeTO()</code>：淡入淡出到指定的不透明度</li>\n</ol>\n<p>上面的前种方法都支持speed和callback两个参数，其中speed参数用来设置动画的速度，callback参数用来设置动画完成后的回调函数。</p>\n<p>其中第三种方法可以切换元素淡入淡出的效果，如果元素是隐藏的，那么就会淡入，如果元素是显示的，那么就会淡出。</p>\n<p><code>$(selector).fadeIn(speed,callback);</code><br><code>$(selector).fadeOut(speed,callback);</code><br><code>$(selector).fadeToggle(speed,callback);</code></p>\n<p>代码演示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn1&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div1&quot;</span>).<span class=\"title function_\">fadeIn</span>();</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div2&quot;</span>).<span class=\"title function_\">fadeIn</span>(<span class=\"string\">&quot;slow&quot;</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div3&quot;</span>).<span class=\"title function_\">fadeIn</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>第四种方法呢：参数与前面三种有点区别，它除了speed和callback两个参数外，还有一个参数：opacity，用来设置元素淡入淡出到指定的不透明度。</p>\n<p><code>$(selector).fadeTo(speed,opacity,callback);</code></p>\n<p>代码演示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn1&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div1&quot;</span>).<span class=\"title function_\">fadeTo</span>(<span class=\"string\">&quot;slow&quot;</span>,<span class=\"number\">0.15</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-滑动\"><a href=\"#3-滑动\" class=\"headerlink\" title=\"3. 滑动\"></a>3. 滑动</h3><p>在jQuery中，我们还可以通过其自带的方法实现滑动的效果。</p>\n<p>jQuery实现滑动的方法也有三种：</p>\n<ol>\n<li>slideDown()：向下滑动</li>\n<li>slideUP()：向上滑动</li>\n<li>slideToggle()：向上向下滑动切换</li>\n</ol>\n<p><code>$(selector).slideDown(speed,callback);</code><br><code>$(selector).slideUp(speed,callback);</code><br><code>$(selector).slideToggle(speed,callback);</code></p>\n<p>参数：</p>\n<p>在这三种方法中，speed和callback参数的含义与前面的方法是一样的。都是定义动画的速度有完成动画之后的回调函数.</p>\n<p>代码演示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn3&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div1&quot;</span>).<span class=\"title function_\">slideToggle</span>();</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div2&quot;</span>).<span class=\"title function_\">slideToggle</span>(<span class=\"string\">&quot;slow&quot;</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div3&quot;</span>).<span class=\"title function_\">slideToggle</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们只展示了<code>slideToggle()</code>方法，其他两种方法的使用方法与<code>slideToggle()</code>方法是一样的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jQuery中的自带动画\"><a href=\"#jQuery中的自带动画\" class=\"headerlink\" title=\"jQuery中的自带动画\"></a>jQuery中的自带动画</h1><p>jQuery是一个非常强大的JavaScript库，它提供了很多非常有用的功能，其中包括动画。</p>\n<p>在前端的实际开发中，我们经常会遇到一些动画效果，比如：鼠标移入移出，点击，滚动等等。这些动画效果，我们可以使用jQuery来实现。下面我们就来看看jQuery中的动画。</p>\n<h2 id=\"jQuery自带的动画\"><a href=\"#jQuery自带的动画\" class=\"headerlink\" title=\"jQuery自带的动画\"></a>jQuery自带的动画</h2><p>在jQuery中内置了一些动画，比如元素的隐藏与显示、淡入淡出、滑动等等。这些动画都是通过jQuery提供的方法来实现的。</p>\n<h3 id=\"1-隐藏与显示\"><a href=\"#1-隐藏与显示\" class=\"headerlink\" title=\"1. 隐藏与显示\"></a>1. 隐藏与显示</h3><p>语法：<br><code>$(selector).hide(speed,callback);</code>隐藏元素<br><code>$(selector).show(speed,callback);</code>显示元素<br><code>$(selector).toggle(speed,callback);</code>切换元素的显示与隐藏</p>\n<p>根据语法，我们不难看出，这两个方法都是通过选择器来选择元素，然后通过speed参数来设置动画的速度，最后通过callback参数来设置动画完成后的回调函数。</p>\n<p>代码演示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn1&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;p&quot;</span>).<span class=\"title function_\">hide</span>();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn2&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;p&quot;</span>).<span class=\"title function_\">show</span>();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面我们获取了两个按钮，第一个按钮控制元素的隐藏，第二个按钮控制元素的显示。</p>\n<h3 id=\"2-淡入淡出\"><a href=\"#2-淡入淡出\" class=\"headerlink\" title=\"2. 淡入淡出\"></a>2. 淡入淡出</h3><p>在jQuery中，有四种方法来实现淡入淡出的效果，分别是：</p>\n<ol>\n<li><code>fadeIn()</code>：淡入</li>\n<li><code>fadeOut()</code>：淡出</li>\n<li><code>fadeToggle()</code>：淡入淡出切换</li>\n<li><code>fadeTO()</code>：淡入淡出到指定的不透明度</li>\n</ol>\n<p>上面的前种方法都支持speed和callback两个参数，其中speed参数用来设置动画的速度，callback参数用来设置动画完成后的回调函数。</p>\n<p>其中第三种方法可以切换元素淡入淡出的效果，如果元素是隐藏的，那么就会淡入，如果元素是显示的，那么就会淡出。</p>\n<p><code>$(selector).fadeIn(speed,callback);</code><br><code>$(selector).fadeOut(speed,callback);</code><br><code>$(selector).fadeToggle(speed,callback);</code></p>\n<p>代码演示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn1&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div1&quot;</span>).<span class=\"title function_\">fadeIn</span>();</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div2&quot;</span>).<span class=\"title function_\">fadeIn</span>(<span class=\"string\">&quot;slow&quot;</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div3&quot;</span>).<span class=\"title function_\">fadeIn</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>第四种方法呢：参数与前面三种有点区别，它除了speed和callback两个参数外，还有一个参数：opacity，用来设置元素淡入淡出到指定的不透明度。</p>\n<p><code>$(selector).fadeTo(speed,opacity,callback);</code></p>\n<p>代码演示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn1&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div1&quot;</span>).<span class=\"title function_\">fadeTo</span>(<span class=\"string\">&quot;slow&quot;</span>,<span class=\"number\">0.15</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-滑动\"><a href=\"#3-滑动\" class=\"headerlink\" title=\"3. 滑动\"></a>3. 滑动</h3><p>在jQuery中，我们还可以通过其自带的方法实现滑动的效果。</p>\n<p>jQuery实现滑动的方法也有三种：</p>\n<ol>\n<li>slideDown()：向下滑动</li>\n<li>slideUP()：向上滑动</li>\n<li>slideToggle()：向上向下滑动切换</li>\n</ol>\n<p><code>$(selector).slideDown(speed,callback);</code><br><code>$(selector).slideUp(speed,callback);</code><br><code>$(selector).slideToggle(speed,callback);</code></p>\n<p>参数：</p>\n<p>在这三种方法中，speed和callback参数的含义与前面的方法是一样的。都是定义动画的速度有完成动画之后的回调函数.</p>\n<p>代码演示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn3&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div1&quot;</span>).<span class=\"title function_\">slideToggle</span>();</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div2&quot;</span>).<span class=\"title function_\">slideToggle</span>(<span class=\"string\">&quot;slow&quot;</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#div3&quot;</span>).<span class=\"title function_\">slideToggle</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们只展示了<code>slideToggle()</code>方法，其他两种方法的使用方法与<code>slideToggle()</code>方法是一样的。</p>\n"},{"title":"MARKDOWN基本语法","date":"2022-10-16T16:00:00.000Z","_content":"# MARKDOWN基本语法\n\n前几天我想朋友推荐了这个轻量级的标记语法，为了更好的帮助大家了解这个标记语言。我就出来写一篇文章来介绍一下这个标记语言。\n\n## 1. 标题\n\n首先写文章最重要的就是标题，有了标题人家才知道这段内容的大概。\n\n在Markdown中，你只需要在文本前面加上#来表示不同的标题，#的个数表示不同的标题级别，#和文本之间要有一个空格。\n\n就像这样：\n\n    # 一级标题\n    ## 二级标题\n    ### 三级标题\n\n依次类推，你可以写到六级标题。\n\n一般来说，我们一般只用到三级标题。因为如果标题层级太深的话，会导致这篇文章难以阅读。\n\n## 2. 加粗与斜体\n\n在Markdown中，你可以使用两个*或者_来表示加粗的内容，一个*或者_表示斜体的内容。\n\n就像这样：\n\n    **加粗**\n    *斜体*\n\n这文章的一些特殊地方，我们会将一些文字进行加粗或者倾斜，来表示强调或者引用\n\n## 3. 列表\n\n在html中有两种列表，一种是有序列表，一种是无序列表。  \n在MarkDown中同样也有这两种列表，只不过他们的语法不一样。\n\n### 无序列表\n\n无序列表使用*或者-来表示，*和-与后面内容之间要有一个空格。\n\n例如：\n\n    - 无序列表1\n    - 无序列表2\n\n### 有序列表\n\n有序列表使用数字加点来表示，点+数字与后面内容之间要有一个空格。\n\n例如：\n\n    1. 有序列表1\n    2. 有序列表2\n\n这两种列表的个数不限，你可以写无数个。\n\n## 4. 引用\n\n在Markdown中，你可以使用>来表示引用，>与引用内容之间要有一个空格。\n\n例如：\n\n    > 这是一个引用\n\n## 5. 链接\n\n在文章中，我们经常会用到链接，比如说我们要给大家推荐一些好的文章，我们就会给出文章的链接。\n\n在Markdown中，你可以使用[]()来表示链接，[]中是链接的文字，()中是链接的地址。\n\n例如：\n\n    [掘金社区](https://juejin.cn/)\n\n## 6. 图片\n\n好的文章配上相应的图片，可以更加吸引读者的注意。\n\n在Markdown中，你可以使用![]()来表示图片，![]中是图片的描述，()中是图片的地址。\n\n例如：\n\n    ![掘金社区](https://juejin.cn/)\n\n我们要与链接的区别开来，链接是[]()，图片是![]()。链接前面没有感叹号，图片前面有感叹号。\n\n## 7. 代码\n\n在Markdown中，你可以使用\\`\\`来表示代码，\\`\\`与代码之间要有一个空格。\n\n例如：\n\n    `这是一段代码`\n\n这样的方式只适合写一小段代码，当你需要书写大量代码时，你可以使用\\`\\`\\`来表示代码，\\`\\`\\`与代码之间要有一个空格。\n\n在\\`\\`\\`后面加上你代码的语言，可以让你的代码高亮显示。\n\n例如：\n\n    ```js\n    这是一段代码\n    这是一段代码\n    这是一段代码\n    ```\n\n## 8. 表格\n\n在文章中，表格也必不可少，我们可以使用表格来展示数据。\n\n在Markdown中，你可以使用|来表示表格，|与表格内容之间要有一个空格。\n\n第一行是表头，第二行是分割表头和内容的分割线，第三行开始是表格的内容。\n\n在表格第二行我们可以指定内容的对齐方式：\n\n- :---表示左对齐\n- ---:表示右对齐\n- :--:表示居中对齐\n\n**所有符号都要使用引文符号哦**\n\n例子：\n\n    | 表头   |   表头 |   表头   |\n    | :----- | -----: | :------: |\n    | 左对齐 | 右对齐 | 居中对齐 |\n    | 内容   |   内容 |   内容   |\n\n## 9. 分割线\n\n在Markdown中，你可以使用三个或者三个以上的*来表示分割线。\n\n例如：\n\n    ***\n    ---\n    *****\n    -----\n\n## 10. 删除线\n\n在Markdown中，你可以使用~~来表示删除线，~~与删除线内容之间要有一个空格。\n\n例如：\n    \n        ~~这是一段删除线~~\n\n删除线是一对，也就是四个波浪线。中间放的是内容。\n\n## 11. 脚注\n\n在Markdown中，你可以使用[^]来表示脚注，[^]与脚注内容之间要有一个空格。\n\n例如：\n\n    这是一个脚注[^1]\n    \n    [^1]: 这是脚注的内容\n\n脚注需要与内容搭配使用，否则不会显示。\n\n## 总结\n\n以上的内容就不差多足够大家日常写文章使用了，若是不够的话，可以去[Markdown官网](https://www.markdownguide.org/)查看更多的语法。","source":"_posts/MARKDOWN基本语法.md","raw":"---\ntitle: MARKDOWN基本语法\ndate: 2022-10-17\ntags: [前端]\ncategories: [随笔]\n---\n# MARKDOWN基本语法\n\n前几天我想朋友推荐了这个轻量级的标记语法，为了更好的帮助大家了解这个标记语言。我就出来写一篇文章来介绍一下这个标记语言。\n\n## 1. 标题\n\n首先写文章最重要的就是标题，有了标题人家才知道这段内容的大概。\n\n在Markdown中，你只需要在文本前面加上#来表示不同的标题，#的个数表示不同的标题级别，#和文本之间要有一个空格。\n\n就像这样：\n\n    # 一级标题\n    ## 二级标题\n    ### 三级标题\n\n依次类推，你可以写到六级标题。\n\n一般来说，我们一般只用到三级标题。因为如果标题层级太深的话，会导致这篇文章难以阅读。\n\n## 2. 加粗与斜体\n\n在Markdown中，你可以使用两个*或者_来表示加粗的内容，一个*或者_表示斜体的内容。\n\n就像这样：\n\n    **加粗**\n    *斜体*\n\n这文章的一些特殊地方，我们会将一些文字进行加粗或者倾斜，来表示强调或者引用\n\n## 3. 列表\n\n在html中有两种列表，一种是有序列表，一种是无序列表。  \n在MarkDown中同样也有这两种列表，只不过他们的语法不一样。\n\n### 无序列表\n\n无序列表使用*或者-来表示，*和-与后面内容之间要有一个空格。\n\n例如：\n\n    - 无序列表1\n    - 无序列表2\n\n### 有序列表\n\n有序列表使用数字加点来表示，点+数字与后面内容之间要有一个空格。\n\n例如：\n\n    1. 有序列表1\n    2. 有序列表2\n\n这两种列表的个数不限，你可以写无数个。\n\n## 4. 引用\n\n在Markdown中，你可以使用>来表示引用，>与引用内容之间要有一个空格。\n\n例如：\n\n    > 这是一个引用\n\n## 5. 链接\n\n在文章中，我们经常会用到链接，比如说我们要给大家推荐一些好的文章，我们就会给出文章的链接。\n\n在Markdown中，你可以使用[]()来表示链接，[]中是链接的文字，()中是链接的地址。\n\n例如：\n\n    [掘金社区](https://juejin.cn/)\n\n## 6. 图片\n\n好的文章配上相应的图片，可以更加吸引读者的注意。\n\n在Markdown中，你可以使用![]()来表示图片，![]中是图片的描述，()中是图片的地址。\n\n例如：\n\n    ![掘金社区](https://juejin.cn/)\n\n我们要与链接的区别开来，链接是[]()，图片是![]()。链接前面没有感叹号，图片前面有感叹号。\n\n## 7. 代码\n\n在Markdown中，你可以使用\\`\\`来表示代码，\\`\\`与代码之间要有一个空格。\n\n例如：\n\n    `这是一段代码`\n\n这样的方式只适合写一小段代码，当你需要书写大量代码时，你可以使用\\`\\`\\`来表示代码，\\`\\`\\`与代码之间要有一个空格。\n\n在\\`\\`\\`后面加上你代码的语言，可以让你的代码高亮显示。\n\n例如：\n\n    ```js\n    这是一段代码\n    这是一段代码\n    这是一段代码\n    ```\n\n## 8. 表格\n\n在文章中，表格也必不可少，我们可以使用表格来展示数据。\n\n在Markdown中，你可以使用|来表示表格，|与表格内容之间要有一个空格。\n\n第一行是表头，第二行是分割表头和内容的分割线，第三行开始是表格的内容。\n\n在表格第二行我们可以指定内容的对齐方式：\n\n- :---表示左对齐\n- ---:表示右对齐\n- :--:表示居中对齐\n\n**所有符号都要使用引文符号哦**\n\n例子：\n\n    | 表头   |   表头 |   表头   |\n    | :----- | -----: | :------: |\n    | 左对齐 | 右对齐 | 居中对齐 |\n    | 内容   |   内容 |   内容   |\n\n## 9. 分割线\n\n在Markdown中，你可以使用三个或者三个以上的*来表示分割线。\n\n例如：\n\n    ***\n    ---\n    *****\n    -----\n\n## 10. 删除线\n\n在Markdown中，你可以使用~~来表示删除线，~~与删除线内容之间要有一个空格。\n\n例如：\n    \n        ~~这是一段删除线~~\n\n删除线是一对，也就是四个波浪线。中间放的是内容。\n\n## 11. 脚注\n\n在Markdown中，你可以使用[^]来表示脚注，[^]与脚注内容之间要有一个空格。\n\n例如：\n\n    这是一个脚注[^1]\n    \n    [^1]: 这是脚注的内容\n\n脚注需要与内容搭配使用，否则不会显示。\n\n## 总结\n\n以上的内容就不差多足够大家日常写文章使用了，若是不够的话，可以去[Markdown官网](https://www.markdownguide.org/)查看更多的语法。","slug":"MARKDOWN基本语法","published":1,"updated":"2023-01-10T02:11:27.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgq000h9kbm554shub5","content":"<h1 id=\"MARKDOWN基本语法\"><a href=\"#MARKDOWN基本语法\" class=\"headerlink\" title=\"MARKDOWN基本语法\"></a>MARKDOWN基本语法</h1><p>前几天我想朋友推荐了这个轻量级的标记语法，为了更好的帮助大家了解这个标记语言。我就出来写一篇文章来介绍一下这个标记语言。</p>\n<h2 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1. 标题\"></a>1. 标题</h2><p>首先写文章最重要的就是标题，有了标题人家才知道这段内容的大概。</p>\n<p>在Markdown中，你只需要在文本前面加上#来表示不同的标题，#的个数表示不同的标题级别，#和文本之间要有一个空格。</p>\n<p>就像这样：</p>\n<pre><code># 一级标题\n## 二级标题\n### 三级标题\n</code></pre>\n<p>依次类推，你可以写到六级标题。</p>\n<p>一般来说，我们一般只用到三级标题。因为如果标题层级太深的话，会导致这篇文章难以阅读。</p>\n<h2 id=\"2-加粗与斜体\"><a href=\"#2-加粗与斜体\" class=\"headerlink\" title=\"2. 加粗与斜体\"></a>2. 加粗与斜体</h2><p>在Markdown中，你可以使用两个<em>或者_来表示加粗的内容，一个</em>或者_表示斜体的内容。</p>\n<p>就像这样：</p>\n<pre><code>**加粗**\n*斜体*\n</code></pre>\n<p>这文章的一些特殊地方，我们会将一些文字进行加粗或者倾斜，来表示强调或者引用</p>\n<h2 id=\"3-列表\"><a href=\"#3-列表\" class=\"headerlink\" title=\"3. 列表\"></a>3. 列表</h2><p>在html中有两种列表，一种是有序列表，一种是无序列表。<br>在MarkDown中同样也有这两种列表，只不过他们的语法不一样。</p>\n<h3 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h3><p>无序列表使用<em>或者-来表示，</em>和-与后面内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>- 无序列表1\n- 无序列表2\n</code></pre>\n<h3 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h3><p>有序列表使用数字加点来表示，点+数字与后面内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>1. 有序列表1\n2. 有序列表2\n</code></pre>\n<p>这两种列表的个数不限，你可以写无数个。</p>\n<h2 id=\"4-引用\"><a href=\"#4-引用\" class=\"headerlink\" title=\"4. 引用\"></a>4. 引用</h2><p>在Markdown中，你可以使用&gt;来表示引用，&gt;与引用内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>&gt; 这是一个引用\n</code></pre>\n<h2 id=\"5-链接\"><a href=\"#5-链接\" class=\"headerlink\" title=\"5. 链接\"></a>5. 链接</h2><p>在文章中，我们经常会用到链接，比如说我们要给大家推荐一些好的文章，我们就会给出文章的链接。</p>\n<p>在Markdown中，你可以使用<a href=\"\"></a>来表示链接，[]中是链接的文字，()中是链接的地址。</p>\n<p>例如：</p>\n<pre><code>[掘金社区](https://juejin.cn/)\n</code></pre>\n<h2 id=\"6-图片\"><a href=\"#6-图片\" class=\"headerlink\" title=\"6. 图片\"></a>6. 图片</h2><p>好的文章配上相应的图片，可以更加吸引读者的注意。</p>\n<p>在Markdown中，你可以使用<img src=\"/\">来表示图片，![]中是图片的描述，()中是图片的地址。</p>\n<p>例如：</p>\n<pre><code>![掘金社区](https://juejin.cn/)\n</code></pre>\n<p>我们要与链接的区别开来，链接是<a href=\"\"></a>，图片是<img src=\"/\">。链接前面没有感叹号，图片前面有感叹号。</p>\n<h2 id=\"7-代码\"><a href=\"#7-代码\" class=\"headerlink\" title=\"7. 代码\"></a>7. 代码</h2><p>在Markdown中，你可以使用``来表示代码，``与代码之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>`这是一段代码`\n</code></pre>\n<p>这样的方式只适合写一小段代码，当你需要书写大量代码时，你可以使用```来表示代码，```与代码之间要有一个空格。</p>\n<p>在```后面加上你代码的语言，可以让你的代码高亮显示。</p>\n<p>例如：</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一段代码</span><br><span class=\"line\">这是一段代码</span><br><span class=\"line\">这是一段代码</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2 id=\"8-表格\"><a href=\"#8-表格\" class=\"headerlink\" title=\"8. 表格\"></a>8. 表格</h2><p>在文章中，表格也必不可少，我们可以使用表格来展示数据。</p>\n<p>在Markdown中，你可以使用|来表示表格，|与表格内容之间要有一个空格。</p>\n<p>第一行是表头，第二行是分割表头和内容的分割线，第三行开始是表格的内容。</p>\n<p>在表格第二行我们可以指定内容的对齐方式：</p>\n<ul>\n<li>:—表示左对齐</li>\n<li>—:表示右对齐</li>\n<li>:–:表示居中对齐</li>\n</ul>\n<p><strong>所有符号都要使用引文符号哦</strong></p>\n<p>例子：</p>\n<pre><code>| 表头   |   表头 |   表头   |\n| :----- | -----: | :------: |\n| 左对齐 | 右对齐 | 居中对齐 |\n| 内容   |   内容 |   内容   |\n</code></pre>\n<h2 id=\"9-分割线\"><a href=\"#9-分割线\" class=\"headerlink\" title=\"9. 分割线\"></a>9. 分割线</h2><p>在Markdown中，你可以使用三个或者三个以上的*来表示分割线。</p>\n<p>例如：</p>\n<pre><code>***\n---\n*****\n-----\n</code></pre>\n<h2 id=\"10-删除线\"><a href=\"#10-删除线\" class=\"headerlink\" title=\"10. 删除线\"></a>10. 删除线</h2><p>在Markdown中，你可以使用<del>来表示删除线，</del>与删除线内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>    ~~这是一段删除线~~\n</code></pre>\n<p>删除线是一对，也就是四个波浪线。中间放的是内容。</p>\n<h2 id=\"11-脚注\"><a href=\"#11-脚注\" class=\"headerlink\" title=\"11. 脚注\"></a>11. 脚注</h2><p>在Markdown中，你可以使用[^]来表示脚注，[^]与脚注内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>这是一个脚注[^1]\n\n[^1]: 这是脚注的内容\n</code></pre>\n<p>脚注需要与内容搭配使用，否则不会显示。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上的内容就不差多足够大家日常写文章使用了，若是不够的话，可以去<a href=\"https://www.markdownguide.org/\">Markdown官网</a>查看更多的语法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MARKDOWN基本语法\"><a href=\"#MARKDOWN基本语法\" class=\"headerlink\" title=\"MARKDOWN基本语法\"></a>MARKDOWN基本语法</h1><p>前几天我想朋友推荐了这个轻量级的标记语法，为了更好的帮助大家了解这个标记语言。我就出来写一篇文章来介绍一下这个标记语言。</p>\n<h2 id=\"1-标题\"><a href=\"#1-标题\" class=\"headerlink\" title=\"1. 标题\"></a>1. 标题</h2><p>首先写文章最重要的就是标题，有了标题人家才知道这段内容的大概。</p>\n<p>在Markdown中，你只需要在文本前面加上#来表示不同的标题，#的个数表示不同的标题级别，#和文本之间要有一个空格。</p>\n<p>就像这样：</p>\n<pre><code># 一级标题\n## 二级标题\n### 三级标题\n</code></pre>\n<p>依次类推，你可以写到六级标题。</p>\n<p>一般来说，我们一般只用到三级标题。因为如果标题层级太深的话，会导致这篇文章难以阅读。</p>\n<h2 id=\"2-加粗与斜体\"><a href=\"#2-加粗与斜体\" class=\"headerlink\" title=\"2. 加粗与斜体\"></a>2. 加粗与斜体</h2><p>在Markdown中，你可以使用两个<em>或者_来表示加粗的内容，一个</em>或者_表示斜体的内容。</p>\n<p>就像这样：</p>\n<pre><code>**加粗**\n*斜体*\n</code></pre>\n<p>这文章的一些特殊地方，我们会将一些文字进行加粗或者倾斜，来表示强调或者引用</p>\n<h2 id=\"3-列表\"><a href=\"#3-列表\" class=\"headerlink\" title=\"3. 列表\"></a>3. 列表</h2><p>在html中有两种列表，一种是有序列表，一种是无序列表。<br>在MarkDown中同样也有这两种列表，只不过他们的语法不一样。</p>\n<h3 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h3><p>无序列表使用<em>或者-来表示，</em>和-与后面内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>- 无序列表1\n- 无序列表2\n</code></pre>\n<h3 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h3><p>有序列表使用数字加点来表示，点+数字与后面内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>1. 有序列表1\n2. 有序列表2\n</code></pre>\n<p>这两种列表的个数不限，你可以写无数个。</p>\n<h2 id=\"4-引用\"><a href=\"#4-引用\" class=\"headerlink\" title=\"4. 引用\"></a>4. 引用</h2><p>在Markdown中，你可以使用&gt;来表示引用，&gt;与引用内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>&gt; 这是一个引用\n</code></pre>\n<h2 id=\"5-链接\"><a href=\"#5-链接\" class=\"headerlink\" title=\"5. 链接\"></a>5. 链接</h2><p>在文章中，我们经常会用到链接，比如说我们要给大家推荐一些好的文章，我们就会给出文章的链接。</p>\n<p>在Markdown中，你可以使用<a href=\"\"></a>来表示链接，[]中是链接的文字，()中是链接的地址。</p>\n<p>例如：</p>\n<pre><code>[掘金社区](https://juejin.cn/)\n</code></pre>\n<h2 id=\"6-图片\"><a href=\"#6-图片\" class=\"headerlink\" title=\"6. 图片\"></a>6. 图片</h2><p>好的文章配上相应的图片，可以更加吸引读者的注意。</p>\n<p>在Markdown中，你可以使用<img src=\"/\">来表示图片，![]中是图片的描述，()中是图片的地址。</p>\n<p>例如：</p>\n<pre><code>![掘金社区](https://juejin.cn/)\n</code></pre>\n<p>我们要与链接的区别开来，链接是<a href=\"\"></a>，图片是<img src=\"/\">。链接前面没有感叹号，图片前面有感叹号。</p>\n<h2 id=\"7-代码\"><a href=\"#7-代码\" class=\"headerlink\" title=\"7. 代码\"></a>7. 代码</h2><p>在Markdown中，你可以使用``来表示代码，``与代码之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>`这是一段代码`\n</code></pre>\n<p>这样的方式只适合写一小段代码，当你需要书写大量代码时，你可以使用```来表示代码，```与代码之间要有一个空格。</p>\n<p>在```后面加上你代码的语言，可以让你的代码高亮显示。</p>\n<p>例如：</p>\n<pre><code><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一段代码</span><br><span class=\"line\">这是一段代码</span><br><span class=\"line\">这是一段代码</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h2 id=\"8-表格\"><a href=\"#8-表格\" class=\"headerlink\" title=\"8. 表格\"></a>8. 表格</h2><p>在文章中，表格也必不可少，我们可以使用表格来展示数据。</p>\n<p>在Markdown中，你可以使用|来表示表格，|与表格内容之间要有一个空格。</p>\n<p>第一行是表头，第二行是分割表头和内容的分割线，第三行开始是表格的内容。</p>\n<p>在表格第二行我们可以指定内容的对齐方式：</p>\n<ul>\n<li>:—表示左对齐</li>\n<li>—:表示右对齐</li>\n<li>:–:表示居中对齐</li>\n</ul>\n<p><strong>所有符号都要使用引文符号哦</strong></p>\n<p>例子：</p>\n<pre><code>| 表头   |   表头 |   表头   |\n| :----- | -----: | :------: |\n| 左对齐 | 右对齐 | 居中对齐 |\n| 内容   |   内容 |   内容   |\n</code></pre>\n<h2 id=\"9-分割线\"><a href=\"#9-分割线\" class=\"headerlink\" title=\"9. 分割线\"></a>9. 分割线</h2><p>在Markdown中，你可以使用三个或者三个以上的*来表示分割线。</p>\n<p>例如：</p>\n<pre><code>***\n---\n*****\n-----\n</code></pre>\n<h2 id=\"10-删除线\"><a href=\"#10-删除线\" class=\"headerlink\" title=\"10. 删除线\"></a>10. 删除线</h2><p>在Markdown中，你可以使用<del>来表示删除线，</del>与删除线内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>    ~~这是一段删除线~~\n</code></pre>\n<p>删除线是一对，也就是四个波浪线。中间放的是内容。</p>\n<h2 id=\"11-脚注\"><a href=\"#11-脚注\" class=\"headerlink\" title=\"11. 脚注\"></a>11. 脚注</h2><p>在Markdown中，你可以使用[^]来表示脚注，[^]与脚注内容之间要有一个空格。</p>\n<p>例如：</p>\n<pre><code>这是一个脚注[^1]\n\n[^1]: 这是脚注的内容\n</code></pre>\n<p>脚注需要与内容搭配使用，否则不会显示。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上的内容就不差多足够大家日常写文章使用了，若是不够的话，可以去<a href=\"https://www.markdownguide.org/\">Markdown官网</a>查看更多的语法。</p>\n"},{"title":"Vue中的列表循环","date":"2022-10-29T16:00:00.000Z","_content":"# Vue中的列表循环\n\n在电商项目的开发中，会用到这样一个问题：商品的陈列我们如果使用原生的js会显得十分臃肿。但是在Vue中，我们可以直接使用列表渲染来实现这样的效果。\n\n## 1. v-for\n\nv-for指令用于渲染一个列表，它接受一个数组或者对象，然后使用一个模板来渲染每个元素。\n\nv-for指令需要使用item in items的语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。\n\n在vue中，使用v-for指令不仅可以渲染数组，还可以渲染对象。当使用v-for渲染对象时，它会遍历对象的属性名。\n\n### 1.1 数组\n\n这里我们使用一个数组来渲染一个列表。\n\n```html\n<div id=\"app\">\n    <ul>\n        <li v-for=\"item in items\">{{item}}</li>\n    </ul>\n```\n\n在上面我们写了一个ul标签，然后使用v-for指令来渲染一个数组。这里我们使用了item in items的语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。\n\n```js\n    var vm = new Vue({\n        el: '#app',\n        data: {\n            items: [\n                11,22,33\n            ],\n        }\n    });\n```\n\n渲染结果：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8da912e898e4234b52b168a52b65dc9~tplv-k3u1fbpfcp-watermark.image?)\n\n当然在使用v-for来遍历数组的时候，还可以添加另外一个属性。这里我们使用index作为数组的索引。\n\n```html\n<div id=\"app\">\n    <ul>\n        <li v-for=\"(item,index) in items\">{{index}}:{{item}}</li>\n    </ul>\n```\n\n渲染结果：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d51089fd6c24e95b870a093b27f9416~tplv-k3u1fbpfcp-watermark.image?)\n\n**tips：**\n\n记得两个属性之间要添加逗号。\n\n### 1.2 对象\n\n前面我们看了数组的渲染，那么我们也可以使用v-for来渲染对象。\n\n```html\n<div id=\"app\">\n    <ul>\n        <li v-for=\"(value,key,index) in object\">{{index}}:{{key}}:{{value}}</li>\n    </ul>\n```\n\n```js\n    var vm = new Vue({\n        el:'#app',\n        data:{\n            obj:{\n                name:'张三',\n                age:18，\n            }\n        },\n    });\n```\n\n结果如下：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01bb9cf61aff4a759ff401c23d1026f3~tplv-k3u1fbpfcp-watermark.image?)\n\n在遍历对象的时候，我们这里填写了三个属性，分别是value,key,index。其中value是对象的值，key是对象的键，index是索引。\n\n通过结果也显而易见。\n\n## 2. v-for的key\n\n在使用v-for来渲染列表的时候，我们需要为每一个节点添加一个唯一的key属性。这样做的好处是可以提高渲染的效率。\n\n众所周知，在vue中有一个虚拟dom，通过虚拟dom可以极大的提高渲染的效率。当我们使用v-for来渲染一个列表的时候，vue会根据key来判断节点是否需要更新。如果key不变，那么vue会复用节点，如果key变了，那么vue会重新渲染节点。\n\n也就是说，如果我们需要给对象或者数组添加/删除元素，vue会先比较哪些元素变了，哪些元素没变。变了的元素，dom才会更新，没有发生改变的，dom就直接拿过来使用。这样就极大的提高了渲染的效率。","source":"_posts/Vue中的列表循环.md","raw":"---\ntitle: Vue中的列表循环\ndate: 2022-10-30\ntags: [前端]\ncategories: [Vue]\n---\n# Vue中的列表循环\n\n在电商项目的开发中，会用到这样一个问题：商品的陈列我们如果使用原生的js会显得十分臃肿。但是在Vue中，我们可以直接使用列表渲染来实现这样的效果。\n\n## 1. v-for\n\nv-for指令用于渲染一个列表，它接受一个数组或者对象，然后使用一个模板来渲染每个元素。\n\nv-for指令需要使用item in items的语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。\n\n在vue中，使用v-for指令不仅可以渲染数组，还可以渲染对象。当使用v-for渲染对象时，它会遍历对象的属性名。\n\n### 1.1 数组\n\n这里我们使用一个数组来渲染一个列表。\n\n```html\n<div id=\"app\">\n    <ul>\n        <li v-for=\"item in items\">{{item}}</li>\n    </ul>\n```\n\n在上面我们写了一个ul标签，然后使用v-for指令来渲染一个数组。这里我们使用了item in items的语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。\n\n```js\n    var vm = new Vue({\n        el: '#app',\n        data: {\n            items: [\n                11,22,33\n            ],\n        }\n    });\n```\n\n渲染结果：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8da912e898e4234b52b168a52b65dc9~tplv-k3u1fbpfcp-watermark.image?)\n\n当然在使用v-for来遍历数组的时候，还可以添加另外一个属性。这里我们使用index作为数组的索引。\n\n```html\n<div id=\"app\">\n    <ul>\n        <li v-for=\"(item,index) in items\">{{index}}:{{item}}</li>\n    </ul>\n```\n\n渲染结果：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d51089fd6c24e95b870a093b27f9416~tplv-k3u1fbpfcp-watermark.image?)\n\n**tips：**\n\n记得两个属性之间要添加逗号。\n\n### 1.2 对象\n\n前面我们看了数组的渲染，那么我们也可以使用v-for来渲染对象。\n\n```html\n<div id=\"app\">\n    <ul>\n        <li v-for=\"(value,key,index) in object\">{{index}}:{{key}}:{{value}}</li>\n    </ul>\n```\n\n```js\n    var vm = new Vue({\n        el:'#app',\n        data:{\n            obj:{\n                name:'张三',\n                age:18，\n            }\n        },\n    });\n```\n\n结果如下：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01bb9cf61aff4a759ff401c23d1026f3~tplv-k3u1fbpfcp-watermark.image?)\n\n在遍历对象的时候，我们这里填写了三个属性，分别是value,key,index。其中value是对象的值，key是对象的键，index是索引。\n\n通过结果也显而易见。\n\n## 2. v-for的key\n\n在使用v-for来渲染列表的时候，我们需要为每一个节点添加一个唯一的key属性。这样做的好处是可以提高渲染的效率。\n\n众所周知，在vue中有一个虚拟dom，通过虚拟dom可以极大的提高渲染的效率。当我们使用v-for来渲染一个列表的时候，vue会根据key来判断节点是否需要更新。如果key不变，那么vue会复用节点，如果key变了，那么vue会重新渲染节点。\n\n也就是说，如果我们需要给对象或者数组添加/删除元素，vue会先比较哪些元素变了，哪些元素没变。变了的元素，dom才会更新，没有发生改变的，dom就直接拿过来使用。这样就极大的提高了渲染的效率。","slug":"Vue中的列表循环","published":1,"updated":"2023-01-10T02:16:16.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgs000k9kbm7h5d2wsj","content":"<h1 id=\"Vue中的列表循环\"><a href=\"#Vue中的列表循环\" class=\"headerlink\" title=\"Vue中的列表循环\"></a>Vue中的列表循环</h1><p>在电商项目的开发中，会用到这样一个问题：商品的陈列我们如果使用原生的js会显得十分臃肿。但是在Vue中，我们可以直接使用列表渲染来实现这样的效果。</p>\n<h2 id=\"1-v-for\"><a href=\"#1-v-for\" class=\"headerlink\" title=\"1. v-for\"></a>1. v-for</h2><p>v-for指令用于渲染一个列表，它接受一个数组或者对象，然后使用一个模板来渲染每个元素。</p>\n<p>v-for指令需要使用item in items的语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。</p>\n<p>在vue中，使用v-for指令不仅可以渲染数组，还可以渲染对象。当使用v-for渲染对象时，它会遍历对象的属性名。</p>\n<h3 id=\"1-1-数组\"><a href=\"#1-1-数组\" class=\"headerlink\" title=\"1.1 数组\"></a>1.1 数组</h3><p>这里我们使用一个数组来渲染一个列表。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面我们写了一个ul标签，然后使用v-for指令来渲染一个数组。这里我们使用了item in items的语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">items</span>: [</span><br><span class=\"line\">            <span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>渲染结果：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8da912e898e4234b52b168a52b65dc9~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>当然在使用v-for来遍历数组的时候，还可以添加另外一个属性。这里我们使用index作为数组的索引。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(item,index) in items&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;:&#123;&#123;item&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>渲染结果：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d51089fd6c24e95b870a093b27f9416~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><strong>tips：</strong></p>\n<p>记得两个属性之间要添加逗号。</p>\n<h3 id=\"1-2-对象\"><a href=\"#1-2-对象\" class=\"headerlink\" title=\"1.2 对象\"></a>1.2 对象</h3><p>前面我们看了数组的渲染，那么我们也可以使用v-for来渲染对象。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(value,key,index) in object&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;:&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>:<span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">obj</span>:&#123;</span><br><span class=\"line\">            <span class=\"attr\">name</span>:<span class=\"string\">&#x27;张三&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">age</span>:<span class=\"number\">18</span>，</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01bb9cf61aff4a759ff401c23d1026f3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在遍历对象的时候，我们这里填写了三个属性，分别是value,key,index。其中value是对象的值，key是对象的键，index是索引。</p>\n<p>通过结果也显而易见。</p>\n<h2 id=\"2-v-for的key\"><a href=\"#2-v-for的key\" class=\"headerlink\" title=\"2. v-for的key\"></a>2. v-for的key</h2><p>在使用v-for来渲染列表的时候，我们需要为每一个节点添加一个唯一的key属性。这样做的好处是可以提高渲染的效率。</p>\n<p>众所周知，在vue中有一个虚拟dom，通过虚拟dom可以极大的提高渲染的效率。当我们使用v-for来渲染一个列表的时候，vue会根据key来判断节点是否需要更新。如果key不变，那么vue会复用节点，如果key变了，那么vue会重新渲染节点。</p>\n<p>也就是说，如果我们需要给对象或者数组添加&#x2F;删除元素，vue会先比较哪些元素变了，哪些元素没变。变了的元素，dom才会更新，没有发生改变的，dom就直接拿过来使用。这样就极大的提高了渲染的效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue中的列表循环\"><a href=\"#Vue中的列表循环\" class=\"headerlink\" title=\"Vue中的列表循环\"></a>Vue中的列表循环</h1><p>在电商项目的开发中，会用到这样一个问题：商品的陈列我们如果使用原生的js会显得十分臃肿。但是在Vue中，我们可以直接使用列表渲染来实现这样的效果。</p>\n<h2 id=\"1-v-for\"><a href=\"#1-v-for\" class=\"headerlink\" title=\"1. v-for\"></a>1. v-for</h2><p>v-for指令用于渲染一个列表，它接受一个数组或者对象，然后使用一个模板来渲染每个元素。</p>\n<p>v-for指令需要使用item in items的语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。</p>\n<p>在vue中，使用v-for指令不仅可以渲染数组，还可以渲染对象。当使用v-for渲染对象时，它会遍历对象的属性名。</p>\n<h3 id=\"1-1-数组\"><a href=\"#1-1-数组\" class=\"headerlink\" title=\"1.1 数组\"></a>1.1 数组</h3><p>这里我们使用一个数组来渲染一个列表。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面我们写了一个ul标签，然后使用v-for指令来渲染一个数组。这里我们使用了item in items的语法，其中items是源数据数组，而item则是被迭代的数组元素的别名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">items</span>: [</span><br><span class=\"line\">            <span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>渲染结果：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8da912e898e4234b52b168a52b65dc9~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>当然在使用v-for来遍历数组的时候，还可以添加另外一个属性。这里我们使用index作为数组的索引。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(item,index) in items&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;:&#123;&#123;item&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>渲染结果：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d51089fd6c24e95b870a093b27f9416~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><strong>tips：</strong></p>\n<p>记得两个属性之间要添加逗号。</p>\n<h3 id=\"1-2-对象\"><a href=\"#1-2-对象\" class=\"headerlink\" title=\"1.2 对象\"></a>1.2 对象</h3><p>前面我们看了数组的渲染，那么我们也可以使用v-for来渲染对象。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(value,key,index) in object&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;:&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>:<span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">obj</span>:&#123;</span><br><span class=\"line\">            <span class=\"attr\">name</span>:<span class=\"string\">&#x27;张三&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">age</span>:<span class=\"number\">18</span>，</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>结果如下：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01bb9cf61aff4a759ff401c23d1026f3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在遍历对象的时候，我们这里填写了三个属性，分别是value,key,index。其中value是对象的值，key是对象的键，index是索引。</p>\n<p>通过结果也显而易见。</p>\n<h2 id=\"2-v-for的key\"><a href=\"#2-v-for的key\" class=\"headerlink\" title=\"2. v-for的key\"></a>2. v-for的key</h2><p>在使用v-for来渲染列表的时候，我们需要为每一个节点添加一个唯一的key属性。这样做的好处是可以提高渲染的效率。</p>\n<p>众所周知，在vue中有一个虚拟dom，通过虚拟dom可以极大的提高渲染的效率。当我们使用v-for来渲染一个列表的时候，vue会根据key来判断节点是否需要更新。如果key不变，那么vue会复用节点，如果key变了，那么vue会重新渲染节点。</p>\n<p>也就是说，如果我们需要给对象或者数组添加&#x2F;删除元素，vue会先比较哪些元素变了，哪些元素没变。变了的元素，dom才会更新，没有发生改变的，dom就直接拿过来使用。这样就极大的提高了渲染的效率。</p>\n"},{"title":"Vue数据驱动","date":"2022-12-10T16:00:00.000Z","_content":"# Vue中数据驱动\n\n使用过Vue框架的小伙伴知道在Vue中有这么一个玩意：`v-model`。  \n这个玩意就用到了Vue中的数据驱动（数据双向绑定）。\n\n那么，什么是数据驱动呢？\n\n## 数据驱动解释\n\n数据驱动是vue.js最大的特点。在vue.js中，所谓的数据驱动就是当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的去修改dom。\n\n再通俗一点就是，你在这里改变了一下数据，在页面其他使用该数据的地方也会随之发生改变，而我们开发者只是在这里改变了一下数据，并没有直接操作`DOM`去改变其他地方的数据。\n\n那Vue是怎么实现的这一效果呢？\n\n## Vue数据驱动\n\n其实这个原理有点像那个中间人，举个例子吧，你的领导有一天改动一条通知（数据发生了改变）：今天不上班，然后被某个人听见了（监听），这个人就把领导的消息传递给下面的程序员，下面的程序员一听到这个消息，马上就准备收拾东西回家休息了（页面的元素随之改变）。\n\n大概就是下面这张图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62c2809f04a34ecc8a84df72cff3dcc7~tplv-k3u1fbpfcp-watermark.image?)\n\n那现在摆在我们面前的就有两个问题，这两个箭头是如何实现的呢？\n\n首先我们看看数据驱动是如何监听数据发生变化的？\n\n`Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。`\n\n这是vue文档里面的话，意思就是vue为`data`里面的属性（也就是我们的数据），都添加了`getter/setter`。这样就可以监听到数据的变化了。是不是还有有点蒙？没关系，其实就是利用`defineProperty`方法来实现监听的。\n\n### 简单说说`defineProperty`\n\n可能有小伙伴不太熟悉这个方法，我在这简单的提一下：\n\n- 语法：`Object.defineProperty(obj,property,descriptor)`\n\n- 参数：`obj` 绑定属性的目标对象\n\t\t`property` 绑定的属性名\n\t\t`descriptor` 属性描述（配置项）\n\t\t\n\n下面我列出一些常见的属性配置项：\n\n1. value:设置属性的默认值\n2. writable:设置属性是否可以被修改\n3. enumerable：设置属性是否可以被遍历\n4. configurable：设置属性是否可以被编辑（包括删除等等）\n5. get：获取属性值\n6. set：设置属性值\n\n其中`set`与`get`就是我们要用到的属性：\n\n举个例子：\n\n```js\nlet data = {\n\ta:1;\n};\nObject.defineProperty(data,a,{\n\tget:()=>{\n        console.log('获取数据啦');\n    },\n    set:(value)=>{\n        console.log('设置新数据啦',value);\n    }\n})\n```\n\n通过这个方法就可以实现vue中数据驱动对数据的监听，vue如何对视图进行更新呢？这就用到了vue中的虚拟DOM。我们下集聊聊这个Vue中的虚拟DOM。\n\n## 结尾\n\n感谢大家观看，本人小白，有不足之处还望各位大佬指正。","source":"_posts/Vue中数据驱动.md","raw":"---\ntitle: Vue数据驱动\ndate: 2022-12-11\ntags: [前端]\ncategories: [Vue]\n---\n# Vue中数据驱动\n\n使用过Vue框架的小伙伴知道在Vue中有这么一个玩意：`v-model`。  \n这个玩意就用到了Vue中的数据驱动（数据双向绑定）。\n\n那么，什么是数据驱动呢？\n\n## 数据驱动解释\n\n数据驱动是vue.js最大的特点。在vue.js中，所谓的数据驱动就是当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的去修改dom。\n\n再通俗一点就是，你在这里改变了一下数据，在页面其他使用该数据的地方也会随之发生改变，而我们开发者只是在这里改变了一下数据，并没有直接操作`DOM`去改变其他地方的数据。\n\n那Vue是怎么实现的这一效果呢？\n\n## Vue数据驱动\n\n其实这个原理有点像那个中间人，举个例子吧，你的领导有一天改动一条通知（数据发生了改变）：今天不上班，然后被某个人听见了（监听），这个人就把领导的消息传递给下面的程序员，下面的程序员一听到这个消息，马上就准备收拾东西回家休息了（页面的元素随之改变）。\n\n大概就是下面这张图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62c2809f04a34ecc8a84df72cff3dcc7~tplv-k3u1fbpfcp-watermark.image?)\n\n那现在摆在我们面前的就有两个问题，这两个箭头是如何实现的呢？\n\n首先我们看看数据驱动是如何监听数据发生变化的？\n\n`Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。`\n\n这是vue文档里面的话，意思就是vue为`data`里面的属性（也就是我们的数据），都添加了`getter/setter`。这样就可以监听到数据的变化了。是不是还有有点蒙？没关系，其实就是利用`defineProperty`方法来实现监听的。\n\n### 简单说说`defineProperty`\n\n可能有小伙伴不太熟悉这个方法，我在这简单的提一下：\n\n- 语法：`Object.defineProperty(obj,property,descriptor)`\n\n- 参数：`obj` 绑定属性的目标对象\n\t\t`property` 绑定的属性名\n\t\t`descriptor` 属性描述（配置项）\n\t\t\n\n下面我列出一些常见的属性配置项：\n\n1. value:设置属性的默认值\n2. writable:设置属性是否可以被修改\n3. enumerable：设置属性是否可以被遍历\n4. configurable：设置属性是否可以被编辑（包括删除等等）\n5. get：获取属性值\n6. set：设置属性值\n\n其中`set`与`get`就是我们要用到的属性：\n\n举个例子：\n\n```js\nlet data = {\n\ta:1;\n};\nObject.defineProperty(data,a,{\n\tget:()=>{\n        console.log('获取数据啦');\n    },\n    set:(value)=>{\n        console.log('设置新数据啦',value);\n    }\n})\n```\n\n通过这个方法就可以实现vue中数据驱动对数据的监听，vue如何对视图进行更新呢？这就用到了vue中的虚拟DOM。我们下集聊聊这个Vue中的虚拟DOM。\n\n## 结尾\n\n感谢大家观看，本人小白，有不足之处还望各位大佬指正。","slug":"Vue中数据驱动","published":1,"updated":"2023-01-10T02:17:33.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgw000o9kbm2dxg0x4v","content":"<h1 id=\"Vue中数据驱动\"><a href=\"#Vue中数据驱动\" class=\"headerlink\" title=\"Vue中数据驱动\"></a>Vue中数据驱动</h1><p>使用过Vue框架的小伙伴知道在Vue中有这么一个玩意：<code>v-model</code>。<br>这个玩意就用到了Vue中的数据驱动（数据双向绑定）。</p>\n<p>那么，什么是数据驱动呢？</p>\n<h2 id=\"数据驱动解释\"><a href=\"#数据驱动解释\" class=\"headerlink\" title=\"数据驱动解释\"></a>数据驱动解释</h2><p>数据驱动是vue.js最大的特点。在vue.js中，所谓的数据驱动就是当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的去修改dom。</p>\n<p>再通俗一点就是，你在这里改变了一下数据，在页面其他使用该数据的地方也会随之发生改变，而我们开发者只是在这里改变了一下数据，并没有直接操作<code>DOM</code>去改变其他地方的数据。</p>\n<p>那Vue是怎么实现的这一效果呢？</p>\n<h2 id=\"Vue数据驱动\"><a href=\"#Vue数据驱动\" class=\"headerlink\" title=\"Vue数据驱动\"></a>Vue数据驱动</h2><p>其实这个原理有点像那个中间人，举个例子吧，你的领导有一天改动一条通知（数据发生了改变）：今天不上班，然后被某个人听见了（监听），这个人就把领导的消息传递给下面的程序员，下面的程序员一听到这个消息，马上就准备收拾东西回家休息了（页面的元素随之改变）。</p>\n<p>大概就是下面这张图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62c2809f04a34ecc8a84df72cff3dcc7~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>那现在摆在我们面前的就有两个问题，这两个箭头是如何实现的呢？</p>\n<p>首先我们看看数据驱动是如何监听数据发生变化的？</p>\n<p><code>Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</code></p>\n<p>这是vue文档里面的话，意思就是vue为<code>data</code>里面的属性（也就是我们的数据），都添加了<code>getter/setter</code>。这样就可以监听到数据的变化了。是不是还有有点蒙？没关系，其实就是利用<code>defineProperty</code>方法来实现监听的。</p>\n<h3 id=\"简单说说defineProperty\"><a href=\"#简单说说defineProperty\" class=\"headerlink\" title=\"简单说说defineProperty\"></a>简单说说<code>defineProperty</code></h3><p>可能有小伙伴不太熟悉这个方法，我在这简单的提一下：</p>\n<ul>\n<li><p>语法：<code>Object.defineProperty(obj,property,descriptor)</code></p>\n</li>\n<li><p>参数：<code>obj</code> 绑定属性的目标对象<br>  <code>property</code> 绑定的属性名<br>  <code>descriptor</code> 属性描述（配置项）</p>\n</li>\n</ul>\n<p>下面我列出一些常见的属性配置项：</p>\n<ol>\n<li>value:设置属性的默认值</li>\n<li>writable:设置属性是否可以被修改</li>\n<li>enumerable：设置属性是否可以被遍历</li>\n<li>configurable：设置属性是否可以被编辑（包括删除等等）</li>\n<li>get：获取属性值</li>\n<li>set：设置属性值</li>\n</ol>\n<p>其中<code>set</code>与<code>get</code>就是我们要用到的属性：</p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">a</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data,a,&#123;</span><br><span class=\"line\">\t<span class=\"attr\">get</span>:<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;获取数据啦&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">set</span>:<span class=\"function\">(<span class=\"params\">value</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;设置新数据啦&#x27;</span>,value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>通过这个方法就可以实现vue中数据驱动对数据的监听，vue如何对视图进行更新呢？这就用到了vue中的虚拟DOM。我们下集聊聊这个Vue中的虚拟DOM。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>感谢大家观看，本人小白，有不足之处还望各位大佬指正。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue中数据驱动\"><a href=\"#Vue中数据驱动\" class=\"headerlink\" title=\"Vue中数据驱动\"></a>Vue中数据驱动</h1><p>使用过Vue框架的小伙伴知道在Vue中有这么一个玩意：<code>v-model</code>。<br>这个玩意就用到了Vue中的数据驱动（数据双向绑定）。</p>\n<p>那么，什么是数据驱动呢？</p>\n<h2 id=\"数据驱动解释\"><a href=\"#数据驱动解释\" class=\"headerlink\" title=\"数据驱动解释\"></a>数据驱动解释</h2><p>数据驱动是vue.js最大的特点。在vue.js中，所谓的数据驱动就是当数据发生变化的时候，用户界面发生相应的变化，开发者不需要手动的去修改dom。</p>\n<p>再通俗一点就是，你在这里改变了一下数据，在页面其他使用该数据的地方也会随之发生改变，而我们开发者只是在这里改变了一下数据，并没有直接操作<code>DOM</code>去改变其他地方的数据。</p>\n<p>那Vue是怎么实现的这一效果呢？</p>\n<h2 id=\"Vue数据驱动\"><a href=\"#Vue数据驱动\" class=\"headerlink\" title=\"Vue数据驱动\"></a>Vue数据驱动</h2><p>其实这个原理有点像那个中间人，举个例子吧，你的领导有一天改动一条通知（数据发生了改变）：今天不上班，然后被某个人听见了（监听），这个人就把领导的消息传递给下面的程序员，下面的程序员一听到这个消息，马上就准备收拾东西回家休息了（页面的元素随之改变）。</p>\n<p>大概就是下面这张图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62c2809f04a34ecc8a84df72cff3dcc7~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>那现在摆在我们面前的就有两个问题，这两个箭头是如何实现的呢？</p>\n<p>首先我们看看数据驱动是如何监听数据发生变化的？</p>\n<p><code>Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</code></p>\n<p>这是vue文档里面的话，意思就是vue为<code>data</code>里面的属性（也就是我们的数据），都添加了<code>getter/setter</code>。这样就可以监听到数据的变化了。是不是还有有点蒙？没关系，其实就是利用<code>defineProperty</code>方法来实现监听的。</p>\n<h3 id=\"简单说说defineProperty\"><a href=\"#简单说说defineProperty\" class=\"headerlink\" title=\"简单说说defineProperty\"></a>简单说说<code>defineProperty</code></h3><p>可能有小伙伴不太熟悉这个方法，我在这简单的提一下：</p>\n<ul>\n<li><p>语法：<code>Object.defineProperty(obj,property,descriptor)</code></p>\n</li>\n<li><p>参数：<code>obj</code> 绑定属性的目标对象<br>  <code>property</code> 绑定的属性名<br>  <code>descriptor</code> 属性描述（配置项）</p>\n</li>\n</ul>\n<p>下面我列出一些常见的属性配置项：</p>\n<ol>\n<li>value:设置属性的默认值</li>\n<li>writable:设置属性是否可以被修改</li>\n<li>enumerable：设置属性是否可以被遍历</li>\n<li>configurable：设置属性是否可以被编辑（包括删除等等）</li>\n<li>get：获取属性值</li>\n<li>set：设置属性值</li>\n</ol>\n<p>其中<code>set</code>与<code>get</code>就是我们要用到的属性：</p>\n<p>举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">a</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data,a,&#123;</span><br><span class=\"line\">\t<span class=\"attr\">get</span>:<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;获取数据啦&#x27;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">set</span>:<span class=\"function\">(<span class=\"params\">value</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;设置新数据啦&#x27;</span>,value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>通过这个方法就可以实现vue中数据驱动对数据的监听，vue如何对视图进行更新呢？这就用到了vue中的虚拟DOM。我们下集聊聊这个Vue中的虚拟DOM。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>感谢大家观看，本人小白，有不足之处还望各位大佬指正。</p>\n"},{"title":"CSS架构之OOCSS","data":["2023-2-18"],"_content":"# CSS架构之OOCSS\n\n在我们初学CSS的时候，我们通常都是一些简单的例子，比如给一个盒子设置一些样式，这个时候，我们经常会把所有的样式全部写在一起，但是随着后面进行了一些项目开发，我发一个问题，如果把每个盒子的样式写在一起，这样会使得CSS文件显得非常臃肿，并且有很多重复的代码，并且在后面进行修改的时候，我们需要一个一个手动的修改每一个盒子的属性。\n\n那么有没有一种很好的方法将这些重复的代码抽离出来呢？或者说，有没有一种规范指导我们将这些重复的代码按照一定规则抽离出来呢？这就是OOCSS的出现的原因。\n\n## 什么是OOCSS\n\nOOCSS代表\"面向对象的CSS\"，是一种编写可重用、可维护的CSS代码的方法论。它强调将样式规则分解为可重用的\"对象\"和\"组件\"，并将样式属性分解为可重用的\"片段\"。\n\nOOCSS方法的核心思想是将样式规则从特定的HTML元素和特定的上下文中抽象出来，以便在不同的元素和上下文中重用它们。通过这种方式，可以减少CSS代码的重复，并使样式更易于维护。\n\nOOCSS还强调使用高度模块化的CSS代码，其中每个模块都具有清晰的功能和界限，并且可以相互组合来创建更复杂的样式。\n\n总之，OOCSS是一种CSS编写的方法论，旨在提高CSS代码的可重用性、可维护性和可扩展性，使样式规则更加模块化和抽象化。\n\n## OOCSS的原则\n\nOOCSS的原则有以下几点：\n\n- 将结构和样式分离\n- 将容器和内容分离\n\n### 将结构和样式分离\n\n在html中，我们对于某种盒子我们会给他设置一些样式，比如盒子的宽度，高度，位置，背景颜色，边框等等，这些样式我们通常都会写在一起，这样会使得CSS文件显得非常臃肿，并且有很多重复的代码，并且在后面进行修改的时候，我们需要一个一个手动的修改每一个盒子的属性。\n\n在OOCSS中，我们将对于盒子的结构样式抽离出来，比如盒子的高度（height），宽度（width），位置（position）单独写在一个css类里面。这样我们在使用的时候，我们只需要在html中添加这个类就可以了，这样就可以减少我们的代码量，同时也可以使得我们的代码更加的简洁。在后面我们修改代码的时候，只需要修改这一个类里面的CSS代码就可以了。\n\n就像下面这样：\n\n```\n\n\n/* 重复的代码 */\n.box-border{\n    position : absolute;\n    border: 1px solid #CCC;\n    border-radius: 10px;\n}\n\n/* 不同的代码 */\n.box-1 {\n    width: 200px;\n    height: 200px;\n}\n\n.box-2 {\n    width: 120px;\n    height: 120px;\n}\n```\n\n这里的代码我们演示了结构上的代码分离，当然样式上的代码时一样的，还有就是最好将结构的CSS代码和样式的CSS代码分开写，这样会使得我们的代码更加的清晰。\n\n### 将容器和内容分离\n\n上面我们讲解了关于结构与样式的分离，现在我们讲解关于容器与内容的分离。\n\n这个原则的基本思想是将容器（即外层元素）的样式与容器中的内容（即内部元素）的样式分离。在OOCSS中，开发人员将定义适用于容器和内容的样式对象，这些样式对象包含了基本属性和通用样式。然后，开发人员将这些对象应用于容器和内容以实现容器与内容的分离。这种方法可以使容器和内容的样式更加灵活和易于修改，也能让样式更好的重用。\n\n同样我们下面举一个简单的例子：\n\n这里我们使用一个卡片组件：卡片组件通常由容器元素（例如 div 或 section）和内容元素（例如 h2、p 或 img）组成。在OOCSS中，开发人员会将适用于容器的样式和适用于内容的样式分别定义为不同的CSS类。例如：\n\n```\n<div class=\"card\">\n  <h2 class=\"card__title\">Card Title</h2>\n  <p class=\"card__text\">This is the text of the card.</p>\n  <img class=\"card__image\" src=\"image.jpg\" alt=\"Card Image\">\n</div>\n```\n\n在这个例子中，容器元素使用 .card 类，内容元素使用以 .card__ 开头的类，如 .card__title、.card__text 和 .card__image。\n\n## 总结\n\n### 优点\n\n- 可维护性：将样式规则分解为可重用的对象和组件，可以减少CSS代码的重复，使CSS更易于维护和扩展。\n\n- 可重用性：通过OOCSS方法，开发人员可以将样式规则分解为可重用的对象和组件，并在不同的元素和上下文中重用它们。这样可以减少代码的冗余，提高代码的可重用性。\n\n- 可扩展性：通过OOCSS方法，开发人员可以使用高度模块化的CSS代码，其中每个模块都具有清晰的功能和界限，并且可以相互组合来创建更复杂的样式。这样可以使样式更加灵活和易于扩展。\n\n- 代码可读性：通过OOCSS方法，开发人员可以将样式分解为对象和组件，使代码更加清晰、易读，并且能够更好地反映页面结构。\n\n- 可定制性：通过OOCSS方法，开发人员可以轻松地修改和定制CSS样式，而不必担心代码的影响范围和修改后的冲突。\n\n### 缺点\n\n要想熟练的使用OOCSS需要一定的学习成本。","source":"_posts/OOCSS.md","raw":"---\ntitle: CSS架构之OOCSS\ndata: [2023-2-18]\ntags: [前端]\ncategories: [CSS]\n---\n# CSS架构之OOCSS\n\n在我们初学CSS的时候，我们通常都是一些简单的例子，比如给一个盒子设置一些样式，这个时候，我们经常会把所有的样式全部写在一起，但是随着后面进行了一些项目开发，我发一个问题，如果把每个盒子的样式写在一起，这样会使得CSS文件显得非常臃肿，并且有很多重复的代码，并且在后面进行修改的时候，我们需要一个一个手动的修改每一个盒子的属性。\n\n那么有没有一种很好的方法将这些重复的代码抽离出来呢？或者说，有没有一种规范指导我们将这些重复的代码按照一定规则抽离出来呢？这就是OOCSS的出现的原因。\n\n## 什么是OOCSS\n\nOOCSS代表\"面向对象的CSS\"，是一种编写可重用、可维护的CSS代码的方法论。它强调将样式规则分解为可重用的\"对象\"和\"组件\"，并将样式属性分解为可重用的\"片段\"。\n\nOOCSS方法的核心思想是将样式规则从特定的HTML元素和特定的上下文中抽象出来，以便在不同的元素和上下文中重用它们。通过这种方式，可以减少CSS代码的重复，并使样式更易于维护。\n\nOOCSS还强调使用高度模块化的CSS代码，其中每个模块都具有清晰的功能和界限，并且可以相互组合来创建更复杂的样式。\n\n总之，OOCSS是一种CSS编写的方法论，旨在提高CSS代码的可重用性、可维护性和可扩展性，使样式规则更加模块化和抽象化。\n\n## OOCSS的原则\n\nOOCSS的原则有以下几点：\n\n- 将结构和样式分离\n- 将容器和内容分离\n\n### 将结构和样式分离\n\n在html中，我们对于某种盒子我们会给他设置一些样式，比如盒子的宽度，高度，位置，背景颜色，边框等等，这些样式我们通常都会写在一起，这样会使得CSS文件显得非常臃肿，并且有很多重复的代码，并且在后面进行修改的时候，我们需要一个一个手动的修改每一个盒子的属性。\n\n在OOCSS中，我们将对于盒子的结构样式抽离出来，比如盒子的高度（height），宽度（width），位置（position）单独写在一个css类里面。这样我们在使用的时候，我们只需要在html中添加这个类就可以了，这样就可以减少我们的代码量，同时也可以使得我们的代码更加的简洁。在后面我们修改代码的时候，只需要修改这一个类里面的CSS代码就可以了。\n\n就像下面这样：\n\n```\n\n\n/* 重复的代码 */\n.box-border{\n    position : absolute;\n    border: 1px solid #CCC;\n    border-radius: 10px;\n}\n\n/* 不同的代码 */\n.box-1 {\n    width: 200px;\n    height: 200px;\n}\n\n.box-2 {\n    width: 120px;\n    height: 120px;\n}\n```\n\n这里的代码我们演示了结构上的代码分离，当然样式上的代码时一样的，还有就是最好将结构的CSS代码和样式的CSS代码分开写，这样会使得我们的代码更加的清晰。\n\n### 将容器和内容分离\n\n上面我们讲解了关于结构与样式的分离，现在我们讲解关于容器与内容的分离。\n\n这个原则的基本思想是将容器（即外层元素）的样式与容器中的内容（即内部元素）的样式分离。在OOCSS中，开发人员将定义适用于容器和内容的样式对象，这些样式对象包含了基本属性和通用样式。然后，开发人员将这些对象应用于容器和内容以实现容器与内容的分离。这种方法可以使容器和内容的样式更加灵活和易于修改，也能让样式更好的重用。\n\n同样我们下面举一个简单的例子：\n\n这里我们使用一个卡片组件：卡片组件通常由容器元素（例如 div 或 section）和内容元素（例如 h2、p 或 img）组成。在OOCSS中，开发人员会将适用于容器的样式和适用于内容的样式分别定义为不同的CSS类。例如：\n\n```\n<div class=\"card\">\n  <h2 class=\"card__title\">Card Title</h2>\n  <p class=\"card__text\">This is the text of the card.</p>\n  <img class=\"card__image\" src=\"image.jpg\" alt=\"Card Image\">\n</div>\n```\n\n在这个例子中，容器元素使用 .card 类，内容元素使用以 .card__ 开头的类，如 .card__title、.card__text 和 .card__image。\n\n## 总结\n\n### 优点\n\n- 可维护性：将样式规则分解为可重用的对象和组件，可以减少CSS代码的重复，使CSS更易于维护和扩展。\n\n- 可重用性：通过OOCSS方法，开发人员可以将样式规则分解为可重用的对象和组件，并在不同的元素和上下文中重用它们。这样可以减少代码的冗余，提高代码的可重用性。\n\n- 可扩展性：通过OOCSS方法，开发人员可以使用高度模块化的CSS代码，其中每个模块都具有清晰的功能和界限，并且可以相互组合来创建更复杂的样式。这样可以使样式更加灵活和易于扩展。\n\n- 代码可读性：通过OOCSS方法，开发人员可以将样式分解为对象和组件，使代码更加清晰、易读，并且能够更好地反映页面结构。\n\n- 可定制性：通过OOCSS方法，开发人员可以轻松地修改和定制CSS样式，而不必担心代码的影响范围和修改后的冲突。\n\n### 缺点\n\n要想熟练的使用OOCSS需要一定的学习成本。","slug":"OOCSS","published":1,"date":"2023-02-18T15:13:29.625Z","updated":"2023-02-18T16:04:31.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmgx000r9kbm8ysn7cum","content":"<h1 id=\"CSS架构之OOCSS\"><a href=\"#CSS架构之OOCSS\" class=\"headerlink\" title=\"CSS架构之OOCSS\"></a>CSS架构之OOCSS</h1><p>在我们初学CSS的时候，我们通常都是一些简单的例子，比如给一个盒子设置一些样式，这个时候，我们经常会把所有的样式全部写在一起，但是随着后面进行了一些项目开发，我发一个问题，如果把每个盒子的样式写在一起，这样会使得CSS文件显得非常臃肿，并且有很多重复的代码，并且在后面进行修改的时候，我们需要一个一个手动的修改每一个盒子的属性。</p>\n<p>那么有没有一种很好的方法将这些重复的代码抽离出来呢？或者说，有没有一种规范指导我们将这些重复的代码按照一定规则抽离出来呢？这就是OOCSS的出现的原因。</p>\n<h2 id=\"什么是OOCSS\"><a href=\"#什么是OOCSS\" class=\"headerlink\" title=\"什么是OOCSS\"></a>什么是OOCSS</h2><p>OOCSS代表”面向对象的CSS”，是一种编写可重用、可维护的CSS代码的方法论。它强调将样式规则分解为可重用的”对象”和”组件”，并将样式属性分解为可重用的”片段”。</p>\n<p>OOCSS方法的核心思想是将样式规则从特定的HTML元素和特定的上下文中抽象出来，以便在不同的元素和上下文中重用它们。通过这种方式，可以减少CSS代码的重复，并使样式更易于维护。</p>\n<p>OOCSS还强调使用高度模块化的CSS代码，其中每个模块都具有清晰的功能和界限，并且可以相互组合来创建更复杂的样式。</p>\n<p>总之，OOCSS是一种CSS编写的方法论，旨在提高CSS代码的可重用性、可维护性和可扩展性，使样式规则更加模块化和抽象化。</p>\n<h2 id=\"OOCSS的原则\"><a href=\"#OOCSS的原则\" class=\"headerlink\" title=\"OOCSS的原则\"></a>OOCSS的原则</h2><p>OOCSS的原则有以下几点：</p>\n<ul>\n<li>将结构和样式分离</li>\n<li>将容器和内容分离</li>\n</ul>\n<h3 id=\"将结构和样式分离\"><a href=\"#将结构和样式分离\" class=\"headerlink\" title=\"将结构和样式分离\"></a>将结构和样式分离</h3><p>在html中，我们对于某种盒子我们会给他设置一些样式，比如盒子的宽度，高度，位置，背景颜色，边框等等，这些样式我们通常都会写在一起，这样会使得CSS文件显得非常臃肿，并且有很多重复的代码，并且在后面进行修改的时候，我们需要一个一个手动的修改每一个盒子的属性。</p>\n<p>在OOCSS中，我们将对于盒子的结构样式抽离出来，比如盒子的高度（height），宽度（width），位置（position）单独写在一个css类里面。这样我们在使用的时候，我们只需要在html中添加这个类就可以了，这样就可以减少我们的代码量，同时也可以使得我们的代码更加的简洁。在后面我们修改代码的时候，只需要修改这一个类里面的CSS代码就可以了。</p>\n<p>就像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/* 重复的代码 */</span><br><span class=\"line\">.box-border&#123;</span><br><span class=\"line\">    position : absolute;</span><br><span class=\"line\">    border: 1px solid #CCC;</span><br><span class=\"line\">    border-radius: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 不同的代码 */</span><br><span class=\"line\">.box-1 &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box-2 &#123;</span><br><span class=\"line\">    width: 120px;</span><br><span class=\"line\">    height: 120px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的代码我们演示了结构上的代码分离，当然样式上的代码时一样的，还有就是最好将结构的CSS代码和样式的CSS代码分开写，这样会使得我们的代码更加的清晰。</p>\n<h3 id=\"将容器和内容分离\"><a href=\"#将容器和内容分离\" class=\"headerlink\" title=\"将容器和内容分离\"></a>将容器和内容分离</h3><p>上面我们讲解了关于结构与样式的分离，现在我们讲解关于容器与内容的分离。</p>\n<p>这个原则的基本思想是将容器（即外层元素）的样式与容器中的内容（即内部元素）的样式分离。在OOCSS中，开发人员将定义适用于容器和内容的样式对象，这些样式对象包含了基本属性和通用样式。然后，开发人员将这些对象应用于容器和内容以实现容器与内容的分离。这种方法可以使容器和内容的样式更加灵活和易于修改，也能让样式更好的重用。</p>\n<p>同样我们下面举一个简单的例子：</p>\n<p>这里我们使用一个卡片组件：卡片组件通常由容器元素（例如 div 或 section）和内容元素（例如 h2、p 或 img）组成。在OOCSS中，开发人员会将适用于容器的样式和适用于内容的样式分别定义为不同的CSS类。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">  &lt;h2 class=&quot;card__title&quot;&gt;Card Title&lt;/h2&gt;</span><br><span class=\"line\">  &lt;p class=&quot;card__text&quot;&gt;This is the text of the card.&lt;/p&gt;</span><br><span class=\"line\">  &lt;img class=&quot;card__image&quot; src=&quot;image.jpg&quot; alt=&quot;Card Image&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，容器元素使用 .card 类，内容元素使用以 .card__ 开头的类，如 .card__title、.card__text 和 .card__image。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li><p>可维护性：将样式规则分解为可重用的对象和组件，可以减少CSS代码的重复，使CSS更易于维护和扩展。</p>\n</li>\n<li><p>可重用性：通过OOCSS方法，开发人员可以将样式规则分解为可重用的对象和组件，并在不同的元素和上下文中重用它们。这样可以减少代码的冗余，提高代码的可重用性。</p>\n</li>\n<li><p>可扩展性：通过OOCSS方法，开发人员可以使用高度模块化的CSS代码，其中每个模块都具有清晰的功能和界限，并且可以相互组合来创建更复杂的样式。这样可以使样式更加灵活和易于扩展。</p>\n</li>\n<li><p>代码可读性：通过OOCSS方法，开发人员可以将样式分解为对象和组件，使代码更加清晰、易读，并且能够更好地反映页面结构。</p>\n</li>\n<li><p>可定制性：通过OOCSS方法，开发人员可以轻松地修改和定制CSS样式，而不必担心代码的影响范围和修改后的冲突。</p>\n</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>要想熟练的使用OOCSS需要一定的学习成本。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS架构之OOCSS\"><a href=\"#CSS架构之OOCSS\" class=\"headerlink\" title=\"CSS架构之OOCSS\"></a>CSS架构之OOCSS</h1><p>在我们初学CSS的时候，我们通常都是一些简单的例子，比如给一个盒子设置一些样式，这个时候，我们经常会把所有的样式全部写在一起，但是随着后面进行了一些项目开发，我发一个问题，如果把每个盒子的样式写在一起，这样会使得CSS文件显得非常臃肿，并且有很多重复的代码，并且在后面进行修改的时候，我们需要一个一个手动的修改每一个盒子的属性。</p>\n<p>那么有没有一种很好的方法将这些重复的代码抽离出来呢？或者说，有没有一种规范指导我们将这些重复的代码按照一定规则抽离出来呢？这就是OOCSS的出现的原因。</p>\n<h2 id=\"什么是OOCSS\"><a href=\"#什么是OOCSS\" class=\"headerlink\" title=\"什么是OOCSS\"></a>什么是OOCSS</h2><p>OOCSS代表”面向对象的CSS”，是一种编写可重用、可维护的CSS代码的方法论。它强调将样式规则分解为可重用的”对象”和”组件”，并将样式属性分解为可重用的”片段”。</p>\n<p>OOCSS方法的核心思想是将样式规则从特定的HTML元素和特定的上下文中抽象出来，以便在不同的元素和上下文中重用它们。通过这种方式，可以减少CSS代码的重复，并使样式更易于维护。</p>\n<p>OOCSS还强调使用高度模块化的CSS代码，其中每个模块都具有清晰的功能和界限，并且可以相互组合来创建更复杂的样式。</p>\n<p>总之，OOCSS是一种CSS编写的方法论，旨在提高CSS代码的可重用性、可维护性和可扩展性，使样式规则更加模块化和抽象化。</p>\n<h2 id=\"OOCSS的原则\"><a href=\"#OOCSS的原则\" class=\"headerlink\" title=\"OOCSS的原则\"></a>OOCSS的原则</h2><p>OOCSS的原则有以下几点：</p>\n<ul>\n<li>将结构和样式分离</li>\n<li>将容器和内容分离</li>\n</ul>\n<h3 id=\"将结构和样式分离\"><a href=\"#将结构和样式分离\" class=\"headerlink\" title=\"将结构和样式分离\"></a>将结构和样式分离</h3><p>在html中，我们对于某种盒子我们会给他设置一些样式，比如盒子的宽度，高度，位置，背景颜色，边框等等，这些样式我们通常都会写在一起，这样会使得CSS文件显得非常臃肿，并且有很多重复的代码，并且在后面进行修改的时候，我们需要一个一个手动的修改每一个盒子的属性。</p>\n<p>在OOCSS中，我们将对于盒子的结构样式抽离出来，比如盒子的高度（height），宽度（width），位置（position）单独写在一个css类里面。这样我们在使用的时候，我们只需要在html中添加这个类就可以了，这样就可以减少我们的代码量，同时也可以使得我们的代码更加的简洁。在后面我们修改代码的时候，只需要修改这一个类里面的CSS代码就可以了。</p>\n<p>就像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/* 重复的代码 */</span><br><span class=\"line\">.box-border&#123;</span><br><span class=\"line\">    position : absolute;</span><br><span class=\"line\">    border: 1px solid #CCC;</span><br><span class=\"line\">    border-radius: 10px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 不同的代码 */</span><br><span class=\"line\">.box-1 &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.box-2 &#123;</span><br><span class=\"line\">    width: 120px;</span><br><span class=\"line\">    height: 120px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的代码我们演示了结构上的代码分离，当然样式上的代码时一样的，还有就是最好将结构的CSS代码和样式的CSS代码分开写，这样会使得我们的代码更加的清晰。</p>\n<h3 id=\"将容器和内容分离\"><a href=\"#将容器和内容分离\" class=\"headerlink\" title=\"将容器和内容分离\"></a>将容器和内容分离</h3><p>上面我们讲解了关于结构与样式的分离，现在我们讲解关于容器与内容的分离。</p>\n<p>这个原则的基本思想是将容器（即外层元素）的样式与容器中的内容（即内部元素）的样式分离。在OOCSS中，开发人员将定义适用于容器和内容的样式对象，这些样式对象包含了基本属性和通用样式。然后，开发人员将这些对象应用于容器和内容以实现容器与内容的分离。这种方法可以使容器和内容的样式更加灵活和易于修改，也能让样式更好的重用。</p>\n<p>同样我们下面举一个简单的例子：</p>\n<p>这里我们使用一个卡片组件：卡片组件通常由容器元素（例如 div 或 section）和内容元素（例如 h2、p 或 img）组成。在OOCSS中，开发人员会将适用于容器的样式和适用于内容的样式分别定义为不同的CSS类。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;card&quot;&gt;</span><br><span class=\"line\">  &lt;h2 class=&quot;card__title&quot;&gt;Card Title&lt;/h2&gt;</span><br><span class=\"line\">  &lt;p class=&quot;card__text&quot;&gt;This is the text of the card.&lt;/p&gt;</span><br><span class=\"line\">  &lt;img class=&quot;card__image&quot; src=&quot;image.jpg&quot; alt=&quot;Card Image&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，容器元素使用 .card 类，内容元素使用以 .card__ 开头的类，如 .card__title、.card__text 和 .card__image。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li><p>可维护性：将样式规则分解为可重用的对象和组件，可以减少CSS代码的重复，使CSS更易于维护和扩展。</p>\n</li>\n<li><p>可重用性：通过OOCSS方法，开发人员可以将样式规则分解为可重用的对象和组件，并在不同的元素和上下文中重用它们。这样可以减少代码的冗余，提高代码的可重用性。</p>\n</li>\n<li><p>可扩展性：通过OOCSS方法，开发人员可以使用高度模块化的CSS代码，其中每个模块都具有清晰的功能和界限，并且可以相互组合来创建更复杂的样式。这样可以使样式更加灵活和易于扩展。</p>\n</li>\n<li><p>代码可读性：通过OOCSS方法，开发人员可以将样式分解为对象和组件，使代码更加清晰、易读，并且能够更好地反映页面结构。</p>\n</li>\n<li><p>可定制性：通过OOCSS方法，开发人员可以轻松地修改和定制CSS样式，而不必担心代码的影响范围和修改后的冲突。</p>\n</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>要想熟练的使用OOCSS需要一定的学习成本。</p>\n"},{"title":"CSS实现一个简答的加载动画","date":"2022-10-26T16:00:00.000Z","_content":"# css实现一个简单的加载动画\n\n在网页的页面中，我们有时候需要等待服务器返回数据给我们，我们再将其渲染到页面上。\n\n但是服务器返回数据给我们的时候，这个是有延迟的；为了让用户得到更好的使用体验。我们需要在用户等待这段时间给用户一个加载动画。\n\n今天我们要实现的是一个圆圈旋转加载效果。\n\n**效果图**：\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146696d099ba4c2383c5ea1615861016~tplv-k3u1fbpfcp-watermark.image?)\n\n## HTML框架\n\n既然有一个圆圈，那么必定就会有一个盒子。  \n但是圆圈不能是全封闭的，得留一个缺口出来，那么这个缺口怎么实现呢？\n\n我们这里的解决方法就是设置一个盒子，覆盖在圆圈的上面，背景颜色与圆圈里面的背景颜色一样。\n\n话不多说，上代码：\n\n```html\n    <div class = \"border\"> // 外部圆圈\n        <div class = \"box\"></div> // 遮住圆圈的盒子\n    </div>\n```\n\n## 加载动画的圆圈\n\n圆圈我们可以通过边框来实现。首先给边框设置一下：边框厚度，边框样式，边框颜色。\n\n然后给边框设置一个`border-radius`属性。\n\n```css\n    .border{\n        box-sizing:border-box;\n        width:50px;\n        height:50px;\n        border:5px solid #0ff;\n        border-radius:50%;\n    }\n```\n我们这里使用`border-box`盒模型，主要是防止边框的问题将这个盒子撑大。\n\n因为我们要通过圆角边框来实现圆圈。所以我们首先将`.border`盒子设置相同的宽高，使之成为一个正方形；然后通过`border-radius`属性设置为50%。  \n圆圈就出来了。\n\n为了使这个加载动画更加美观，我们使用定位将其放到页面中央：\n\n```css\n.border{\n    position: absolute;\n    top: 50%;\n    margin-top: -50px;\n    left: 50%;\n    margin-left: -50px; \n}\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54478ba8ee4945239063586e2be6a90b~tplv-k3u1fbpfcp-watermark.image?)\n\n## 圆圈的缺口\n\n在上面的效果图里面，加载动画圆圈是由一个缺口的，我们在这里使用一个同背景色的盒子来遮住圆圈实现。\n\n```css\n.border>.box {\n    position: relative;\n    top: 50%;\n    left: 50%;\n    width: 25px;\n    height: 25px;\n    background-color: inherit;\n}\n```\n\n我们还需要将这个用于遮罩的盒子，移动到圆圈的旁边，所以我们使用到了绝对定位。  \n在背景颜色上面，我们选择继承父盒子的颜色。\n\n为了尽量不影响其他元素。我们将这个遮罩的宽高设置为圆圈直径的（父盒子宽高）一半。\n\n最后出现的效果就是这样：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6d97fcb9ea49118d2c5ea04e95c014~tplv-k3u1fbpfcp-watermark.image?)\n\n接下来就是添加动画让圆圈动起来：\n\n## 动画设置\n\n为了让这个加载动画看起来更加丝滑，我们不设置用百分比的方式来设置，使用`from to`的方式来设置动画。\n\n然后我们还要设置动画旋转的中心点，默认的中心点是盒子的左上角，但这不是我们想要的效果，我们希望从盒子中心旋转。于是我们使用`transform-origin: center center;`的方式将旋转中心设置为盒子中央。\n\n```css\n    @keyframe rotate{\n        from{\n            transform-origin: center center;\n            transform: rotate(0deg);\n        }\n        to{\n            transform-origin: center center;\n                transform: rotate(360deg);\n        }\n    }\n```\n\n我们这里就把加载动画设置完毕了，我么将这个动画加在`.border`的盒子上。\n\n```css\n    .border{\n        animation: rotate 1s linear infinite;\n    }\n```\n\n最后的效果展示：\n\n![动画1.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f826fdec7974092906cf5b7aa55b087~tplv-k3u1fbpfcp-watermark.image?)","source":"_posts/css实现一个简单的加载动画.md","raw":"---\ntitle: CSS实现一个简答的加载动画\ndate: 2022-10-27\ntags: [前端]\ncategories: [css,html]\n---\n# css实现一个简单的加载动画\n\n在网页的页面中，我们有时候需要等待服务器返回数据给我们，我们再将其渲染到页面上。\n\n但是服务器返回数据给我们的时候，这个是有延迟的；为了让用户得到更好的使用体验。我们需要在用户等待这段时间给用户一个加载动画。\n\n今天我们要实现的是一个圆圈旋转加载效果。\n\n**效果图**：\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146696d099ba4c2383c5ea1615861016~tplv-k3u1fbpfcp-watermark.image?)\n\n## HTML框架\n\n既然有一个圆圈，那么必定就会有一个盒子。  \n但是圆圈不能是全封闭的，得留一个缺口出来，那么这个缺口怎么实现呢？\n\n我们这里的解决方法就是设置一个盒子，覆盖在圆圈的上面，背景颜色与圆圈里面的背景颜色一样。\n\n话不多说，上代码：\n\n```html\n    <div class = \"border\"> // 外部圆圈\n        <div class = \"box\"></div> // 遮住圆圈的盒子\n    </div>\n```\n\n## 加载动画的圆圈\n\n圆圈我们可以通过边框来实现。首先给边框设置一下：边框厚度，边框样式，边框颜色。\n\n然后给边框设置一个`border-radius`属性。\n\n```css\n    .border{\n        box-sizing:border-box;\n        width:50px;\n        height:50px;\n        border:5px solid #0ff;\n        border-radius:50%;\n    }\n```\n我们这里使用`border-box`盒模型，主要是防止边框的问题将这个盒子撑大。\n\n因为我们要通过圆角边框来实现圆圈。所以我们首先将`.border`盒子设置相同的宽高，使之成为一个正方形；然后通过`border-radius`属性设置为50%。  \n圆圈就出来了。\n\n为了使这个加载动画更加美观，我们使用定位将其放到页面中央：\n\n```css\n.border{\n    position: absolute;\n    top: 50%;\n    margin-top: -50px;\n    left: 50%;\n    margin-left: -50px; \n}\n```\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54478ba8ee4945239063586e2be6a90b~tplv-k3u1fbpfcp-watermark.image?)\n\n## 圆圈的缺口\n\n在上面的效果图里面，加载动画圆圈是由一个缺口的，我们在这里使用一个同背景色的盒子来遮住圆圈实现。\n\n```css\n.border>.box {\n    position: relative;\n    top: 50%;\n    left: 50%;\n    width: 25px;\n    height: 25px;\n    background-color: inherit;\n}\n```\n\n我们还需要将这个用于遮罩的盒子，移动到圆圈的旁边，所以我们使用到了绝对定位。  \n在背景颜色上面，我们选择继承父盒子的颜色。\n\n为了尽量不影响其他元素。我们将这个遮罩的宽高设置为圆圈直径的（父盒子宽高）一半。\n\n最后出现的效果就是这样：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6d97fcb9ea49118d2c5ea04e95c014~tplv-k3u1fbpfcp-watermark.image?)\n\n接下来就是添加动画让圆圈动起来：\n\n## 动画设置\n\n为了让这个加载动画看起来更加丝滑，我们不设置用百分比的方式来设置，使用`from to`的方式来设置动画。\n\n然后我们还要设置动画旋转的中心点，默认的中心点是盒子的左上角，但这不是我们想要的效果，我们希望从盒子中心旋转。于是我们使用`transform-origin: center center;`的方式将旋转中心设置为盒子中央。\n\n```css\n    @keyframe rotate{\n        from{\n            transform-origin: center center;\n            transform: rotate(0deg);\n        }\n        to{\n            transform-origin: center center;\n                transform: rotate(360deg);\n        }\n    }\n```\n\n我们这里就把加载动画设置完毕了，我么将这个动画加在`.border`的盒子上。\n\n```css\n    .border{\n        animation: rotate 1s linear infinite;\n    }\n```\n\n最后的效果展示：\n\n![动画1.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f826fdec7974092906cf5b7aa55b087~tplv-k3u1fbpfcp-watermark.image?)","slug":"css实现一个简单的加载动画","published":1,"updated":"2023-01-09T12:02:11.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmh3000v9kbmbzw82bmi","content":"<h1 id=\"css实现一个简单的加载动画\"><a href=\"#css实现一个简单的加载动画\" class=\"headerlink\" title=\"css实现一个简单的加载动画\"></a>css实现一个简单的加载动画</h1><p>在网页的页面中，我们有时候需要等待服务器返回数据给我们，我们再将其渲染到页面上。</p>\n<p>但是服务器返回数据给我们的时候，这个是有延迟的；为了让用户得到更好的使用体验。我们需要在用户等待这段时间给用户一个加载动画。</p>\n<p>今天我们要实现的是一个圆圈旋转加载效果。</p>\n<p><strong>效果图</strong>：<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146696d099ba4c2383c5ea1615861016~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2 id=\"HTML框架\"><a href=\"#HTML框架\" class=\"headerlink\" title=\"HTML框架\"></a>HTML框架</h2><p>既然有一个圆圈，那么必定就会有一个盒子。<br>但是圆圈不能是全封闭的，得留一个缺口出来，那么这个缺口怎么实现呢？</p>\n<p>我们这里的解决方法就是设置一个盒子，覆盖在圆圈的上面，背景颜色与圆圈里面的背景颜色一样。</p>\n<p>话不多说，上代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> = <span class=\"string\">&quot;border&quot;</span>&gt;</span> // 外部圆圈</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> = <span class=\"string\">&quot;box&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> // 遮住圆圈的盒子</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"加载动画的圆圈\"><a href=\"#加载动画的圆圈\" class=\"headerlink\" title=\"加载动画的圆圈\"></a>加载动画的圆圈</h2><p>圆圈我们可以通过边框来实现。首先给边框设置一下：边框厚度，边框样式，边框颜色。</p>\n<p>然后给边框设置一个<code>border-radius</code>属性。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>:border-box;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">5px</span> solid <span class=\"number\">#0ff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们这里使用<code>border-box</code>盒模型，主要是防止边框的问题将这个盒子撑大。</p>\n<p>因为我们要通过圆角边框来实现圆圈。所以我们首先将<code>.border</code>盒子设置相同的宽高，使之成为一个正方形；然后通过<code>border-radius</code>属性设置为50%。<br>圆圈就出来了。</p>\n<p>为了使这个加载动画更加美观，我们使用定位将其放到页面中央：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">50px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54478ba8ee4945239063586e2be6a90b~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2 id=\"圆圈的缺口\"><a href=\"#圆圈的缺口\" class=\"headerlink\" title=\"圆圈的缺口\"></a>圆圈的缺口</h2><p>在上面的效果图里面，加载动画圆圈是由一个缺口的，我们在这里使用一个同背景色的盒子来遮住圆圈实现。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span>&gt;<span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">25px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">25px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们还需要将这个用于遮罩的盒子，移动到圆圈的旁边，所以我们使用到了绝对定位。<br>在背景颜色上面，我们选择继承父盒子的颜色。</p>\n<p>为了尽量不影响其他元素。我们将这个遮罩的宽高设置为圆圈直径的（父盒子宽高）一半。</p>\n<p>最后出现的效果就是这样：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6d97fcb9ea49118d2c5ea04e95c014~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>接下来就是添加动画让圆圈动起来：</p>\n<h2 id=\"动画设置\"><a href=\"#动画设置\" class=\"headerlink\" title=\"动画设置\"></a>动画设置</h2><p>为了让这个加载动画看起来更加丝滑，我们不设置用百分比的方式来设置，使用<code>from to</code>的方式来设置动画。</p>\n<p>然后我们还要设置动画旋转的中心点，默认的中心点是盒子的左上角，但这不是我们想要的效果，我们希望从盒子中心旋转。于是我们使用<code>transform-origin: center center;</code>的方式将旋转中心设置为盒子中央。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframe</span> rotate&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform-origin</span>: center center;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">0deg</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform-origin</span>: center center;</span><br><span class=\"line\">            <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里就把加载动画设置完毕了，我么将这个动画加在<code>.border</code>的盒子上。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: rotate <span class=\"number\">1s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后的效果展示：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f826fdec7974092906cf5b7aa55b087~tplv-k3u1fbpfcp-watermark.image\" alt=\"动画1.gif\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"css实现一个简单的加载动画\"><a href=\"#css实现一个简单的加载动画\" class=\"headerlink\" title=\"css实现一个简单的加载动画\"></a>css实现一个简单的加载动画</h1><p>在网页的页面中，我们有时候需要等待服务器返回数据给我们，我们再将其渲染到页面上。</p>\n<p>但是服务器返回数据给我们的时候，这个是有延迟的；为了让用户得到更好的使用体验。我们需要在用户等待这段时间给用户一个加载动画。</p>\n<p>今天我们要实现的是一个圆圈旋转加载效果。</p>\n<p><strong>效果图</strong>：<br><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146696d099ba4c2383c5ea1615861016~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2 id=\"HTML框架\"><a href=\"#HTML框架\" class=\"headerlink\" title=\"HTML框架\"></a>HTML框架</h2><p>既然有一个圆圈，那么必定就会有一个盒子。<br>但是圆圈不能是全封闭的，得留一个缺口出来，那么这个缺口怎么实现呢？</p>\n<p>我们这里的解决方法就是设置一个盒子，覆盖在圆圈的上面，背景颜色与圆圈里面的背景颜色一样。</p>\n<p>话不多说，上代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> = <span class=\"string\">&quot;border&quot;</span>&gt;</span> // 外部圆圈</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> = <span class=\"string\">&quot;box&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> // 遮住圆圈的盒子</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"加载动画的圆圈\"><a href=\"#加载动画的圆圈\" class=\"headerlink\" title=\"加载动画的圆圈\"></a>加载动画的圆圈</h2><p>圆圈我们可以通过边框来实现。首先给边框设置一下：边框厚度，边框样式，边框颜色。</p>\n<p>然后给边框设置一个<code>border-radius</code>属性。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>:border-box;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>:<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:<span class=\"number\">5px</span> solid <span class=\"number\">#0ff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们这里使用<code>border-box</code>盒模型，主要是防止边框的问题将这个盒子撑大。</p>\n<p>因为我们要通过圆角边框来实现圆圈。所以我们首先将<code>.border</code>盒子设置相同的宽高，使之成为一个正方形；然后通过<code>border-radius</code>属性设置为50%。<br>圆圈就出来了。</p>\n<p>为了使这个加载动画更加美观，我们使用定位将其放到页面中央：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">50px</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54478ba8ee4945239063586e2be6a90b~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2 id=\"圆圈的缺口\"><a href=\"#圆圈的缺口\" class=\"headerlink\" title=\"圆圈的缺口\"></a>圆圈的缺口</h2><p>在上面的效果图里面，加载动画圆圈是由一个缺口的，我们在这里使用一个同背景色的盒子来遮住圆圈实现。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span>&gt;<span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">25px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">25px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们还需要将这个用于遮罩的盒子，移动到圆圈的旁边，所以我们使用到了绝对定位。<br>在背景颜色上面，我们选择继承父盒子的颜色。</p>\n<p>为了尽量不影响其他元素。我们将这个遮罩的宽高设置为圆圈直径的（父盒子宽高）一半。</p>\n<p>最后出现的效果就是这样：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6d97fcb9ea49118d2c5ea04e95c014~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>接下来就是添加动画让圆圈动起来：</p>\n<h2 id=\"动画设置\"><a href=\"#动画设置\" class=\"headerlink\" title=\"动画设置\"></a>动画设置</h2><p>为了让这个加载动画看起来更加丝滑，我们不设置用百分比的方式来设置，使用<code>from to</code>的方式来设置动画。</p>\n<p>然后我们还要设置动画旋转的中心点，默认的中心点是盒子的左上角，但这不是我们想要的效果，我们希望从盒子中心旋转。于是我们使用<code>transform-origin: center center;</code>的方式将旋转中心设置为盒子中央。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframe</span> rotate&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform-origin</span>: center center;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">0deg</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform-origin</span>: center center;</span><br><span class=\"line\">            <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里就把加载动画设置完毕了，我么将这个动画加在<code>.border</code>的盒子上。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.border</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: rotate <span class=\"number\">1s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后的效果展示：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f826fdec7974092906cf5b7aa55b087~tplv-k3u1fbpfcp-watermark.image\" alt=\"动画1.gif\"></p>\n"},{"title":"CSS盒模型","date":"2022-10-16T16:00:00.000Z","_content":"# 教你5分钟搞懂css里面的盒模型\n\n## 什么是盒模型\n\n在html中，我们写的标签，很多都是有盒模型的，也就是在css里面，我们为这些标签设置样式的时候，实际上就是为这些盒子设置样式。\n\n可能这样不是很好理解，我们来看一个例子：\n\n在日常生活中，我们经常使用一些盒子来装东西，此时我们将盒子想象成从上往下看的二维平面：  \n那么盒子将会包含以下东西：\n\n- 盒子里面装的东西【内容】\n- 盒子内容与盒子包装的距离【内边距】\n- 盒子的厚度：【边框】\n- 盒子距离其他东西的距离【外边距】\n\ncss里面的盒模型就包含内容`content`,内边距`padding`,边框`border`,外边距`margin`\n如下图所示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bf44e4c1d4e4aa1806ec005354e67aa~tplv-k3u1fbpfcp-watermark.image?)\n\n- 白色框框里面的就是内容`content`\n- 绿色箭头的距离就是内边距`padding`\n- 再往外的黑色边框就是盒子的边框`border`\n- 最外面的的蓝色箭头就是外边距`margin`\n\n## 盒模型的分类\n\n在如今css的标准里面，盒模型有两种，一种是标准盒模型，一种是IE盒模型。\n\ncss默认使用的是ie盒模型，这就导致了一些初学者在设置css样式的时候出现一些出乎意料的问题。\n\n至于是什么问题呢？  \n接着往下看。\n\n### ie盒模型\n\n首先我们来讲讲ie盒模型是怎么样子的。\n\n我们在ie盒模型中，设置的宽度以及高度，只是包含了内容`content`的宽度以及高度，不包含内边距`padding`以及边框`border`的宽度以及高度。\n\n```css\n.box{\n    width: 100px;\n    height: 100px;\n    padding: 10px;\n    border: 1px solid #000;\n    margin: 19px;\n}\n```\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e263168872d44beade22cf89637312b~tplv-k3u1fbpfcp-watermark.image?)\n\n在浏览器开发者工具中，我们可以看到，该盒子的内容内容长宽都为100px,但是盒子的实际长宽为130px，这就是因为ie盒模型长宽只包含内容的长宽。\n\n此时我们设置的长宽度计算方式为：\n\n`width = content.width`  \n`height = content.height`\n\n这时候，问题就来了：  \n一些初学者明明只给盒子设置了100px的宽度，为什么盒子的实际宽度却是130px呢？\n\n看来上面的例子，就很明了了，这就是ie盒子长宽不包含内边距以及边框的宽度导致的问题。\n\n### 标准盒模型\n\n标准盒模型，就是我们常说的盒模型，它的长宽包含了内容`content`，内边距`padding`，边框`border`的宽度以及高度。\n\n**注意：**\n\n- 标准盒模型并不包含外边距`margin`的宽度以及高度。\n- 在使用标准盒模型之前，我们需要通过`box-sizing: border-box;`来设置盒模型的类型。\n\n```css\n.borderBox {\n            box-sizing: border-box;\n            width: 100px;\n            height: 100px;\n            padding: 10px;\n            border: 1px solid #000;\n            margin: 19px;\n        }\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054c4c4110094f78911e7579839d7a4f~tplv-k3u1fbpfcp-watermark.image?)\n\n在上面的图片我们可以看到，盒子里面的内容明显比ie盒模型的内容要小，这是因为标准盒模型的长宽包含了内容`content`，内边距`padding`，边框`border`的宽度以及高度。\n\n此时的我们设置的长宽度计算方式为：  \n`width = content.width + padding.width + border.width`  \n`height = content.height + padding.height + border.height`\n\n","source":"_posts/css里面的盒模型.md","raw":"---\ntitle: CSS盒模型\ndate: 2022-10-17\ntags: [前端]\ncategories: [css]\n---\n# 教你5分钟搞懂css里面的盒模型\n\n## 什么是盒模型\n\n在html中，我们写的标签，很多都是有盒模型的，也就是在css里面，我们为这些标签设置样式的时候，实际上就是为这些盒子设置样式。\n\n可能这样不是很好理解，我们来看一个例子：\n\n在日常生活中，我们经常使用一些盒子来装东西，此时我们将盒子想象成从上往下看的二维平面：  \n那么盒子将会包含以下东西：\n\n- 盒子里面装的东西【内容】\n- 盒子内容与盒子包装的距离【内边距】\n- 盒子的厚度：【边框】\n- 盒子距离其他东西的距离【外边距】\n\ncss里面的盒模型就包含内容`content`,内边距`padding`,边框`border`,外边距`margin`\n如下图所示：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bf44e4c1d4e4aa1806ec005354e67aa~tplv-k3u1fbpfcp-watermark.image?)\n\n- 白色框框里面的就是内容`content`\n- 绿色箭头的距离就是内边距`padding`\n- 再往外的黑色边框就是盒子的边框`border`\n- 最外面的的蓝色箭头就是外边距`margin`\n\n## 盒模型的分类\n\n在如今css的标准里面，盒模型有两种，一种是标准盒模型，一种是IE盒模型。\n\ncss默认使用的是ie盒模型，这就导致了一些初学者在设置css样式的时候出现一些出乎意料的问题。\n\n至于是什么问题呢？  \n接着往下看。\n\n### ie盒模型\n\n首先我们来讲讲ie盒模型是怎么样子的。\n\n我们在ie盒模型中，设置的宽度以及高度，只是包含了内容`content`的宽度以及高度，不包含内边距`padding`以及边框`border`的宽度以及高度。\n\n```css\n.box{\n    width: 100px;\n    height: 100px;\n    padding: 10px;\n    border: 1px solid #000;\n    margin: 19px;\n}\n```\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e263168872d44beade22cf89637312b~tplv-k3u1fbpfcp-watermark.image?)\n\n在浏览器开发者工具中，我们可以看到，该盒子的内容内容长宽都为100px,但是盒子的实际长宽为130px，这就是因为ie盒模型长宽只包含内容的长宽。\n\n此时我们设置的长宽度计算方式为：\n\n`width = content.width`  \n`height = content.height`\n\n这时候，问题就来了：  \n一些初学者明明只给盒子设置了100px的宽度，为什么盒子的实际宽度却是130px呢？\n\n看来上面的例子，就很明了了，这就是ie盒子长宽不包含内边距以及边框的宽度导致的问题。\n\n### 标准盒模型\n\n标准盒模型，就是我们常说的盒模型，它的长宽包含了内容`content`，内边距`padding`，边框`border`的宽度以及高度。\n\n**注意：**\n\n- 标准盒模型并不包含外边距`margin`的宽度以及高度。\n- 在使用标准盒模型之前，我们需要通过`box-sizing: border-box;`来设置盒模型的类型。\n\n```css\n.borderBox {\n            box-sizing: border-box;\n            width: 100px;\n            height: 100px;\n            padding: 10px;\n            border: 1px solid #000;\n            margin: 19px;\n        }\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054c4c4110094f78911e7579839d7a4f~tplv-k3u1fbpfcp-watermark.image?)\n\n在上面的图片我们可以看到，盒子里面的内容明显比ie盒模型的内容要小，这是因为标准盒模型的长宽包含了内容`content`，内边距`padding`，边框`border`的宽度以及高度。\n\n此时的我们设置的长宽度计算方式为：  \n`width = content.width + padding.width + border.width`  \n`height = content.height + padding.height + border.height`\n\n","slug":"css里面的盒模型","published":1,"updated":"2023-01-09T11:59:20.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmh7000y9kbm0nncfnnd","content":"<h1 id=\"教你5分钟搞懂css里面的盒模型\"><a href=\"#教你5分钟搞懂css里面的盒模型\" class=\"headerlink\" title=\"教你5分钟搞懂css里面的盒模型\"></a>教你5分钟搞懂css里面的盒模型</h1><h2 id=\"什么是盒模型\"><a href=\"#什么是盒模型\" class=\"headerlink\" title=\"什么是盒模型\"></a>什么是盒模型</h2><p>在html中，我们写的标签，很多都是有盒模型的，也就是在css里面，我们为这些标签设置样式的时候，实际上就是为这些盒子设置样式。</p>\n<p>可能这样不是很好理解，我们来看一个例子：</p>\n<p>在日常生活中，我们经常使用一些盒子来装东西，此时我们将盒子想象成从上往下看的二维平面：<br>那么盒子将会包含以下东西：</p>\n<ul>\n<li>盒子里面装的东西【内容】</li>\n<li>盒子内容与盒子包装的距离【内边距】</li>\n<li>盒子的厚度：【边框】</li>\n<li>盒子距离其他东西的距离【外边距】</li>\n</ul>\n<p>css里面的盒模型就包含内容<code>content</code>,内边距<code>padding</code>,边框<code>border</code>,外边距<code>margin</code><br>如下图所示：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bf44e4c1d4e4aa1806ec005354e67aa~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>白色框框里面的就是内容<code>content</code></li>\n<li>绿色箭头的距离就是内边距<code>padding</code></li>\n<li>再往外的黑色边框就是盒子的边框<code>border</code></li>\n<li>最外面的的蓝色箭头就是外边距<code>margin</code></li>\n</ul>\n<h2 id=\"盒模型的分类\"><a href=\"#盒模型的分类\" class=\"headerlink\" title=\"盒模型的分类\"></a>盒模型的分类</h2><p>在如今css的标准里面，盒模型有两种，一种是标准盒模型，一种是IE盒模型。</p>\n<p>css默认使用的是ie盒模型，这就导致了一些初学者在设置css样式的时候出现一些出乎意料的问题。</p>\n<p>至于是什么问题呢？<br>接着往下看。</p>\n<h3 id=\"ie盒模型\"><a href=\"#ie盒模型\" class=\"headerlink\" title=\"ie盒模型\"></a>ie盒模型</h3><p>首先我们来讲讲ie盒模型是怎么样子的。</p>\n<p>我们在ie盒模型中，设置的宽度以及高度，只是包含了内容<code>content</code>的宽度以及高度，不包含内边距<code>padding</code>以及边框<code>border</code>的宽度以及高度。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">19px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e263168872d44beade22cf89637312b~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在浏览器开发者工具中，我们可以看到，该盒子的内容内容长宽都为100px,但是盒子的实际长宽为130px，这就是因为ie盒模型长宽只包含内容的长宽。</p>\n<p>此时我们设置的长宽度计算方式为：</p>\n<p><code>width = content.width</code><br><code>height = content.height</code></p>\n<p>这时候，问题就来了：<br>一些初学者明明只给盒子设置了100px的宽度，为什么盒子的实际宽度却是130px呢？</p>\n<p>看来上面的例子，就很明了了，这就是ie盒子长宽不包含内边距以及边框的宽度导致的问题。</p>\n<h3 id=\"标准盒模型\"><a href=\"#标准盒模型\" class=\"headerlink\" title=\"标准盒模型\"></a>标准盒模型</h3><p>标准盒模型，就是我们常说的盒模型，它的长宽包含了内容<code>content</code>，内边距<code>padding</code>，边框<code>border</code>的宽度以及高度。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>标准盒模型并不包含外边距<code>margin</code>的宽度以及高度。</li>\n<li>在使用标准盒模型之前，我们需要通过<code>box-sizing: border-box;</code>来设置盒模型的类型。</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.borderBox</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">            <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">            <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">            <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">            <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">19px</span>;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054c4c4110094f78911e7579839d7a4f~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在上面的图片我们可以看到，盒子里面的内容明显比ie盒模型的内容要小，这是因为标准盒模型的长宽包含了内容<code>content</code>，内边距<code>padding</code>，边框<code>border</code>的宽度以及高度。</p>\n<p>此时的我们设置的长宽度计算方式为：<br><code>width = content.width + padding.width + border.width</code><br><code>height = content.height + padding.height + border.height</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"教你5分钟搞懂css里面的盒模型\"><a href=\"#教你5分钟搞懂css里面的盒模型\" class=\"headerlink\" title=\"教你5分钟搞懂css里面的盒模型\"></a>教你5分钟搞懂css里面的盒模型</h1><h2 id=\"什么是盒模型\"><a href=\"#什么是盒模型\" class=\"headerlink\" title=\"什么是盒模型\"></a>什么是盒模型</h2><p>在html中，我们写的标签，很多都是有盒模型的，也就是在css里面，我们为这些标签设置样式的时候，实际上就是为这些盒子设置样式。</p>\n<p>可能这样不是很好理解，我们来看一个例子：</p>\n<p>在日常生活中，我们经常使用一些盒子来装东西，此时我们将盒子想象成从上往下看的二维平面：<br>那么盒子将会包含以下东西：</p>\n<ul>\n<li>盒子里面装的东西【内容】</li>\n<li>盒子内容与盒子包装的距离【内边距】</li>\n<li>盒子的厚度：【边框】</li>\n<li>盒子距离其他东西的距离【外边距】</li>\n</ul>\n<p>css里面的盒模型就包含内容<code>content</code>,内边距<code>padding</code>,边框<code>border</code>,外边距<code>margin</code><br>如下图所示：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bf44e4c1d4e4aa1806ec005354e67aa~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>白色框框里面的就是内容<code>content</code></li>\n<li>绿色箭头的距离就是内边距<code>padding</code></li>\n<li>再往外的黑色边框就是盒子的边框<code>border</code></li>\n<li>最外面的的蓝色箭头就是外边距<code>margin</code></li>\n</ul>\n<h2 id=\"盒模型的分类\"><a href=\"#盒模型的分类\" class=\"headerlink\" title=\"盒模型的分类\"></a>盒模型的分类</h2><p>在如今css的标准里面，盒模型有两种，一种是标准盒模型，一种是IE盒模型。</p>\n<p>css默认使用的是ie盒模型，这就导致了一些初学者在设置css样式的时候出现一些出乎意料的问题。</p>\n<p>至于是什么问题呢？<br>接着往下看。</p>\n<h3 id=\"ie盒模型\"><a href=\"#ie盒模型\" class=\"headerlink\" title=\"ie盒模型\"></a>ie盒模型</h3><p>首先我们来讲讲ie盒模型是怎么样子的。</p>\n<p>我们在ie盒模型中，设置的宽度以及高度，只是包含了内容<code>content</code>的宽度以及高度，不包含内边距<code>padding</code>以及边框<code>border</code>的宽度以及高度。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">19px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e263168872d44beade22cf89637312b~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在浏览器开发者工具中，我们可以看到，该盒子的内容内容长宽都为100px,但是盒子的实际长宽为130px，这就是因为ie盒模型长宽只包含内容的长宽。</p>\n<p>此时我们设置的长宽度计算方式为：</p>\n<p><code>width = content.width</code><br><code>height = content.height</code></p>\n<p>这时候，问题就来了：<br>一些初学者明明只给盒子设置了100px的宽度，为什么盒子的实际宽度却是130px呢？</p>\n<p>看来上面的例子，就很明了了，这就是ie盒子长宽不包含内边距以及边框的宽度导致的问题。</p>\n<h3 id=\"标准盒模型\"><a href=\"#标准盒模型\" class=\"headerlink\" title=\"标准盒模型\"></a>标准盒模型</h3><p>标准盒模型，就是我们常说的盒模型，它的长宽包含了内容<code>content</code>，内边距<code>padding</code>，边框<code>border</code>的宽度以及高度。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>标准盒模型并不包含外边距<code>margin</code>的宽度以及高度。</li>\n<li>在使用标准盒模型之前，我们需要通过<code>box-sizing: border-box;</code>来设置盒模型的类型。</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.borderBox</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">            <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">            <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">            <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">            <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">            <span class=\"attribute\">margin</span>: <span class=\"number\">19px</span>;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054c4c4110094f78911e7579839d7a4f~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在上面的图片我们可以看到，盒子里面的内容明显比ie盒模型的内容要小，这是因为标准盒模型的长宽包含了内容<code>content</code>，内边距<code>padding</code>，边框<code>border</code>的宽度以及高度。</p>\n<p>此时的我们设置的长宽度计算方式为：<br><code>width = content.width + padding.width + border.width</code><br><code>height = content.height + padding.height + border.height</code></p>\n"},{"title":"ES6的提升","date":"2022-10-15T16:00:00.000Z","_content":"# es6的提升\n\n在es6之前，我们定义定义变量的时候，只能使用var关键字来定变量，这样有一个问题，var定义的变量会成为全局变量。  \n但是在我们实际开发的过程中，我们应该尽量少的将变量或者函数暴露在全局作用域下，这是一种好的软件设计原则。\n\n为了解决var的变量泄露问题，es6引入了let和const关键字。  \n\n## 什么是提升\n\n提升就是变量或者函数在定义之前就可以使用，这是因为js引擎在编译的时候，会将变量和函数的声明提升到作用域的顶部。\n\n注意这里我们讲到了函数与变量都存在提升的现象：\n\n### 变量提升\n\n```js\n    console.log(a); // undefined\n    var a = 1;\n```\n\n在这里并不会出现`ReferenceError`的错误，因为js引擎在编译的时候，会将变量的声明提升到作用域的顶部，所以在这里我们可以使用变量a，但是值为undefined。\n\n也就是说，变量提升只会提升变量的声明，而不会提升变量的赋值。  \n变量提升，提升的变量的声明，而变量的运行逻辑还是停留在原地。\n\n那么es6新增的let和const关键字，是否也存在变量提升呢？\n\n我认为是会提升的，但是：由于let与const暂时性死区的问题，导致在变量声明之前使用变量会报错。\n*这里看法不统一，有人认为会提升，有人认为不会提升*\n\n```js\n    console.log(a); // ReferenceError: a is not defined\n    let a = 1;\n```\n\n### 函数提升\n\n```js\n    console.log(a); // function a() {}\n    function a() {};\n```\n\n**这里注意：**\n我们上面这段代码里面书写的是函数声明，而不是函数表达式。  \n这点很重要，因为在函数提升中，只有函数声明才会被提升，函数表达式是不会被提升的。\n\n其实很好理解，这就像变量提升相似，提升的只是函数的声明，而不会提升函数的赋值。\n\n```js\n    console.log(a); // TypeError\n    var a = function() {};\n```\n\n其实上面的代码就类似于下面的样子：\n    \n```js\n    var a;\n    console.log(a); // TypeError\n    a = function() {};\n```\n\n## 函数提升优先\n\n要是函数和变量提升两者同时存在的时候，谁会更先提升呢？\n\n```js\n    console.log(a); // function a() {}\n    var a = 1;\n    function a() {};\n```\n\n到这里答案就很明显了，函数优先。\n\n## 总结\n\n不管是函数还是变量，被提升的只有声明，并没有赋值。\n\n**注意**\n\n- 函数提升优先\n- 函数只会提升函数声明，不会提升函数表达式","source":"_posts/es6的提升.md","raw":"---\ntitle: ES6的提升\ndate: 2022-10-16\ntags: [前端]\ncategories: [ES6]\n---\n# es6的提升\n\n在es6之前，我们定义定义变量的时候，只能使用var关键字来定变量，这样有一个问题，var定义的变量会成为全局变量。  \n但是在我们实际开发的过程中，我们应该尽量少的将变量或者函数暴露在全局作用域下，这是一种好的软件设计原则。\n\n为了解决var的变量泄露问题，es6引入了let和const关键字。  \n\n## 什么是提升\n\n提升就是变量或者函数在定义之前就可以使用，这是因为js引擎在编译的时候，会将变量和函数的声明提升到作用域的顶部。\n\n注意这里我们讲到了函数与变量都存在提升的现象：\n\n### 变量提升\n\n```js\n    console.log(a); // undefined\n    var a = 1;\n```\n\n在这里并不会出现`ReferenceError`的错误，因为js引擎在编译的时候，会将变量的声明提升到作用域的顶部，所以在这里我们可以使用变量a，但是值为undefined。\n\n也就是说，变量提升只会提升变量的声明，而不会提升变量的赋值。  \n变量提升，提升的变量的声明，而变量的运行逻辑还是停留在原地。\n\n那么es6新增的let和const关键字，是否也存在变量提升呢？\n\n我认为是会提升的，但是：由于let与const暂时性死区的问题，导致在变量声明之前使用变量会报错。\n*这里看法不统一，有人认为会提升，有人认为不会提升*\n\n```js\n    console.log(a); // ReferenceError: a is not defined\n    let a = 1;\n```\n\n### 函数提升\n\n```js\n    console.log(a); // function a() {}\n    function a() {};\n```\n\n**这里注意：**\n我们上面这段代码里面书写的是函数声明，而不是函数表达式。  \n这点很重要，因为在函数提升中，只有函数声明才会被提升，函数表达式是不会被提升的。\n\n其实很好理解，这就像变量提升相似，提升的只是函数的声明，而不会提升函数的赋值。\n\n```js\n    console.log(a); // TypeError\n    var a = function() {};\n```\n\n其实上面的代码就类似于下面的样子：\n    \n```js\n    var a;\n    console.log(a); // TypeError\n    a = function() {};\n```\n\n## 函数提升优先\n\n要是函数和变量提升两者同时存在的时候，谁会更先提升呢？\n\n```js\n    console.log(a); // function a() {}\n    var a = 1;\n    function a() {};\n```\n\n到这里答案就很明显了，函数优先。\n\n## 总结\n\n不管是函数还是变量，被提升的只有声明，并没有赋值。\n\n**注意**\n\n- 函数提升优先\n- 函数只会提升函数声明，不会提升函数表达式","slug":"es6的提升","published":1,"updated":"2023-01-09T12:05:31.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhc00129kbm9dda1rxb","content":"<h1 id=\"es6的提升\"><a href=\"#es6的提升\" class=\"headerlink\" title=\"es6的提升\"></a>es6的提升</h1><p>在es6之前，我们定义定义变量的时候，只能使用var关键字来定变量，这样有一个问题，var定义的变量会成为全局变量。<br>但是在我们实际开发的过程中，我们应该尽量少的将变量或者函数暴露在全局作用域下，这是一种好的软件设计原则。</p>\n<p>为了解决var的变量泄露问题，es6引入了let和const关键字。  </p>\n<h2 id=\"什么是提升\"><a href=\"#什么是提升\" class=\"headerlink\" title=\"什么是提升\"></a>什么是提升</h2><p>提升就是变量或者函数在定义之前就可以使用，这是因为js引擎在编译的时候，会将变量和函数的声明提升到作用域的顶部。</p>\n<p>注意这里我们讲到了函数与变量都存在提升的现象：</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里并不会出现<code>ReferenceError</code>的错误，因为js引擎在编译的时候，会将变量的声明提升到作用域的顶部，所以在这里我们可以使用变量a，但是值为undefined。</p>\n<p>也就是说，变量提升只会提升变量的声明，而不会提升变量的赋值。<br>变量提升，提升的变量的声明，而变量的运行逻辑还是停留在原地。</p>\n<p>那么es6新增的let和const关键字，是否也存在变量提升呢？</p>\n<p>我认为是会提升的，但是：由于let与const暂时性死区的问题，导致在变量声明之前使用变量会报错。<br><em>这里看法不统一，有人认为会提升，有人认为不会提升</em></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// function a() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里注意：</strong><br>我们上面这段代码里面书写的是函数声明，而不是函数表达式。<br>这点很重要，因为在函数提升中，只有函数声明才会被提升，函数表达式是不会被提升的。</p>\n<p>其实很好理解，这就像变量提升相似，提升的只是函数的声明，而不会提升函数的赋值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其实上面的代码就类似于下面的样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">a = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数提升优先\"><a href=\"#函数提升优先\" class=\"headerlink\" title=\"函数提升优先\"></a>函数提升优先</h2><p>要是函数和变量提升两者同时存在的时候，谁会更先提升呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// function a() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>到这里答案就很明显了，函数优先。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不管是函数还是变量，被提升的只有声明，并没有赋值。</p>\n<p><strong>注意</strong></p>\n<ul>\n<li>函数提升优先</li>\n<li>函数只会提升函数声明，不会提升函数表达式</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"es6的提升\"><a href=\"#es6的提升\" class=\"headerlink\" title=\"es6的提升\"></a>es6的提升</h1><p>在es6之前，我们定义定义变量的时候，只能使用var关键字来定变量，这样有一个问题，var定义的变量会成为全局变量。<br>但是在我们实际开发的过程中，我们应该尽量少的将变量或者函数暴露在全局作用域下，这是一种好的软件设计原则。</p>\n<p>为了解决var的变量泄露问题，es6引入了let和const关键字。  </p>\n<h2 id=\"什么是提升\"><a href=\"#什么是提升\" class=\"headerlink\" title=\"什么是提升\"></a>什么是提升</h2><p>提升就是变量或者函数在定义之前就可以使用，这是因为js引擎在编译的时候，会将变量和函数的声明提升到作用域的顶部。</p>\n<p>注意这里我们讲到了函数与变量都存在提升的现象：</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在这里并不会出现<code>ReferenceError</code>的错误，因为js引擎在编译的时候，会将变量的声明提升到作用域的顶部，所以在这里我们可以使用变量a，但是值为undefined。</p>\n<p>也就是说，变量提升只会提升变量的声明，而不会提升变量的赋值。<br>变量提升，提升的变量的声明，而变量的运行逻辑还是停留在原地。</p>\n<p>那么es6新增的let和const关键字，是否也存在变量提升呢？</p>\n<p>我认为是会提升的，但是：由于let与const暂时性死区的问题，导致在变量声明之前使用变量会报错。<br><em>这里看法不统一，有人认为会提升，有人认为不会提升</em></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// ReferenceError: a is not defined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// function a() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里注意：</strong><br>我们上面这段代码里面书写的是函数声明，而不是函数表达式。<br>这点很重要，因为在函数提升中，只有函数声明才会被提升，函数表达式是不会被提升的。</p>\n<p>其实很好理解，这就像变量提升相似，提升的只是函数的声明，而不会提升函数的赋值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其实上面的代码就类似于下面的样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">a = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数提升优先\"><a href=\"#函数提升优先\" class=\"headerlink\" title=\"函数提升优先\"></a>函数提升优先</h2><p>要是函数和变量提升两者同时存在的时候，谁会更先提升呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// function a() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>到这里答案就很明显了，函数优先。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不管是函数还是变量，被提升的只有声明，并没有赋值。</p>\n<p><strong>注意</strong></p>\n<ul>\n<li>函数提升优先</li>\n<li>函数只会提升函数声明，不会提升函数表达式</li>\n</ul>\n"},{"title":"Flex布局","date":"2022-08-21T16:00:00.000Z","_content":"# flex布局\n\n在传统的网页布局模式中，我们使用的是盒模型，这种盒模型往往依赖dispaly属性，position属性，float属性，但是对于一些特殊布局这样的布局方式会非常的不方便，比如在垂直居中的时候，使用position布局就会非常不方便，而且使用float布局的话，后面我们还需要清除浮动，非常的不方便。\n\n## 什么是flex布局\n\nflex是Flexible Box的缩写，意思为弹性布局，在html中任何一个容器都可以被指定为flex布局。\n\n*注意：*\n\nhtml中，设置为flex布局之后，它的子元素**float、clear、vertical-align**属性将会失效\n\n## flex的基本概念\n\n采用flex布局的元素，我们称之为容器，这个容器里面的所有子元素我们称之为容器成员，也就是flex项目，我们简称为项目。\n\n在flex容器中，存在两根轴，主轴和交叉轴；在主轴的开始位置我们称之为main start,结束位置我们称之为main end；交叉轴的开始位置叫做cross start,结束位置我们称之为cross end。\n\n主轴默认水平排列，交叉轴默认竖直排列，项目默认沿着主轴排列。单个项目占用主轴的空间叫做main size，单个项目占用交叉轴的空间叫做cross size。\n\n## 容器的属性\n\n下面列出容器的属性：\n\n- flex-direction\n- flex-wrap\n- flex-flow\n- justify-content\n- align-items\n- align-content\n\n### flex-direction属性\n\nflex-direction属性可以决定主轴的方向（也就是我们项目的排列方向），当主轴的排雷方向发生改变的时候，交叉轴的方向随之发生改变。\n\n    .div{\n        flex-direction:row | row-reverse | colum | colum-reverse;\n    }\n\n这个属性可能有四个值：\n\n- row(默认值):主轴为水平方向，起点在左端。\n- row-reverse:主轴为水平方向，起点在右端。\n- column:主轴为垂直方向，起点在上面。\n- colum-reverse:主轴为垂直方向，起点在下面。\n\n### flex-wrap属性\n\n在默认情况下，项目都是排列在主轴上的，当主轴的长度不够时，项目会换行。换行的方式我们可以通过flex-wrap属性来指定。\n\n    .div{\n        flex-wrap:nowrap | wrap | wrap-reverse;\n    }\n\n这个属性可以有三个值：\n\n- nowrap(默认值):项目不会换行。\n- wrap:换行，第一行会在上方。\n- wrap-reverse:换行，第一行会在下方。\n\n### flex-flow属性\n\nflex-flow属性可以同时指定flex-direction和flex-wrap属性。默认值是row nowrap。\n\n    .div{\n        //flex-flow:<flex-direction> <flex-wrap>;\n        flex-flow:row nowrap;\n    }\n\n### justify-content属性\n\njustify-content定义了项目在主轴上的对齐方式。\n\n    .div{\n        justify-content:flex-start | flex-end | center | space-between | space-around;\n    }\n\n这个属性可以有五个值：(具体对齐方式与主轴方向有关)\n\n- flex-start:。从主轴的起点开始往终点排列项目。\n- flex-end:。从主轴的终点开始往起点排列项目。\n- center:。项目排列在主轴的中间。\n- space-between:。项目排列在主轴的中间，两端对齐，项目之间的间隔都相等。\n- space-around:。项目排列在主轴的中间，两端对齐，项目之间的间隔不相等(项目之间的距离是项目距离边框的两倍)。\n\n### algin-items属性\n\nalgin-items定义了项目在交叉轴上的对齐方式。\n\n    .div{\n        align-items:flex-start | flex-end | center | baseline | stretch;\n    }\n\n这个属性可以有五个值：(具体对齐方式同样与交叉轴方向有关)\n\n- flax-start:。项目在交叉轴的起点开始往终点排列。\n- flex-end:。项目在交叉轴的终点开始往起点排列。\n- center:。项目在交叉轴的中间。\n- baseline:。项目在交叉轴的基线(也就是与项目第一行文字的基线对齐)。\n- stretch:。项目在交叉轴的中间，并且占满交叉轴的空间(也就是如果项目没有设置高度或者设置为auto那么这个项目将会占满整个容器)。\n  \n### align-content属性\n\nalign-content定义了**多根轴线**的对齐方式。如果项目只有一根轴线，那么这个属性就不会起作用。\n\n    .div{\n        align-content:flex-start | flex-end | center | space-between | space-around | stretch;\n    }\n\n这个属性可以有六个值：\n\n- flex-start:从交叉轴的起点开始往终点排列。\n- flex-end:从交叉轴的终点开始往起点排列。\n- center:项目在交叉轴的中间。\n- space-between:项目在交叉轴的中间，两端对齐，项目之间的间隔都相等。\n- space-around:项目在交叉轴的中间，两端对齐，项目之间的间隔不相等(项目之间的距离是项目距离边框的两倍)。\n- stretch:轴线占满整个交叉轴。\n\n## 项目属性\n\n前面我们说了容器的属性，这里我们再来了解一下项目的属性。\n\n- order　　项目的排列顺序。数值越小，排列越靠前，默认为0。\n- flex-grow　　项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n- flex-shrink　　项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n- flex-basis　　在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n- flex　　是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n- align-self　　允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n","source":"_posts/flex布局.md","raw":"---\ntitle: Flex布局\ndate: 2022-8-22\ntags: [前端]\ncategories: [css]\n---\n# flex布局\n\n在传统的网页布局模式中，我们使用的是盒模型，这种盒模型往往依赖dispaly属性，position属性，float属性，但是对于一些特殊布局这样的布局方式会非常的不方便，比如在垂直居中的时候，使用position布局就会非常不方便，而且使用float布局的话，后面我们还需要清除浮动，非常的不方便。\n\n## 什么是flex布局\n\nflex是Flexible Box的缩写，意思为弹性布局，在html中任何一个容器都可以被指定为flex布局。\n\n*注意：*\n\nhtml中，设置为flex布局之后，它的子元素**float、clear、vertical-align**属性将会失效\n\n## flex的基本概念\n\n采用flex布局的元素，我们称之为容器，这个容器里面的所有子元素我们称之为容器成员，也就是flex项目，我们简称为项目。\n\n在flex容器中，存在两根轴，主轴和交叉轴；在主轴的开始位置我们称之为main start,结束位置我们称之为main end；交叉轴的开始位置叫做cross start,结束位置我们称之为cross end。\n\n主轴默认水平排列，交叉轴默认竖直排列，项目默认沿着主轴排列。单个项目占用主轴的空间叫做main size，单个项目占用交叉轴的空间叫做cross size。\n\n## 容器的属性\n\n下面列出容器的属性：\n\n- flex-direction\n- flex-wrap\n- flex-flow\n- justify-content\n- align-items\n- align-content\n\n### flex-direction属性\n\nflex-direction属性可以决定主轴的方向（也就是我们项目的排列方向），当主轴的排雷方向发生改变的时候，交叉轴的方向随之发生改变。\n\n    .div{\n        flex-direction:row | row-reverse | colum | colum-reverse;\n    }\n\n这个属性可能有四个值：\n\n- row(默认值):主轴为水平方向，起点在左端。\n- row-reverse:主轴为水平方向，起点在右端。\n- column:主轴为垂直方向，起点在上面。\n- colum-reverse:主轴为垂直方向，起点在下面。\n\n### flex-wrap属性\n\n在默认情况下，项目都是排列在主轴上的，当主轴的长度不够时，项目会换行。换行的方式我们可以通过flex-wrap属性来指定。\n\n    .div{\n        flex-wrap:nowrap | wrap | wrap-reverse;\n    }\n\n这个属性可以有三个值：\n\n- nowrap(默认值):项目不会换行。\n- wrap:换行，第一行会在上方。\n- wrap-reverse:换行，第一行会在下方。\n\n### flex-flow属性\n\nflex-flow属性可以同时指定flex-direction和flex-wrap属性。默认值是row nowrap。\n\n    .div{\n        //flex-flow:<flex-direction> <flex-wrap>;\n        flex-flow:row nowrap;\n    }\n\n### justify-content属性\n\njustify-content定义了项目在主轴上的对齐方式。\n\n    .div{\n        justify-content:flex-start | flex-end | center | space-between | space-around;\n    }\n\n这个属性可以有五个值：(具体对齐方式与主轴方向有关)\n\n- flex-start:。从主轴的起点开始往终点排列项目。\n- flex-end:。从主轴的终点开始往起点排列项目。\n- center:。项目排列在主轴的中间。\n- space-between:。项目排列在主轴的中间，两端对齐，项目之间的间隔都相等。\n- space-around:。项目排列在主轴的中间，两端对齐，项目之间的间隔不相等(项目之间的距离是项目距离边框的两倍)。\n\n### algin-items属性\n\nalgin-items定义了项目在交叉轴上的对齐方式。\n\n    .div{\n        align-items:flex-start | flex-end | center | baseline | stretch;\n    }\n\n这个属性可以有五个值：(具体对齐方式同样与交叉轴方向有关)\n\n- flax-start:。项目在交叉轴的起点开始往终点排列。\n- flex-end:。项目在交叉轴的终点开始往起点排列。\n- center:。项目在交叉轴的中间。\n- baseline:。项目在交叉轴的基线(也就是与项目第一行文字的基线对齐)。\n- stretch:。项目在交叉轴的中间，并且占满交叉轴的空间(也就是如果项目没有设置高度或者设置为auto那么这个项目将会占满整个容器)。\n  \n### align-content属性\n\nalign-content定义了**多根轴线**的对齐方式。如果项目只有一根轴线，那么这个属性就不会起作用。\n\n    .div{\n        align-content:flex-start | flex-end | center | space-between | space-around | stretch;\n    }\n\n这个属性可以有六个值：\n\n- flex-start:从交叉轴的起点开始往终点排列。\n- flex-end:从交叉轴的终点开始往起点排列。\n- center:项目在交叉轴的中间。\n- space-between:项目在交叉轴的中间，两端对齐，项目之间的间隔都相等。\n- space-around:项目在交叉轴的中间，两端对齐，项目之间的间隔不相等(项目之间的距离是项目距离边框的两倍)。\n- stretch:轴线占满整个交叉轴。\n\n## 项目属性\n\n前面我们说了容器的属性，这里我们再来了解一下项目的属性。\n\n- order　　项目的排列顺序。数值越小，排列越靠前，默认为0。\n- flex-grow　　项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n- flex-shrink　　项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n- flex-basis　　在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n- flex　　是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n- align-self　　允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n","slug":"flex布局","published":1,"updated":"2023-01-09T12:07:21.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhd00149kbm0snsgjr8","content":"<h1 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h1><p>在传统的网页布局模式中，我们使用的是盒模型，这种盒模型往往依赖dispaly属性，position属性，float属性，但是对于一些特殊布局这样的布局方式会非常的不方便，比如在垂直居中的时候，使用position布局就会非常不方便，而且使用float布局的话，后面我们还需要清除浮动，非常的不方便。</p>\n<h2 id=\"什么是flex布局\"><a href=\"#什么是flex布局\" class=\"headerlink\" title=\"什么是flex布局\"></a>什么是flex布局</h2><p>flex是Flexible Box的缩写，意思为弹性布局，在html中任何一个容器都可以被指定为flex布局。</p>\n<p><em>注意：</em></p>\n<p>html中，设置为flex布局之后，它的子元素<strong>float、clear、vertical-align</strong>属性将会失效</p>\n<h2 id=\"flex的基本概念\"><a href=\"#flex的基本概念\" class=\"headerlink\" title=\"flex的基本概念\"></a>flex的基本概念</h2><p>采用flex布局的元素，我们称之为容器，这个容器里面的所有子元素我们称之为容器成员，也就是flex项目，我们简称为项目。</p>\n<p>在flex容器中，存在两根轴，主轴和交叉轴；在主轴的开始位置我们称之为main start,结束位置我们称之为main end；交叉轴的开始位置叫做cross start,结束位置我们称之为cross end。</p>\n<p>主轴默认水平排列，交叉轴默认竖直排列，项目默认沿着主轴排列。单个项目占用主轴的空间叫做main size，单个项目占用交叉轴的空间叫做cross size。</p>\n<h2 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h2><p>下面列出容器的属性：</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<h3 id=\"flex-direction属性\"><a href=\"#flex-direction属性\" class=\"headerlink\" title=\"flex-direction属性\"></a>flex-direction属性</h3><p>flex-direction属性可以决定主轴的方向（也就是我们项目的排列方向），当主轴的排雷方向发生改变的时候，交叉轴的方向随之发生改变。</p>\n<pre><code>.div&#123;\n    flex-direction:row | row-reverse | colum | colum-reverse;\n&#125;\n</code></pre>\n<p>这个属性可能有四个值：</p>\n<ul>\n<li>row(默认值):主轴为水平方向，起点在左端。</li>\n<li>row-reverse:主轴为水平方向，起点在右端。</li>\n<li>column:主轴为垂直方向，起点在上面。</li>\n<li>colum-reverse:主轴为垂直方向，起点在下面。</li>\n</ul>\n<h3 id=\"flex-wrap属性\"><a href=\"#flex-wrap属性\" class=\"headerlink\" title=\"flex-wrap属性\"></a>flex-wrap属性</h3><p>在默认情况下，项目都是排列在主轴上的，当主轴的长度不够时，项目会换行。换行的方式我们可以通过flex-wrap属性来指定。</p>\n<pre><code>.div&#123;\n    flex-wrap:nowrap | wrap | wrap-reverse;\n&#125;\n</code></pre>\n<p>这个属性可以有三个值：</p>\n<ul>\n<li>nowrap(默认值):项目不会换行。</li>\n<li>wrap:换行，第一行会在上方。</li>\n<li>wrap-reverse:换行，第一行会在下方。</li>\n</ul>\n<h3 id=\"flex-flow属性\"><a href=\"#flex-flow属性\" class=\"headerlink\" title=\"flex-flow属性\"></a>flex-flow属性</h3><p>flex-flow属性可以同时指定flex-direction和flex-wrap属性。默认值是row nowrap。</p>\n<pre><code>.div&#123;\n    //flex-flow:&lt;flex-direction&gt; &lt;flex-wrap&gt;;\n    flex-flow:row nowrap;\n&#125;\n</code></pre>\n<h3 id=\"justify-content属性\"><a href=\"#justify-content属性\" class=\"headerlink\" title=\"justify-content属性\"></a>justify-content属性</h3><p>justify-content定义了项目在主轴上的对齐方式。</p>\n<pre><code>.div&#123;\n    justify-content:flex-start | flex-end | center | space-between | space-around;\n&#125;\n</code></pre>\n<p>这个属性可以有五个值：(具体对齐方式与主轴方向有关)</p>\n<ul>\n<li>flex-start:。从主轴的起点开始往终点排列项目。</li>\n<li>flex-end:。从主轴的终点开始往起点排列项目。</li>\n<li>center:。项目排列在主轴的中间。</li>\n<li>space-between:。项目排列在主轴的中间，两端对齐，项目之间的间隔都相等。</li>\n<li>space-around:。项目排列在主轴的中间，两端对齐，项目之间的间隔不相等(项目之间的距离是项目距离边框的两倍)。</li>\n</ul>\n<h3 id=\"algin-items属性\"><a href=\"#algin-items属性\" class=\"headerlink\" title=\"algin-items属性\"></a>algin-items属性</h3><p>algin-items定义了项目在交叉轴上的对齐方式。</p>\n<pre><code>.div&#123;\n    align-items:flex-start | flex-end | center | baseline | stretch;\n&#125;\n</code></pre>\n<p>这个属性可以有五个值：(具体对齐方式同样与交叉轴方向有关)</p>\n<ul>\n<li>flax-start:。项目在交叉轴的起点开始往终点排列。</li>\n<li>flex-end:。项目在交叉轴的终点开始往起点排列。</li>\n<li>center:。项目在交叉轴的中间。</li>\n<li>baseline:。项目在交叉轴的基线(也就是与项目第一行文字的基线对齐)。</li>\n<li>stretch:。项目在交叉轴的中间，并且占满交叉轴的空间(也就是如果项目没有设置高度或者设置为auto那么这个项目将会占满整个容器)。</li>\n</ul>\n<h3 id=\"align-content属性\"><a href=\"#align-content属性\" class=\"headerlink\" title=\"align-content属性\"></a>align-content属性</h3><p>align-content定义了<strong>多根轴线</strong>的对齐方式。如果项目只有一根轴线，那么这个属性就不会起作用。</p>\n<pre><code>.div&#123;\n    align-content:flex-start | flex-end | center | space-between | space-around | stretch;\n&#125;\n</code></pre>\n<p>这个属性可以有六个值：</p>\n<ul>\n<li>flex-start:从交叉轴的起点开始往终点排列。</li>\n<li>flex-end:从交叉轴的终点开始往起点排列。</li>\n<li>center:项目在交叉轴的中间。</li>\n<li>space-between:项目在交叉轴的中间，两端对齐，项目之间的间隔都相等。</li>\n<li>space-around:项目在交叉轴的中间，两端对齐，项目之间的间隔不相等(项目之间的距离是项目距离边框的两倍)。</li>\n<li>stretch:轴线占满整个交叉轴。</li>\n</ul>\n<h2 id=\"项目属性\"><a href=\"#项目属性\" class=\"headerlink\" title=\"项目属性\"></a>项目属性</h2><p>前面我们说了容器的属性，这里我们再来了解一下项目的属性。</p>\n<ul>\n<li>order　　项目的排列顺序。数值越小，排列越靠前，默认为0。</li>\n<li>flex-grow　　项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>\n<li>flex-shrink　　项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>\n<li>flex-basis　　在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>\n<li>flex　　是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li>\n<li>align-self　　允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h1><p>在传统的网页布局模式中，我们使用的是盒模型，这种盒模型往往依赖dispaly属性，position属性，float属性，但是对于一些特殊布局这样的布局方式会非常的不方便，比如在垂直居中的时候，使用position布局就会非常不方便，而且使用float布局的话，后面我们还需要清除浮动，非常的不方便。</p>\n<h2 id=\"什么是flex布局\"><a href=\"#什么是flex布局\" class=\"headerlink\" title=\"什么是flex布局\"></a>什么是flex布局</h2><p>flex是Flexible Box的缩写，意思为弹性布局，在html中任何一个容器都可以被指定为flex布局。</p>\n<p><em>注意：</em></p>\n<p>html中，设置为flex布局之后，它的子元素<strong>float、clear、vertical-align</strong>属性将会失效</p>\n<h2 id=\"flex的基本概念\"><a href=\"#flex的基本概念\" class=\"headerlink\" title=\"flex的基本概念\"></a>flex的基本概念</h2><p>采用flex布局的元素，我们称之为容器，这个容器里面的所有子元素我们称之为容器成员，也就是flex项目，我们简称为项目。</p>\n<p>在flex容器中，存在两根轴，主轴和交叉轴；在主轴的开始位置我们称之为main start,结束位置我们称之为main end；交叉轴的开始位置叫做cross start,结束位置我们称之为cross end。</p>\n<p>主轴默认水平排列，交叉轴默认竖直排列，项目默认沿着主轴排列。单个项目占用主轴的空间叫做main size，单个项目占用交叉轴的空间叫做cross size。</p>\n<h2 id=\"容器的属性\"><a href=\"#容器的属性\" class=\"headerlink\" title=\"容器的属性\"></a>容器的属性</h2><p>下面列出容器的属性：</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<h3 id=\"flex-direction属性\"><a href=\"#flex-direction属性\" class=\"headerlink\" title=\"flex-direction属性\"></a>flex-direction属性</h3><p>flex-direction属性可以决定主轴的方向（也就是我们项目的排列方向），当主轴的排雷方向发生改变的时候，交叉轴的方向随之发生改变。</p>\n<pre><code>.div&#123;\n    flex-direction:row | row-reverse | colum | colum-reverse;\n&#125;\n</code></pre>\n<p>这个属性可能有四个值：</p>\n<ul>\n<li>row(默认值):主轴为水平方向，起点在左端。</li>\n<li>row-reverse:主轴为水平方向，起点在右端。</li>\n<li>column:主轴为垂直方向，起点在上面。</li>\n<li>colum-reverse:主轴为垂直方向，起点在下面。</li>\n</ul>\n<h3 id=\"flex-wrap属性\"><a href=\"#flex-wrap属性\" class=\"headerlink\" title=\"flex-wrap属性\"></a>flex-wrap属性</h3><p>在默认情况下，项目都是排列在主轴上的，当主轴的长度不够时，项目会换行。换行的方式我们可以通过flex-wrap属性来指定。</p>\n<pre><code>.div&#123;\n    flex-wrap:nowrap | wrap | wrap-reverse;\n&#125;\n</code></pre>\n<p>这个属性可以有三个值：</p>\n<ul>\n<li>nowrap(默认值):项目不会换行。</li>\n<li>wrap:换行，第一行会在上方。</li>\n<li>wrap-reverse:换行，第一行会在下方。</li>\n</ul>\n<h3 id=\"flex-flow属性\"><a href=\"#flex-flow属性\" class=\"headerlink\" title=\"flex-flow属性\"></a>flex-flow属性</h3><p>flex-flow属性可以同时指定flex-direction和flex-wrap属性。默认值是row nowrap。</p>\n<pre><code>.div&#123;\n    //flex-flow:&lt;flex-direction&gt; &lt;flex-wrap&gt;;\n    flex-flow:row nowrap;\n&#125;\n</code></pre>\n<h3 id=\"justify-content属性\"><a href=\"#justify-content属性\" class=\"headerlink\" title=\"justify-content属性\"></a>justify-content属性</h3><p>justify-content定义了项目在主轴上的对齐方式。</p>\n<pre><code>.div&#123;\n    justify-content:flex-start | flex-end | center | space-between | space-around;\n&#125;\n</code></pre>\n<p>这个属性可以有五个值：(具体对齐方式与主轴方向有关)</p>\n<ul>\n<li>flex-start:。从主轴的起点开始往终点排列项目。</li>\n<li>flex-end:。从主轴的终点开始往起点排列项目。</li>\n<li>center:。项目排列在主轴的中间。</li>\n<li>space-between:。项目排列在主轴的中间，两端对齐，项目之间的间隔都相等。</li>\n<li>space-around:。项目排列在主轴的中间，两端对齐，项目之间的间隔不相等(项目之间的距离是项目距离边框的两倍)。</li>\n</ul>\n<h3 id=\"algin-items属性\"><a href=\"#algin-items属性\" class=\"headerlink\" title=\"algin-items属性\"></a>algin-items属性</h3><p>algin-items定义了项目在交叉轴上的对齐方式。</p>\n<pre><code>.div&#123;\n    align-items:flex-start | flex-end | center | baseline | stretch;\n&#125;\n</code></pre>\n<p>这个属性可以有五个值：(具体对齐方式同样与交叉轴方向有关)</p>\n<ul>\n<li>flax-start:。项目在交叉轴的起点开始往终点排列。</li>\n<li>flex-end:。项目在交叉轴的终点开始往起点排列。</li>\n<li>center:。项目在交叉轴的中间。</li>\n<li>baseline:。项目在交叉轴的基线(也就是与项目第一行文字的基线对齐)。</li>\n<li>stretch:。项目在交叉轴的中间，并且占满交叉轴的空间(也就是如果项目没有设置高度或者设置为auto那么这个项目将会占满整个容器)。</li>\n</ul>\n<h3 id=\"align-content属性\"><a href=\"#align-content属性\" class=\"headerlink\" title=\"align-content属性\"></a>align-content属性</h3><p>align-content定义了<strong>多根轴线</strong>的对齐方式。如果项目只有一根轴线，那么这个属性就不会起作用。</p>\n<pre><code>.div&#123;\n    align-content:flex-start | flex-end | center | space-between | space-around | stretch;\n&#125;\n</code></pre>\n<p>这个属性可以有六个值：</p>\n<ul>\n<li>flex-start:从交叉轴的起点开始往终点排列。</li>\n<li>flex-end:从交叉轴的终点开始往起点排列。</li>\n<li>center:项目在交叉轴的中间。</li>\n<li>space-between:项目在交叉轴的中间，两端对齐，项目之间的间隔都相等。</li>\n<li>space-around:项目在交叉轴的中间，两端对齐，项目之间的间隔不相等(项目之间的距离是项目距离边框的两倍)。</li>\n<li>stretch:轴线占满整个交叉轴。</li>\n</ul>\n<h2 id=\"项目属性\"><a href=\"#项目属性\" class=\"headerlink\" title=\"项目属性\"></a>项目属性</h2><p>前面我们说了容器的属性，这里我们再来了解一下项目的属性。</p>\n<ul>\n<li>order　　项目的排列顺序。数值越小，排列越靠前，默认为0。</li>\n<li>flex-grow　　项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>\n<li>flex-shrink　　项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>\n<li>flex-basis　　在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>\n<li>flex　　是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li>\n<li>align-self　　允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>\n</ul>\n"},{"title":"jQuery中自定义动画","date":"2022-10-23T16:00:00.000Z","_content":"# jQuery中自定义动画\n\n在上一篇文章当中，我们讲述了jQuery中自带的一些动画属性，但是在开发中，产品经理提出的一些需求靠这些自带的动画，往往是实现不了的，这个时候，我们就需要自定义动画了。\n\n## 1. 自定义动画\n\n在jQuery中，自定义动画的方法是通过animate()方法来实现的，这个方法的参数是一个对象，对象中的属性是需要改变的样式，属性值是改变后的样式值。\n\n`$(selector).animate({params},speed,callback);`\n\n**解释：**\n\n- selector：必需。规定要添加动画效果的元素。\n- params：必需。规定形成动画效果的 CSS 属性集。[对象]\n- speed：可选。规定完成动画的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。\n- callback：可选。在动画完成时所执行的函数名称。\n\n注意看，在动画第二个参数中，我们传入的是一个对象，这个对象中的属性是需要改变的样式，属性值是改变后的样式值。  \n并且我们可以传入多个样式，来实现多个样式的动画。\n\n### 1.1动画操作多个属性\n\n我们可以通过animate()方式来为一个动画操作该元素的多个属性。\n\n```js\n    $('button').click(function(){\n        $('div').animate({\n            width:'300px',\n            height:'300px',\n            opacity:'0.5'\n        },1000);\n    });\n```\n\n代码解释：\n\n在上面的代码当中，我们为button绑定了一个点击事件，当点击button的时候，我们就会让div元素的宽度、高度、透明度都发生变化。  \n这里让这个动画在一秒内同时操作了div元素的宽度、高度、透明度，这样就实现了一个动画操作多个属性的效果。\n\n### 1.2动画中属性使用相对值\n\n是不是觉得每次为动画设置属性值很麻烦，因为这些都是基于浏览器默认的样式值，如果我们想要的效果是基于当前的样式值，那么我们就需要使用相对值来实现。\n\n使用相对值的方法就是在元素属性值前面加上+=或者-=，这样就可以实现相对值的效果。\n\n- +=：表示相对于当前元素增加\n- -=: 表示相对于当前元素减少\n\n```js\n    $('button').click(function(){\n        $('div').animate({\n            width:'+=300px',\n            height:'+=300px',\n        },1000);\n    });\n```\n\n代码解释：\n\n在上面的代码中，我们将div元素的宽度和高度都设置为相对值，将这个div元素的宽度和高度都增加300px。\n\n### 1.3动画中的队列功能\n\n其实在jQuery中，我们还可以同时为一个元素设置多个动画，这样就可以实现一个元素的多个动画效果。\n\n并且这些多花按照从上之下的顺序依次执行。\n\n```js\n    $('button').click(function(){\n        var div=$('div')；\n        div.animate({\n            width:'300px',\n            height:'300px',\n            opacity:'0.5'\n        },1000);\n        div.animate({\n            width:'600px',\n            height:'600px',\n            opacity:'1'\n        },1000);\n    });\n```\n\n这样极大的提高了我们的开发效率。\n\n## 2.动画停止\n\n在动画执行的过程中，我们可以随时停止。\n\n停止动画我们需要用到`stop`方法。\n\n`$(selector).stop(stopAll,goToEnd);`\n\n- 什么参数也没有：停止当前正在执行的动画，但是不清除队列中的动画。\n- 只有一个stopAll参数，当参数为true：停止当前正在执行的动画，并且清除队列中的动画；当参数为false:停止当前正在执行的动画，但是不清除队列中的动画。\n- goToEnd参数：当参数为true：停止当前正在执行的动画，并且清除队列中的动画，并且将动画的属性值设置为最终的值；当参数为false:停止当前正在执行的动画，但是不清除队列中的动画。\n\n```js\n$(document).ready(function(){\n    $(\"#btn1\").click(function(){\n        $(\"#panel\").slideDown(5000);\n    });\n    $(\"#bnt2\").click(function(){\n        // $(\"#panel\").stop();\n        // $(\"#panel\").stop(true);\n        // $(\"#panel\").stop(false);\n        // $(\"#panel\").stop(true,true);\n        $(\"#panel\").stop(false,true);\n    });\n});\n```\n\n上面停止动画的代码中，从上至下，我们分别使用了不同的参数来停止动画，可以看到不同的效果。\n\n## 3.动画回调函数\n\n在一些开发中，我们希望在动画完成之后，来执行一些操作，这时候我们就需要使用到动画回调函数。\n\n动画里面的回调函数，只会在动画执行完毕之后，才会被调用，这就避免了在动画执行的过程中，执行回调函数。\n\n```js\n    $('button').click(function(){\n        $('div').animate({\n            width:'300px',\n            height:'300px',\n            opacity:'0.5'\n        },1000,function(){\n            alert('动画执行完毕');\n        });\n    });\n``` \n\n代码解释：\n\n上面的代码中，在动画执行完毕之后，会弹出一个提示框，提示动画执行完毕。","source":"_posts/jQuery中自定义动画.md","raw":"---\ntitle: jQuery中自定义动画\ndate: 2022-10-24\ntags: [前端]\ncategories: [jQuery]\n---\n# jQuery中自定义动画\n\n在上一篇文章当中，我们讲述了jQuery中自带的一些动画属性，但是在开发中，产品经理提出的一些需求靠这些自带的动画，往往是实现不了的，这个时候，我们就需要自定义动画了。\n\n## 1. 自定义动画\n\n在jQuery中，自定义动画的方法是通过animate()方法来实现的，这个方法的参数是一个对象，对象中的属性是需要改变的样式，属性值是改变后的样式值。\n\n`$(selector).animate({params},speed,callback);`\n\n**解释：**\n\n- selector：必需。规定要添加动画效果的元素。\n- params：必需。规定形成动画效果的 CSS 属性集。[对象]\n- speed：可选。规定完成动画的时长。它可以取以下值：\"slow\"、\"fast\" 或毫秒。\n- callback：可选。在动画完成时所执行的函数名称。\n\n注意看，在动画第二个参数中，我们传入的是一个对象，这个对象中的属性是需要改变的样式，属性值是改变后的样式值。  \n并且我们可以传入多个样式，来实现多个样式的动画。\n\n### 1.1动画操作多个属性\n\n我们可以通过animate()方式来为一个动画操作该元素的多个属性。\n\n```js\n    $('button').click(function(){\n        $('div').animate({\n            width:'300px',\n            height:'300px',\n            opacity:'0.5'\n        },1000);\n    });\n```\n\n代码解释：\n\n在上面的代码当中，我们为button绑定了一个点击事件，当点击button的时候，我们就会让div元素的宽度、高度、透明度都发生变化。  \n这里让这个动画在一秒内同时操作了div元素的宽度、高度、透明度，这样就实现了一个动画操作多个属性的效果。\n\n### 1.2动画中属性使用相对值\n\n是不是觉得每次为动画设置属性值很麻烦，因为这些都是基于浏览器默认的样式值，如果我们想要的效果是基于当前的样式值，那么我们就需要使用相对值来实现。\n\n使用相对值的方法就是在元素属性值前面加上+=或者-=，这样就可以实现相对值的效果。\n\n- +=：表示相对于当前元素增加\n- -=: 表示相对于当前元素减少\n\n```js\n    $('button').click(function(){\n        $('div').animate({\n            width:'+=300px',\n            height:'+=300px',\n        },1000);\n    });\n```\n\n代码解释：\n\n在上面的代码中，我们将div元素的宽度和高度都设置为相对值，将这个div元素的宽度和高度都增加300px。\n\n### 1.3动画中的队列功能\n\n其实在jQuery中，我们还可以同时为一个元素设置多个动画，这样就可以实现一个元素的多个动画效果。\n\n并且这些多花按照从上之下的顺序依次执行。\n\n```js\n    $('button').click(function(){\n        var div=$('div')；\n        div.animate({\n            width:'300px',\n            height:'300px',\n            opacity:'0.5'\n        },1000);\n        div.animate({\n            width:'600px',\n            height:'600px',\n            opacity:'1'\n        },1000);\n    });\n```\n\n这样极大的提高了我们的开发效率。\n\n## 2.动画停止\n\n在动画执行的过程中，我们可以随时停止。\n\n停止动画我们需要用到`stop`方法。\n\n`$(selector).stop(stopAll,goToEnd);`\n\n- 什么参数也没有：停止当前正在执行的动画，但是不清除队列中的动画。\n- 只有一个stopAll参数，当参数为true：停止当前正在执行的动画，并且清除队列中的动画；当参数为false:停止当前正在执行的动画，但是不清除队列中的动画。\n- goToEnd参数：当参数为true：停止当前正在执行的动画，并且清除队列中的动画，并且将动画的属性值设置为最终的值；当参数为false:停止当前正在执行的动画，但是不清除队列中的动画。\n\n```js\n$(document).ready(function(){\n    $(\"#btn1\").click(function(){\n        $(\"#panel\").slideDown(5000);\n    });\n    $(\"#bnt2\").click(function(){\n        // $(\"#panel\").stop();\n        // $(\"#panel\").stop(true);\n        // $(\"#panel\").stop(false);\n        // $(\"#panel\").stop(true,true);\n        $(\"#panel\").stop(false,true);\n    });\n});\n```\n\n上面停止动画的代码中，从上至下，我们分别使用了不同的参数来停止动画，可以看到不同的效果。\n\n## 3.动画回调函数\n\n在一些开发中，我们希望在动画完成之后，来执行一些操作，这时候我们就需要使用到动画回调函数。\n\n动画里面的回调函数，只会在动画执行完毕之后，才会被调用，这就避免了在动画执行的过程中，执行回调函数。\n\n```js\n    $('button').click(function(){\n        $('div').animate({\n            width:'300px',\n            height:'300px',\n            opacity:'0.5'\n        },1000,function(){\n            alert('动画执行完毕');\n        });\n    });\n``` \n\n代码解释：\n\n上面的代码中，在动画执行完毕之后，会弹出一个提示框，提示动画执行完毕。","slug":"jQuery中自定义动画","published":1,"updated":"2023-01-09T12:48:47.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhe00189kbm8n42ea3k","content":"<h1 id=\"jQuery中自定义动画\"><a href=\"#jQuery中自定义动画\" class=\"headerlink\" title=\"jQuery中自定义动画\"></a>jQuery中自定义动画</h1><p>在上一篇文章当中，我们讲述了jQuery中自带的一些动画属性，但是在开发中，产品经理提出的一些需求靠这些自带的动画，往往是实现不了的，这个时候，我们就需要自定义动画了。</p>\n<h2 id=\"1-自定义动画\"><a href=\"#1-自定义动画\" class=\"headerlink\" title=\"1. 自定义动画\"></a>1. 自定义动画</h2><p>在jQuery中，自定义动画的方法是通过animate()方法来实现的，这个方法的参数是一个对象，对象中的属性是需要改变的样式，属性值是改变后的样式值。</p>\n<p><code>$(selector).animate(&#123;params&#125;,speed,callback);</code></p>\n<p><strong>解释：</strong></p>\n<ul>\n<li>selector：必需。规定要添加动画效果的元素。</li>\n<li>params：必需。规定形成动画效果的 CSS 属性集。[对象]</li>\n<li>speed：可选。规定完成动画的时长。它可以取以下值：”slow”、”fast” 或毫秒。</li>\n<li>callback：可选。在动画完成时所执行的函数名称。</li>\n</ul>\n<p>注意看，在动画第二个参数中，我们传入的是一个对象，这个对象中的属性是需要改变的样式，属性值是改变后的样式值。<br>并且我们可以传入多个样式，来实现多个样式的动画。</p>\n<h3 id=\"1-1动画操作多个属性\"><a href=\"#1-1动画操作多个属性\" class=\"headerlink\" title=\"1.1动画操作多个属性\"></a>1.1动画操作多个属性</h3><p>我们可以通过animate()方式来为一个动画操作该元素的多个属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;button&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;div&#x27;</span>).<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">opacity</span>:<span class=\"string\">&#x27;0.5&#x27;</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：</p>\n<p>在上面的代码当中，我们为button绑定了一个点击事件，当点击button的时候，我们就会让div元素的宽度、高度、透明度都发生变化。<br>这里让这个动画在一秒内同时操作了div元素的宽度、高度、透明度，这样就实现了一个动画操作多个属性的效果。</p>\n<h3 id=\"1-2动画中属性使用相对值\"><a href=\"#1-2动画中属性使用相对值\" class=\"headerlink\" title=\"1.2动画中属性使用相对值\"></a>1.2动画中属性使用相对值</h3><p>是不是觉得每次为动画设置属性值很麻烦，因为这些都是基于浏览器默认的样式值，如果我们想要的效果是基于当前的样式值，那么我们就需要使用相对值来实现。</p>\n<p>使用相对值的方法就是在元素属性值前面加上+&#x3D;或者-&#x3D;，这样就可以实现相对值的效果。</p>\n<ul>\n<li>+&#x3D;：表示相对于当前元素增加</li>\n<li>-&#x3D;: 表示相对于当前元素减少</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;button&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;div&#x27;</span>).<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;+=300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;+=300px&#x27;</span>,</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：</p>\n<p>在上面的代码中，我们将div元素的宽度和高度都设置为相对值，将这个div元素的宽度和高度都增加300px。</p>\n<h3 id=\"1-3动画中的队列功能\"><a href=\"#1-3动画中的队列功能\" class=\"headerlink\" title=\"1.3动画中的队列功能\"></a>1.3动画中的队列功能</h3><p>其实在jQuery中，我们还可以同时为一个元素设置多个动画，这样就可以实现一个元素的多个动画效果。</p>\n<p>并且这些多花按照从上之下的顺序依次执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;button&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> div=$(<span class=\"string\">&#x27;div&#x27;</span>)；</span><br><span class=\"line\">    div.<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">opacity</span>:<span class=\"string\">&#x27;0.5&#x27;</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    div.<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;600px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;600px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">opacity</span>:<span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样极大的提高了我们的开发效率。</p>\n<h2 id=\"2-动画停止\"><a href=\"#2-动画停止\" class=\"headerlink\" title=\"2.动画停止\"></a>2.动画停止</h2><p>在动画执行的过程中，我们可以随时停止。</p>\n<p>停止动画我们需要用到<code>stop</code>方法。</p>\n<p><code>$(selector).stop(stopAll,goToEnd);</code></p>\n<ul>\n<li>什么参数也没有：停止当前正在执行的动画，但是不清除队列中的动画。</li>\n<li>只有一个stopAll参数，当参数为true：停止当前正在执行的动画，并且清除队列中的动画；当参数为false:停止当前正在执行的动画，但是不清除队列中的动画。</li>\n<li>goToEnd参数：当参数为true：停止当前正在执行的动画，并且清除队列中的动画，并且将动画的属性值设置为最终的值；当参数为false:停止当前正在执行的动画，但是不清除队列中的动画。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn1&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#panel&quot;</span>).<span class=\"title function_\">slideDown</span>(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#bnt2&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// $(&quot;#panel&quot;).stop();</span></span><br><span class=\"line\">        <span class=\"comment\">// $(&quot;#panel&quot;).stop(true);</span></span><br><span class=\"line\">        <span class=\"comment\">// $(&quot;#panel&quot;).stop(false);</span></span><br><span class=\"line\">        <span class=\"comment\">// $(&quot;#panel&quot;).stop(true,true);</span></span><br><span class=\"line\">        $(<span class=\"string\">&quot;#panel&quot;</span>).<span class=\"title function_\">stop</span>(<span class=\"literal\">false</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面停止动画的代码中，从上至下，我们分别使用了不同的参数来停止动画，可以看到不同的效果。</p>\n<h2 id=\"3-动画回调函数\"><a href=\"#3-动画回调函数\" class=\"headerlink\" title=\"3.动画回调函数\"></a>3.动画回调函数</h2><p>在一些开发中，我们希望在动画完成之后，来执行一些操作，这时候我们就需要使用到动画回调函数。</p>\n<p>动画里面的回调函数，只会在动画执行完毕之后，才会被调用，这就避免了在动画执行的过程中，执行回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;button&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;div&#x27;</span>).<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">opacity</span>:<span class=\"string\">&#x27;0.5&#x27;</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;动画执行完毕&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：</p>\n<p>上面的代码中，在动画执行完毕之后，会弹出一个提示框，提示动画执行完毕。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jQuery中自定义动画\"><a href=\"#jQuery中自定义动画\" class=\"headerlink\" title=\"jQuery中自定义动画\"></a>jQuery中自定义动画</h1><p>在上一篇文章当中，我们讲述了jQuery中自带的一些动画属性，但是在开发中，产品经理提出的一些需求靠这些自带的动画，往往是实现不了的，这个时候，我们就需要自定义动画了。</p>\n<h2 id=\"1-自定义动画\"><a href=\"#1-自定义动画\" class=\"headerlink\" title=\"1. 自定义动画\"></a>1. 自定义动画</h2><p>在jQuery中，自定义动画的方法是通过animate()方法来实现的，这个方法的参数是一个对象，对象中的属性是需要改变的样式，属性值是改变后的样式值。</p>\n<p><code>$(selector).animate(&#123;params&#125;,speed,callback);</code></p>\n<p><strong>解释：</strong></p>\n<ul>\n<li>selector：必需。规定要添加动画效果的元素。</li>\n<li>params：必需。规定形成动画效果的 CSS 属性集。[对象]</li>\n<li>speed：可选。规定完成动画的时长。它可以取以下值：”slow”、”fast” 或毫秒。</li>\n<li>callback：可选。在动画完成时所执行的函数名称。</li>\n</ul>\n<p>注意看，在动画第二个参数中，我们传入的是一个对象，这个对象中的属性是需要改变的样式，属性值是改变后的样式值。<br>并且我们可以传入多个样式，来实现多个样式的动画。</p>\n<h3 id=\"1-1动画操作多个属性\"><a href=\"#1-1动画操作多个属性\" class=\"headerlink\" title=\"1.1动画操作多个属性\"></a>1.1动画操作多个属性</h3><p>我们可以通过animate()方式来为一个动画操作该元素的多个属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;button&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;div&#x27;</span>).<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">opacity</span>:<span class=\"string\">&#x27;0.5&#x27;</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：</p>\n<p>在上面的代码当中，我们为button绑定了一个点击事件，当点击button的时候，我们就会让div元素的宽度、高度、透明度都发生变化。<br>这里让这个动画在一秒内同时操作了div元素的宽度、高度、透明度，这样就实现了一个动画操作多个属性的效果。</p>\n<h3 id=\"1-2动画中属性使用相对值\"><a href=\"#1-2动画中属性使用相对值\" class=\"headerlink\" title=\"1.2动画中属性使用相对值\"></a>1.2动画中属性使用相对值</h3><p>是不是觉得每次为动画设置属性值很麻烦，因为这些都是基于浏览器默认的样式值，如果我们想要的效果是基于当前的样式值，那么我们就需要使用相对值来实现。</p>\n<p>使用相对值的方法就是在元素属性值前面加上+&#x3D;或者-&#x3D;，这样就可以实现相对值的效果。</p>\n<ul>\n<li>+&#x3D;：表示相对于当前元素增加</li>\n<li>-&#x3D;: 表示相对于当前元素减少</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;button&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;div&#x27;</span>).<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;+=300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;+=300px&#x27;</span>,</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：</p>\n<p>在上面的代码中，我们将div元素的宽度和高度都设置为相对值，将这个div元素的宽度和高度都增加300px。</p>\n<h3 id=\"1-3动画中的队列功能\"><a href=\"#1-3动画中的队列功能\" class=\"headerlink\" title=\"1.3动画中的队列功能\"></a>1.3动画中的队列功能</h3><p>其实在jQuery中，我们还可以同时为一个元素设置多个动画，这样就可以实现一个元素的多个动画效果。</p>\n<p>并且这些多花按照从上之下的顺序依次执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;button&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> div=$(<span class=\"string\">&#x27;div&#x27;</span>)；</span><br><span class=\"line\">    div.<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">opacity</span>:<span class=\"string\">&#x27;0.5&#x27;</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    div.<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;600px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;600px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">opacity</span>:<span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样极大的提高了我们的开发效率。</p>\n<h2 id=\"2-动画停止\"><a href=\"#2-动画停止\" class=\"headerlink\" title=\"2.动画停止\"></a>2.动画停止</h2><p>在动画执行的过程中，我们可以随时停止。</p>\n<p>停止动画我们需要用到<code>stop</code>方法。</p>\n<p><code>$(selector).stop(stopAll,goToEnd);</code></p>\n<ul>\n<li>什么参数也没有：停止当前正在执行的动画，但是不清除队列中的动画。</li>\n<li>只有一个stopAll参数，当参数为true：停止当前正在执行的动画，并且清除队列中的动画；当参数为false:停止当前正在执行的动画，但是不清除队列中的动画。</li>\n<li>goToEnd参数：当参数为true：停止当前正在执行的动画，并且清除队列中的动画，并且将动画的属性值设置为最终的值；当参数为false:停止当前正在执行的动画，但是不清除队列中的动画。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#btn1&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        $(<span class=\"string\">&quot;#panel&quot;</span>).<span class=\"title function_\">slideDown</span>(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#bnt2&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// $(&quot;#panel&quot;).stop();</span></span><br><span class=\"line\">        <span class=\"comment\">// $(&quot;#panel&quot;).stop(true);</span></span><br><span class=\"line\">        <span class=\"comment\">// $(&quot;#panel&quot;).stop(false);</span></span><br><span class=\"line\">        <span class=\"comment\">// $(&quot;#panel&quot;).stop(true,true);</span></span><br><span class=\"line\">        $(<span class=\"string\">&quot;#panel&quot;</span>).<span class=\"title function_\">stop</span>(<span class=\"literal\">false</span>,<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面停止动画的代码中，从上至下，我们分别使用了不同的参数来停止动画，可以看到不同的效果。</p>\n<h2 id=\"3-动画回调函数\"><a href=\"#3-动画回调函数\" class=\"headerlink\" title=\"3.动画回调函数\"></a>3.动画回调函数</h2><p>在一些开发中，我们希望在动画完成之后，来执行一些操作，这时候我们就需要使用到动画回调函数。</p>\n<p>动画里面的回调函数，只会在动画执行完毕之后，才会被调用，这就避免了在动画执行的过程中，执行回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;button&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;div&#x27;</span>).<span class=\"title function_\">animate</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">width</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">height</span>:<span class=\"string\">&#x27;300px&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">opacity</span>:<span class=\"string\">&#x27;0.5&#x27;</span></span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;动画执行完毕&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：</p>\n<p>上面的代码中，在动画执行完毕之后，会弹出一个提示框，提示动画执行完毕。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-01-09T14:00:27.879Z","updated":"2023-01-08T08:15:42.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhf001b9kbmcwwu1gh6","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"jQuery引入及其选择器","date":"2022-09-29T16:00:00.000Z","_content":"# jQuery引入及其选择器\n\njQuery是JS的一个库，它里面封装了一些我们开发中常用的一些功能；它提供了一些方便的选择器，可以让我们更方便的操作DOM。\n\n在我们使用中，只需要引入jQuery的js文件，就可以使用jQuery的选择器了。\n\n## jQuery的使用\n\njQuery的使用分为三步：\n\n- 引入jQuery的js文件\n- 写入口函数\n- 写功能的实现代码（事件处理函数）\n\n```js\n    // 引入jQuery的js文件\n    <script src=\"jquery-3.2.1.js\"></script>\n    // 写入口函数\n     $(document).ready(function () {\n        // 写功能的实现代码（事件处理函数）\n            $('#show').click(function () {\n                $('p').show();\n            })\n        });\n```\n\n### 书写入口函数的集中写法\n\n1. $(document).ready(function () {});  \n   适用于文档加载完毕，图片还未加载的时候执行此函数\n2. $(function () {});  \n   适用于文档加载完毕，图片未加载的时候执行此函数\n3. $(window).ready(function(){});  \n   适用于文档加载完毕，图片也加载完毕的时候执行此函数\n\n## jQuery的选择器\n\n1. 基本选择器\n\n|      符号      |                 说明                 |      用法      |\n| :------------: | :----------------------------------: | :------------: |\n|   $('#demo')   |       选择id为demo的第一个元素       |   $('#test')   |\n|   $('.demo')   |       选择所有类名为demo的元素       |   $('.test')   |\n|  $('tagName')  |      选择所有对应标签名的元素怒      |    $('div')    |\n|     $('*')     |             选择所有元素             |     $('*')     |\n| $('.demo,div') | 选择多个指定元素，中间使用逗逗号间隔 | $('.test,div') |\n\n其中ID选择器、类选择器、标签选择器比较重要。\n\n2. 层级选择器\n\n| 符号  |                说明                |     用法      |\n| :---: | :--------------------------------: | :-----------: |\n| 空格  |   后代选择器，选择所有的后代元素   |  $('div p')   |\n|   >   |   自带选择器，选择所有的子代元素   | $('div span') |\n|   +   |       选择紧挨着的下一个元素       |  $('div+p')   |\n|   ~   | 兄弟选择器，选择后面所有的兄弟元素 |  $('div~p')   |\n\n3. 过滤选择器\n\n|    符号    |               说明                |      用法      |\n| :--------: | :-------------------------------: | :------------: |\n| :eq(index) | 选择序号为index的元素，匹配第一个 |  $(li:eq(4))   |\n| :gt(index) |      选择序号大于index的元素      | $('li:gt:(3)') |\n| :lt(index) |     选择序号小于index的远元素     | $('li:lt(2)')  |\n|    :odd    |       选择序号为奇数的元素        |  $('ul:odd')   |\n|   :even    |       选择序号为偶数的元素        |  $('ul:even')  |\n|   :first   |       选择匹配的第一个元素        | $('div:first') |\n|   :last    |      悬着匹配的最后一个元素       |  $('p:last')   |\n\n上面表格中，所有的index都是大于或者等于0的整数，代表着索引号。\n\n4.属性选择器\n\n|            符号            |                    说明                    |          用法           |\n| :------------------------: | :----------------------------------------: | :---------------------: |\n|      $('标签[属性]')       |          选择所有包含此属性的标签          |      $('a[href]')       |\n|   $('标签[属性 = \"值\"]')   |   选择所有包含此属性且属性值相匹配的标签   | $('div[class = \"box\"]') |\n|  $('标签[属性 != \"值\"]')   | 选择所有包含该属性且属性值不相匹配的该标签 | $(div[class != \"box\"])  |\n| $('标签[属性 ^= \"value\"]') |   选择所有该属性值以value开头的对应标签    |  $('div[id ^= \"vm\"]')   |\n| $('标签[属性 $= \"value\"]') |   选择所有该属性值以value结尾的对应标签    |  $('p[class $= \"qw\"]')  |\n| $('标签[属性 *= \"value\"]') | 选择所有包含该属性且值包含value的对应标签  | $('div [class *= 'o']') |\n\n5. 筛选选择器\n\n|       符号       |                     说明                     |                    用法                    |\n| :--------------: | :------------------------------------------: | :----------------------------------------: |\n|      find()      |        选择指定元素的所欲所有后代元素        | $('ul').find('li') 选择ul所有的后代元素li  |\n| children('标签') |             选择指定元素的子元素             | $('ul').children('li')选择ul所有的子代元素 |\n|    siblings()    |              查找所有的兄弟元素              |             $('ul').siblings()             |\n|     parent()     |                 查找亲父元素                 |              $('ul').parent()              |\n|    eq(index)     | 查找指定元素的第index+1个元素，index为所索引 |                $('ul').e(3)                |","source":"_posts/jQuery选择器.md","raw":"---\ntitle: jQuery引入及其选择器\ndate: 2022-9-30\ntags: [前端]\ncategories: [jQuery]\n---\n# jQuery引入及其选择器\n\njQuery是JS的一个库，它里面封装了一些我们开发中常用的一些功能；它提供了一些方便的选择器，可以让我们更方便的操作DOM。\n\n在我们使用中，只需要引入jQuery的js文件，就可以使用jQuery的选择器了。\n\n## jQuery的使用\n\njQuery的使用分为三步：\n\n- 引入jQuery的js文件\n- 写入口函数\n- 写功能的实现代码（事件处理函数）\n\n```js\n    // 引入jQuery的js文件\n    <script src=\"jquery-3.2.1.js\"></script>\n    // 写入口函数\n     $(document).ready(function () {\n        // 写功能的实现代码（事件处理函数）\n            $('#show').click(function () {\n                $('p').show();\n            })\n        });\n```\n\n### 书写入口函数的集中写法\n\n1. $(document).ready(function () {});  \n   适用于文档加载完毕，图片还未加载的时候执行此函数\n2. $(function () {});  \n   适用于文档加载完毕，图片未加载的时候执行此函数\n3. $(window).ready(function(){});  \n   适用于文档加载完毕，图片也加载完毕的时候执行此函数\n\n## jQuery的选择器\n\n1. 基本选择器\n\n|      符号      |                 说明                 |      用法      |\n| :------------: | :----------------------------------: | :------------: |\n|   $('#demo')   |       选择id为demo的第一个元素       |   $('#test')   |\n|   $('.demo')   |       选择所有类名为demo的元素       |   $('.test')   |\n|  $('tagName')  |      选择所有对应标签名的元素怒      |    $('div')    |\n|     $('*')     |             选择所有元素             |     $('*')     |\n| $('.demo,div') | 选择多个指定元素，中间使用逗逗号间隔 | $('.test,div') |\n\n其中ID选择器、类选择器、标签选择器比较重要。\n\n2. 层级选择器\n\n| 符号  |                说明                |     用法      |\n| :---: | :--------------------------------: | :-----------: |\n| 空格  |   后代选择器，选择所有的后代元素   |  $('div p')   |\n|   >   |   自带选择器，选择所有的子代元素   | $('div span') |\n|   +   |       选择紧挨着的下一个元素       |  $('div+p')   |\n|   ~   | 兄弟选择器，选择后面所有的兄弟元素 |  $('div~p')   |\n\n3. 过滤选择器\n\n|    符号    |               说明                |      用法      |\n| :--------: | :-------------------------------: | :------------: |\n| :eq(index) | 选择序号为index的元素，匹配第一个 |  $(li:eq(4))   |\n| :gt(index) |      选择序号大于index的元素      | $('li:gt:(3)') |\n| :lt(index) |     选择序号小于index的远元素     | $('li:lt(2)')  |\n|    :odd    |       选择序号为奇数的元素        |  $('ul:odd')   |\n|   :even    |       选择序号为偶数的元素        |  $('ul:even')  |\n|   :first   |       选择匹配的第一个元素        | $('div:first') |\n|   :last    |      悬着匹配的最后一个元素       |  $('p:last')   |\n\n上面表格中，所有的index都是大于或者等于0的整数，代表着索引号。\n\n4.属性选择器\n\n|            符号            |                    说明                    |          用法           |\n| :------------------------: | :----------------------------------------: | :---------------------: |\n|      $('标签[属性]')       |          选择所有包含此属性的标签          |      $('a[href]')       |\n|   $('标签[属性 = \"值\"]')   |   选择所有包含此属性且属性值相匹配的标签   | $('div[class = \"box\"]') |\n|  $('标签[属性 != \"值\"]')   | 选择所有包含该属性且属性值不相匹配的该标签 | $(div[class != \"box\"])  |\n| $('标签[属性 ^= \"value\"]') |   选择所有该属性值以value开头的对应标签    |  $('div[id ^= \"vm\"]')   |\n| $('标签[属性 $= \"value\"]') |   选择所有该属性值以value结尾的对应标签    |  $('p[class $= \"qw\"]')  |\n| $('标签[属性 *= \"value\"]') | 选择所有包含该属性且值包含value的对应标签  | $('div [class *= 'o']') |\n\n5. 筛选选择器\n\n|       符号       |                     说明                     |                    用法                    |\n| :--------------: | :------------------------------------------: | :----------------------------------------: |\n|      find()      |        选择指定元素的所欲所有后代元素        | $('ul').find('li') 选择ul所有的后代元素li  |\n| children('标签') |             选择指定元素的子元素             | $('ul').children('li')选择ul所有的子代元素 |\n|    siblings()    |              查找所有的兄弟元素              |             $('ul').siblings()             |\n|     parent()     |                 查找亲父元素                 |              $('ul').parent()              |\n|    eq(index)     | 查找指定元素的第index+1个元素，index为所索引 |                $('ul').e(3)                |","slug":"jQuery选择器","published":1,"updated":"2023-01-09T12:16:41.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhg001f9kbm8pyyhnvf","content":"<h1 id=\"jQuery引入及其选择器\"><a href=\"#jQuery引入及其选择器\" class=\"headerlink\" title=\"jQuery引入及其选择器\"></a>jQuery引入及其选择器</h1><p>jQuery是JS的一个库，它里面封装了一些我们开发中常用的一些功能；它提供了一些方便的选择器，可以让我们更方便的操作DOM。</p>\n<p>在我们使用中，只需要引入jQuery的js文件，就可以使用jQuery的选择器了。</p>\n<h2 id=\"jQuery的使用\"><a href=\"#jQuery的使用\" class=\"headerlink\" title=\"jQuery的使用\"></a>jQuery的使用</h2><p>jQuery的使用分为三步：</p>\n<ul>\n<li>引入jQuery的js文件</li>\n<li>写入口函数</li>\n<li>写功能的实现代码（事件处理函数）</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入jQuery的js文件</span></span><br><span class=\"line\">&lt;script src=<span class=\"string\">&quot;jquery-3.2.1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"comment\">// 写入口函数</span></span><br><span class=\"line\"> $(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 写功能的实现代码（事件处理函数）</span></span><br><span class=\"line\">        $(<span class=\"string\">&#x27;#show&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            $(<span class=\"string\">&#x27;p&#x27;</span>).<span class=\"title function_\">show</span>();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"书写入口函数的集中写法\"><a href=\"#书写入口函数的集中写法\" class=\"headerlink\" title=\"书写入口函数的集中写法\"></a>书写入口函数的集中写法</h3><ol>\n<li>$(document).ready(function () {});<br>适用于文档加载完毕，图片还未加载的时候执行此函数</li>\n<li>$(function () {});<br>适用于文档加载完毕，图片未加载的时候执行此函数</li>\n<li>$(window).ready(function(){});<br>适用于文档加载完毕，图片也加载完毕的时候执行此函数</li>\n</ol>\n<h2 id=\"jQuery的选择器\"><a href=\"#jQuery的选择器\" class=\"headerlink\" title=\"jQuery的选择器\"></a>jQuery的选择器</h2><ol>\n<li>基本选择器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$(‘#demo’)</td>\n<td align=\"center\">选择id为demo的第一个元素</td>\n<td align=\"center\">$(‘#test’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘.demo’)</td>\n<td align=\"center\">选择所有类名为demo的元素</td>\n<td align=\"center\">$(‘.test’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘tagName’)</td>\n<td align=\"center\">选择所有对应标签名的元素怒</td>\n<td align=\"center\">$(‘div’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘*’)</td>\n<td align=\"center\">选择所有元素</td>\n<td align=\"center\">$(‘*’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘.demo,div’)</td>\n<td align=\"center\">选择多个指定元素，中间使用逗逗号间隔</td>\n<td align=\"center\">$(‘.test,div’)</td>\n</tr>\n</tbody></table>\n<p>其中ID选择器、类选择器、标签选择器比较重要。</p>\n<ol start=\"2\">\n<li>层级选择器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">空格</td>\n<td align=\"center\">后代选择器，选择所有的后代元素</td>\n<td align=\"center\">$(‘div p’)</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;</td>\n<td align=\"center\">自带选择器，选择所有的子代元素</td>\n<td align=\"center\">$(‘div span’)</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">选择紧挨着的下一个元素</td>\n<td align=\"center\">$(‘div+p’)</td>\n</tr>\n<tr>\n<td align=\"center\">~</td>\n<td align=\"center\">兄弟选择器，选择后面所有的兄弟元素</td>\n<td align=\"center\">$(‘div~p’)</td>\n</tr>\n</tbody></table>\n<ol start=\"3\">\n<li>过滤选择器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">:eq(index)</td>\n<td align=\"center\">选择序号为index的元素，匹配第一个</td>\n<td align=\"center\">$(li:eq(4))</td>\n</tr>\n<tr>\n<td align=\"center\">:gt(index)</td>\n<td align=\"center\">选择序号大于index的元素</td>\n<td align=\"center\">$(‘li:gt:(3)’)</td>\n</tr>\n<tr>\n<td align=\"center\">:lt(index)</td>\n<td align=\"center\">选择序号小于index的远元素</td>\n<td align=\"center\">$(‘li:lt(2)’)</td>\n</tr>\n<tr>\n<td align=\"center\">:odd</td>\n<td align=\"center\">选择序号为奇数的元素</td>\n<td align=\"center\">$(‘ul:odd’)</td>\n</tr>\n<tr>\n<td align=\"center\">:even</td>\n<td align=\"center\">选择序号为偶数的元素</td>\n<td align=\"center\">$(‘ul:even’)</td>\n</tr>\n<tr>\n<td align=\"center\">:first</td>\n<td align=\"center\">选择匹配的第一个元素</td>\n<td align=\"center\">$(‘div:first’)</td>\n</tr>\n<tr>\n<td align=\"center\">:last</td>\n<td align=\"center\">悬着匹配的最后一个元素</td>\n<td align=\"center\">$(‘p:last’)</td>\n</tr>\n</tbody></table>\n<p>上面表格中，所有的index都是大于或者等于0的整数，代表着索引号。</p>\n<p>4.属性选择器</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$(‘标签[属性]’)</td>\n<td align=\"center\">选择所有包含此属性的标签</td>\n<td align=\"center\">$(‘a[href]’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 &#x3D; “值”]’)</td>\n<td align=\"center\">选择所有包含此属性且属性值相匹配的标签</td>\n<td align=\"center\">$(‘div[class &#x3D; “box”]’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 !&#x3D; “值”]’)</td>\n<td align=\"center\">选择所有包含该属性且属性值不相匹配的该标签</td>\n<td align=\"center\">$(div[class !&#x3D; “box”])</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 ^&#x3D; “value”]’)</td>\n<td align=\"center\">选择所有该属性值以value开头的对应标签</td>\n<td align=\"center\">$(‘div[id ^&#x3D; “vm”]’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 $&#x3D; “value”]’)</td>\n<td align=\"center\">选择所有该属性值以value结尾的对应标签</td>\n<td align=\"center\">$(‘p[class $&#x3D; “qw”]’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 *&#x3D; “value”]’)</td>\n<td align=\"center\">选择所有包含该属性且值包含value的对应标签</td>\n<td align=\"center\">$(‘div [class *&#x3D; ‘o’]’)</td>\n</tr>\n</tbody></table>\n<ol start=\"5\">\n<li>筛选选择器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">find()</td>\n<td align=\"center\">选择指定元素的所欲所有后代元素</td>\n<td align=\"center\">$(‘ul’).find(‘li’) 选择ul所有的后代元素li</td>\n</tr>\n<tr>\n<td align=\"center\">children(‘标签’)</td>\n<td align=\"center\">选择指定元素的子元素</td>\n<td align=\"center\">$(‘ul’).children(‘li’)选择ul所有的子代元素</td>\n</tr>\n<tr>\n<td align=\"center\">siblings()</td>\n<td align=\"center\">查找所有的兄弟元素</td>\n<td align=\"center\">$(‘ul’).siblings()</td>\n</tr>\n<tr>\n<td align=\"center\">parent()</td>\n<td align=\"center\">查找亲父元素</td>\n<td align=\"center\">$(‘ul’).parent()</td>\n</tr>\n<tr>\n<td align=\"center\">eq(index)</td>\n<td align=\"center\">查找指定元素的第index+1个元素，index为所索引</td>\n<td align=\"center\">$(‘ul’).e(3)</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jQuery引入及其选择器\"><a href=\"#jQuery引入及其选择器\" class=\"headerlink\" title=\"jQuery引入及其选择器\"></a>jQuery引入及其选择器</h1><p>jQuery是JS的一个库，它里面封装了一些我们开发中常用的一些功能；它提供了一些方便的选择器，可以让我们更方便的操作DOM。</p>\n<p>在我们使用中，只需要引入jQuery的js文件，就可以使用jQuery的选择器了。</p>\n<h2 id=\"jQuery的使用\"><a href=\"#jQuery的使用\" class=\"headerlink\" title=\"jQuery的使用\"></a>jQuery的使用</h2><p>jQuery的使用分为三步：</p>\n<ul>\n<li>引入jQuery的js文件</li>\n<li>写入口函数</li>\n<li>写功能的实现代码（事件处理函数）</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入jQuery的js文件</span></span><br><span class=\"line\">&lt;script src=<span class=\"string\">&quot;jquery-3.2.1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"comment\">// 写入口函数</span></span><br><span class=\"line\"> $(<span class=\"variable language_\">document</span>).<span class=\"title function_\">ready</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 写功能的实现代码（事件处理函数）</span></span><br><span class=\"line\">        $(<span class=\"string\">&#x27;#show&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            $(<span class=\"string\">&#x27;p&#x27;</span>).<span class=\"title function_\">show</span>();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"书写入口函数的集中写法\"><a href=\"#书写入口函数的集中写法\" class=\"headerlink\" title=\"书写入口函数的集中写法\"></a>书写入口函数的集中写法</h3><ol>\n<li>$(document).ready(function () {});<br>适用于文档加载完毕，图片还未加载的时候执行此函数</li>\n<li>$(function () {});<br>适用于文档加载完毕，图片未加载的时候执行此函数</li>\n<li>$(window).ready(function(){});<br>适用于文档加载完毕，图片也加载完毕的时候执行此函数</li>\n</ol>\n<h2 id=\"jQuery的选择器\"><a href=\"#jQuery的选择器\" class=\"headerlink\" title=\"jQuery的选择器\"></a>jQuery的选择器</h2><ol>\n<li>基本选择器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$(‘#demo’)</td>\n<td align=\"center\">选择id为demo的第一个元素</td>\n<td align=\"center\">$(‘#test’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘.demo’)</td>\n<td align=\"center\">选择所有类名为demo的元素</td>\n<td align=\"center\">$(‘.test’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘tagName’)</td>\n<td align=\"center\">选择所有对应标签名的元素怒</td>\n<td align=\"center\">$(‘div’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘*’)</td>\n<td align=\"center\">选择所有元素</td>\n<td align=\"center\">$(‘*’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘.demo,div’)</td>\n<td align=\"center\">选择多个指定元素，中间使用逗逗号间隔</td>\n<td align=\"center\">$(‘.test,div’)</td>\n</tr>\n</tbody></table>\n<p>其中ID选择器、类选择器、标签选择器比较重要。</p>\n<ol start=\"2\">\n<li>层级选择器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">空格</td>\n<td align=\"center\">后代选择器，选择所有的后代元素</td>\n<td align=\"center\">$(‘div p’)</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;</td>\n<td align=\"center\">自带选择器，选择所有的子代元素</td>\n<td align=\"center\">$(‘div span’)</td>\n</tr>\n<tr>\n<td align=\"center\">+</td>\n<td align=\"center\">选择紧挨着的下一个元素</td>\n<td align=\"center\">$(‘div+p’)</td>\n</tr>\n<tr>\n<td align=\"center\">~</td>\n<td align=\"center\">兄弟选择器，选择后面所有的兄弟元素</td>\n<td align=\"center\">$(‘div~p’)</td>\n</tr>\n</tbody></table>\n<ol start=\"3\">\n<li>过滤选择器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">:eq(index)</td>\n<td align=\"center\">选择序号为index的元素，匹配第一个</td>\n<td align=\"center\">$(li:eq(4))</td>\n</tr>\n<tr>\n<td align=\"center\">:gt(index)</td>\n<td align=\"center\">选择序号大于index的元素</td>\n<td align=\"center\">$(‘li:gt:(3)’)</td>\n</tr>\n<tr>\n<td align=\"center\">:lt(index)</td>\n<td align=\"center\">选择序号小于index的远元素</td>\n<td align=\"center\">$(‘li:lt(2)’)</td>\n</tr>\n<tr>\n<td align=\"center\">:odd</td>\n<td align=\"center\">选择序号为奇数的元素</td>\n<td align=\"center\">$(‘ul:odd’)</td>\n</tr>\n<tr>\n<td align=\"center\">:even</td>\n<td align=\"center\">选择序号为偶数的元素</td>\n<td align=\"center\">$(‘ul:even’)</td>\n</tr>\n<tr>\n<td align=\"center\">:first</td>\n<td align=\"center\">选择匹配的第一个元素</td>\n<td align=\"center\">$(‘div:first’)</td>\n</tr>\n<tr>\n<td align=\"center\">:last</td>\n<td align=\"center\">悬着匹配的最后一个元素</td>\n<td align=\"center\">$(‘p:last’)</td>\n</tr>\n</tbody></table>\n<p>上面表格中，所有的index都是大于或者等于0的整数，代表着索引号。</p>\n<p>4.属性选择器</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">$(‘标签[属性]’)</td>\n<td align=\"center\">选择所有包含此属性的标签</td>\n<td align=\"center\">$(‘a[href]’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 &#x3D; “值”]’)</td>\n<td align=\"center\">选择所有包含此属性且属性值相匹配的标签</td>\n<td align=\"center\">$(‘div[class &#x3D; “box”]’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 !&#x3D; “值”]’)</td>\n<td align=\"center\">选择所有包含该属性且属性值不相匹配的该标签</td>\n<td align=\"center\">$(div[class !&#x3D; “box”])</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 ^&#x3D; “value”]’)</td>\n<td align=\"center\">选择所有该属性值以value开头的对应标签</td>\n<td align=\"center\">$(‘div[id ^&#x3D; “vm”]’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 $&#x3D; “value”]’)</td>\n<td align=\"center\">选择所有该属性值以value结尾的对应标签</td>\n<td align=\"center\">$(‘p[class $&#x3D; “qw”]’)</td>\n</tr>\n<tr>\n<td align=\"center\">$(‘标签[属性 *&#x3D; “value”]’)</td>\n<td align=\"center\">选择所有包含该属性且值包含value的对应标签</td>\n<td align=\"center\">$(‘div [class *&#x3D; ‘o’]’)</td>\n</tr>\n</tbody></table>\n<ol start=\"5\">\n<li>筛选选择器</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">说明</th>\n<th align=\"center\">用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">find()</td>\n<td align=\"center\">选择指定元素的所欲所有后代元素</td>\n<td align=\"center\">$(‘ul’).find(‘li’) 选择ul所有的后代元素li</td>\n</tr>\n<tr>\n<td align=\"center\">children(‘标签’)</td>\n<td align=\"center\">选择指定元素的子元素</td>\n<td align=\"center\">$(‘ul’).children(‘li’)选择ul所有的子代元素</td>\n</tr>\n<tr>\n<td align=\"center\">siblings()</td>\n<td align=\"center\">查找所有的兄弟元素</td>\n<td align=\"center\">$(‘ul’).siblings()</td>\n</tr>\n<tr>\n<td align=\"center\">parent()</td>\n<td align=\"center\">查找亲父元素</td>\n<td align=\"center\">$(‘ul’).parent()</td>\n</tr>\n<tr>\n<td align=\"center\">eq(index)</td>\n<td align=\"center\">查找指定元素的第index+1个元素，index为所索引</td>\n<td align=\"center\">$(‘ul’).e(3)</td>\n</tr>\n</tbody></table>\n"},{"title":"v-if与v-show的使用方法以及区别","date":"2022-10-18T16:00:00.000Z","_content":"# v-if与v-show的使用方法以及区别\n\n在vue里面有两种方式来控制元素的显示与隐藏，分别是v-if和v-show，这两种方式都可以控制元素的显示与隐藏，那么如何进行使用呢？\n\n## v-if\n\n在vue中使用v-if来控制元素的显示与隐藏，v-if是一个指令，当v-if的值为true时，元素显示，当v-if的值为false时，元素隐藏。\n\n使用一个栗子来说明：\n\n```html\n\n  <div id = \"app\">\n    <button @click=\"show = !show\">切换</button>\n    <div v-if=\"show\">我是v-if</div>\n  </div>\n```\n\n```javascript\n    var app = new Vue({\n        el: '#app',\n        data: {\n        show: true,\n        }\n    })\n```\n\n当点击按钮时，show的值会发生改变，当show的值为true时，元素显示，当show的值为false时，元素隐藏。\n\n## v-show\n\n在vue中使用v-show来控制元素的显示与隐藏，v-show是一个指令，当v-show的值为true时，元素显示，当v-show的值为false时，元素隐藏。\n\n使用一个栗子来说明：\n\n```html\n\n  <div id = \"app\">\n    <button @click=\"show = !show\">切换</button>\n    <div v-show=\"show\">我是v-show</div>\n  </div>\n```\n\n```javascript\n    var app = new Vue({\n        el: '#app',\n        data: {\n        show: true,\n        }\n    })\n```\n\n在这个例子中，我们点击按钮的时候，show的值会发生改变，当show的值为true时，元素显示，当show的值为false时，元素隐藏。\n\n## 两种方式的区别\n\n上面我们看到，两种方式都可以控制元素的显示与隐藏，那么这两种方式有什么区别呢？\n\n### v-if\n\n其实真正的隐藏元素是通过`v-if`来实现的，当v-if的值为false时，元素并不会被页面渲染，当v-if的值为true时，元素才会开始渲染。\n\n当`v-if`的值为false时，元素并不会出现在页面中。\n*true:*\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee372a34472749cabdb49c8c995a4428~tplv-k3u1fbpfcp-watermark.image?)\n\n*false:*\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b896278430b482ca738e85175626b0b~tplv-k3u1fbpfcp-watermark.image?)\n\n如果页面不需要频繁的控制同一元素的显示与隐藏，那么使用v-if来控制元素的显示与隐藏是最好的选择。  \n因为这样可以更好的提高页面的性能。\n\n### v-show\n\n在`v-show`中，元素一开始就会被渲染，就类似于css中的display属性，当v-show的值为false时，元素的display属性为none，当v-show的值为true时，元素的display属性为block。\n\n当`v-show`的值为false时，元素的display属性为none：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2951857028044d59df6046bccdeb160~tplv-k3u1fbpfcp-watermark.image?)\n\n当`v-show`的值为true时，元素的display属性为block：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ac4fa7fe1c4412c9d97556c1d26ffe3~tplv-k3u1fbpfcp-watermark.image?)\n\n也就是当我们使用v-show来控制元素的显示与隐藏时，元素一直都存在与页面当中，当我们页面中需要经常切换元素的显示与隐藏的时候，我们就可以使用v-show来控制元素的显示与隐藏。","source":"_posts/v-if与v-show的使用方法以及区别.md","raw":"---\ntitle:  v-if与v-show的使用方法以及区别\ndate: 2022-10-19\ntags: [前端]\ncategories: [Vue]\n---\n# v-if与v-show的使用方法以及区别\n\n在vue里面有两种方式来控制元素的显示与隐藏，分别是v-if和v-show，这两种方式都可以控制元素的显示与隐藏，那么如何进行使用呢？\n\n## v-if\n\n在vue中使用v-if来控制元素的显示与隐藏，v-if是一个指令，当v-if的值为true时，元素显示，当v-if的值为false时，元素隐藏。\n\n使用一个栗子来说明：\n\n```html\n\n  <div id = \"app\">\n    <button @click=\"show = !show\">切换</button>\n    <div v-if=\"show\">我是v-if</div>\n  </div>\n```\n\n```javascript\n    var app = new Vue({\n        el: '#app',\n        data: {\n        show: true,\n        }\n    })\n```\n\n当点击按钮时，show的值会发生改变，当show的值为true时，元素显示，当show的值为false时，元素隐藏。\n\n## v-show\n\n在vue中使用v-show来控制元素的显示与隐藏，v-show是一个指令，当v-show的值为true时，元素显示，当v-show的值为false时，元素隐藏。\n\n使用一个栗子来说明：\n\n```html\n\n  <div id = \"app\">\n    <button @click=\"show = !show\">切换</button>\n    <div v-show=\"show\">我是v-show</div>\n  </div>\n```\n\n```javascript\n    var app = new Vue({\n        el: '#app',\n        data: {\n        show: true,\n        }\n    })\n```\n\n在这个例子中，我们点击按钮的时候，show的值会发生改变，当show的值为true时，元素显示，当show的值为false时，元素隐藏。\n\n## 两种方式的区别\n\n上面我们看到，两种方式都可以控制元素的显示与隐藏，那么这两种方式有什么区别呢？\n\n### v-if\n\n其实真正的隐藏元素是通过`v-if`来实现的，当v-if的值为false时，元素并不会被页面渲染，当v-if的值为true时，元素才会开始渲染。\n\n当`v-if`的值为false时，元素并不会出现在页面中。\n*true:*\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee372a34472749cabdb49c8c995a4428~tplv-k3u1fbpfcp-watermark.image?)\n\n*false:*\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b896278430b482ca738e85175626b0b~tplv-k3u1fbpfcp-watermark.image?)\n\n如果页面不需要频繁的控制同一元素的显示与隐藏，那么使用v-if来控制元素的显示与隐藏是最好的选择。  \n因为这样可以更好的提高页面的性能。\n\n### v-show\n\n在`v-show`中，元素一开始就会被渲染，就类似于css中的display属性，当v-show的值为false时，元素的display属性为none，当v-show的值为true时，元素的display属性为block。\n\n当`v-show`的值为false时，元素的display属性为none：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2951857028044d59df6046bccdeb160~tplv-k3u1fbpfcp-watermark.image?)\n\n当`v-show`的值为true时，元素的display属性为block：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ac4fa7fe1c4412c9d97556c1d26ffe3~tplv-k3u1fbpfcp-watermark.image?)\n\n也就是当我们使用v-show来控制元素的显示与隐藏时，元素一直都存在与页面当中，当我们页面中需要经常切换元素的显示与隐藏的时候，我们就可以使用v-show来控制元素的显示与隐藏。","slug":"v-if与v-show的使用方法以及区别","published":1,"updated":"2023-01-10T02:14:59.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhh001i9kbmgxitcs58","content":"<h1 id=\"v-if与v-show的使用方法以及区别\"><a href=\"#v-if与v-show的使用方法以及区别\" class=\"headerlink\" title=\"v-if与v-show的使用方法以及区别\"></a>v-if与v-show的使用方法以及区别</h1><p>在vue里面有两种方式来控制元素的显示与隐藏，分别是v-if和v-show，这两种方式都可以控制元素的显示与隐藏，那么如何进行使用呢？</p>\n<h2 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h2><p>在vue中使用v-if来控制元素的显示与隐藏，v-if是一个指令，当v-if的值为true时，元素显示，当v-if的值为false时，元素隐藏。</p>\n<p>使用一个栗子来说明：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span> = <span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;show = !show&quot;</span>&gt;</span>切换<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;show&quot;</span>&gt;</span>我是v-if<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当点击按钮时，show的值会发生改变，当show的值为true时，元素显示，当show的值为false时，元素隐藏。</p>\n<h2 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h2><p>在vue中使用v-show来控制元素的显示与隐藏，v-show是一个指令，当v-show的值为true时，元素显示，当v-show的值为false时，元素隐藏。</p>\n<p>使用一个栗子来说明：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span> = <span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;show = !show&quot;</span>&gt;</span>切换<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-show</span>=<span class=\"string\">&quot;show&quot;</span>&gt;</span>我是v-show<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们点击按钮的时候，show的值会发生改变，当show的值为true时，元素显示，当show的值为false时，元素隐藏。</p>\n<h2 id=\"两种方式的区别\"><a href=\"#两种方式的区别\" class=\"headerlink\" title=\"两种方式的区别\"></a>两种方式的区别</h2><p>上面我们看到，两种方式都可以控制元素的显示与隐藏，那么这两种方式有什么区别呢？</p>\n<h3 id=\"v-if-1\"><a href=\"#v-if-1\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><p>其实真正的隐藏元素是通过<code>v-if</code>来实现的，当v-if的值为false时，元素并不会被页面渲染，当v-if的值为true时，元素才会开始渲染。</p>\n<p>当<code>v-if</code>的值为false时，元素并不会出现在页面中。<br><em>true:</em><br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee372a34472749cabdb49c8c995a4428~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><em>false:</em></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b896278430b482ca738e85175626b0b~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>如果页面不需要频繁的控制同一元素的显示与隐藏，那么使用v-if来控制元素的显示与隐藏是最好的选择。<br>因为这样可以更好的提高页面的性能。</p>\n<h3 id=\"v-show-1\"><a href=\"#v-show-1\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><p>在<code>v-show</code>中，元素一开始就会被渲染，就类似于css中的display属性，当v-show的值为false时，元素的display属性为none，当v-show的值为true时，元素的display属性为block。</p>\n<p>当<code>v-show</code>的值为false时，元素的display属性为none：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2951857028044d59df6046bccdeb160~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>当<code>v-show</code>的值为true时，元素的display属性为block：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ac4fa7fe1c4412c9d97556c1d26ffe3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>也就是当我们使用v-show来控制元素的显示与隐藏时，元素一直都存在与页面当中，当我们页面中需要经常切换元素的显示与隐藏的时候，我们就可以使用v-show来控制元素的显示与隐藏。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"v-if与v-show的使用方法以及区别\"><a href=\"#v-if与v-show的使用方法以及区别\" class=\"headerlink\" title=\"v-if与v-show的使用方法以及区别\"></a>v-if与v-show的使用方法以及区别</h1><p>在vue里面有两种方式来控制元素的显示与隐藏，分别是v-if和v-show，这两种方式都可以控制元素的显示与隐藏，那么如何进行使用呢？</p>\n<h2 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h2><p>在vue中使用v-if来控制元素的显示与隐藏，v-if是一个指令，当v-if的值为true时，元素显示，当v-if的值为false时，元素隐藏。</p>\n<p>使用一个栗子来说明：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span> = <span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;show = !show&quot;</span>&gt;</span>切换<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;show&quot;</span>&gt;</span>我是v-if<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当点击按钮时，show的值会发生改变，当show的值为true时，元素显示，当show的值为false时，元素隐藏。</p>\n<h2 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h2><p>在vue中使用v-show来控制元素的显示与隐藏，v-show是一个指令，当v-show的值为true时，元素显示，当v-show的值为false时，元素隐藏。</p>\n<p>使用一个栗子来说明：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span> = <span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;show = !show&quot;</span>&gt;</span>切换<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-show</span>=<span class=\"string\">&quot;show&quot;</span>&gt;</span>我是v-show<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">show</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，我们点击按钮的时候，show的值会发生改变，当show的值为true时，元素显示，当show的值为false时，元素隐藏。</p>\n<h2 id=\"两种方式的区别\"><a href=\"#两种方式的区别\" class=\"headerlink\" title=\"两种方式的区别\"></a>两种方式的区别</h2><p>上面我们看到，两种方式都可以控制元素的显示与隐藏，那么这两种方式有什么区别呢？</p>\n<h3 id=\"v-if-1\"><a href=\"#v-if-1\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><p>其实真正的隐藏元素是通过<code>v-if</code>来实现的，当v-if的值为false时，元素并不会被页面渲染，当v-if的值为true时，元素才会开始渲染。</p>\n<p>当<code>v-if</code>的值为false时，元素并不会出现在页面中。<br><em>true:</em><br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee372a34472749cabdb49c8c995a4428~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><em>false:</em></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b896278430b482ca738e85175626b0b~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>如果页面不需要频繁的控制同一元素的显示与隐藏，那么使用v-if来控制元素的显示与隐藏是最好的选择。<br>因为这样可以更好的提高页面的性能。</p>\n<h3 id=\"v-show-1\"><a href=\"#v-show-1\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><p>在<code>v-show</code>中，元素一开始就会被渲染，就类似于css中的display属性，当v-show的值为false时，元素的display属性为none，当v-show的值为true时，元素的display属性为block。</p>\n<p>当<code>v-show</code>的值为false时，元素的display属性为none：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2951857028044d59df6046bccdeb160~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>当<code>v-show</code>的值为true时，元素的display属性为block：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ac4fa7fe1c4412c9d97556c1d26ffe3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>也就是当我们使用v-show来控制元素的显示与隐藏时，元素一直都存在与页面当中，当我们页面中需要经常切换元素的显示与隐藏的时候，我们就可以使用v-show来控制元素的显示与隐藏。</p>\n"},{"title":"vue中的事件","date":"2022-10-08T16:00:00.000Z","_content":"# vue中的事件\n\n## 1. 事件绑定\n在vue中，事件的绑定使用vue指令来完成，我们需要使用v-on指令来完成事件的绑定，v-on指令可以简写为@，如下：\n\n```html\n    <div id=\"app\">\n    <button v-on:click=\"handleClick\">按钮</button>\n```\n\n如上面代码所示：\n\nvue绑定事件的写法为 `v-on:事件名 = \"事件处理函数\"`,当然我们也可以使用简写形式：`@事件名 = \"事件处理函数\"`\n\n前面是事件在html中的写法，后面是事件在vue中的写法。\n\n在vue实例化对象中，我们需要将事件处理函数写在`methods`对象中，最终这个方法会出现在vue实例化的对象中，如下：\n\n```javascript\n    var vm = new Vue({\n        el: '#app',\n        data: {\n            msg: 'hello world'\n        },\n        methods: {\n            handleClick: function () {\n                alert('hello world')\n            }\n        }\n    })\n```\n\n那为什么我们不直接将方法写在`data`中，这样不是更方便吗？其实这样写是不行的，因为vue会将`data`中的数据进行数据劫持，当数据发生变化时，会通知视图进行更新，但是方法是不会进行数据劫持的，所以当方法发生变化时，视图不会进行更新。\n\n也就是说，如果我们将事件处理函数写在`data`中，那么这些函数vue会给我们做一个数据代理，这样极大地浪费了资源，导致页面运行缓慢。\n\n**注意：**\n\n在前面我们提到了两种遭html中绑定事件的写法，那么这两种写法有什么区别呢？\n\n- `v-on:click = \"methods\"`这个写法我们不能再传递参数，但是`@click = \"methods()\"`可以传递参数。\n\n## 2. 事件修饰符\n\n在vue中常见的事件修饰符有：\n\n- prevent: 阻止默认事件(如：阻止a标签的跳转)\n- stop:阻止事件的冒泡\n- once:只执行一次事件处理函数\n\n```html\n    <div id=\"app\">\n    <button v-on:click=\"handleClick\">按钮</button>\n    <a href=\"https://juejin.cn\" v-on:click.prevent=\"handleClick\">百度</a>\n    <button v-on:click = \"handleClick1\">\n            <button v-on:click.stop=\"handleClick\">按钮</button>\n    </button>\n    <button v-on:click.once=\"handleClick\">按钮</button>\n```\n\n在上面的代码中，我们可以看到，我们使用了三种事件修饰符，分别是`prevent`、`stop`、`once`，这三种事件修饰符的作用分别是：\n\n- prevent:阻止了a标签的跳转页面\n- stop：阻止了按钮的冒泡（因为在vue中，事件默认是冒泡）\n- once:设定了这个按钮只能点击一次，点击一次之后再点击就没有反应了\n\n这三种修饰符是比较常见的，还有几种我们不是经常用到的，这里我们提几句：\n\n- self:只有当事件是从该元素本身触发时才会触发\n- capture:使用事件捕获模式(改变事件的触发顺序)\n- passive:被动事件监听器(提高性能：事件的默认行为立刻执行，无需等到vue的事件处理函数执行完毕)\n\n如果在同一个事件上需要多种修饰符，那么我们可以这样写：\n\n```html\n    <button v-on:click.stop.prevent=\"handleClick\">按钮</button>\n```\n\n这样就可以在点击按钮的时候阻止事件的冒泡，又可以阻止默认事件。\n\n## 3.键盘事件\n\n在vue中，键盘事件有三种：\n\n- keydown:按下键盘时触发\n- keypress:键盘按住时触发\n- keyup:键盘抬起时触发\n\n```html\n    <div id=\"app\">\n    <input type=\"text\" v-on:keydown=\"handleKeydown\">\n    <input type=\"text\" v-on:keypress=\"handleKeypress\">\n    <input type=\"text\" v-on:keyup=\"handleKeyup\">\n```\n\n在键盘事件中，同样也有着事件修饰符，下面我会列举一些常见的键盘修饰符：\n| 键盘修饰符 |  解释   |        备注         |\n| :--------: | :-----: | :-----------------: |\n|   enter    | 回车键  |                     |\n|    tab     |  tab键  | 必须配合keydown使用 |\n|   delete   | 删除键  |  delete/backspace   |\n|    esc     |  esc键  |                     |\n|   space    | 空格键  |                     |\n|     up     | 上箭头  |                     |\n|    down    | 下箭头  |                     |\n|    left    | 左箭头  |                     |\n|   right    | 右箭头  |                     |\n|    ctrl    | ctrl键  |                     |\n|    alt     |  alt键  |                     |\n|   shift    | shift键 |                     |\n|    meta    | meta键  |                     |\n\n上面这些就是vue根据我们常用的键位设置的属性，我们可以直接在事件绑定的时候使用。\n\n就像这样`@keyup.enter = \"methods\"`，这样就可以监听到回车键的事件了。\n\n但是需要注意的是：\n\n- 修饰符可以串联，如：`@keyup.enter.alt = \"methods\"`\n- 系统修饰键比较特殊：\n    (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才可以触发\n    (2).配合keydown使用：正常触发事件\n\n虽然vue给我们准备了很多常见的键位，但是在实际开发中，难免会有一些特殊的键位，需要我们自定义：  \n不要担心，vue提供了一个方法，可以让我们自定义键位：\n\n```html\n    <div id=\"app\">\n    <input type=\"text\" v-on:keyup.自定义按键名=\"handleKeyup\">\n```\n\n```js\n    Vue.congig.keyCodes.自定义按键名 = 按键值;\n```\n","source":"_posts/vue中的事件.md","raw":"---\ntitle: vue中的事件\ndate: 2022-10-9\ntags: [前端]\ncategories: [Vue]\n---\n# vue中的事件\n\n## 1. 事件绑定\n在vue中，事件的绑定使用vue指令来完成，我们需要使用v-on指令来完成事件的绑定，v-on指令可以简写为@，如下：\n\n```html\n    <div id=\"app\">\n    <button v-on:click=\"handleClick\">按钮</button>\n```\n\n如上面代码所示：\n\nvue绑定事件的写法为 `v-on:事件名 = \"事件处理函数\"`,当然我们也可以使用简写形式：`@事件名 = \"事件处理函数\"`\n\n前面是事件在html中的写法，后面是事件在vue中的写法。\n\n在vue实例化对象中，我们需要将事件处理函数写在`methods`对象中，最终这个方法会出现在vue实例化的对象中，如下：\n\n```javascript\n    var vm = new Vue({\n        el: '#app',\n        data: {\n            msg: 'hello world'\n        },\n        methods: {\n            handleClick: function () {\n                alert('hello world')\n            }\n        }\n    })\n```\n\n那为什么我们不直接将方法写在`data`中，这样不是更方便吗？其实这样写是不行的，因为vue会将`data`中的数据进行数据劫持，当数据发生变化时，会通知视图进行更新，但是方法是不会进行数据劫持的，所以当方法发生变化时，视图不会进行更新。\n\n也就是说，如果我们将事件处理函数写在`data`中，那么这些函数vue会给我们做一个数据代理，这样极大地浪费了资源，导致页面运行缓慢。\n\n**注意：**\n\n在前面我们提到了两种遭html中绑定事件的写法，那么这两种写法有什么区别呢？\n\n- `v-on:click = \"methods\"`这个写法我们不能再传递参数，但是`@click = \"methods()\"`可以传递参数。\n\n## 2. 事件修饰符\n\n在vue中常见的事件修饰符有：\n\n- prevent: 阻止默认事件(如：阻止a标签的跳转)\n- stop:阻止事件的冒泡\n- once:只执行一次事件处理函数\n\n```html\n    <div id=\"app\">\n    <button v-on:click=\"handleClick\">按钮</button>\n    <a href=\"https://juejin.cn\" v-on:click.prevent=\"handleClick\">百度</a>\n    <button v-on:click = \"handleClick1\">\n            <button v-on:click.stop=\"handleClick\">按钮</button>\n    </button>\n    <button v-on:click.once=\"handleClick\">按钮</button>\n```\n\n在上面的代码中，我们可以看到，我们使用了三种事件修饰符，分别是`prevent`、`stop`、`once`，这三种事件修饰符的作用分别是：\n\n- prevent:阻止了a标签的跳转页面\n- stop：阻止了按钮的冒泡（因为在vue中，事件默认是冒泡）\n- once:设定了这个按钮只能点击一次，点击一次之后再点击就没有反应了\n\n这三种修饰符是比较常见的，还有几种我们不是经常用到的，这里我们提几句：\n\n- self:只有当事件是从该元素本身触发时才会触发\n- capture:使用事件捕获模式(改变事件的触发顺序)\n- passive:被动事件监听器(提高性能：事件的默认行为立刻执行，无需等到vue的事件处理函数执行完毕)\n\n如果在同一个事件上需要多种修饰符，那么我们可以这样写：\n\n```html\n    <button v-on:click.stop.prevent=\"handleClick\">按钮</button>\n```\n\n这样就可以在点击按钮的时候阻止事件的冒泡，又可以阻止默认事件。\n\n## 3.键盘事件\n\n在vue中，键盘事件有三种：\n\n- keydown:按下键盘时触发\n- keypress:键盘按住时触发\n- keyup:键盘抬起时触发\n\n```html\n    <div id=\"app\">\n    <input type=\"text\" v-on:keydown=\"handleKeydown\">\n    <input type=\"text\" v-on:keypress=\"handleKeypress\">\n    <input type=\"text\" v-on:keyup=\"handleKeyup\">\n```\n\n在键盘事件中，同样也有着事件修饰符，下面我会列举一些常见的键盘修饰符：\n| 键盘修饰符 |  解释   |        备注         |\n| :--------: | :-----: | :-----------------: |\n|   enter    | 回车键  |                     |\n|    tab     |  tab键  | 必须配合keydown使用 |\n|   delete   | 删除键  |  delete/backspace   |\n|    esc     |  esc键  |                     |\n|   space    | 空格键  |                     |\n|     up     | 上箭头  |                     |\n|    down    | 下箭头  |                     |\n|    left    | 左箭头  |                     |\n|   right    | 右箭头  |                     |\n|    ctrl    | ctrl键  |                     |\n|    alt     |  alt键  |                     |\n|   shift    | shift键 |                     |\n|    meta    | meta键  |                     |\n\n上面这些就是vue根据我们常用的键位设置的属性，我们可以直接在事件绑定的时候使用。\n\n就像这样`@keyup.enter = \"methods\"`，这样就可以监听到回车键的事件了。\n\n但是需要注意的是：\n\n- 修饰符可以串联，如：`@keyup.enter.alt = \"methods\"`\n- 系统修饰键比较特殊：\n    (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才可以触发\n    (2).配合keydown使用：正常触发事件\n\n虽然vue给我们准备了很多常见的键位，但是在实际开发中，难免会有一些特殊的键位，需要我们自定义：  \n不要担心，vue提供了一个方法，可以让我们自定义键位：\n\n```html\n    <div id=\"app\">\n    <input type=\"text\" v-on:keyup.自定义按键名=\"handleKeyup\">\n```\n\n```js\n    Vue.congig.keyCodes.自定义按键名 = 按键值;\n```\n","slug":"vue中的事件","published":1,"updated":"2023-01-10T02:16:39.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhi001l9kbm7ckef7gr","content":"<h1 id=\"vue中的事件\"><a href=\"#vue中的事件\" class=\"headerlink\" title=\"vue中的事件\"></a>vue中的事件</h1><h2 id=\"1-事件绑定\"><a href=\"#1-事件绑定\" class=\"headerlink\" title=\"1. 事件绑定\"></a>1. 事件绑定</h2><p>在vue中，事件的绑定使用vue指令来完成，我们需要使用v-on指令来完成事件的绑定，v-on指令可以简写为@，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如上面代码所示：</p>\n<p>vue绑定事件的写法为 <code>v-on:事件名 = &quot;事件处理函数&quot;</code>,当然我们也可以使用简写形式：<code>@事件名 = &quot;事件处理函数&quot;</code></p>\n<p>前面是事件在html中的写法，后面是事件在vue中的写法。</p>\n<p>在vue实例化对象中，我们需要将事件处理函数写在<code>methods</code>对象中，最终这个方法会出现在vue实例化的对象中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">handleClick</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;hello world&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>那为什么我们不直接将方法写在<code>data</code>中，这样不是更方便吗？其实这样写是不行的，因为vue会将<code>data</code>中的数据进行数据劫持，当数据发生变化时，会通知视图进行更新，但是方法是不会进行数据劫持的，所以当方法发生变化时，视图不会进行更新。</p>\n<p>也就是说，如果我们将事件处理函数写在<code>data</code>中，那么这些函数vue会给我们做一个数据代理，这样极大地浪费了资源，导致页面运行缓慢。</p>\n<p><strong>注意：</strong></p>\n<p>在前面我们提到了两种遭html中绑定事件的写法，那么这两种写法有什么区别呢？</p>\n<ul>\n<li><code>v-on:click = &quot;methods&quot;</code>这个写法我们不能再传递参数，但是<code>@click = &quot;methods()&quot;</code>可以传递参数。</li>\n</ul>\n<h2 id=\"2-事件修饰符\"><a href=\"#2-事件修饰符\" class=\"headerlink\" title=\"2. 事件修饰符\"></a>2. 事件修饰符</h2><p>在vue中常见的事件修饰符有：</p>\n<ul>\n<li>prevent: 阻止默认事件(如：阻止a标签的跳转)</li>\n<li>stop:阻止事件的冒泡</li>\n<li>once:只执行一次事件处理函数</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://juejin.cn&quot;</span> <span class=\"attr\">v-on:click.prevent</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>百度<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span> = <span class=\"string\">&quot;handleClick1&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click.stop</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click.once</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们可以看到，我们使用了三种事件修饰符，分别是<code>prevent</code>、<code>stop</code>、<code>once</code>，这三种事件修饰符的作用分别是：</p>\n<ul>\n<li>prevent:阻止了a标签的跳转页面</li>\n<li>stop：阻止了按钮的冒泡（因为在vue中，事件默认是冒泡）</li>\n<li>once:设定了这个按钮只能点击一次，点击一次之后再点击就没有反应了</li>\n</ul>\n<p>这三种修饰符是比较常见的，还有几种我们不是经常用到的，这里我们提几句：</p>\n<ul>\n<li>self:只有当事件是从该元素本身触发时才会触发</li>\n<li>capture:使用事件捕获模式(改变事件的触发顺序)</li>\n<li>passive:被动事件监听器(提高性能：事件的默认行为立刻执行，无需等到vue的事件处理函数执行完毕)</li>\n</ul>\n<p>如果在同一个事件上需要多种修饰符，那么我们可以这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click.stop.prevent</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就可以在点击按钮的时候阻止事件的冒泡，又可以阻止默认事件。</p>\n<h2 id=\"3-键盘事件\"><a href=\"#3-键盘事件\" class=\"headerlink\" title=\"3.键盘事件\"></a>3.键盘事件</h2><p>在vue中，键盘事件有三种：</p>\n<ul>\n<li>keydown:按下键盘时触发</li>\n<li>keypress:键盘按住时触发</li>\n<li>keyup:键盘抬起时触发</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:keydown</span>=<span class=\"string\">&quot;handleKeydown&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:keypress</span>=<span class=\"string\">&quot;handleKeypress&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:keyup</span>=<span class=\"string\">&quot;handleKeyup&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在键盘事件中，同样也有着事件修饰符，下面我会列举一些常见的键盘修饰符：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">键盘修饰符</th>\n<th align=\"center\">解释</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">enter</td>\n<td align=\"center\">回车键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">tab</td>\n<td align=\"center\">tab键</td>\n<td align=\"center\">必须配合keydown使用</td>\n</tr>\n<tr>\n<td align=\"center\">delete</td>\n<td align=\"center\">删除键</td>\n<td align=\"center\">delete&#x2F;backspace</td>\n</tr>\n<tr>\n<td align=\"center\">esc</td>\n<td align=\"center\">esc键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">space</td>\n<td align=\"center\">空格键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">up</td>\n<td align=\"center\">上箭头</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">down</td>\n<td align=\"center\">下箭头</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">left</td>\n<td align=\"center\">左箭头</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">right</td>\n<td align=\"center\">右箭头</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ctrl</td>\n<td align=\"center\">ctrl键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">alt</td>\n<td align=\"center\">alt键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">shift</td>\n<td align=\"center\">shift键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">meta</td>\n<td align=\"center\">meta键</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>上面这些就是vue根据我们常用的键位设置的属性，我们可以直接在事件绑定的时候使用。</p>\n<p>就像这样<code>@keyup.enter = &quot;methods&quot;</code>，这样就可以监听到回车键的事件了。</p>\n<p>但是需要注意的是：</p>\n<ul>\n<li>修饰符可以串联，如：<code>@keyup.enter.alt = &quot;methods&quot;</code></li>\n<li>系统修饰键比较特殊：<br>  (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才可以触发<br>  (2).配合keydown使用：正常触发事件</li>\n</ul>\n<p>虽然vue给我们准备了很多常见的键位，但是在实际开发中，难免会有一些特殊的键位，需要我们自定义：<br>不要担心，vue提供了一个方法，可以让我们自定义键位：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:keyup.自定义按键名</span>=<span class=\"string\">&quot;handleKeyup&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\">congig</span>.<span class=\"property\">keyCodes</span>.自定义按键名 = 按键值;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue中的事件\"><a href=\"#vue中的事件\" class=\"headerlink\" title=\"vue中的事件\"></a>vue中的事件</h1><h2 id=\"1-事件绑定\"><a href=\"#1-事件绑定\" class=\"headerlink\" title=\"1. 事件绑定\"></a>1. 事件绑定</h2><p>在vue中，事件的绑定使用vue指令来完成，我们需要使用v-on指令来完成事件的绑定，v-on指令可以简写为@，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如上面代码所示：</p>\n<p>vue绑定事件的写法为 <code>v-on:事件名 = &quot;事件处理函数&quot;</code>,当然我们也可以使用简写形式：<code>@事件名 = &quot;事件处理函数&quot;</code></p>\n<p>前面是事件在html中的写法，后面是事件在vue中的写法。</p>\n<p>在vue实例化对象中，我们需要将事件处理函数写在<code>methods</code>对象中，最终这个方法会出现在vue实例化的对象中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">handleClick</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;hello world&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>那为什么我们不直接将方法写在<code>data</code>中，这样不是更方便吗？其实这样写是不行的，因为vue会将<code>data</code>中的数据进行数据劫持，当数据发生变化时，会通知视图进行更新，但是方法是不会进行数据劫持的，所以当方法发生变化时，视图不会进行更新。</p>\n<p>也就是说，如果我们将事件处理函数写在<code>data</code>中，那么这些函数vue会给我们做一个数据代理，这样极大地浪费了资源，导致页面运行缓慢。</p>\n<p><strong>注意：</strong></p>\n<p>在前面我们提到了两种遭html中绑定事件的写法，那么这两种写法有什么区别呢？</p>\n<ul>\n<li><code>v-on:click = &quot;methods&quot;</code>这个写法我们不能再传递参数，但是<code>@click = &quot;methods()&quot;</code>可以传递参数。</li>\n</ul>\n<h2 id=\"2-事件修饰符\"><a href=\"#2-事件修饰符\" class=\"headerlink\" title=\"2. 事件修饰符\"></a>2. 事件修饰符</h2><p>在vue中常见的事件修饰符有：</p>\n<ul>\n<li>prevent: 阻止默认事件(如：阻止a标签的跳转)</li>\n<li>stop:阻止事件的冒泡</li>\n<li>once:只执行一次事件处理函数</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://juejin.cn&quot;</span> <span class=\"attr\">v-on:click.prevent</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>百度<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span> = <span class=\"string\">&quot;handleClick1&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click.stop</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click.once</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们可以看到，我们使用了三种事件修饰符，分别是<code>prevent</code>、<code>stop</code>、<code>once</code>，这三种事件修饰符的作用分别是：</p>\n<ul>\n<li>prevent:阻止了a标签的跳转页面</li>\n<li>stop：阻止了按钮的冒泡（因为在vue中，事件默认是冒泡）</li>\n<li>once:设定了这个按钮只能点击一次，点击一次之后再点击就没有反应了</li>\n</ul>\n<p>这三种修饰符是比较常见的，还有几种我们不是经常用到的，这里我们提几句：</p>\n<ul>\n<li>self:只有当事件是从该元素本身触发时才会触发</li>\n<li>capture:使用事件捕获模式(改变事件的触发顺序)</li>\n<li>passive:被动事件监听器(提高性能：事件的默认行为立刻执行，无需等到vue的事件处理函数执行完毕)</li>\n</ul>\n<p>如果在同一个事件上需要多种修饰符，那么我们可以这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click.stop.prevent</span>=<span class=\"string\">&quot;handleClick&quot;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就可以在点击按钮的时候阻止事件的冒泡，又可以阻止默认事件。</p>\n<h2 id=\"3-键盘事件\"><a href=\"#3-键盘事件\" class=\"headerlink\" title=\"3.键盘事件\"></a>3.键盘事件</h2><p>在vue中，键盘事件有三种：</p>\n<ul>\n<li>keydown:按下键盘时触发</li>\n<li>keypress:键盘按住时触发</li>\n<li>keyup:键盘抬起时触发</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:keydown</span>=<span class=\"string\">&quot;handleKeydown&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:keypress</span>=<span class=\"string\">&quot;handleKeypress&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:keyup</span>=<span class=\"string\">&quot;handleKeyup&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在键盘事件中，同样也有着事件修饰符，下面我会列举一些常见的键盘修饰符：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">键盘修饰符</th>\n<th align=\"center\">解释</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">enter</td>\n<td align=\"center\">回车键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">tab</td>\n<td align=\"center\">tab键</td>\n<td align=\"center\">必须配合keydown使用</td>\n</tr>\n<tr>\n<td align=\"center\">delete</td>\n<td align=\"center\">删除键</td>\n<td align=\"center\">delete&#x2F;backspace</td>\n</tr>\n<tr>\n<td align=\"center\">esc</td>\n<td align=\"center\">esc键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">space</td>\n<td align=\"center\">空格键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">up</td>\n<td align=\"center\">上箭头</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">down</td>\n<td align=\"center\">下箭头</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">left</td>\n<td align=\"center\">左箭头</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">right</td>\n<td align=\"center\">右箭头</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ctrl</td>\n<td align=\"center\">ctrl键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">alt</td>\n<td align=\"center\">alt键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">shift</td>\n<td align=\"center\">shift键</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">meta</td>\n<td align=\"center\">meta键</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>上面这些就是vue根据我们常用的键位设置的属性，我们可以直接在事件绑定的时候使用。</p>\n<p>就像这样<code>@keyup.enter = &quot;methods&quot;</code>，这样就可以监听到回车键的事件了。</p>\n<p>但是需要注意的是：</p>\n<ul>\n<li>修饰符可以串联，如：<code>@keyup.enter.alt = &quot;methods&quot;</code></li>\n<li>系统修饰键比较特殊：<br>  (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才可以触发<br>  (2).配合keydown使用：正常触发事件</li>\n</ul>\n<p>虽然vue给我们准备了很多常见的键位，但是在实际开发中，难免会有一些特殊的键位，需要我们自定义：<br>不要担心，vue提供了一个方法，可以让我们自定义键位：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-on:keyup.自定义按键名</span>=<span class=\"string\">&quot;handleKeyup&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Vue</span>.<span class=\"property\">congig</span>.<span class=\"property\">keyCodes</span>.自定义按键名 = 按键值;</span><br></pre></td></tr></table></figure>\n"},{"title":"vue中计算属性","date":"2022-10-09T16:00:00.000Z","_content":"# vue中计算属性\n\n在我们使用vue的时候，会遇到这样一种情况：我们需要对一个数据进行处理，然后再显示出来，比如我们有一个数据`a`，我们需要对它进行处理，然后再显示出来，这个时候我们就可以使用计算属性。\n\n使用计算属性的一大好处就是不用在插值语法中书写整个计算过程，使得代码更加简洁，可读性更好。\n\n## 1.什么是计算属性\n\n在最开始的时候，我们在插值语法中使用的是一个数据，但是随机业务逻辑的增加，我们需要对这个数据进行处理，然后再显示出来，这个时候我们就可以使用计算属性。\n\n计算属性就是将一个或者多个已经存在的数据进行处理，然后再返回一个新的数据。\n\n## 2.计算属性的使用\n\n首先，我们要知道需要处理的数据是否在vue实例中，如果不在，那么我们就需要将它添加到vue实例中，然后再使用计算属性。  \n计算属性需要写在`computed`中，然后再写一个函数，函数的返回值就是我们需要的数据。\n\n`<p>{{sum}}</p>`\n\n```js\nvar vm = new Vue({\n    el: '#app',\n    data: {\n        a: 1,\n        b: 2\n    },\n    computed: {\n        sum: function () {\n            return this.a + this.b;\n        }\n    }\n});\n```\n\n上面的代码就是将`a`和`b`进行相加，然后再返回一个新的数据，在插值语法中，我们直接使用`sum`就可以得到`a`与`b`的和了。\n\n## 3.计算属性的原理\n\n计算属性的原理实际借助了JavaScript中Object.defineProperty()方法，这个方法可以给对象添加属性，然后可以对这个属性进行一些操作，比如设置它的可读性，可写性，可枚举性等等。\n\n计算属性的完整写法应该要包含setter和getter。\n\n```js\n    computed:{\n        sum:{\n            get:function(){\n                return this.a+this.b;\n            },\n            set:function(newValueA,newVa lueB){\n                this.a = newValue;\n            }\n        },\n    }\n```\n\n上面的代码就是计算属性的完整写法，其中`get`是获取计算属性的值，`set`是设置计算属性的值。\n\n### 3.1 getter函数执行的时机\n\ngetter函数执行的时机有两种：\n\n- 当我们初次读取该计算属性的值的时候，会执行一次getter函数，然后将返回值缓存起来，以后再读取该计算属性的值的时候，就会直接返回缓存的值，不会再次执行getter函数。\n- 当该计算属性所依赖的数据发生改变时，会再次执行getter函数，然后将返回值缓存起来。\n\n## 4.计算属性的优势\n\n其实我们不难发现，计算属性可以实现的功能，在方法中也可以得到实现。那为什么vue要设计一种计算属性呢？\n\n这是因为有以下几点原因：\n\n1. 可以提高性能：  \n    在methods中每次调用函数都会执行，而计算属性只有在依赖的数据发生变化的时候才会执行\n2. 可以提高代码的可读性:  \n    不必再插值表达式中写复杂的逻辑代码，而是把复杂的逻辑代码放到计算属性中\n3. 可以提高代码的可维护性:  \n    当逻辑代码发生变化的时候，只需要修改计算属性中的代码即可，不必再去修改插值表达式中的代码\n\n## 5. 其余注意事项\n\n1. 计算属性是基于它的依赖进行缓存的，只有它的依赖发生改变时才会重新求值。这也意味着只要需要计算的属性值没有发生改变，多次访问该计算属性会立即返回之前的计算结果，而不必再次执行函数。\n2. 计算属性最终会出现在vue实例化对象上，我们直接去调用就可以了，并不需要在计算属性名的后面添加`()`。","source":"_posts/vue中计算属性.md","raw":"---\ntitle: vue中计算属性\ndate: 2022-10-10\ntags: [前端]\ncategories: [Vue]\n---\n# vue中计算属性\n\n在我们使用vue的时候，会遇到这样一种情况：我们需要对一个数据进行处理，然后再显示出来，比如我们有一个数据`a`，我们需要对它进行处理，然后再显示出来，这个时候我们就可以使用计算属性。\n\n使用计算属性的一大好处就是不用在插值语法中书写整个计算过程，使得代码更加简洁，可读性更好。\n\n## 1.什么是计算属性\n\n在最开始的时候，我们在插值语法中使用的是一个数据，但是随机业务逻辑的增加，我们需要对这个数据进行处理，然后再显示出来，这个时候我们就可以使用计算属性。\n\n计算属性就是将一个或者多个已经存在的数据进行处理，然后再返回一个新的数据。\n\n## 2.计算属性的使用\n\n首先，我们要知道需要处理的数据是否在vue实例中，如果不在，那么我们就需要将它添加到vue实例中，然后再使用计算属性。  \n计算属性需要写在`computed`中，然后再写一个函数，函数的返回值就是我们需要的数据。\n\n`<p>{{sum}}</p>`\n\n```js\nvar vm = new Vue({\n    el: '#app',\n    data: {\n        a: 1,\n        b: 2\n    },\n    computed: {\n        sum: function () {\n            return this.a + this.b;\n        }\n    }\n});\n```\n\n上面的代码就是将`a`和`b`进行相加，然后再返回一个新的数据，在插值语法中，我们直接使用`sum`就可以得到`a`与`b`的和了。\n\n## 3.计算属性的原理\n\n计算属性的原理实际借助了JavaScript中Object.defineProperty()方法，这个方法可以给对象添加属性，然后可以对这个属性进行一些操作，比如设置它的可读性，可写性，可枚举性等等。\n\n计算属性的完整写法应该要包含setter和getter。\n\n```js\n    computed:{\n        sum:{\n            get:function(){\n                return this.a+this.b;\n            },\n            set:function(newValueA,newVa lueB){\n                this.a = newValue;\n            }\n        },\n    }\n```\n\n上面的代码就是计算属性的完整写法，其中`get`是获取计算属性的值，`set`是设置计算属性的值。\n\n### 3.1 getter函数执行的时机\n\ngetter函数执行的时机有两种：\n\n- 当我们初次读取该计算属性的值的时候，会执行一次getter函数，然后将返回值缓存起来，以后再读取该计算属性的值的时候，就会直接返回缓存的值，不会再次执行getter函数。\n- 当该计算属性所依赖的数据发生改变时，会再次执行getter函数，然后将返回值缓存起来。\n\n## 4.计算属性的优势\n\n其实我们不难发现，计算属性可以实现的功能，在方法中也可以得到实现。那为什么vue要设计一种计算属性呢？\n\n这是因为有以下几点原因：\n\n1. 可以提高性能：  \n    在methods中每次调用函数都会执行，而计算属性只有在依赖的数据发生变化的时候才会执行\n2. 可以提高代码的可读性:  \n    不必再插值表达式中写复杂的逻辑代码，而是把复杂的逻辑代码放到计算属性中\n3. 可以提高代码的可维护性:  \n    当逻辑代码发生变化的时候，只需要修改计算属性中的代码即可，不必再去修改插值表达式中的代码\n\n## 5. 其余注意事项\n\n1. 计算属性是基于它的依赖进行缓存的，只有它的依赖发生改变时才会重新求值。这也意味着只要需要计算的属性值没有发生改变，多次访问该计算属性会立即返回之前的计算结果，而不必再次执行函数。\n2. 计算属性最终会出现在vue实例化对象上，我们直接去调用就可以了，并不需要在计算属性名的后面添加`()`。","slug":"vue中计算属性","published":1,"updated":"2023-01-10T02:17:04.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhj001p9kbmazc0c0nb","content":"<h1 id=\"vue中计算属性\"><a href=\"#vue中计算属性\" class=\"headerlink\" title=\"vue中计算属性\"></a>vue中计算属性</h1><p>在我们使用vue的时候，会遇到这样一种情况：我们需要对一个数据进行处理，然后再显示出来，比如我们有一个数据<code>a</code>，我们需要对它进行处理，然后再显示出来，这个时候我们就可以使用计算属性。</p>\n<p>使用计算属性的一大好处就是不用在插值语法中书写整个计算过程，使得代码更加简洁，可读性更好。</p>\n<h2 id=\"1-什么是计算属性\"><a href=\"#1-什么是计算属性\" class=\"headerlink\" title=\"1.什么是计算属性\"></a>1.什么是计算属性</h2><p>在最开始的时候，我们在插值语法中使用的是一个数据，但是随机业务逻辑的增加，我们需要对这个数据进行处理，然后再显示出来，这个时候我们就可以使用计算属性。</p>\n<p>计算属性就是将一个或者多个已经存在的数据进行处理，然后再返回一个新的数据。</p>\n<h2 id=\"2-计算属性的使用\"><a href=\"#2-计算属性的使用\" class=\"headerlink\" title=\"2.计算属性的使用\"></a>2.计算属性的使用</h2><p>首先，我们要知道需要处理的数据是否在vue实例中，如果不在，那么我们就需要将它添加到vue实例中，然后再使用计算属性。<br>计算属性需要写在<code>computed</code>中，然后再写一个函数，函数的返回值就是我们需要的数据。</p>\n<p><code>&lt;p&gt;&#123;&#123;sum&#125;&#125;&lt;/p&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"attr\">b</span>: <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">sum</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">b</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就是将<code>a</code>和<code>b</code>进行相加，然后再返回一个新的数据，在插值语法中，我们直接使用<code>sum</code>就可以得到<code>a</code>与<code>b</code>的和了。</p>\n<h2 id=\"3-计算属性的原理\"><a href=\"#3-计算属性的原理\" class=\"headerlink\" title=\"3.计算属性的原理\"></a>3.计算属性的原理</h2><p>计算属性的原理实际借助了JavaScript中Object.defineProperty()方法，这个方法可以给对象添加属性，然后可以对这个属性进行一些操作，比如设置它的可读性，可写性，可枚举性等等。</p>\n<p>计算属性的完整写法应该要包含setter和getter。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">computed</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">sum</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">get</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>+<span class=\"variable language_\">this</span>.<span class=\"property\">b</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>:<span class=\"keyword\">function</span>(<span class=\"params\">newValueA,newVa lueB</span>)&#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = newValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就是计算属性的完整写法，其中<code>get</code>是获取计算属性的值，<code>set</code>是设置计算属性的值。</p>\n<h3 id=\"3-1-getter函数执行的时机\"><a href=\"#3-1-getter函数执行的时机\" class=\"headerlink\" title=\"3.1 getter函数执行的时机\"></a>3.1 getter函数执行的时机</h3><p>getter函数执行的时机有两种：</p>\n<ul>\n<li>当我们初次读取该计算属性的值的时候，会执行一次getter函数，然后将返回值缓存起来，以后再读取该计算属性的值的时候，就会直接返回缓存的值，不会再次执行getter函数。</li>\n<li>当该计算属性所依赖的数据发生改变时，会再次执行getter函数，然后将返回值缓存起来。</li>\n</ul>\n<h2 id=\"4-计算属性的优势\"><a href=\"#4-计算属性的优势\" class=\"headerlink\" title=\"4.计算属性的优势\"></a>4.计算属性的优势</h2><p>其实我们不难发现，计算属性可以实现的功能，在方法中也可以得到实现。那为什么vue要设计一种计算属性呢？</p>\n<p>这是因为有以下几点原因：</p>\n<ol>\n<li>可以提高性能：<br> 在methods中每次调用函数都会执行，而计算属性只有在依赖的数据发生变化的时候才会执行</li>\n<li>可以提高代码的可读性:<br> 不必再插值表达式中写复杂的逻辑代码，而是把复杂的逻辑代码放到计算属性中</li>\n<li>可以提高代码的可维护性:<br> 当逻辑代码发生变化的时候，只需要修改计算属性中的代码即可，不必再去修改插值表达式中的代码</li>\n</ol>\n<h2 id=\"5-其余注意事项\"><a href=\"#5-其余注意事项\" class=\"headerlink\" title=\"5. 其余注意事项\"></a>5. 其余注意事项</h2><ol>\n<li>计算属性是基于它的依赖进行缓存的，只有它的依赖发生改变时才会重新求值。这也意味着只要需要计算的属性值没有发生改变，多次访问该计算属性会立即返回之前的计算结果，而不必再次执行函数。</li>\n<li>计算属性最终会出现在vue实例化对象上，我们直接去调用就可以了，并不需要在计算属性名的后面添加<code>()</code>。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue中计算属性\"><a href=\"#vue中计算属性\" class=\"headerlink\" title=\"vue中计算属性\"></a>vue中计算属性</h1><p>在我们使用vue的时候，会遇到这样一种情况：我们需要对一个数据进行处理，然后再显示出来，比如我们有一个数据<code>a</code>，我们需要对它进行处理，然后再显示出来，这个时候我们就可以使用计算属性。</p>\n<p>使用计算属性的一大好处就是不用在插值语法中书写整个计算过程，使得代码更加简洁，可读性更好。</p>\n<h2 id=\"1-什么是计算属性\"><a href=\"#1-什么是计算属性\" class=\"headerlink\" title=\"1.什么是计算属性\"></a>1.什么是计算属性</h2><p>在最开始的时候，我们在插值语法中使用的是一个数据，但是随机业务逻辑的增加，我们需要对这个数据进行处理，然后再显示出来，这个时候我们就可以使用计算属性。</p>\n<p>计算属性就是将一个或者多个已经存在的数据进行处理，然后再返回一个新的数据。</p>\n<h2 id=\"2-计算属性的使用\"><a href=\"#2-计算属性的使用\" class=\"headerlink\" title=\"2.计算属性的使用\"></a>2.计算属性的使用</h2><p>首先，我们要知道需要处理的数据是否在vue实例中，如果不在，那么我们就需要将它添加到vue实例中，然后再使用计算属性。<br>计算属性需要写在<code>computed</code>中，然后再写一个函数，函数的返回值就是我们需要的数据。</p>\n<p><code>&lt;p&gt;&#123;&#123;sum&#125;&#125;&lt;/p&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">a</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"attr\">b</span>: <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">sum</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">b</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就是将<code>a</code>和<code>b</code>进行相加，然后再返回一个新的数据，在插值语法中，我们直接使用<code>sum</code>就可以得到<code>a</code>与<code>b</code>的和了。</p>\n<h2 id=\"3-计算属性的原理\"><a href=\"#3-计算属性的原理\" class=\"headerlink\" title=\"3.计算属性的原理\"></a>3.计算属性的原理</h2><p>计算属性的原理实际借助了JavaScript中Object.defineProperty()方法，这个方法可以给对象添加属性，然后可以对这个属性进行一些操作，比如设置它的可读性，可写性，可枚举性等等。</p>\n<p>计算属性的完整写法应该要包含setter和getter。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">computed</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">sum</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">get</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>+<span class=\"variable language_\">this</span>.<span class=\"property\">b</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>:<span class=\"keyword\">function</span>(<span class=\"params\">newValueA,newVa lueB</span>)&#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> = newValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码就是计算属性的完整写法，其中<code>get</code>是获取计算属性的值，<code>set</code>是设置计算属性的值。</p>\n<h3 id=\"3-1-getter函数执行的时机\"><a href=\"#3-1-getter函数执行的时机\" class=\"headerlink\" title=\"3.1 getter函数执行的时机\"></a>3.1 getter函数执行的时机</h3><p>getter函数执行的时机有两种：</p>\n<ul>\n<li>当我们初次读取该计算属性的值的时候，会执行一次getter函数，然后将返回值缓存起来，以后再读取该计算属性的值的时候，就会直接返回缓存的值，不会再次执行getter函数。</li>\n<li>当该计算属性所依赖的数据发生改变时，会再次执行getter函数，然后将返回值缓存起来。</li>\n</ul>\n<h2 id=\"4-计算属性的优势\"><a href=\"#4-计算属性的优势\" class=\"headerlink\" title=\"4.计算属性的优势\"></a>4.计算属性的优势</h2><p>其实我们不难发现，计算属性可以实现的功能，在方法中也可以得到实现。那为什么vue要设计一种计算属性呢？</p>\n<p>这是因为有以下几点原因：</p>\n<ol>\n<li>可以提高性能：<br> 在methods中每次调用函数都会执行，而计算属性只有在依赖的数据发生变化的时候才会执行</li>\n<li>可以提高代码的可读性:<br> 不必再插值表达式中写复杂的逻辑代码，而是把复杂的逻辑代码放到计算属性中</li>\n<li>可以提高代码的可维护性:<br> 当逻辑代码发生变化的时候，只需要修改计算属性中的代码即可，不必再去修改插值表达式中的代码</li>\n</ol>\n<h2 id=\"5-其余注意事项\"><a href=\"#5-其余注意事项\" class=\"headerlink\" title=\"5. 其余注意事项\"></a>5. 其余注意事项</h2><ol>\n<li>计算属性是基于它的依赖进行缓存的，只有它的依赖发生改变时才会重新求值。这也意味着只要需要计算的属性值没有发生改变，多次访问该计算属性会立即返回之前的计算结果，而不必再次执行函数。</li>\n<li>计算属性最终会出现在vue实例化对象上，我们直接去调用就可以了，并不需要在计算属性名的后面添加<code>()</code>。</li>\n</ol>\n"},{"title":"vue监视属性","date":"2022-10-10T16:00:00.000Z","_content":"# vue监视属性\n\n在开发中，我们会遇到这样一种情况，我们需要一个属性变化的时候，然后做出一些操作。而检测这个变化的属性，在vue中叫做监视属性。\n\n## 1.监视属性是什么\n\n在vue中，我们可以通过watch属性来监视某个属性的变化，当这个属性发生变化时，我们可以执行一些操作。\n\n- 当监视属性所监视的属性发生变化的时候，回调函数（handler）就会自动调用，并且执行相关的操作\n- 监视属性所监视的属性要存在，才能产生作用。\n\n我们这里用一个天气案例来解释什么是监视属性：\n\n首先html代码：\n\n```html\n    <div id=\"app\">\n        <p>今天天气很{{info}}</p>\n        <button v-on:click=\"change\">切换天气</button>\n    </div>\n```\n\n接下来我们书写js代码：\n\n```js\n    var vm = new Vue({\n        el: \"#app\",\n        data: {\n            isHot: true,\n        },\n        computed: {\n            info: function () {\n                return this.isHot ? \"热\" : \"冷\";\n            }\n        },\n        methods: {\n            change: function () {\n                this.isHot = !this.isHot;\n            }\n        },\n        watch: {\n            isHot: {\n                handler:function (newVal, oldVal) {\n                    console.log(\"isHot属性发生了变化\");\n                },\n            }\n        }\n    });\n```\n\n在代码里面的`handler`这个函数就是我们前面说的回调函数，当`isHot`属性发生变化的时候，这个函数就会自动调用。\n\n当然我们可以在`idHot`对象面添加一个属性：`immediate`，当此属性布尔值为真的时候，`handler`回调函数在初始化的时候就会调用一次。\n\n```js\n    watch: {\n        isHot: {\n            handler:function (newVal, oldVal) {\n                console.log(\"isHot属性发生了变化\");\n            },\n            immediate: true\n        }\n    }\n```\n\n## 2.监视属性的写法\n\n监视属性有两种写法：\n\n- 在vue实例化对象中直接书写：  \n  `new Vue({watch:{}})`,然后传入相关配置\n- 通过vue实例化对象.$watch('属性名'，回调函数)来书写\n\n这里的第一种写法上面我们已经展现过了，下面我们就展示一下第二种写法：\n\n这里我们假设vue的实例化对象为vm。\n\n```js\n    vm.$watch('isHot',function (newVal, oldVal) {\n        console.log(\"isHot属性发生了变化\");\n    });\n```\n\n## 3.监视属性之深度监视\n\n前面我们实现的监视，只能监视vue实例data中直接的简单数据，要是遇到对象或者数组，就无法监视了。\n\n这样做的方法是vue为了提高效率，在vue监视属性中，默认只监视一层，如果要监视多层，就需要我们手动开启深度监视。\n\n```js\n    watch: {\n        isHot: {\n            handler:function (newVal, oldVal) {\n                console.log(\"isHot属性发生了变化\");\n            },\n            immediate: true,\n            deep: true\n        }\n    }\n```\n\n其中`deep:true`就开启了深度监视。\n深度监视就是监视vue中data中的对象或者数组，当对象或者数组中的属性发生变化的时候，监视属性的回调函数就会自动调用。\n\n在vue中其实是可以检测对象内部值的变化，那为什么vue监视属性不默认开启深度监视呢？\n\n因为vue监视属性的回调函数是在数据发生变化的时候才会调用，如果开启深度监视，那么vue就要监视对象内部的所有属性，这样会大大降低vue的效率。\n\n在我们使用监视属性的时候，我们根据具体的业务需求，来判断要不要开启深度监视。","source":"_posts/vue监视属性.md","raw":"---\ntitle: vue监视属性\ndate: 2022-10-11\ntags: [前端]\ncategories: [Vue]\n---\n# vue监视属性\n\n在开发中，我们会遇到这样一种情况，我们需要一个属性变化的时候，然后做出一些操作。而检测这个变化的属性，在vue中叫做监视属性。\n\n## 1.监视属性是什么\n\n在vue中，我们可以通过watch属性来监视某个属性的变化，当这个属性发生变化时，我们可以执行一些操作。\n\n- 当监视属性所监视的属性发生变化的时候，回调函数（handler）就会自动调用，并且执行相关的操作\n- 监视属性所监视的属性要存在，才能产生作用。\n\n我们这里用一个天气案例来解释什么是监视属性：\n\n首先html代码：\n\n```html\n    <div id=\"app\">\n        <p>今天天气很{{info}}</p>\n        <button v-on:click=\"change\">切换天气</button>\n    </div>\n```\n\n接下来我们书写js代码：\n\n```js\n    var vm = new Vue({\n        el: \"#app\",\n        data: {\n            isHot: true,\n        },\n        computed: {\n            info: function () {\n                return this.isHot ? \"热\" : \"冷\";\n            }\n        },\n        methods: {\n            change: function () {\n                this.isHot = !this.isHot;\n            }\n        },\n        watch: {\n            isHot: {\n                handler:function (newVal, oldVal) {\n                    console.log(\"isHot属性发生了变化\");\n                },\n            }\n        }\n    });\n```\n\n在代码里面的`handler`这个函数就是我们前面说的回调函数，当`isHot`属性发生变化的时候，这个函数就会自动调用。\n\n当然我们可以在`idHot`对象面添加一个属性：`immediate`，当此属性布尔值为真的时候，`handler`回调函数在初始化的时候就会调用一次。\n\n```js\n    watch: {\n        isHot: {\n            handler:function (newVal, oldVal) {\n                console.log(\"isHot属性发生了变化\");\n            },\n            immediate: true\n        }\n    }\n```\n\n## 2.监视属性的写法\n\n监视属性有两种写法：\n\n- 在vue实例化对象中直接书写：  \n  `new Vue({watch:{}})`,然后传入相关配置\n- 通过vue实例化对象.$watch('属性名'，回调函数)来书写\n\n这里的第一种写法上面我们已经展现过了，下面我们就展示一下第二种写法：\n\n这里我们假设vue的实例化对象为vm。\n\n```js\n    vm.$watch('isHot',function (newVal, oldVal) {\n        console.log(\"isHot属性发生了变化\");\n    });\n```\n\n## 3.监视属性之深度监视\n\n前面我们实现的监视，只能监视vue实例data中直接的简单数据，要是遇到对象或者数组，就无法监视了。\n\n这样做的方法是vue为了提高效率，在vue监视属性中，默认只监视一层，如果要监视多层，就需要我们手动开启深度监视。\n\n```js\n    watch: {\n        isHot: {\n            handler:function (newVal, oldVal) {\n                console.log(\"isHot属性发生了变化\");\n            },\n            immediate: true,\n            deep: true\n        }\n    }\n```\n\n其中`deep:true`就开启了深度监视。\n深度监视就是监视vue中data中的对象或者数组，当对象或者数组中的属性发生变化的时候，监视属性的回调函数就会自动调用。\n\n在vue中其实是可以检测对象内部值的变化，那为什么vue监视属性不默认开启深度监视呢？\n\n因为vue监视属性的回调函数是在数据发生变化的时候才会调用，如果开启深度监视，那么vue就要监视对象内部的所有属性，这样会大大降低vue的效率。\n\n在我们使用监视属性的时候，我们根据具体的业务需求，来判断要不要开启深度监视。","slug":"vue监视属性","published":1,"updated":"2023-01-10T02:15:51.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhk001s9kbm4dwk7f98","content":"<h1 id=\"vue监视属性\"><a href=\"#vue监视属性\" class=\"headerlink\" title=\"vue监视属性\"></a>vue监视属性</h1><p>在开发中，我们会遇到这样一种情况，我们需要一个属性变化的时候，然后做出一些操作。而检测这个变化的属性，在vue中叫做监视属性。</p>\n<h2 id=\"1-监视属性是什么\"><a href=\"#1-监视属性是什么\" class=\"headerlink\" title=\"1.监视属性是什么\"></a>1.监视属性是什么</h2><p>在vue中，我们可以通过watch属性来监视某个属性的变化，当这个属性发生变化时，我们可以执行一些操作。</p>\n<ul>\n<li>当监视属性所监视的属性发生变化的时候，回调函数（handler）就会自动调用，并且执行相关的操作</li>\n<li>监视属性所监视的属性要存在，才能产生作用。</li>\n</ul>\n<p>我们这里用一个天气案例来解释什么是监视属性：</p>\n<p>首先html代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>今天天气很&#123;&#123;info&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;change&quot;</span>&gt;</span>切换天气<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来我们书写js代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">isHot</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">info</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">isHot</span> ? <span class=\"string\">&quot;热&quot;</span> : <span class=\"string\">&quot;冷&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">change</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">isHot</span> = !<span class=\"variable language_\">this</span>.<span class=\"property\">isHot</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">isHot</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">handler</span>:<span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;isHot属性发生了变化&quot;</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在代码里面的<code>handler</code>这个函数就是我们前面说的回调函数，当<code>isHot</code>属性发生变化的时候，这个函数就会自动调用。</p>\n<p>当然我们可以在<code>idHot</code>对象面添加一个属性：<code>immediate</code>，当此属性布尔值为真的时候，<code>handler</code>回调函数在初始化的时候就会调用一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">isHot</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">handler</span>:<span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;isHot属性发生了变化&quot;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-监视属性的写法\"><a href=\"#2-监视属性的写法\" class=\"headerlink\" title=\"2.监视属性的写法\"></a>2.监视属性的写法</h2><p>监视属性有两种写法：</p>\n<ul>\n<li>在vue实例化对象中直接书写：<br><code>new Vue(&#123;watch:&#123;&#125;&#125;)</code>,然后传入相关配置</li>\n<li>通过vue实例化对象.$watch(‘属性名’，回调函数)来书写</li>\n</ul>\n<p>这里的第一种写法上面我们已经展现过了，下面我们就展示一下第二种写法：</p>\n<p>这里我们假设vue的实例化对象为vm。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$watch(<span class=\"string\">&#x27;isHot&#x27;</span>,<span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;isHot属性发生了变化&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-监视属性之深度监视\"><a href=\"#3-监视属性之深度监视\" class=\"headerlink\" title=\"3.监视属性之深度监视\"></a>3.监视属性之深度监视</h2><p>前面我们实现的监视，只能监视vue实例data中直接的简单数据，要是遇到对象或者数组，就无法监视了。</p>\n<p>这样做的方法是vue为了提高效率，在vue监视属性中，默认只监视一层，如果要监视多层，就需要我们手动开启深度监视。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">isHot</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">handler</span>:<span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;isHot属性发生了变化&quot;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>deep:true</code>就开启了深度监视。<br>深度监视就是监视vue中data中的对象或者数组，当对象或者数组中的属性发生变化的时候，监视属性的回调函数就会自动调用。</p>\n<p>在vue中其实是可以检测对象内部值的变化，那为什么vue监视属性不默认开启深度监视呢？</p>\n<p>因为vue监视属性的回调函数是在数据发生变化的时候才会调用，如果开启深度监视，那么vue就要监视对象内部的所有属性，这样会大大降低vue的效率。</p>\n<p>在我们使用监视属性的时候，我们根据具体的业务需求，来判断要不要开启深度监视。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue监视属性\"><a href=\"#vue监视属性\" class=\"headerlink\" title=\"vue监视属性\"></a>vue监视属性</h1><p>在开发中，我们会遇到这样一种情况，我们需要一个属性变化的时候，然后做出一些操作。而检测这个变化的属性，在vue中叫做监视属性。</p>\n<h2 id=\"1-监视属性是什么\"><a href=\"#1-监视属性是什么\" class=\"headerlink\" title=\"1.监视属性是什么\"></a>1.监视属性是什么</h2><p>在vue中，我们可以通过watch属性来监视某个属性的变化，当这个属性发生变化时，我们可以执行一些操作。</p>\n<ul>\n<li>当监视属性所监视的属性发生变化的时候，回调函数（handler）就会自动调用，并且执行相关的操作</li>\n<li>监视属性所监视的属性要存在，才能产生作用。</li>\n</ul>\n<p>我们这里用一个天气案例来解释什么是监视属性：</p>\n<p>首先html代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>今天天气很&#123;&#123;info&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">v-on:click</span>=<span class=\"string\">&quot;change&quot;</span>&gt;</span>切换天气<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>接下来我们书写js代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">isHot</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">info</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">isHot</span> ? <span class=\"string\">&quot;热&quot;</span> : <span class=\"string\">&quot;冷&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">change</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">isHot</span> = !<span class=\"variable language_\">this</span>.<span class=\"property\">isHot</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">isHot</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">handler</span>:<span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;isHot属性发生了变化&quot;</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在代码里面的<code>handler</code>这个函数就是我们前面说的回调函数，当<code>isHot</code>属性发生变化的时候，这个函数就会自动调用。</p>\n<p>当然我们可以在<code>idHot</code>对象面添加一个属性：<code>immediate</code>，当此属性布尔值为真的时候，<code>handler</code>回调函数在初始化的时候就会调用一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">isHot</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">handler</span>:<span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;isHot属性发生了变化&quot;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-监视属性的写法\"><a href=\"#2-监视属性的写法\" class=\"headerlink\" title=\"2.监视属性的写法\"></a>2.监视属性的写法</h2><p>监视属性有两种写法：</p>\n<ul>\n<li>在vue实例化对象中直接书写：<br><code>new Vue(&#123;watch:&#123;&#125;&#125;)</code>,然后传入相关配置</li>\n<li>通过vue实例化对象.$watch(‘属性名’，回调函数)来书写</li>\n</ul>\n<p>这里的第一种写法上面我们已经展现过了，下面我们就展示一下第二种写法：</p>\n<p>这里我们假设vue的实例化对象为vm。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$watch(<span class=\"string\">&#x27;isHot&#x27;</span>,<span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;isHot属性发生了变化&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-监视属性之深度监视\"><a href=\"#3-监视属性之深度监视\" class=\"headerlink\" title=\"3.监视属性之深度监视\"></a>3.监视属性之深度监视</h2><p>前面我们实现的监视，只能监视vue实例data中直接的简单数据，要是遇到对象或者数组，就无法监视了。</p>\n<p>这样做的方法是vue为了提高效率，在vue监视属性中，默认只监视一层，如果要监视多层，就需要我们手动开启深度监视。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">isHot</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">handler</span>:<span class=\"keyword\">function</span> (<span class=\"params\">newVal, oldVal</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;isHot属性发生了变化&quot;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">deep</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>deep:true</code>就开启了深度监视。<br>深度监视就是监视vue中data中的对象或者数组，当对象或者数组中的属性发生变化的时候，监视属性的回调函数就会自动调用。</p>\n<p>在vue中其实是可以检测对象内部值的变化，那为什么vue监视属性不默认开启深度监视呢？</p>\n<p>因为vue监视属性的回调函数是在数据发生变化的时候才会调用，如果开启深度监视，那么vue就要监视对象内部的所有属性，这样会大大降低vue的效率。</p>\n<p>在我们使用监视属性的时候，我们根据具体的业务需求，来判断要不要开启深度监视。</p>\n"},{"title":"vue绑定样式","date":"2022-10-18T16:00:00.000Z","_content":"# vue绑定样式\n\n总所周知，vue是一个响应式的框架，当数据发生改变的时候，页面会自动响应这个变化。那么当元素的样式发生改变的时候，也应该动态的发生改变，要实现这样一种效果，我们可以使用vue的绑定样式的方式来实现。\n\n在vue中，我们可以使用v-bind来绑定元素的属性，那么这里我们就需要使用到v-bind去绑定元素的class属性，来实现元素的样式绑定。\n\n具体如何操作我们接着往下看：\n\n## 1. 绑定class\n\n我们使用v-bind绑定class属性，来实现元素的样式绑定。\n\n```html\n<div id=\"app\">\n    <div v-bind:class=\"classObject\">我是一个div</div>\n</div>\n```\n\n```javascript\nvar app = new Vue({\n    el:'#app',\n    data:{\n        classObject:{\n            'class1':true,\n            'class2':false\n        }\n    }\n})\n```\n\n```css\n.class1{\n    color:red;\n}\n.class2{\n    color:blue;\n}\n```\n\n代码解释：  \n在上面我们分别将html、css、JavaScript分开写，我们可以看到，我们在html中使用v-bind绑定了class属性，然后在JavaScript中定义了一个classObject对象，这个对象中有两个属性，分别是class1和class2，这两个属性的值分别是true和false，那么我们可以看到，当class1的值为true的时候，div的颜色为红色，当class2的值为true的时候，div的颜色为蓝色，当两个值都为true的时候，div的颜色为蓝色，当两个值都为false的时候，div的颜色为黑色。\n\n## 2.绑定内联样式\n\n前面我们演示了如何绑定class，那么我们也可以使用v-bind绑定style属性，来实现元素的样式绑定。\n\n```html\n<div id=\"app\">\n    <div v-bind:style=\"backGroundColor,fontSize\">我是一个div</div>\n</div>\n```\n\n```js\n    var vm = new Vue({\n        el:'#app',\n        data(){\n            return {\n                backGroundColor:'background-color:red',\n                fontSize:'font-size:20px',\n            }\n        }\n    })\n```\n\n在上面的代码中，我们使用vue绑定了一个style样式，在代码里面我们可以看到，内联样式我们属性名使用的是驼峰命名，而不是外部css样式采用`-`连接的方式。\n\n## 3. 扩展\n\n\n在实际的开发中，我们经常会遇到统一个元素需要绑定多个样式的情况，vue中同样可以做到。\n\n### 数组语法（绑定多个样式）\n\n使用数组语法，就是将多个样式传进一个数组里面，最后在模板里面使用`v-bind:style`绑定这个数组。\n\n```html\n<div id=\"app\">\n    <div v-bind:class=\"[bgc,color]\">我是一个div</div>\n</div>\n```\n\n```js\n    var vm = new Vue({\n        el:\"#app\",\n        data(){\n            return {\n                bgc:'background-color':'red',\n                color:'color':'blue',\n            }\n        }\n    })\n```\n","source":"_posts/vue绑定样式.md","raw":"---\ntitle:  vue绑定样式\ndate: 2022-10-19\ntags: [前端]\ncategories: [Vue]\n---\n# vue绑定样式\n\n总所周知，vue是一个响应式的框架，当数据发生改变的时候，页面会自动响应这个变化。那么当元素的样式发生改变的时候，也应该动态的发生改变，要实现这样一种效果，我们可以使用vue的绑定样式的方式来实现。\n\n在vue中，我们可以使用v-bind来绑定元素的属性，那么这里我们就需要使用到v-bind去绑定元素的class属性，来实现元素的样式绑定。\n\n具体如何操作我们接着往下看：\n\n## 1. 绑定class\n\n我们使用v-bind绑定class属性，来实现元素的样式绑定。\n\n```html\n<div id=\"app\">\n    <div v-bind:class=\"classObject\">我是一个div</div>\n</div>\n```\n\n```javascript\nvar app = new Vue({\n    el:'#app',\n    data:{\n        classObject:{\n            'class1':true,\n            'class2':false\n        }\n    }\n})\n```\n\n```css\n.class1{\n    color:red;\n}\n.class2{\n    color:blue;\n}\n```\n\n代码解释：  \n在上面我们分别将html、css、JavaScript分开写，我们可以看到，我们在html中使用v-bind绑定了class属性，然后在JavaScript中定义了一个classObject对象，这个对象中有两个属性，分别是class1和class2，这两个属性的值分别是true和false，那么我们可以看到，当class1的值为true的时候，div的颜色为红色，当class2的值为true的时候，div的颜色为蓝色，当两个值都为true的时候，div的颜色为蓝色，当两个值都为false的时候，div的颜色为黑色。\n\n## 2.绑定内联样式\n\n前面我们演示了如何绑定class，那么我们也可以使用v-bind绑定style属性，来实现元素的样式绑定。\n\n```html\n<div id=\"app\">\n    <div v-bind:style=\"backGroundColor,fontSize\">我是一个div</div>\n</div>\n```\n\n```js\n    var vm = new Vue({\n        el:'#app',\n        data(){\n            return {\n                backGroundColor:'background-color:red',\n                fontSize:'font-size:20px',\n            }\n        }\n    })\n```\n\n在上面的代码中，我们使用vue绑定了一个style样式，在代码里面我们可以看到，内联样式我们属性名使用的是驼峰命名，而不是外部css样式采用`-`连接的方式。\n\n## 3. 扩展\n\n\n在实际的开发中，我们经常会遇到统一个元素需要绑定多个样式的情况，vue中同样可以做到。\n\n### 数组语法（绑定多个样式）\n\n使用数组语法，就是将多个样式传进一个数组里面，最后在模板里面使用`v-bind:style`绑定这个数组。\n\n```html\n<div id=\"app\">\n    <div v-bind:class=\"[bgc,color]\">我是一个div</div>\n</div>\n```\n\n```js\n    var vm = new Vue({\n        el:\"#app\",\n        data(){\n            return {\n                bgc:'background-color':'red',\n                color:'color':'blue',\n            }\n        }\n    })\n```\n","slug":"vue绑定样式","published":1,"updated":"2023-01-10T02:15:21.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhl001w9kbm7dlbdzgx","content":"<h1 id=\"vue绑定样式\"><a href=\"#vue绑定样式\" class=\"headerlink\" title=\"vue绑定样式\"></a>vue绑定样式</h1><p>总所周知，vue是一个响应式的框架，当数据发生改变的时候，页面会自动响应这个变化。那么当元素的样式发生改变的时候，也应该动态的发生改变，要实现这样一种效果，我们可以使用vue的绑定样式的方式来实现。</p>\n<p>在vue中，我们可以使用v-bind来绑定元素的属性，那么这里我们就需要使用到v-bind去绑定元素的class属性，来实现元素的样式绑定。</p>\n<p>具体如何操作我们接着往下看：</p>\n<h2 id=\"1-绑定class\"><a href=\"#1-绑定class\" class=\"headerlink\" title=\"1. 绑定class\"></a>1. 绑定class</h2><p>我们使用v-bind绑定class属性，来实现元素的样式绑定。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">&quot;classObject&quot;</span>&gt;</span>我是一个div<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>:<span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">classObject</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;class1&#x27;</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;class2&#x27;</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.class1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.class2</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：<br>在上面我们分别将html、css、JavaScript分开写，我们可以看到，我们在html中使用v-bind绑定了class属性，然后在JavaScript中定义了一个classObject对象，这个对象中有两个属性，分别是class1和class2，这两个属性的值分别是true和false，那么我们可以看到，当class1的值为true的时候，div的颜色为红色，当class2的值为true的时候，div的颜色为蓝色，当两个值都为true的时候，div的颜色为蓝色，当两个值都为false的时候，div的颜色为黑色。</p>\n<h2 id=\"2-绑定内联样式\"><a href=\"#2-绑定内联样式\" class=\"headerlink\" title=\"2.绑定内联样式\"></a>2.绑定内联样式</h2><p>前面我们演示了如何绑定class，那么我们也可以使用v-bind绑定style属性，来实现元素的样式绑定。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">&quot;backGroundColor,fontSize&quot;</span>&gt;</span>我是一个div<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>:<span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">backGroundColor</span>:<span class=\"string\">&#x27;background-color:red&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">fontSize</span>:<span class=\"string\">&#x27;font-size:20px&#x27;</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们使用vue绑定了一个style样式，在代码里面我们可以看到，内联样式我们属性名使用的是驼峰命名，而不是外部css样式采用<code>-</code>连接的方式。</p>\n<h2 id=\"3-扩展\"><a href=\"#3-扩展\" class=\"headerlink\" title=\"3. 扩展\"></a>3. 扩展</h2><p>在实际的开发中，我们经常会遇到统一个元素需要绑定多个样式的情况，vue中同样可以做到。</p>\n<h3 id=\"数组语法（绑定多个样式）\"><a href=\"#数组语法（绑定多个样式）\" class=\"headerlink\" title=\"数组语法（绑定多个样式）\"></a>数组语法（绑定多个样式）</h3><p>使用数组语法，就是将多个样式传进一个数组里面，最后在模板里面使用<code>v-bind:style</code>绑定这个数组。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">&quot;[bgc,color]&quot;</span>&gt;</span>我是一个div<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>:<span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">bgc</span>:<span class=\"string\">&#x27;background-color&#x27;</span>:<span class=\"string\">&#x27;red&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">color</span>:<span class=\"string\">&#x27;color&#x27;</span>:<span class=\"string\">&#x27;blue&#x27;</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"vue绑定样式\"><a href=\"#vue绑定样式\" class=\"headerlink\" title=\"vue绑定样式\"></a>vue绑定样式</h1><p>总所周知，vue是一个响应式的框架，当数据发生改变的时候，页面会自动响应这个变化。那么当元素的样式发生改变的时候，也应该动态的发生改变，要实现这样一种效果，我们可以使用vue的绑定样式的方式来实现。</p>\n<p>在vue中，我们可以使用v-bind来绑定元素的属性，那么这里我们就需要使用到v-bind去绑定元素的class属性，来实现元素的样式绑定。</p>\n<p>具体如何操作我们接着往下看：</p>\n<h2 id=\"1-绑定class\"><a href=\"#1-绑定class\" class=\"headerlink\" title=\"1. 绑定class\"></a>1. 绑定class</h2><p>我们使用v-bind绑定class属性，来实现元素的样式绑定。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">&quot;classObject&quot;</span>&gt;</span>我是一个div<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>:<span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>:&#123;</span><br><span class=\"line\">        <span class=\"attr\">classObject</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;class1&#x27;</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;class2&#x27;</span>:<span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.class1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.class2</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:blue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：<br>在上面我们分别将html、css、JavaScript分开写，我们可以看到，我们在html中使用v-bind绑定了class属性，然后在JavaScript中定义了一个classObject对象，这个对象中有两个属性，分别是class1和class2，这两个属性的值分别是true和false，那么我们可以看到，当class1的值为true的时候，div的颜色为红色，当class2的值为true的时候，div的颜色为蓝色，当两个值都为true的时候，div的颜色为蓝色，当两个值都为false的时候，div的颜色为黑色。</p>\n<h2 id=\"2-绑定内联样式\"><a href=\"#2-绑定内联样式\" class=\"headerlink\" title=\"2.绑定内联样式\"></a>2.绑定内联样式</h2><p>前面我们演示了如何绑定class，那么我们也可以使用v-bind绑定style属性，来实现元素的样式绑定。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:style</span>=<span class=\"string\">&quot;backGroundColor,fontSize&quot;</span>&gt;</span>我是一个div<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>:<span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">backGroundColor</span>:<span class=\"string\">&#x27;background-color:red&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">fontSize</span>:<span class=\"string\">&#x27;font-size:20px&#x27;</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们使用vue绑定了一个style样式，在代码里面我们可以看到，内联样式我们属性名使用的是驼峰命名，而不是外部css样式采用<code>-</code>连接的方式。</p>\n<h2 id=\"3-扩展\"><a href=\"#3-扩展\" class=\"headerlink\" title=\"3. 扩展\"></a>3. 扩展</h2><p>在实际的开发中，我们经常会遇到统一个元素需要绑定多个样式的情况，vue中同样可以做到。</p>\n<h3 id=\"数组语法（绑定多个样式）\"><a href=\"#数组语法（绑定多个样式）\" class=\"headerlink\" title=\"数组语法（绑定多个样式）\"></a>数组语法（绑定多个样式）</h3><p>使用数组语法，就是将多个样式传进一个数组里面，最后在模板里面使用<code>v-bind:style</code>绑定这个数组。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;app&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-bind:class</span>=<span class=\"string\">&quot;[bgc,color]&quot;</span>&gt;</span>我是一个div<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vm = <span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>:<span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">bgc</span>:<span class=\"string\">&#x27;background-color&#x27;</span>:<span class=\"string\">&#x27;red&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">color</span>:<span class=\"string\">&#x27;color&#x27;</span>:<span class=\"string\">&#x27;blue&#x27;</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"一个商务简约的登陆界面","date":"2022-11-14T16:00:00.000Z","_content":"# 一个商务简约的登陆界面\n\n前几天在逛codepen的时候，发现了一个很有意思的登陆界面，于是就想着自己实现一下，于是就有了这个demo。  \n顺便将接下来网站的登陆界面也改成这个样式了。\n\n先上一个效果图：\n\n![登陆动画1.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608aaa31d43b449c9fe46394d8da333d~tplv-k3u1fbpfcp-watermark.image?)\n\n在效果图里面我们看到有两个输入框，一个为文本输入框，一个为密码输入框。  \n由于两个输入框的样式大体差不多，所以我们只讲述第一个输入框的实现。\n\n## 1.输入框结构\n\n实际上，这个输入框有两部分组成：  \n分别是输入框的提示内容和输输入框本体。\n\n我们将输入框的提示内容放进`label`标签中，并且给`label`标签添加一个`for`属性，值为输入框的`id`属性值。\n\n这样用户在点击提示语句时，光标会自动聚焦到输入框中。\n\n```html\n    <div class=\"user_name\">\n        <label for=\"userName\" class=\"userNameTip\">请输入您的用户名</label>\n        <input type=\"text\" id=\"userName\">\n    </div>\n```\n\n到此为止，我们输入框的结构就搭建好了。\n\n## 2.输入框样式\n\n我们先给整个大盒子添加一个相对定位，方便后续我们对里面元素的位置调整。顺便设置一个整个盒子的大小。\n\n```css\n    .user_name {\n        position: relative;\n        width: 400px;\n        height: 200px;\n    }\n```\n\n接下来我们就给输入框改变一个样式，毕竟这样一个默认的框框实在太难看了。\n\n```css\n    .user_name{\n        width: 200px;\n        height: 50px;\n        position: absolute;\n        top: 50px;\n        left: 30px;\n        font-size: 20px;\n    }\n```\n\n这里我们首先给整个输入框的整体调整一个位置，然后设置一个字体大小，这样我们的输入框就有了一个基本的样式。\n\n下面就开始设置输入框的样式：\n\n```css\n#userName{\n    display: inline-block;\n    width: 300px;\n    height: 30px;\n    color: #0FF;\n    font-size: 20px;\n    border: 0px transparent;\n    border-bottom: 2px solid #fff;\n    background-color: rgb(54, 54, 54);\n}\n```\n\n在这里我们设置了输入框的宽度，高度，字体颜色，字体大小，边框，背景颜色。\n\n因为我此时整个大背景颜色为`rgb(54, 54, 54)`,为了不让这个输入框这么突出没所以我设置了输入框的背景颜色与大背景颜色为一样的颜色。\n\n但是这样还不够，因为在输入框获得焦点的时候，输入框外边还有一个边框，这样会使得输入框很丑。\n\n通过`outline`属性我们可以设置输入框获得焦点时的边框样式。  \n在效果图中，我们可以看见输入框获得焦点时，输入框下边有一个蓝色的边框，这个边框的宽度为2px，颜色为`#0FF`。\n \n我们我们这样给输入框来一个样式：\n\n```css\n#userName:focus{\n    outline: none;\n    border-bottom: 2px solid #0FF;\n}\n```\n\n这样输入框的样式就出来了：\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a7e84995e24015bfe6b8ed95a0408e~tplv-k3u1fbpfcp-watermark.image?)\n\n## 3.输入框提示语\n\n在效果图里面输入框还未获得焦点的时候，提示语句在输入框里面的，这个就是我们使用绝对定位来实现的，调整到合适的位置，将提示语句放在输入框里面。  \n并且此时文字的颜色为白色。\n\n```css\n.userNameTip{\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    font-size: 20px;\n    color: #fff;\n}\n```\n\n最后这整个输入框的样式就是这样：\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f378810fa248c6a5de236917b7af40~tplv-k3u1fbpfcp-watermark.image?)\n\n当然现在这是一个静态的输入框，没有任何的交互，我们接下来就来实现这个输入框的交互。\n\n## 4.输入框交互\n\n交互肯定需要一个动画来实现，这里我们发现在输入框获得焦点之后，提示文字会变小，颜色也会随之改变，然后移动到输入框的上方，这个就是我们需要实现的效果。\n\n失去焦点之后,我们就会判断，这个输入框里面是否有内容：  \n如果有内容的话，动画就不移除，一直保持动画的结束状态；如果没有内容，就移除动画回到初识状态。\n\n那么我们定义一个动画：\n\n```css\n@keyframes user {\n    from{\n        top: 0px;\n        font-size: 20px;\n    }\n    to{\n        top: -20px;\n        font-size: 12px;\n        color: #0FF;\n    }\n}\n```\n\n现在有一个问题，我们点击输入框，最后将这个动画添加到输入框的提示语句上，那么我们如何将动画添加上去呢？\n\n我这里使用的jquery中对`class`的操作来实现，也就是利用`jQuery`中的`addClass()`和`removeClass()`方法来实现。\n\n那么在此之前，我们就需要先将动画写进一个类里面，然后通过`jQuery`来操作这个类。\n\n我这里简单的写了一个`class`，然后将动画写进去：\n\n```css\n.userNameTipA{\n    animation: user 0.3s linear normal forwards;\n    animation-iteration-count: 1;\n}\n```\n\n然后我们就可以通过`jQuery`来操作这个类了：\n\n```javascript\n$('#userName').focus(function () {\n    $('.userNameTip').addClass('userNameTipA');\n    console.log(\"点击了\");\n})\n$('#userName').blur(function () {\n    let val = $('#userName').val();\n    if (val) {\n        return;\n    } else {\n        $('.userNameTip').removeClass('userNameTipA');\n    }\n});\n```\n\n最后点击保存，运行，就可以看到效果了。\n\n## 总结\n\n其实这个demo还是很简单的，就是利用一些定位来调整输入框的位置，然后针对输入框的聚焦样式和失焦样式来实现动画，最后通过`jQuery`来操作这个动画。","source":"_posts/一个商务简约的登陆界面.md","raw":"---\ntitle: 一个商务简约的登陆界面\ndate: 2022-11-15\ntags: [前端]\ncategories: [css,html]\n---\n# 一个商务简约的登陆界面\n\n前几天在逛codepen的时候，发现了一个很有意思的登陆界面，于是就想着自己实现一下，于是就有了这个demo。  \n顺便将接下来网站的登陆界面也改成这个样式了。\n\n先上一个效果图：\n\n![登陆动画1.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608aaa31d43b449c9fe46394d8da333d~tplv-k3u1fbpfcp-watermark.image?)\n\n在效果图里面我们看到有两个输入框，一个为文本输入框，一个为密码输入框。  \n由于两个输入框的样式大体差不多，所以我们只讲述第一个输入框的实现。\n\n## 1.输入框结构\n\n实际上，这个输入框有两部分组成：  \n分别是输入框的提示内容和输输入框本体。\n\n我们将输入框的提示内容放进`label`标签中，并且给`label`标签添加一个`for`属性，值为输入框的`id`属性值。\n\n这样用户在点击提示语句时，光标会自动聚焦到输入框中。\n\n```html\n    <div class=\"user_name\">\n        <label for=\"userName\" class=\"userNameTip\">请输入您的用户名</label>\n        <input type=\"text\" id=\"userName\">\n    </div>\n```\n\n到此为止，我们输入框的结构就搭建好了。\n\n## 2.输入框样式\n\n我们先给整个大盒子添加一个相对定位，方便后续我们对里面元素的位置调整。顺便设置一个整个盒子的大小。\n\n```css\n    .user_name {\n        position: relative;\n        width: 400px;\n        height: 200px;\n    }\n```\n\n接下来我们就给输入框改变一个样式，毕竟这样一个默认的框框实在太难看了。\n\n```css\n    .user_name{\n        width: 200px;\n        height: 50px;\n        position: absolute;\n        top: 50px;\n        left: 30px;\n        font-size: 20px;\n    }\n```\n\n这里我们首先给整个输入框的整体调整一个位置，然后设置一个字体大小，这样我们的输入框就有了一个基本的样式。\n\n下面就开始设置输入框的样式：\n\n```css\n#userName{\n    display: inline-block;\n    width: 300px;\n    height: 30px;\n    color: #0FF;\n    font-size: 20px;\n    border: 0px transparent;\n    border-bottom: 2px solid #fff;\n    background-color: rgb(54, 54, 54);\n}\n```\n\n在这里我们设置了输入框的宽度，高度，字体颜色，字体大小，边框，背景颜色。\n\n因为我此时整个大背景颜色为`rgb(54, 54, 54)`,为了不让这个输入框这么突出没所以我设置了输入框的背景颜色与大背景颜色为一样的颜色。\n\n但是这样还不够，因为在输入框获得焦点的时候，输入框外边还有一个边框，这样会使得输入框很丑。\n\n通过`outline`属性我们可以设置输入框获得焦点时的边框样式。  \n在效果图中，我们可以看见输入框获得焦点时，输入框下边有一个蓝色的边框，这个边框的宽度为2px，颜色为`#0FF`。\n \n我们我们这样给输入框来一个样式：\n\n```css\n#userName:focus{\n    outline: none;\n    border-bottom: 2px solid #0FF;\n}\n```\n\n这样输入框的样式就出来了：\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a7e84995e24015bfe6b8ed95a0408e~tplv-k3u1fbpfcp-watermark.image?)\n\n## 3.输入框提示语\n\n在效果图里面输入框还未获得焦点的时候，提示语句在输入框里面的，这个就是我们使用绝对定位来实现的，调整到合适的位置，将提示语句放在输入框里面。  \n并且此时文字的颜色为白色。\n\n```css\n.userNameTip{\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    font-size: 20px;\n    color: #fff;\n}\n```\n\n最后这整个输入框的样式就是这样：\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f378810fa248c6a5de236917b7af40~tplv-k3u1fbpfcp-watermark.image?)\n\n当然现在这是一个静态的输入框，没有任何的交互，我们接下来就来实现这个输入框的交互。\n\n## 4.输入框交互\n\n交互肯定需要一个动画来实现，这里我们发现在输入框获得焦点之后，提示文字会变小，颜色也会随之改变，然后移动到输入框的上方，这个就是我们需要实现的效果。\n\n失去焦点之后,我们就会判断，这个输入框里面是否有内容：  \n如果有内容的话，动画就不移除，一直保持动画的结束状态；如果没有内容，就移除动画回到初识状态。\n\n那么我们定义一个动画：\n\n```css\n@keyframes user {\n    from{\n        top: 0px;\n        font-size: 20px;\n    }\n    to{\n        top: -20px;\n        font-size: 12px;\n        color: #0FF;\n    }\n}\n```\n\n现在有一个问题，我们点击输入框，最后将这个动画添加到输入框的提示语句上，那么我们如何将动画添加上去呢？\n\n我这里使用的jquery中对`class`的操作来实现，也就是利用`jQuery`中的`addClass()`和`removeClass()`方法来实现。\n\n那么在此之前，我们就需要先将动画写进一个类里面，然后通过`jQuery`来操作这个类。\n\n我这里简单的写了一个`class`，然后将动画写进去：\n\n```css\n.userNameTipA{\n    animation: user 0.3s linear normal forwards;\n    animation-iteration-count: 1;\n}\n```\n\n然后我们就可以通过`jQuery`来操作这个类了：\n\n```javascript\n$('#userName').focus(function () {\n    $('.userNameTip').addClass('userNameTipA');\n    console.log(\"点击了\");\n})\n$('#userName').blur(function () {\n    let val = $('#userName').val();\n    if (val) {\n        return;\n    } else {\n        $('.userNameTip').removeClass('userNameTipA');\n    }\n});\n```\n\n最后点击保存，运行，就可以看到效果了。\n\n## 总结\n\n其实这个demo还是很简单的，就是利用一些定位来调整输入框的位置，然后针对输入框的聚焦样式和失焦样式来实现动画，最后通过`jQuery`来操作这个动画。","slug":"一个商务简约的登陆界面","published":1,"updated":"2023-01-09T11:44:40.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhm001z9kbm2l4mhoeo","content":"<h1 id=\"一个商务简约的登陆界面\"><a href=\"#一个商务简约的登陆界面\" class=\"headerlink\" title=\"一个商务简约的登陆界面\"></a>一个商务简约的登陆界面</h1><p>前几天在逛codepen的时候，发现了一个很有意思的登陆界面，于是就想着自己实现一下，于是就有了这个demo。<br>顺便将接下来网站的登陆界面也改成这个样式了。</p>\n<p>先上一个效果图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608aaa31d43b449c9fe46394d8da333d~tplv-k3u1fbpfcp-watermark.image\" alt=\"登陆动画1.gif\"></p>\n<p>在效果图里面我们看到有两个输入框，一个为文本输入框，一个为密码输入框。<br>由于两个输入框的样式大体差不多，所以我们只讲述第一个输入框的实现。</p>\n<h2 id=\"1-输入框结构\"><a href=\"#1-输入框结构\" class=\"headerlink\" title=\"1.输入框结构\"></a>1.输入框结构</h2><p>实际上，这个输入框有两部分组成：<br>分别是输入框的提示内容和输输入框本体。</p>\n<p>我们将输入框的提示内容放进<code>label</code>标签中，并且给<code>label</code>标签添加一个<code>for</code>属性，值为输入框的<code>id</code>属性值。</p>\n<p>这样用户在点击提示语句时，光标会自动聚焦到输入框中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;user_name&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;userName&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;userNameTip&quot;</span>&gt;</span>请输入您的用户名<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userName&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>到此为止，我们输入框的结构就搭建好了。</p>\n<h2 id=\"2-输入框样式\"><a href=\"#2-输入框样式\" class=\"headerlink\" title=\"2.输入框样式\"></a>2.输入框样式</h2><p>我们先给整个大盒子添加一个相对定位，方便后续我们对里面元素的位置调整。顺便设置一个整个盒子的大小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.user_name</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们就给输入框改变一个样式，毕竟这样一个默认的框框实在太难看了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.user_name</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们首先给整个输入框的整体调整一个位置，然后设置一个字体大小，这样我们的输入框就有了一个基本的样式。</p>\n<p>下面就开始设置输入框的样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#userName</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#0FF</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0px</span> transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">54</span>, <span class=\"number\">54</span>, <span class=\"number\">54</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里我们设置了输入框的宽度，高度，字体颜色，字体大小，边框，背景颜色。</p>\n<p>因为我此时整个大背景颜色为<code>rgb(54, 54, 54)</code>,为了不让这个输入框这么突出没所以我设置了输入框的背景颜色与大背景颜色为一样的颜色。</p>\n<p>但是这样还不够，因为在输入框获得焦点的时候，输入框外边还有一个边框，这样会使得输入框很丑。</p>\n<p>通过<code>outline</code>属性我们可以设置输入框获得焦点时的边框样式。<br>在效果图中，我们可以看见输入框获得焦点时，输入框下边有一个蓝色的边框，这个边框的宽度为2px，颜色为<code>#0FF</code>。</p>\n<p>我们我们这样给输入框来一个样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#userName</span><span class=\"selector-pseudo\">:focus</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#0FF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样输入框的样式就出来了：<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a7e84995e24015bfe6b8ed95a0408e~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2 id=\"3-输入框提示语\"><a href=\"#3-输入框提示语\" class=\"headerlink\" title=\"3.输入框提示语\"></a>3.输入框提示语</h2><p>在效果图里面输入框还未获得焦点的时候，提示语句在输入框里面的，这个就是我们使用绝对定位来实现的，调整到合适的位置，将提示语句放在输入框里面。<br>并且此时文字的颜色为白色。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.userNameTip</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后这整个输入框的样式就是这样：<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f378810fa248c6a5de236917b7af40~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>当然现在这是一个静态的输入框，没有任何的交互，我们接下来就来实现这个输入框的交互。</p>\n<h2 id=\"4-输入框交互\"><a href=\"#4-输入框交互\" class=\"headerlink\" title=\"4.输入框交互\"></a>4.输入框交互</h2><p>交互肯定需要一个动画来实现，这里我们发现在输入框获得焦点之后，提示文字会变小，颜色也会随之改变，然后移动到输入框的上方，这个就是我们需要实现的效果。</p>\n<p>失去焦点之后,我们就会判断，这个输入框里面是否有内容：<br>如果有内容的话，动画就不移除，一直保持动画的结束状态；如果没有内容，就移除动画回到初识状态。</p>\n<p>那么我们定义一个动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> user &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">font-size</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: <span class=\"number\">#0FF</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在有一个问题，我们点击输入框，最后将这个动画添加到输入框的提示语句上，那么我们如何将动画添加上去呢？</p>\n<p>我这里使用的jquery中对<code>class</code>的操作来实现，也就是利用<code>jQuery</code>中的<code>addClass()</code>和<code>removeClass()</code>方法来实现。</p>\n<p>那么在此之前，我们就需要先将动画写进一个类里面，然后通过<code>jQuery</code>来操作这个类。</p>\n<p>我这里简单的写了一个<code>class</code>，然后将动画写进去：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.userNameTipA</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: user <span class=\"number\">0.3s</span> linear normal forwards;</span><br><span class=\"line\">    <span class=\"attribute\">animation-iteration-count</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们就可以通过<code>jQuery</code>来操作这个类了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;#userName&#x27;</span>).<span class=\"title function_\">focus</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;.userNameTip&#x27;</span>).<span class=\"title function_\">addClass</span>(<span class=\"string\">&#x27;userNameTipA&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;点击了&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(<span class=\"string\">&#x27;#userName&#x27;</span>).<span class=\"title function_\">blur</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> val = $(<span class=\"string\">&#x27;#userName&#x27;</span>).<span class=\"title function_\">val</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        $(<span class=\"string\">&#x27;.userNameTip&#x27;</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&#x27;userNameTipA&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>最后点击保存，运行，就可以看到效果了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实这个demo还是很简单的，就是利用一些定位来调整输入框的位置，然后针对输入框的聚焦样式和失焦样式来实现动画，最后通过<code>jQuery</code>来操作这个动画。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一个商务简约的登陆界面\"><a href=\"#一个商务简约的登陆界面\" class=\"headerlink\" title=\"一个商务简约的登陆界面\"></a>一个商务简约的登陆界面</h1><p>前几天在逛codepen的时候，发现了一个很有意思的登陆界面，于是就想着自己实现一下，于是就有了这个demo。<br>顺便将接下来网站的登陆界面也改成这个样式了。</p>\n<p>先上一个效果图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608aaa31d43b449c9fe46394d8da333d~tplv-k3u1fbpfcp-watermark.image\" alt=\"登陆动画1.gif\"></p>\n<p>在效果图里面我们看到有两个输入框，一个为文本输入框，一个为密码输入框。<br>由于两个输入框的样式大体差不多，所以我们只讲述第一个输入框的实现。</p>\n<h2 id=\"1-输入框结构\"><a href=\"#1-输入框结构\" class=\"headerlink\" title=\"1.输入框结构\"></a>1.输入框结构</h2><p>实际上，这个输入框有两部分组成：<br>分别是输入框的提示内容和输输入框本体。</p>\n<p>我们将输入框的提示内容放进<code>label</code>标签中，并且给<code>label</code>标签添加一个<code>for</code>属性，值为输入框的<code>id</code>属性值。</p>\n<p>这样用户在点击提示语句时，光标会自动聚焦到输入框中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;user_name&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;userName&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;userNameTip&quot;</span>&gt;</span>请输入您的用户名<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userName&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>到此为止，我们输入框的结构就搭建好了。</p>\n<h2 id=\"2-输入框样式\"><a href=\"#2-输入框样式\" class=\"headerlink\" title=\"2.输入框样式\"></a>2.输入框样式</h2><p>我们先给整个大盒子添加一个相对定位，方便后续我们对里面元素的位置调整。顺便设置一个整个盒子的大小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.user_name</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们就给输入框改变一个样式，毕竟这样一个默认的框框实在太难看了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.user_name</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们首先给整个输入框的整体调整一个位置，然后设置一个字体大小，这样我们的输入框就有了一个基本的样式。</p>\n<p>下面就开始设置输入框的样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#userName</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#0FF</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0px</span> transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">54</span>, <span class=\"number\">54</span>, <span class=\"number\">54</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里我们设置了输入框的宽度，高度，字体颜色，字体大小，边框，背景颜色。</p>\n<p>因为我此时整个大背景颜色为<code>rgb(54, 54, 54)</code>,为了不让这个输入框这么突出没所以我设置了输入框的背景颜色与大背景颜色为一样的颜色。</p>\n<p>但是这样还不够，因为在输入框获得焦点的时候，输入框外边还有一个边框，这样会使得输入框很丑。</p>\n<p>通过<code>outline</code>属性我们可以设置输入框获得焦点时的边框样式。<br>在效果图中，我们可以看见输入框获得焦点时，输入框下边有一个蓝色的边框，这个边框的宽度为2px，颜色为<code>#0FF</code>。</p>\n<p>我们我们这样给输入框来一个样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#userName</span><span class=\"selector-pseudo\">:focus</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">2px</span> solid <span class=\"number\">#0FF</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样输入框的样式就出来了：<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a7e84995e24015bfe6b8ed95a0408e~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2 id=\"3-输入框提示语\"><a href=\"#3-输入框提示语\" class=\"headerlink\" title=\"3.输入框提示语\"></a>3.输入框提示语</h2><p>在效果图里面输入框还未获得焦点的时候，提示语句在输入框里面的，这个就是我们使用绝对定位来实现的，调整到合适的位置，将提示语句放在输入框里面。<br>并且此时文字的颜色为白色。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.userNameTip</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后这整个输入框的样式就是这样：<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f378810fa248c6a5de236917b7af40~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>当然现在这是一个静态的输入框，没有任何的交互，我们接下来就来实现这个输入框的交互。</p>\n<h2 id=\"4-输入框交互\"><a href=\"#4-输入框交互\" class=\"headerlink\" title=\"4.输入框交互\"></a>4.输入框交互</h2><p>交互肯定需要一个动画来实现，这里我们发现在输入框获得焦点之后，提示文字会变小，颜色也会随之改变，然后移动到输入框的上方，这个就是我们需要实现的效果。</p>\n<p>失去焦点之后,我们就会判断，这个输入框里面是否有内容：<br>如果有内容的话，动画就不移除，一直保持动画的结束状态；如果没有内容，就移除动画回到初识状态。</p>\n<p>那么我们定义一个动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> user &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">font-size</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: <span class=\"number\">#0FF</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在有一个问题，我们点击输入框，最后将这个动画添加到输入框的提示语句上，那么我们如何将动画添加上去呢？</p>\n<p>我这里使用的jquery中对<code>class</code>的操作来实现，也就是利用<code>jQuery</code>中的<code>addClass()</code>和<code>removeClass()</code>方法来实现。</p>\n<p>那么在此之前，我们就需要先将动画写进一个类里面，然后通过<code>jQuery</code>来操作这个类。</p>\n<p>我这里简单的写了一个<code>class</code>，然后将动画写进去：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.userNameTipA</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: user <span class=\"number\">0.3s</span> linear normal forwards;</span><br><span class=\"line\">    <span class=\"attribute\">animation-iteration-count</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们就可以通过<code>jQuery</code>来操作这个类了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&#x27;#userName&#x27;</span>).<span class=\"title function_\">focus</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    $(<span class=\"string\">&#x27;.userNameTip&#x27;</span>).<span class=\"title function_\">addClass</span>(<span class=\"string\">&#x27;userNameTipA&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;点击了&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(<span class=\"string\">&#x27;#userName&#x27;</span>).<span class=\"title function_\">blur</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> val = $(<span class=\"string\">&#x27;#userName&#x27;</span>).<span class=\"title function_\">val</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        $(<span class=\"string\">&#x27;.userNameTip&#x27;</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&#x27;userNameTipA&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>最后点击保存，运行，就可以看到效果了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实这个demo还是很简单的，就是利用一些定位来调整输入框的位置，然后针对输入框的聚焦样式和失焦样式来实现动画，最后通过<code>jQuery</code>来操作这个动画。</p>\n"},{"title":"我的2022年终总结","date":"2023-01-09T14:00:27.961Z","_content":"# 我的2022年终总结\n\n### 前言\n\n作为一名在校的大学生来说，大学四年就如白驹过隙一般，感觉什么都还没做，就已经来到了大三，回顾这一整年，感觉什么都没做。又感觉过得十分充实，并且收获颇丰。\n\n大学四年生活，对于我而言，还剩最后一年左右的时间，之后就要与社会对线。前两年碌碌无为，但是在有了目标之后，一切都开始变得不一样了。\n\n## 我的前端梦\n在22年年初的时候，当时我还是一个不知道自己以后要干嘛的盲目者，在流水线上打着螺丝，在这个时候，我似乎意识到，这样的生活并不是我想要的生活，明天做着一样的工作，枯燥且无聊。每天累死累活，到手的却只有100来块钱。\n\n于是在大二下学期开学之后，我开始寻找自己的目标，想要知道自己想要的是什么，慢慢的我接触了前端。\n\n### 梦的开始\n\n为什么说这是一场梦呢？  \n因为从学习前端到现在，更加事件过得好快，就已经大半年时间了。感觉这短短的时间，就已经让我在别人眼中不一样的。在这之前，我想增加项目经验，人家根本看不上我，到现在我也慢慢成为别人眼中的大佬。这种前后巨大的反差，真就像一场梦一样。\n\n前端的开始，最初是从微信小程序开始的，当时一时兴起，想要做一个微信点单的小程序出来，但是发现我什么也不会，最后我们班里面的大佬建议我先去学习前端三件套，从这个时候，我就开始了我的前端之路，在我的文件夹里面，依旧还保留着我学习`html`的第一个文件，\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c51c08fbf2b4797925c7d9f9356b496~tplv-k3u1fbpfcp-watermark.image?)\n\n### 追梦\n\n在最开始学习三件套的时候，我一边看视频，一边照着样子敲代码。虽然有点枯燥，但是每次看见自己实现的效果与视频里面的效果是一样的，心里面的成就感就爆棚，就有促使我继续学习。前面学习是枯燥的，因为自己会的东西也不多，更加实现的效果也就那样，但是不能放弃，坚持。\n\n当时学习`html`的时候，看见使用`css`能够实现好多好多奇妙的效果，我就不断告诉自己，努力学，学到`css`就好了。  \n但是当真正学到`css`的时候，我有会看到使用`js`有可以完成各种各样的交互，越来越接近日常网页的交互效果，这个时候我又激励自己：“加油，学完`js`，我也可以实现这样的效果”。\n\n到此为止，上半年也就差不多结束了，然后就快开始了我的暑假生活。\n\n## 掘金\n\n在6月1号的时候，我在网上某论坛看到了`稀土掘金`前端社区，因为当时我想找一个前端的社区，一方面自己可以写写博客，另一方面也能接触一下大佬的知识。\n\n从那一天开始我加入的掘金大家庭，渐渐的，在掘金上我收获了很多，在掘金的日更计划中，我遇到了很多很多的大佬，时不时和他们一起摸摸鱼，一边在聊天的同时，也收获了一些知识，比如最近一些最新的技术，这些我在学校是永远也学不到的；在参加青训营打卡活动中，又结识了很多与我同龄的大学生，这让我认识到了我与他们的差距，当然这也激励着我不断朝着更高处攀登。\n\n慢慢的，经过接近半年的摸索，逐渐有了一定的成果：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf845f6950047d7ab3f41c69324155e~tplv-k3u1fbpfcp-watermark.image?)\n\n有了掘金这个平台，我认识了更多志同道合的朋友，也让我在前进的路上不在感到孤独，有着他们的激励，我一步一步走得更远。\n\n\n\n### 掘金的收获\n\n说实话，自从来到了掘金，我的认知范围大了很多：从原来的三件套，慢慢到框架，什么`vite`等等。\n\n\n\n掘金社区的氛围真的是技术社区里面的一股清流，某站里面成篇的抄袭，搜索一篇文章，可以看到千篇一律的，你看半天得不到一丁点知识。但是在掘金里面，每一篇文章都是用户自己用心写出来的，因为在掘金社区，是坚决打击这种抄袭的行为。而且掘金社区里面，几乎看不到广告，看到的永远都是对程序员提升有帮助的文章，就比如那我这种小白来说，我已加入掘金，并不知道掘金有什么活动，我一开始只是看看里面的文章；慢慢的我了解到掘金的日新计划，掘金鼓励创作者们原创文章，并且养成创作的习惯。为什么好的技术人员一定要写技术文章呢？因为你自己理解了不一定是真正理解了，如果你还能将别人也讲清楚，那就证明你是真正学懂了。\n\n最后聊聊我在掘金收获：\n\n- 掘金的各种活动群，让我结识了很多大佬，包括从业好几年的，还有和我一样在校的大学生。\n- 掘金让我养成了良好的写作习惯，每当我学习到新知识的时候，第一想法就是通过博客的形式展现出来，这样一方面方便自己复习，另一方面也可以更好的传播知识。\n- 当然少不了掘金社区的奖励：在我见过的众多社区里面，只有掘金是最舍得花钱的，键盘、手机云台、按摩仪等等奖品满足要求直接送。\n\n![microMsg.1670228245115.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42bf9f033c1f428a96d7d1ffc3b7c8d0~tplv-k3u1fbpfcp-watermark.image?)\n\n奖品只是一种奖励，人是惰性动物，只有当受到正向的反馈的时候，才会不断向前。就如我在掘金这半年时间里，我上过一次掘金一周，达到四级之后开始自动推荐我的文章，文章的收藏数与点赞数不断上涨。这些都是对我的正向反馈。\n\n## 未来\n\n知识的大海是无穷无尽的，技术的边界也在不断扩大，未来还有很多有趣的事情值得我去探索，相信每一天付出的努力，在最后终将会有回报。\n\n### 展望2023\n\n在2022，我初次接触前端，学习了三件套，并开始接触vue，希望自己在2023，不忘初心，继续出发。希望自己前半年将vue学习完毕，并开始学习node的一些框架。","source":"_posts/我的2020年终总结.md","raw":"---\ntitle: 我的2022年终总结\ndate: 2022-13-9\ntags: [随笔]\ncategories: [随笔]\n---\n# 我的2022年终总结\n\n### 前言\n\n作为一名在校的大学生来说，大学四年就如白驹过隙一般，感觉什么都还没做，就已经来到了大三，回顾这一整年，感觉什么都没做。又感觉过得十分充实，并且收获颇丰。\n\n大学四年生活，对于我而言，还剩最后一年左右的时间，之后就要与社会对线。前两年碌碌无为，但是在有了目标之后，一切都开始变得不一样了。\n\n## 我的前端梦\n在22年年初的时候，当时我还是一个不知道自己以后要干嘛的盲目者，在流水线上打着螺丝，在这个时候，我似乎意识到，这样的生活并不是我想要的生活，明天做着一样的工作，枯燥且无聊。每天累死累活，到手的却只有100来块钱。\n\n于是在大二下学期开学之后，我开始寻找自己的目标，想要知道自己想要的是什么，慢慢的我接触了前端。\n\n### 梦的开始\n\n为什么说这是一场梦呢？  \n因为从学习前端到现在，更加事件过得好快，就已经大半年时间了。感觉这短短的时间，就已经让我在别人眼中不一样的。在这之前，我想增加项目经验，人家根本看不上我，到现在我也慢慢成为别人眼中的大佬。这种前后巨大的反差，真就像一场梦一样。\n\n前端的开始，最初是从微信小程序开始的，当时一时兴起，想要做一个微信点单的小程序出来，但是发现我什么也不会，最后我们班里面的大佬建议我先去学习前端三件套，从这个时候，我就开始了我的前端之路，在我的文件夹里面，依旧还保留着我学习`html`的第一个文件，\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c51c08fbf2b4797925c7d9f9356b496~tplv-k3u1fbpfcp-watermark.image?)\n\n### 追梦\n\n在最开始学习三件套的时候，我一边看视频，一边照着样子敲代码。虽然有点枯燥，但是每次看见自己实现的效果与视频里面的效果是一样的，心里面的成就感就爆棚，就有促使我继续学习。前面学习是枯燥的，因为自己会的东西也不多，更加实现的效果也就那样，但是不能放弃，坚持。\n\n当时学习`html`的时候，看见使用`css`能够实现好多好多奇妙的效果，我就不断告诉自己，努力学，学到`css`就好了。  \n但是当真正学到`css`的时候，我有会看到使用`js`有可以完成各种各样的交互，越来越接近日常网页的交互效果，这个时候我又激励自己：“加油，学完`js`，我也可以实现这样的效果”。\n\n到此为止，上半年也就差不多结束了，然后就快开始了我的暑假生活。\n\n## 掘金\n\n在6月1号的时候，我在网上某论坛看到了`稀土掘金`前端社区，因为当时我想找一个前端的社区，一方面自己可以写写博客，另一方面也能接触一下大佬的知识。\n\n从那一天开始我加入的掘金大家庭，渐渐的，在掘金上我收获了很多，在掘金的日更计划中，我遇到了很多很多的大佬，时不时和他们一起摸摸鱼，一边在聊天的同时，也收获了一些知识，比如最近一些最新的技术，这些我在学校是永远也学不到的；在参加青训营打卡活动中，又结识了很多与我同龄的大学生，这让我认识到了我与他们的差距，当然这也激励着我不断朝着更高处攀登。\n\n慢慢的，经过接近半年的摸索，逐渐有了一定的成果：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf845f6950047d7ab3f41c69324155e~tplv-k3u1fbpfcp-watermark.image?)\n\n有了掘金这个平台，我认识了更多志同道合的朋友，也让我在前进的路上不在感到孤独，有着他们的激励，我一步一步走得更远。\n\n\n\n### 掘金的收获\n\n说实话，自从来到了掘金，我的认知范围大了很多：从原来的三件套，慢慢到框架，什么`vite`等等。\n\n\n\n掘金社区的氛围真的是技术社区里面的一股清流，某站里面成篇的抄袭，搜索一篇文章，可以看到千篇一律的，你看半天得不到一丁点知识。但是在掘金里面，每一篇文章都是用户自己用心写出来的，因为在掘金社区，是坚决打击这种抄袭的行为。而且掘金社区里面，几乎看不到广告，看到的永远都是对程序员提升有帮助的文章，就比如那我这种小白来说，我已加入掘金，并不知道掘金有什么活动，我一开始只是看看里面的文章；慢慢的我了解到掘金的日新计划，掘金鼓励创作者们原创文章，并且养成创作的习惯。为什么好的技术人员一定要写技术文章呢？因为你自己理解了不一定是真正理解了，如果你还能将别人也讲清楚，那就证明你是真正学懂了。\n\n最后聊聊我在掘金收获：\n\n- 掘金的各种活动群，让我结识了很多大佬，包括从业好几年的，还有和我一样在校的大学生。\n- 掘金让我养成了良好的写作习惯，每当我学习到新知识的时候，第一想法就是通过博客的形式展现出来，这样一方面方便自己复习，另一方面也可以更好的传播知识。\n- 当然少不了掘金社区的奖励：在我见过的众多社区里面，只有掘金是最舍得花钱的，键盘、手机云台、按摩仪等等奖品满足要求直接送。\n\n![microMsg.1670228245115.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42bf9f033c1f428a96d7d1ffc3b7c8d0~tplv-k3u1fbpfcp-watermark.image?)\n\n奖品只是一种奖励，人是惰性动物，只有当受到正向的反馈的时候，才会不断向前。就如我在掘金这半年时间里，我上过一次掘金一周，达到四级之后开始自动推荐我的文章，文章的收藏数与点赞数不断上涨。这些都是对我的正向反馈。\n\n## 未来\n\n知识的大海是无穷无尽的，技术的边界也在不断扩大，未来还有很多有趣的事情值得我去探索，相信每一天付出的努力，在最后终将会有回报。\n\n### 展望2023\n\n在2022，我初次接触前端，学习了三件套，并开始接触vue，希望自己在2023，不忘初心，继续出发。希望自己前半年将vue学习完毕，并开始学习node的一些框架。","slug":"我的2020年终总结","published":1,"updated":"2023-01-08T12:12:27.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhn00229kbmbzqk7lnf","content":"<h1 id=\"我的2022年终总结\"><a href=\"#我的2022年终总结\" class=\"headerlink\" title=\"我的2022年终总结\"></a>我的2022年终总结</h1><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>作为一名在校的大学生来说，大学四年就如白驹过隙一般，感觉什么都还没做，就已经来到了大三，回顾这一整年，感觉什么都没做。又感觉过得十分充实，并且收获颇丰。</p>\n<p>大学四年生活，对于我而言，还剩最后一年左右的时间，之后就要与社会对线。前两年碌碌无为，但是在有了目标之后，一切都开始变得不一样了。</p>\n<h2 id=\"我的前端梦\"><a href=\"#我的前端梦\" class=\"headerlink\" title=\"我的前端梦\"></a>我的前端梦</h2><p>在22年年初的时候，当时我还是一个不知道自己以后要干嘛的盲目者，在流水线上打着螺丝，在这个时候，我似乎意识到，这样的生活并不是我想要的生活，明天做着一样的工作，枯燥且无聊。每天累死累活，到手的却只有100来块钱。</p>\n<p>于是在大二下学期开学之后，我开始寻找自己的目标，想要知道自己想要的是什么，慢慢的我接触了前端。</p>\n<h3 id=\"梦的开始\"><a href=\"#梦的开始\" class=\"headerlink\" title=\"梦的开始\"></a>梦的开始</h3><p>为什么说这是一场梦呢？<br>因为从学习前端到现在，更加事件过得好快，就已经大半年时间了。感觉这短短的时间，就已经让我在别人眼中不一样的。在这之前，我想增加项目经验，人家根本看不上我，到现在我也慢慢成为别人眼中的大佬。这种前后巨大的反差，真就像一场梦一样。</p>\n<p>前端的开始，最初是从微信小程序开始的，当时一时兴起，想要做一个微信点单的小程序出来，但是发现我什么也不会，最后我们班里面的大佬建议我先去学习前端三件套，从这个时候，我就开始了我的前端之路，在我的文件夹里面，依旧还保留着我学习<code>html</code>的第一个文件，</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c51c08fbf2b4797925c7d9f9356b496~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"追梦\"><a href=\"#追梦\" class=\"headerlink\" title=\"追梦\"></a>追梦</h3><p>在最开始学习三件套的时候，我一边看视频，一边照着样子敲代码。虽然有点枯燥，但是每次看见自己实现的效果与视频里面的效果是一样的，心里面的成就感就爆棚，就有促使我继续学习。前面学习是枯燥的，因为自己会的东西也不多，更加实现的效果也就那样，但是不能放弃，坚持。</p>\n<p>当时学习<code>html</code>的时候，看见使用<code>css</code>能够实现好多好多奇妙的效果，我就不断告诉自己，努力学，学到<code>css</code>就好了。<br>但是当真正学到<code>css</code>的时候，我有会看到使用<code>js</code>有可以完成各种各样的交互，越来越接近日常网页的交互效果，这个时候我又激励自己：“加油，学完<code>js</code>，我也可以实现这样的效果”。</p>\n<p>到此为止，上半年也就差不多结束了，然后就快开始了我的暑假生活。</p>\n<h2 id=\"掘金\"><a href=\"#掘金\" class=\"headerlink\" title=\"掘金\"></a>掘金</h2><p>在6月1号的时候，我在网上某论坛看到了<code>稀土掘金</code>前端社区，因为当时我想找一个前端的社区，一方面自己可以写写博客，另一方面也能接触一下大佬的知识。</p>\n<p>从那一天开始我加入的掘金大家庭，渐渐的，在掘金上我收获了很多，在掘金的日更计划中，我遇到了很多很多的大佬，时不时和他们一起摸摸鱼，一边在聊天的同时，也收获了一些知识，比如最近一些最新的技术，这些我在学校是永远也学不到的；在参加青训营打卡活动中，又结识了很多与我同龄的大学生，这让我认识到了我与他们的差距，当然这也激励着我不断朝着更高处攀登。</p>\n<p>慢慢的，经过接近半年的摸索，逐渐有了一定的成果：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf845f6950047d7ab3f41c69324155e~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>有了掘金这个平台，我认识了更多志同道合的朋友，也让我在前进的路上不在感到孤独，有着他们的激励，我一步一步走得更远。</p>\n<h3 id=\"掘金的收获\"><a href=\"#掘金的收获\" class=\"headerlink\" title=\"掘金的收获\"></a>掘金的收获</h3><p>说实话，自从来到了掘金，我的认知范围大了很多：从原来的三件套，慢慢到框架，什么<code>vite</code>等等。</p>\n<p>掘金社区的氛围真的是技术社区里面的一股清流，某站里面成篇的抄袭，搜索一篇文章，可以看到千篇一律的，你看半天得不到一丁点知识。但是在掘金里面，每一篇文章都是用户自己用心写出来的，因为在掘金社区，是坚决打击这种抄袭的行为。而且掘金社区里面，几乎看不到广告，看到的永远都是对程序员提升有帮助的文章，就比如那我这种小白来说，我已加入掘金，并不知道掘金有什么活动，我一开始只是看看里面的文章；慢慢的我了解到掘金的日新计划，掘金鼓励创作者们原创文章，并且养成创作的习惯。为什么好的技术人员一定要写技术文章呢？因为你自己理解了不一定是真正理解了，如果你还能将别人也讲清楚，那就证明你是真正学懂了。</p>\n<p>最后聊聊我在掘金收获：</p>\n<ul>\n<li>掘金的各种活动群，让我结识了很多大佬，包括从业好几年的，还有和我一样在校的大学生。</li>\n<li>掘金让我养成了良好的写作习惯，每当我学习到新知识的时候，第一想法就是通过博客的形式展现出来，这样一方面方便自己复习，另一方面也可以更好的传播知识。</li>\n<li>当然少不了掘金社区的奖励：在我见过的众多社区里面，只有掘金是最舍得花钱的，键盘、手机云台、按摩仪等等奖品满足要求直接送。</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42bf9f033c1f428a96d7d1ffc3b7c8d0~tplv-k3u1fbpfcp-watermark.image\" alt=\"microMsg.1670228245115.jpg\"></p>\n<p>奖品只是一种奖励，人是惰性动物，只有当受到正向的反馈的时候，才会不断向前。就如我在掘金这半年时间里，我上过一次掘金一周，达到四级之后开始自动推荐我的文章，文章的收藏数与点赞数不断上涨。这些都是对我的正向反馈。</p>\n<h2 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h2><p>知识的大海是无穷无尽的，技术的边界也在不断扩大，未来还有很多有趣的事情值得我去探索，相信每一天付出的努力，在最后终将会有回报。</p>\n<h3 id=\"展望2023\"><a href=\"#展望2023\" class=\"headerlink\" title=\"展望2023\"></a>展望2023</h3><p>在2022，我初次接触前端，学习了三件套，并开始接触vue，希望自己在2023，不忘初心，继续出发。希望自己前半年将vue学习完毕，并开始学习node的一些框架。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我的2022年终总结\"><a href=\"#我的2022年终总结\" class=\"headerlink\" title=\"我的2022年终总结\"></a>我的2022年终总结</h1><h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>作为一名在校的大学生来说，大学四年就如白驹过隙一般，感觉什么都还没做，就已经来到了大三，回顾这一整年，感觉什么都没做。又感觉过得十分充实，并且收获颇丰。</p>\n<p>大学四年生活，对于我而言，还剩最后一年左右的时间，之后就要与社会对线。前两年碌碌无为，但是在有了目标之后，一切都开始变得不一样了。</p>\n<h2 id=\"我的前端梦\"><a href=\"#我的前端梦\" class=\"headerlink\" title=\"我的前端梦\"></a>我的前端梦</h2><p>在22年年初的时候，当时我还是一个不知道自己以后要干嘛的盲目者，在流水线上打着螺丝，在这个时候，我似乎意识到，这样的生活并不是我想要的生活，明天做着一样的工作，枯燥且无聊。每天累死累活，到手的却只有100来块钱。</p>\n<p>于是在大二下学期开学之后，我开始寻找自己的目标，想要知道自己想要的是什么，慢慢的我接触了前端。</p>\n<h3 id=\"梦的开始\"><a href=\"#梦的开始\" class=\"headerlink\" title=\"梦的开始\"></a>梦的开始</h3><p>为什么说这是一场梦呢？<br>因为从学习前端到现在，更加事件过得好快，就已经大半年时间了。感觉这短短的时间，就已经让我在别人眼中不一样的。在这之前，我想增加项目经验，人家根本看不上我，到现在我也慢慢成为别人眼中的大佬。这种前后巨大的反差，真就像一场梦一样。</p>\n<p>前端的开始，最初是从微信小程序开始的，当时一时兴起，想要做一个微信点单的小程序出来，但是发现我什么也不会，最后我们班里面的大佬建议我先去学习前端三件套，从这个时候，我就开始了我的前端之路，在我的文件夹里面，依旧还保留着我学习<code>html</code>的第一个文件，</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c51c08fbf2b4797925c7d9f9356b496~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"追梦\"><a href=\"#追梦\" class=\"headerlink\" title=\"追梦\"></a>追梦</h3><p>在最开始学习三件套的时候，我一边看视频，一边照着样子敲代码。虽然有点枯燥，但是每次看见自己实现的效果与视频里面的效果是一样的，心里面的成就感就爆棚，就有促使我继续学习。前面学习是枯燥的，因为自己会的东西也不多，更加实现的效果也就那样，但是不能放弃，坚持。</p>\n<p>当时学习<code>html</code>的时候，看见使用<code>css</code>能够实现好多好多奇妙的效果，我就不断告诉自己，努力学，学到<code>css</code>就好了。<br>但是当真正学到<code>css</code>的时候，我有会看到使用<code>js</code>有可以完成各种各样的交互，越来越接近日常网页的交互效果，这个时候我又激励自己：“加油，学完<code>js</code>，我也可以实现这样的效果”。</p>\n<p>到此为止，上半年也就差不多结束了，然后就快开始了我的暑假生活。</p>\n<h2 id=\"掘金\"><a href=\"#掘金\" class=\"headerlink\" title=\"掘金\"></a>掘金</h2><p>在6月1号的时候，我在网上某论坛看到了<code>稀土掘金</code>前端社区，因为当时我想找一个前端的社区，一方面自己可以写写博客，另一方面也能接触一下大佬的知识。</p>\n<p>从那一天开始我加入的掘金大家庭，渐渐的，在掘金上我收获了很多，在掘金的日更计划中，我遇到了很多很多的大佬，时不时和他们一起摸摸鱼，一边在聊天的同时，也收获了一些知识，比如最近一些最新的技术，这些我在学校是永远也学不到的；在参加青训营打卡活动中，又结识了很多与我同龄的大学生，这让我认识到了我与他们的差距，当然这也激励着我不断朝着更高处攀登。</p>\n<p>慢慢的，经过接近半年的摸索，逐渐有了一定的成果：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf845f6950047d7ab3f41c69324155e~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>有了掘金这个平台，我认识了更多志同道合的朋友，也让我在前进的路上不在感到孤独，有着他们的激励，我一步一步走得更远。</p>\n<h3 id=\"掘金的收获\"><a href=\"#掘金的收获\" class=\"headerlink\" title=\"掘金的收获\"></a>掘金的收获</h3><p>说实话，自从来到了掘金，我的认知范围大了很多：从原来的三件套，慢慢到框架，什么<code>vite</code>等等。</p>\n<p>掘金社区的氛围真的是技术社区里面的一股清流，某站里面成篇的抄袭，搜索一篇文章，可以看到千篇一律的，你看半天得不到一丁点知识。但是在掘金里面，每一篇文章都是用户自己用心写出来的，因为在掘金社区，是坚决打击这种抄袭的行为。而且掘金社区里面，几乎看不到广告，看到的永远都是对程序员提升有帮助的文章，就比如那我这种小白来说，我已加入掘金，并不知道掘金有什么活动，我一开始只是看看里面的文章；慢慢的我了解到掘金的日新计划，掘金鼓励创作者们原创文章，并且养成创作的习惯。为什么好的技术人员一定要写技术文章呢？因为你自己理解了不一定是真正理解了，如果你还能将别人也讲清楚，那就证明你是真正学懂了。</p>\n<p>最后聊聊我在掘金收获：</p>\n<ul>\n<li>掘金的各种活动群，让我结识了很多大佬，包括从业好几年的，还有和我一样在校的大学生。</li>\n<li>掘金让我养成了良好的写作习惯，每当我学习到新知识的时候，第一想法就是通过博客的形式展现出来，这样一方面方便自己复习，另一方面也可以更好的传播知识。</li>\n<li>当然少不了掘金社区的奖励：在我见过的众多社区里面，只有掘金是最舍得花钱的，键盘、手机云台、按摩仪等等奖品满足要求直接送。</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42bf9f033c1f428a96d7d1ffc3b7c8d0~tplv-k3u1fbpfcp-watermark.image\" alt=\"microMsg.1670228245115.jpg\"></p>\n<p>奖品只是一种奖励，人是惰性动物，只有当受到正向的反馈的时候，才会不断向前。就如我在掘金这半年时间里，我上过一次掘金一周，达到四级之后开始自动推荐我的文章，文章的收藏数与点赞数不断上涨。这些都是对我的正向反馈。</p>\n<h2 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h2><p>知识的大海是无穷无尽的，技术的边界也在不断扩大，未来还有很多有趣的事情值得我去探索，相信每一天付出的努力，在最后终将会有回报。</p>\n<h3 id=\"展望2023\"><a href=\"#展望2023\" class=\"headerlink\" title=\"展望2023\"></a>展望2023</h3><p>在2022，我初次接触前端，学习了三件套，并开始接触vue，希望自己在2023，不忘初心，继续出发。希望自己前半年将vue学习完毕，并开始学习node的一些框架。</p>\n"},{"title":"抽象类与抽象方法","date":"2023-01-06T16:00:00.000Z","_content":"# 抽象类与抽象方法\n\n[TOC]\n## 定义\n\n- 抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。那么该方法就可以定义抽象方法。\n- 抽象类：如果一个类中存在抽象方法，那么该类<font color=red>必须声明为抽象类</font>。\n## 抽象类与抽象方法的定义格式\n\n- 抽象方法的定义格式：\n\t- public abstract 返回值类型 方法名(参数列表);\n- 抽象类的定义格式：\n\t- public abstract class 类名{}\n\t\n**抽象类和抽象方法的注意事项：**\n- 抽象类不能实例化\n- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n- 可以有构造方法\n- 抽象类的子类：\n\t- 要么重写抽象类中的所有抽象方法\n\t- 要么是抽象类\n## 抽象方法的定义格式\n\n## 子类继承抽象类之后，如何重写抽象方法","source":"_posts/抽象类与抽象方法.md","raw":"---\ntitle: 抽象类与抽象方法\ndate: 2023-1-7\ntags: [后端]\ncategories: [Java]\n---\n# 抽象类与抽象方法\n\n[TOC]\n## 定义\n\n- 抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。那么该方法就可以定义抽象方法。\n- 抽象类：如果一个类中存在抽象方法，那么该类<font color=red>必须声明为抽象类</font>。\n## 抽象类与抽象方法的定义格式\n\n- 抽象方法的定义格式：\n\t- public abstract 返回值类型 方法名(参数列表);\n- 抽象类的定义格式：\n\t- public abstract class 类名{}\n\t\n**抽象类和抽象方法的注意事项：**\n- 抽象类不能实例化\n- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n- 可以有构造方法\n- 抽象类的子类：\n\t- 要么重写抽象类中的所有抽象方法\n\t- 要么是抽象类\n## 抽象方法的定义格式\n\n## 子类继承抽象类之后，如何重写抽象方法","slug":"抽象类与抽象方法","published":1,"updated":"2023-01-10T02:24:23.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhn00259kbm79j3gyxe","content":"<h1 id=\"抽象类与抽象方法\"><a href=\"#抽象类与抽象方法\" class=\"headerlink\" title=\"抽象类与抽象方法\"></a>抽象类与抽象方法</h1><p>[TOC]</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li>抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。那么该方法就可以定义抽象方法。</li>\n<li>抽象类：如果一个类中存在抽象方法，那么该类<font color=red>必须声明为抽象类</font>。</li>\n</ul>\n<h2 id=\"抽象类与抽象方法的定义格式\"><a href=\"#抽象类与抽象方法的定义格式\" class=\"headerlink\" title=\"抽象类与抽象方法的定义格式\"></a>抽象类与抽象方法的定义格式</h2><ul>\n<li>抽象方法的定义格式：<ul>\n<li>public abstract 返回值类型 方法名(参数列表);</li>\n</ul>\n</li>\n<li>抽象类的定义格式：<ul>\n<li>public abstract class 类名{}</li>\n</ul>\n</li>\n</ul>\n<p><strong>抽象类和抽象方法的注意事项：</strong></p>\n<ul>\n<li>抽象类不能实例化</li>\n<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>\n<li>可以有构造方法</li>\n<li>抽象类的子类：<ul>\n<li>要么重写抽象类中的所有抽象方法</li>\n<li>要么是抽象类</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象方法的定义格式\"><a href=\"#抽象方法的定义格式\" class=\"headerlink\" title=\"抽象方法的定义格式\"></a>抽象方法的定义格式</h2><h2 id=\"子类继承抽象类之后，如何重写抽象方法\"><a href=\"#子类继承抽象类之后，如何重写抽象方法\" class=\"headerlink\" title=\"子类继承抽象类之后，如何重写抽象方法\"></a>子类继承抽象类之后，如何重写抽象方法</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"抽象类与抽象方法\"><a href=\"#抽象类与抽象方法\" class=\"headerlink\" title=\"抽象类与抽象方法\"></a>抽象类与抽象方法</h1><p>[TOC]</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li>抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。那么该方法就可以定义抽象方法。</li>\n<li>抽象类：如果一个类中存在抽象方法，那么该类<font color=red>必须声明为抽象类</font>。</li>\n</ul>\n<h2 id=\"抽象类与抽象方法的定义格式\"><a href=\"#抽象类与抽象方法的定义格式\" class=\"headerlink\" title=\"抽象类与抽象方法的定义格式\"></a>抽象类与抽象方法的定义格式</h2><ul>\n<li>抽象方法的定义格式：<ul>\n<li>public abstract 返回值类型 方法名(参数列表);</li>\n</ul>\n</li>\n<li>抽象类的定义格式：<ul>\n<li>public abstract class 类名{}</li>\n</ul>\n</li>\n</ul>\n<p><strong>抽象类和抽象方法的注意事项：</strong></p>\n<ul>\n<li>抽象类不能实例化</li>\n<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>\n<li>可以有构造方法</li>\n<li>抽象类的子类：<ul>\n<li>要么重写抽象类中的所有抽象方法</li>\n<li>要么是抽象类</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象方法的定义格式\"><a href=\"#抽象方法的定义格式\" class=\"headerlink\" title=\"抽象方法的定义格式\"></a>抽象方法的定义格式</h2><h2 id=\"子类继承抽象类之后，如何重写抽象方法\"><a href=\"#子类继承抽象类之后，如何重写抽象方法\" class=\"headerlink\" title=\"子类继承抽象类之后，如何重写抽象方法\"></a>子类继承抽象类之后，如何重写抽象方法</h2>"},{"title":"纯css实现跑马灯效果","date":"2022-12-02T16:00:00.000Z","_content":"# 纯CSS实现跑马灯效果\n\n又是一个安静的晚上，又是没有灵感的一天，又只能去逛逛`codepen`。看到一个流光的边框效果，我就想如何通过自己的方式来现这样一个效果。\n\n突然又想起路边夜市的招牌，不就是一个流光效果加一个广告词吗。这下我的兴趣一下就激发起来了。\n\n首先上一个效果图\n\n![跑马灯.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7bd3aa2a13e4bf1be984a32560e72e7~tplv-k3u1fbpfcp-watermark.image?)\n\n那这里的广告词就写我的名字吧，这都不重要，接下来让我们看看是怎么实现的吧。\n\n## 结构分析\n\n首先很明显我们使用了一个盒子将文字装起来，并且将文字进行了居中，然后我们看到这盒子的周围围绕了两条光带，那么这两条光带是怎么实现的呢？\n\n其实这是用四个小盒子实现的，就是我们将这四个小盒子分别放在大盒子的周围（紧贴这大盒子的内壁），然后使用这几个小盒子实现跑马灯效果。\n\n接下来我们就看看具体的实现效果\n\n## 代码实现\n\n### 外部大盒子\n\n首先准备一个`div`盒子，用来装我们的广告语，还有跑马灯的四个小盒子。\n```html\n<div class=\"main\">\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        海绵宝宝\n</div>\n```\n\n这个盒子就准备好了  我们给这个何止设置一点样式，让他在浏览器中可以被我们看到\n\n```html\n.main{\n    width: 100px;\n    height: 40px;\n    background-color: transparent;\n    /* 盒子居中 */\n    position: absolute;\n    top: 50%;\n    margin-top: -20px;\n    left: 50%;\n    margin-left: -50px;\n    /* 文字居中 */\n    text-align: center;\n    line-height: 40px;\n    font-family: '宋体';\n    color: aquamarine;\n    overflow: hidden;\n}\n```\n\n我们给这个大盒子设置了宽高，以及背景颜色，这样使得我们的盒子在浏览器中显得不那么突兀，并且我们将盒子在浏览器中居中，并且将盒子里面的文字也进行居中，不要问我为什么一定要居中，纯属我的强迫症。\n\n到现在为止，我们就已经把大盒子准备好了，效果就是这样的：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32d4a7803a2e4520904bc5cd03ecfdfe~tplv-k3u1fbpfcp-watermark.image?)\n\n接下来我们给大盒子设置灯光效果。\n\n### 内部灯光效果\n\n既然是灯光效果，那颜色就必须得亮，这里我选着`#0FF`配色，在效果图上，我们可以看到灯光尾部的颜色比较淡，展现出一种过渡效果，组件从头部慢慢过渡到小盒子的原本颜色。\n\n那这样的效果是怎么实现的呢？\n\n这里就需要用到`background`的一个新的属性值:`linear-gradient`,通过这个属性，我们可以将多个颜色设置为一个盒子的背景颜色，并且还有过渡效果，更强大的地方在于，这个属性值可以设置渐变的方向。\n\n语法：\n\n`linear-gradient(渐变方向,color1,color2,color3...)`\n\n那就开始使用这个属性值，我们写其中一个小盒子的效果，其他的效果实现方法都类似。\n\n```css\n.main :nth-child(1){\n    background: linear-gradient(to right, transparent , #0FF);\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 1px;\n}\n```\n\n我们这里设置的是顶部的灯光效果，这里我们使用`top`和`left`的属性，设置这个盒子的位置；使用`width:100%`，使得这个盒子的宽度与大盒子保持一致，然后使用`height:1px`,将灯光条的宽度设置为1px,当然你也可以根据实际需求，改变灯光条的宽度。\n\n接着剩下三条灯光的实现原理基本相同，只有位置和背景颜色不同。\n\n剩下背景颜色的渐变方向分别是`to bottom`、`to left`、`to top`。\n\n最后的效果就是这样：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c902a90d4444931a0dae4dd13fc3c91~tplv-k3u1fbpfcp-watermark.image?)\n\n是不是离我们最终的效果越来越像了，对的，我们还差最后一部，给灯光加上动画效果。\n\n### 灯光的动画效果\n\n说道动画效果，那必定离不开`@keyframes`,我们使用该属性为我们的灯光添加动画效果。\n\n同样我们也设置顶部的灯光效果作为示范：\n\n动画：\n\n```css\n@keyframes run1{\n    0%{\n        transform: translateX(-200px);\n    }\n    100%{\n        transform: translateX(200px);\n    }\n}\n```\n\n盒子：\n\n给盒子加上动画\n\n```css\n.main :nth-child(1){\n    animation: run1 1s linear infinite;\n}\n```\n\n前面我们没有设置动画之前，可以看到颜色最深的部分在最右边，但是跑马灯的实现需求是需要颜色最什么部分从左边出现，然后移动到右边，所有我们这里将动画的初识位置向左移整个盒子的长度。这样就实现了需求。\n\n其他几个小盒子实现的方式大同小异。\n\n接下来我们来看看效果：\n\n![跑马灯.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14c2f986d6f74376bd515021cf4ec0b4~tplv-k3u1fbpfcp-watermark.image?)\n\n此时我们看到该动画显得有点乱，我们通过使用动画延时来实现我们想要的动画效果。\n\n我们从第二个小盒子开始添加延时：每个盒子比前一个盒子多`0.5`的延时。\n\n```css\n.main :nth-child(2){\n    animation-delay: .5s;\n}\n.main :nth-child(3){\n    animation-delay: 1s;   \n}\n.main :nth-child(4){\n    animation-delay: 1.5s;\n}\n```\n\n最后效果就出来了。\n\n\n\n接下来放上码上掘金的地址，这里有全部代码：↓\n\n[代码片段](https://code.juejin.cn/pen/7172800105433530400)","source":"_posts/纯CSS实现跑马灯效果.md","raw":"---\ntitle: 纯css实现跑马灯效果\ndate: 2022-12-3\ntags: 前端\ncategories: [css,html]\n---\n# 纯CSS实现跑马灯效果\n\n又是一个安静的晚上，又是没有灵感的一天，又只能去逛逛`codepen`。看到一个流光的边框效果，我就想如何通过自己的方式来现这样一个效果。\n\n突然又想起路边夜市的招牌，不就是一个流光效果加一个广告词吗。这下我的兴趣一下就激发起来了。\n\n首先上一个效果图\n\n![跑马灯.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7bd3aa2a13e4bf1be984a32560e72e7~tplv-k3u1fbpfcp-watermark.image?)\n\n那这里的广告词就写我的名字吧，这都不重要，接下来让我们看看是怎么实现的吧。\n\n## 结构分析\n\n首先很明显我们使用了一个盒子将文字装起来，并且将文字进行了居中，然后我们看到这盒子的周围围绕了两条光带，那么这两条光带是怎么实现的呢？\n\n其实这是用四个小盒子实现的，就是我们将这四个小盒子分别放在大盒子的周围（紧贴这大盒子的内壁），然后使用这几个小盒子实现跑马灯效果。\n\n接下来我们就看看具体的实现效果\n\n## 代码实现\n\n### 外部大盒子\n\n首先准备一个`div`盒子，用来装我们的广告语，还有跑马灯的四个小盒子。\n```html\n<div class=\"main\">\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        海绵宝宝\n</div>\n```\n\n这个盒子就准备好了  我们给这个何止设置一点样式，让他在浏览器中可以被我们看到\n\n```html\n.main{\n    width: 100px;\n    height: 40px;\n    background-color: transparent;\n    /* 盒子居中 */\n    position: absolute;\n    top: 50%;\n    margin-top: -20px;\n    left: 50%;\n    margin-left: -50px;\n    /* 文字居中 */\n    text-align: center;\n    line-height: 40px;\n    font-family: '宋体';\n    color: aquamarine;\n    overflow: hidden;\n}\n```\n\n我们给这个大盒子设置了宽高，以及背景颜色，这样使得我们的盒子在浏览器中显得不那么突兀，并且我们将盒子在浏览器中居中，并且将盒子里面的文字也进行居中，不要问我为什么一定要居中，纯属我的强迫症。\n\n到现在为止，我们就已经把大盒子准备好了，效果就是这样的：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32d4a7803a2e4520904bc5cd03ecfdfe~tplv-k3u1fbpfcp-watermark.image?)\n\n接下来我们给大盒子设置灯光效果。\n\n### 内部灯光效果\n\n既然是灯光效果，那颜色就必须得亮，这里我选着`#0FF`配色，在效果图上，我们可以看到灯光尾部的颜色比较淡，展现出一种过渡效果，组件从头部慢慢过渡到小盒子的原本颜色。\n\n那这样的效果是怎么实现的呢？\n\n这里就需要用到`background`的一个新的属性值:`linear-gradient`,通过这个属性，我们可以将多个颜色设置为一个盒子的背景颜色，并且还有过渡效果，更强大的地方在于，这个属性值可以设置渐变的方向。\n\n语法：\n\n`linear-gradient(渐变方向,color1,color2,color3...)`\n\n那就开始使用这个属性值，我们写其中一个小盒子的效果，其他的效果实现方法都类似。\n\n```css\n.main :nth-child(1){\n    background: linear-gradient(to right, transparent , #0FF);\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 1px;\n}\n```\n\n我们这里设置的是顶部的灯光效果，这里我们使用`top`和`left`的属性，设置这个盒子的位置；使用`width:100%`，使得这个盒子的宽度与大盒子保持一致，然后使用`height:1px`,将灯光条的宽度设置为1px,当然你也可以根据实际需求，改变灯光条的宽度。\n\n接着剩下三条灯光的实现原理基本相同，只有位置和背景颜色不同。\n\n剩下背景颜色的渐变方向分别是`to bottom`、`to left`、`to top`。\n\n最后的效果就是这样：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c902a90d4444931a0dae4dd13fc3c91~tplv-k3u1fbpfcp-watermark.image?)\n\n是不是离我们最终的效果越来越像了，对的，我们还差最后一部，给灯光加上动画效果。\n\n### 灯光的动画效果\n\n说道动画效果，那必定离不开`@keyframes`,我们使用该属性为我们的灯光添加动画效果。\n\n同样我们也设置顶部的灯光效果作为示范：\n\n动画：\n\n```css\n@keyframes run1{\n    0%{\n        transform: translateX(-200px);\n    }\n    100%{\n        transform: translateX(200px);\n    }\n}\n```\n\n盒子：\n\n给盒子加上动画\n\n```css\n.main :nth-child(1){\n    animation: run1 1s linear infinite;\n}\n```\n\n前面我们没有设置动画之前，可以看到颜色最深的部分在最右边，但是跑马灯的实现需求是需要颜色最什么部分从左边出现，然后移动到右边，所有我们这里将动画的初识位置向左移整个盒子的长度。这样就实现了需求。\n\n其他几个小盒子实现的方式大同小异。\n\n接下来我们来看看效果：\n\n![跑马灯.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14c2f986d6f74376bd515021cf4ec0b4~tplv-k3u1fbpfcp-watermark.image?)\n\n此时我们看到该动画显得有点乱，我们通过使用动画延时来实现我们想要的动画效果。\n\n我们从第二个小盒子开始添加延时：每个盒子比前一个盒子多`0.5`的延时。\n\n```css\n.main :nth-child(2){\n    animation-delay: .5s;\n}\n.main :nth-child(3){\n    animation-delay: 1s;   \n}\n.main :nth-child(4){\n    animation-delay: 1.5s;\n}\n```\n\n最后效果就出来了。\n\n\n\n接下来放上码上掘金的地址，这里有全部代码：↓\n\n[代码片段](https://code.juejin.cn/pen/7172800105433530400)","slug":"纯CSS实现跑马灯效果","published":1,"updated":"2023-01-08T11:11:48.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmho00299kbm0iki0cjz","content":"<h1 id=\"纯CSS实现跑马灯效果\"><a href=\"#纯CSS实现跑马灯效果\" class=\"headerlink\" title=\"纯CSS实现跑马灯效果\"></a>纯CSS实现跑马灯效果</h1><p>又是一个安静的晚上，又是没有灵感的一天，又只能去逛逛<code>codepen</code>。看到一个流光的边框效果，我就想如何通过自己的方式来现这样一个效果。</p>\n<p>突然又想起路边夜市的招牌，不就是一个流光效果加一个广告词吗。这下我的兴趣一下就激发起来了。</p>\n<p>首先上一个效果图</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7bd3aa2a13e4bf1be984a32560e72e7~tplv-k3u1fbpfcp-watermark.image\" alt=\"跑马灯.gif\"></p>\n<p>那这里的广告词就写我的名字吧，这都不重要，接下来让我们看看是怎么实现的吧。</p>\n<h2 id=\"结构分析\"><a href=\"#结构分析\" class=\"headerlink\" title=\"结构分析\"></a>结构分析</h2><p>首先很明显我们使用了一个盒子将文字装起来，并且将文字进行了居中，然后我们看到这盒子的周围围绕了两条光带，那么这两条光带是怎么实现的呢？</p>\n<p>其实这是用四个小盒子实现的，就是我们将这四个小盒子分别放在大盒子的周围（紧贴这大盒子的内壁），然后使用这几个小盒子实现跑马灯效果。</p>\n<p>接下来我们就看看具体的实现效果</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"外部大盒子\"><a href=\"#外部大盒子\" class=\"headerlink\" title=\"外部大盒子\"></a>外部大盒子</h3><p>首先准备一个<code>div</code>盒子，用来装我们的广告语，还有跑马灯的四个小盒子。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;main&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        海绵宝宝</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个盒子就准备好了  我们给这个何止设置一点样式，让他在浏览器中可以被我们看到</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.main&#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 40px;</span><br><span class=\"line\">    background-color: transparent;</span><br><span class=\"line\">    /* 盒子居中 */</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 50%;</span><br><span class=\"line\">    margin-top: -20px;</span><br><span class=\"line\">    left: 50%;</span><br><span class=\"line\">    margin-left: -50px;</span><br><span class=\"line\">    /* 文字居中 */</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">    line-height: 40px;</span><br><span class=\"line\">    font-family: &#x27;宋体&#x27;;</span><br><span class=\"line\">    color: aquamarine;</span><br><span class=\"line\">    overflow: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们给这个大盒子设置了宽高，以及背景颜色，这样使得我们的盒子在浏览器中显得不那么突兀，并且我们将盒子在浏览器中居中，并且将盒子里面的文字也进行居中，不要问我为什么一定要居中，纯属我的强迫症。</p>\n<p>到现在为止，我们就已经把大盒子准备好了，效果就是这样的：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32d4a7803a2e4520904bc5cd03ecfdfe~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>接下来我们给大盒子设置灯光效果。</p>\n<h3 id=\"内部灯光效果\"><a href=\"#内部灯光效果\" class=\"headerlink\" title=\"内部灯光效果\"></a>内部灯光效果</h3><p>既然是灯光效果，那颜色就必须得亮，这里我选着<code>#0FF</code>配色，在效果图上，我们可以看到灯光尾部的颜色比较淡，展现出一种过渡效果，组件从头部慢慢过渡到小盒子的原本颜色。</p>\n<p>那这样的效果是怎么实现的呢？</p>\n<p>这里就需要用到<code>background</code>的一个新的属性值:<code>linear-gradient</code>,通过这个属性，我们可以将多个颜色设置为一个盒子的背景颜色，并且还有过渡效果，更强大的地方在于，这个属性值可以设置渐变的方向。</p>\n<p>语法：</p>\n<p><code>linear-gradient(渐变方向,color1,color2,color3...)</code></p>\n<p>那就开始使用这个属性值，我们写其中一个小盒子的效果，其他的效果实现方法都类似。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">linear-gradient</span>(to right, transparent , <span class=\"number\">#0FF</span>);</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里设置的是顶部的灯光效果，这里我们使用<code>top</code>和<code>left</code>的属性，设置这个盒子的位置；使用<code>width:100%</code>，使得这个盒子的宽度与大盒子保持一致，然后使用<code>height:1px</code>,将灯光条的宽度设置为1px,当然你也可以根据实际需求，改变灯光条的宽度。</p>\n<p>接着剩下三条灯光的实现原理基本相同，只有位置和背景颜色不同。</p>\n<p>剩下背景颜色的渐变方向分别是<code>to bottom</code>、<code>to left</code>、<code>to top</code>。</p>\n<p>最后的效果就是这样：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c902a90d4444931a0dae4dd13fc3c91~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>是不是离我们最终的效果越来越像了，对的，我们还差最后一部，给灯光加上动画效果。</p>\n<h3 id=\"灯光的动画效果\"><a href=\"#灯光的动画效果\" class=\"headerlink\" title=\"灯光的动画效果\"></a>灯光的动画效果</h3><p>说道动画效果，那必定离不开<code>@keyframes</code>,我们使用该属性为我们的灯光添加动画效果。</p>\n<p>同样我们也设置顶部的灯光效果作为示范：</p>\n<p>动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> run1&#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(-<span class=\"number\">200px</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(<span class=\"number\">200px</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>盒子：</p>\n<p>给盒子加上动画</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: run1 <span class=\"number\">1s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面我们没有设置动画之前，可以看到颜色最深的部分在最右边，但是跑马灯的实现需求是需要颜色最什么部分从左边出现，然后移动到右边，所有我们这里将动画的初识位置向左移整个盒子的长度。这样就实现了需求。</p>\n<p>其他几个小盒子实现的方式大同小异。</p>\n<p>接下来我们来看看效果：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14c2f986d6f74376bd515021cf4ec0b4~tplv-k3u1fbpfcp-watermark.image\" alt=\"跑马灯.gif\"></p>\n<p>此时我们看到该动画显得有点乱，我们通过使用动画延时来实现我们想要的动画效果。</p>\n<p>我们从第二个小盒子开始添加延时：每个盒子比前一个盒子多<code>0.5</code>的延时。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation-delay</span>: .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation-delay</span>: <span class=\"number\">1s</span>;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation-delay</span>: <span class=\"number\">1.5s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后效果就出来了。</p>\n<p>接下来放上码上掘金的地址，这里有全部代码：↓</p>\n<p><a href=\"https://code.juejin.cn/pen/7172800105433530400\">代码片段</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"纯CSS实现跑马灯效果\"><a href=\"#纯CSS实现跑马灯效果\" class=\"headerlink\" title=\"纯CSS实现跑马灯效果\"></a>纯CSS实现跑马灯效果</h1><p>又是一个安静的晚上，又是没有灵感的一天，又只能去逛逛<code>codepen</code>。看到一个流光的边框效果，我就想如何通过自己的方式来现这样一个效果。</p>\n<p>突然又想起路边夜市的招牌，不就是一个流光效果加一个广告词吗。这下我的兴趣一下就激发起来了。</p>\n<p>首先上一个效果图</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7bd3aa2a13e4bf1be984a32560e72e7~tplv-k3u1fbpfcp-watermark.image\" alt=\"跑马灯.gif\"></p>\n<p>那这里的广告词就写我的名字吧，这都不重要，接下来让我们看看是怎么实现的吧。</p>\n<h2 id=\"结构分析\"><a href=\"#结构分析\" class=\"headerlink\" title=\"结构分析\"></a>结构分析</h2><p>首先很明显我们使用了一个盒子将文字装起来，并且将文字进行了居中，然后我们看到这盒子的周围围绕了两条光带，那么这两条光带是怎么实现的呢？</p>\n<p>其实这是用四个小盒子实现的，就是我们将这四个小盒子分别放在大盒子的周围（紧贴这大盒子的内壁），然后使用这几个小盒子实现跑马灯效果。</p>\n<p>接下来我们就看看具体的实现效果</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"外部大盒子\"><a href=\"#外部大盒子\" class=\"headerlink\" title=\"外部大盒子\"></a>外部大盒子</h3><p>首先准备一个<code>div</code>盒子，用来装我们的广告语，还有跑马灯的四个小盒子。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;main&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        海绵宝宝</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个盒子就准备好了  我们给这个何止设置一点样式，让他在浏览器中可以被我们看到</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.main&#123;</span><br><span class=\"line\">    width: 100px;</span><br><span class=\"line\">    height: 40px;</span><br><span class=\"line\">    background-color: transparent;</span><br><span class=\"line\">    /* 盒子居中 */</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 50%;</span><br><span class=\"line\">    margin-top: -20px;</span><br><span class=\"line\">    left: 50%;</span><br><span class=\"line\">    margin-left: -50px;</span><br><span class=\"line\">    /* 文字居中 */</span><br><span class=\"line\">    text-align: center;</span><br><span class=\"line\">    line-height: 40px;</span><br><span class=\"line\">    font-family: &#x27;宋体&#x27;;</span><br><span class=\"line\">    color: aquamarine;</span><br><span class=\"line\">    overflow: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们给这个大盒子设置了宽高，以及背景颜色，这样使得我们的盒子在浏览器中显得不那么突兀，并且我们将盒子在浏览器中居中，并且将盒子里面的文字也进行居中，不要问我为什么一定要居中，纯属我的强迫症。</p>\n<p>到现在为止，我们就已经把大盒子准备好了，效果就是这样的：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32d4a7803a2e4520904bc5cd03ecfdfe~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>接下来我们给大盒子设置灯光效果。</p>\n<h3 id=\"内部灯光效果\"><a href=\"#内部灯光效果\" class=\"headerlink\" title=\"内部灯光效果\"></a>内部灯光效果</h3><p>既然是灯光效果，那颜色就必须得亮，这里我选着<code>#0FF</code>配色，在效果图上，我们可以看到灯光尾部的颜色比较淡，展现出一种过渡效果，组件从头部慢慢过渡到小盒子的原本颜色。</p>\n<p>那这样的效果是怎么实现的呢？</p>\n<p>这里就需要用到<code>background</code>的一个新的属性值:<code>linear-gradient</code>,通过这个属性，我们可以将多个颜色设置为一个盒子的背景颜色，并且还有过渡效果，更强大的地方在于，这个属性值可以设置渐变的方向。</p>\n<p>语法：</p>\n<p><code>linear-gradient(渐变方向,color1,color2,color3...)</code></p>\n<p>那就开始使用这个属性值，我们写其中一个小盒子的效果，其他的效果实现方法都类似。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">linear-gradient</span>(to right, transparent , <span class=\"number\">#0FF</span>);</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里设置的是顶部的灯光效果，这里我们使用<code>top</code>和<code>left</code>的属性，设置这个盒子的位置；使用<code>width:100%</code>，使得这个盒子的宽度与大盒子保持一致，然后使用<code>height:1px</code>,将灯光条的宽度设置为1px,当然你也可以根据实际需求，改变灯光条的宽度。</p>\n<p>接着剩下三条灯光的实现原理基本相同，只有位置和背景颜色不同。</p>\n<p>剩下背景颜色的渐变方向分别是<code>to bottom</code>、<code>to left</code>、<code>to top</code>。</p>\n<p>最后的效果就是这样：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c902a90d4444931a0dae4dd13fc3c91~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>是不是离我们最终的效果越来越像了，对的，我们还差最后一部，给灯光加上动画效果。</p>\n<h3 id=\"灯光的动画效果\"><a href=\"#灯光的动画效果\" class=\"headerlink\" title=\"灯光的动画效果\"></a>灯光的动画效果</h3><p>说道动画效果，那必定离不开<code>@keyframes</code>,我们使用该属性为我们的灯光添加动画效果。</p>\n<p>同样我们也设置顶部的灯光效果作为示范：</p>\n<p>动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> run1&#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(-<span class=\"number\">200px</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateX</span>(<span class=\"number\">200px</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>盒子：</p>\n<p>给盒子加上动画</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: run1 <span class=\"number\">1s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面我们没有设置动画之前，可以看到颜色最深的部分在最右边，但是跑马灯的实现需求是需要颜色最什么部分从左边出现，然后移动到右边，所有我们这里将动画的初识位置向左移整个盒子的长度。这样就实现了需求。</p>\n<p>其他几个小盒子实现的方式大同小异。</p>\n<p>接下来我们来看看效果：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14c2f986d6f74376bd515021cf4ec0b4~tplv-k3u1fbpfcp-watermark.image\" alt=\"跑马灯.gif\"></p>\n<p>此时我们看到该动画显得有点乱，我们通过使用动画延时来实现我们想要的动画效果。</p>\n<p>我们从第二个小盒子开始添加延时：每个盒子比前一个盒子多<code>0.5</code>的延时。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation-delay</span>: .<span class=\"number\">5s</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation-delay</span>: <span class=\"number\">1s</span>;   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.main</span> <span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation-delay</span>: <span class=\"number\">1.5s</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后效果就出来了。</p>\n<p>接下来放上码上掘金的地址，这里有全部代码：↓</p>\n<p><a href=\"https://code.juejin.cn/pen/7172800105433530400\">代码片段</a></p>\n"},{"title":"跳动小球加载动画","date":"2022-11-12T16:00:00.000Z","_content":"# 跳动小球加载动画\n\n在网页开发中，加载动画是必不可缺的一个设计；因为在一些资源加载的时候需要让用户等待一段时间，为了使用户有更好的交互体验，一个使人身心愉悦的加载动画变必不可少。\n\n今天为大家带来的就是一个小求跳动加载动画\n\n## 效果图\n![码上掘金动画1.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e66a755d7b6f4841934dfa6158a558db~tplv-k3u1fbpfcp-watermark.image?)\n\n就如效果图上面多战士出来的，我们大致可以分为两部分：一部分是上面的灯，另一部分则是下面跳动的小球。\n\n设计思路也很简单，上面的小灯打下来的灯光，使得下面下面跳动的小球有一定的阴影，并且根据小球距离灯的距离远近，其阴影也随之变化。\n\n## 实现\n\n话不多说，直接开始通过代码实现，这是一个纯html与css实现的动画，不需要任何js。\n\n### 灯光部分\n\n灯光部分我使用了一个`div`将灯和灯光包裹起来，这样做为了方便调整位置，同时也可以方便的调整灯光的大小。\n\n```html\n<div class=\"lightBox\">\n    <div class=\"light\"></div>// 灯泡\n    <div class=\"lampLight\"></div>// 灯光\n</div>\n```\n\n灯光主题很简单，这里就不多说了。\n\n下面就是样式部分：\n\n我的设计思路是这样的：灯泡部分设置一个宽高，然后使用`border-radius`，使得灯泡呈现一个圆形。然后灯光我们使用一个盒子，设置一个宽高，然后使用`border-radius`，使得灯光呈现一个圆形，但是灯光这个盒子的大小比灯泡的盒子大得多，这样就可以使得灯光有一定的阴影效果。\n\n我们将整个灯光的大盒子居中，但不是垂直居中，因为下面还有一个跳动的小球。\n\n```css\n.lightBox{\n    position: absolute;\n    top: 20%;\n    left: 50%;\n}\n.light{\n    position: absolute;\n    top: 50px;\n    left: 50%;\n    margin-left: -10px;\n    width: 20px;\n    height: 20px;\n    background-color: rgb(249, 159, 4);\n    border-radius:50%;\n    z-index: 1;\n}\n.lampLight{\n    position: absolute;\n    top: 16%;\n    left: 50%;\n    margin-left: -60px;\n    width: 20px;\n    height: 20px;\n    border-bottom: 50px solid rgb(251, 232, 124);\n    border-top: 50px solid transparent;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-radius: 50%;\n}\n```\n\n最后灯光的效果就出来了：\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab0fa55f7f1e4b7f8ca434690e8f38bd~tplv-k3u1fbpfcp-watermark.image?)\n\n### 小球部分\n\n接下来就是小球的跳动部分，在这里我们使用一个稍大的长方形盒子，将三个小球放在盒子顶部，并设置一定间距，在盒子下面我们设置三个阴影。\n\n```html\n<div class=\"father\">\n    <!-- 加载小球 -->\n    <div class=\"ball1\"></div>\n    <div class=\"ball2\"></div>\n    <div class=\"ball3\"></div>\n\n    <!-- 小球阴影 -->\n    <div CLASS=\"ballShadow1\"></div>\n    <div CLASS=\"ballShadow2\"></div>\n    <div CLASS=\"ballShadow3\"></div>\n</div>\n```\n\n然后我们设置一下样式：\n\n首先就是整个大盒子的样式，我们给这个大盒子设置150px的宽度,70px高度，然后设置一个背景颜色，这样就可以看到这个大盒子的位置了。\n\n但是后期我们并不需要这个背景颜色，此时设置背景颜色只是为了更好的观察。\n\n```css\n.father{\n    position: absolute;\n    /* 居中 */\n    top:50%;\n    margin-top: -50px;\n    left: 50%;\n    margin-left: -80px;\n    /* 设置长宽 */\n    width: 160px;\n    height: 70px;\n    /* 背景色 */\n    /* background-color: #ccc; */\n}\n```\n\n接下来就是给小球设置一些样式，我们给小球设置一个宽高，然后设置一个背景颜色，这样就可以看到小球的位置了，前面我们还说到要讲小球均匀分布，所以这里还需要设置一些外边距。\n\n```css\n.ball1{\n    position: absolute;\n    width: 20px;\n    height: 20px;\n    background-color: #0ff;\n    left: 10px;// **1\n    border-radius: 50%;\n    z-index: 1;\n    animation: bounce 2s ease-in-out infinite;// **2\n    animation-delay: 0s;// **3 \n}\n```\n\n上面的代码只是第一个小球的样式,我们可以看到，在第一个小球上面我们设置小球的位置，但是每一个小球的位置都不一样，所以我这样设置：第一个小球左边距为10px,后面的每个小球依次比前一个小球多60px。这里我就不重复写了。\n\n然后我们设置小球的动画，这里我们使用的是CSS3的动画，我们设置一个动画名字为bounce，动画时间为2s，动画的效果为ease-in-out，动画的次数为无限次。\n\n然后我们设置小球的动画延迟，这里我们设置第一个小球的动画延迟为0s，第二个小球的动画延迟为0.5s，第三个小球的动画延迟为1s。\n\n接下来我们为小球设置动画：\n\n```css\n@keyframes bounce{\n    0%{\n        top: 0px;\n    }\n    50%{\n        top: 40px;\n    }\n    100%{\n        top:0px;\n    }\n}\n```\n\n### 阴影部分\n\n在效果图里面还有小球跳动的阴影，这里我们也给小球设置一个阴影，在父盒子下面设置三个盒子，长宽比例为2：1，然后设置一个背景颜色，边框使用`border-radius:50%`,这样就可以看到阴影的位置了。\n\n```css\n.ballShadow1{\n    position: absolute;\n    bottom: 2px;\n    left: 0px;\n    width: 40px;\n    height: 20px;\n    border-radius: 50%;\n    background-color: #ededed;\n    animation: box_shadow 2s ease-in-out 0s infinite;\n}\n```\n\n同样的，我这里展示的是第一个小球跳动的阴影。我们可以看到，阴影的位置是在小球的下面，所以我们设置了`bottom: 2px;`，然后我们设置了一个动画，动画的名字为box_shadow，动画的时间为2s，动画的效果为ease-in-out，动画的延迟为0s，动画的次数为无限次。\n\n后面的两个小球只需要设置一下位置就可以了，这里我就不重复写了。\n\n接下来我们设置阴影的动画：\n\n在日常生活中物体距离光源的距离会引起物体的阴影变化（大小，颜色深浅），我们这里使用缩放来实现阴影大小的变化，使用设置深一点的颜色来体现颜色的变化。\n\n```css\n    @keyframes box_shadow {\n    0%{\n        transform: scale(1,1);\n        background-color: #ededed;\n    }\n    50%{\n        transform: scale(0.5,0.5);\n        background-color: #999999;\n    }\n    100%{\n        transform: scale(1,1);\n        background-color: #ededed;\n    }\n}\n```\n\n## 结尾\n\n这里我们就完成了一个简单的小球跳动的效果，这里我们使用了CSS3的动画，这里我们使用了`@keyframes`来设置动画，然后我们使用`animation`来设置动画的属性，这里我们使用了`animation-delay`来设置动画的延迟，这样我们就可以实现小球跳动的效果了。\n\n这样一个小小的demo，不仅可以给我带来乐趣，也在无形之中让我进一步巩固了知识。","source":"_posts/跳动小球加载动画.md","raw":"---\ntitle: 跳动小球加载动画\ndate: 2022-11-13\ntags: [前端]\ncategories: [css,html]\n---\n# 跳动小球加载动画\n\n在网页开发中，加载动画是必不可缺的一个设计；因为在一些资源加载的时候需要让用户等待一段时间，为了使用户有更好的交互体验，一个使人身心愉悦的加载动画变必不可少。\n\n今天为大家带来的就是一个小求跳动加载动画\n\n## 效果图\n![码上掘金动画1.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e66a755d7b6f4841934dfa6158a558db~tplv-k3u1fbpfcp-watermark.image?)\n\n就如效果图上面多战士出来的，我们大致可以分为两部分：一部分是上面的灯，另一部分则是下面跳动的小球。\n\n设计思路也很简单，上面的小灯打下来的灯光，使得下面下面跳动的小球有一定的阴影，并且根据小球距离灯的距离远近，其阴影也随之变化。\n\n## 实现\n\n话不多说，直接开始通过代码实现，这是一个纯html与css实现的动画，不需要任何js。\n\n### 灯光部分\n\n灯光部分我使用了一个`div`将灯和灯光包裹起来，这样做为了方便调整位置，同时也可以方便的调整灯光的大小。\n\n```html\n<div class=\"lightBox\">\n    <div class=\"light\"></div>// 灯泡\n    <div class=\"lampLight\"></div>// 灯光\n</div>\n```\n\n灯光主题很简单，这里就不多说了。\n\n下面就是样式部分：\n\n我的设计思路是这样的：灯泡部分设置一个宽高，然后使用`border-radius`，使得灯泡呈现一个圆形。然后灯光我们使用一个盒子，设置一个宽高，然后使用`border-radius`，使得灯光呈现一个圆形，但是灯光这个盒子的大小比灯泡的盒子大得多，这样就可以使得灯光有一定的阴影效果。\n\n我们将整个灯光的大盒子居中，但不是垂直居中，因为下面还有一个跳动的小球。\n\n```css\n.lightBox{\n    position: absolute;\n    top: 20%;\n    left: 50%;\n}\n.light{\n    position: absolute;\n    top: 50px;\n    left: 50%;\n    margin-left: -10px;\n    width: 20px;\n    height: 20px;\n    background-color: rgb(249, 159, 4);\n    border-radius:50%;\n    z-index: 1;\n}\n.lampLight{\n    position: absolute;\n    top: 16%;\n    left: 50%;\n    margin-left: -60px;\n    width: 20px;\n    height: 20px;\n    border-bottom: 50px solid rgb(251, 232, 124);\n    border-top: 50px solid transparent;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-radius: 50%;\n}\n```\n\n最后灯光的效果就出来了：\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab0fa55f7f1e4b7f8ca434690e8f38bd~tplv-k3u1fbpfcp-watermark.image?)\n\n### 小球部分\n\n接下来就是小球的跳动部分，在这里我们使用一个稍大的长方形盒子，将三个小球放在盒子顶部，并设置一定间距，在盒子下面我们设置三个阴影。\n\n```html\n<div class=\"father\">\n    <!-- 加载小球 -->\n    <div class=\"ball1\"></div>\n    <div class=\"ball2\"></div>\n    <div class=\"ball3\"></div>\n\n    <!-- 小球阴影 -->\n    <div CLASS=\"ballShadow1\"></div>\n    <div CLASS=\"ballShadow2\"></div>\n    <div CLASS=\"ballShadow3\"></div>\n</div>\n```\n\n然后我们设置一下样式：\n\n首先就是整个大盒子的样式，我们给这个大盒子设置150px的宽度,70px高度，然后设置一个背景颜色，这样就可以看到这个大盒子的位置了。\n\n但是后期我们并不需要这个背景颜色，此时设置背景颜色只是为了更好的观察。\n\n```css\n.father{\n    position: absolute;\n    /* 居中 */\n    top:50%;\n    margin-top: -50px;\n    left: 50%;\n    margin-left: -80px;\n    /* 设置长宽 */\n    width: 160px;\n    height: 70px;\n    /* 背景色 */\n    /* background-color: #ccc; */\n}\n```\n\n接下来就是给小球设置一些样式，我们给小球设置一个宽高，然后设置一个背景颜色，这样就可以看到小球的位置了，前面我们还说到要讲小球均匀分布，所以这里还需要设置一些外边距。\n\n```css\n.ball1{\n    position: absolute;\n    width: 20px;\n    height: 20px;\n    background-color: #0ff;\n    left: 10px;// **1\n    border-radius: 50%;\n    z-index: 1;\n    animation: bounce 2s ease-in-out infinite;// **2\n    animation-delay: 0s;// **3 \n}\n```\n\n上面的代码只是第一个小球的样式,我们可以看到，在第一个小球上面我们设置小球的位置，但是每一个小球的位置都不一样，所以我这样设置：第一个小球左边距为10px,后面的每个小球依次比前一个小球多60px。这里我就不重复写了。\n\n然后我们设置小球的动画，这里我们使用的是CSS3的动画，我们设置一个动画名字为bounce，动画时间为2s，动画的效果为ease-in-out，动画的次数为无限次。\n\n然后我们设置小球的动画延迟，这里我们设置第一个小球的动画延迟为0s，第二个小球的动画延迟为0.5s，第三个小球的动画延迟为1s。\n\n接下来我们为小球设置动画：\n\n```css\n@keyframes bounce{\n    0%{\n        top: 0px;\n    }\n    50%{\n        top: 40px;\n    }\n    100%{\n        top:0px;\n    }\n}\n```\n\n### 阴影部分\n\n在效果图里面还有小球跳动的阴影，这里我们也给小球设置一个阴影，在父盒子下面设置三个盒子，长宽比例为2：1，然后设置一个背景颜色，边框使用`border-radius:50%`,这样就可以看到阴影的位置了。\n\n```css\n.ballShadow1{\n    position: absolute;\n    bottom: 2px;\n    left: 0px;\n    width: 40px;\n    height: 20px;\n    border-radius: 50%;\n    background-color: #ededed;\n    animation: box_shadow 2s ease-in-out 0s infinite;\n}\n```\n\n同样的，我这里展示的是第一个小球跳动的阴影。我们可以看到，阴影的位置是在小球的下面，所以我们设置了`bottom: 2px;`，然后我们设置了一个动画，动画的名字为box_shadow，动画的时间为2s，动画的效果为ease-in-out，动画的延迟为0s，动画的次数为无限次。\n\n后面的两个小球只需要设置一下位置就可以了，这里我就不重复写了。\n\n接下来我们设置阴影的动画：\n\n在日常生活中物体距离光源的距离会引起物体的阴影变化（大小，颜色深浅），我们这里使用缩放来实现阴影大小的变化，使用设置深一点的颜色来体现颜色的变化。\n\n```css\n    @keyframes box_shadow {\n    0%{\n        transform: scale(1,1);\n        background-color: #ededed;\n    }\n    50%{\n        transform: scale(0.5,0.5);\n        background-color: #999999;\n    }\n    100%{\n        transform: scale(1,1);\n        background-color: #ededed;\n    }\n}\n```\n\n## 结尾\n\n这里我们就完成了一个简单的小球跳动的效果，这里我们使用了CSS3的动画，这里我们使用了`@keyframes`来设置动画，然后我们使用`animation`来设置动画的属性，这里我们使用了`animation-delay`来设置动画的延迟，这样我们就可以实现小球跳动的效果了。\n\n这样一个小小的demo，不仅可以给我带来乐趣，也在无形之中让我进一步巩固了知识。","slug":"跳动小球加载动画","published":1,"updated":"2023-01-08T12:08:29.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhq002d9kbm5iqv32wi","content":"<h1 id=\"跳动小球加载动画\"><a href=\"#跳动小球加载动画\" class=\"headerlink\" title=\"跳动小球加载动画\"></a>跳动小球加载动画</h1><p>在网页开发中，加载动画是必不可缺的一个设计；因为在一些资源加载的时候需要让用户等待一段时间，为了使用户有更好的交互体验，一个使人身心愉悦的加载动画变必不可少。</p>\n<p>今天为大家带来的就是一个小求跳动加载动画</p>\n<h2 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h2><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e66a755d7b6f4841934dfa6158a558db~tplv-k3u1fbpfcp-watermark.image\" alt=\"码上掘金动画1.gif\"></p>\n<p>就如效果图上面多战士出来的，我们大致可以分为两部分：一部分是上面的灯，另一部分则是下面跳动的小球。</p>\n<p>设计思路也很简单，上面的小灯打下来的灯光，使得下面下面跳动的小球有一定的阴影，并且根据小球距离灯的距离远近，其阴影也随之变化。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>话不多说，直接开始通过代码实现，这是一个纯html与css实现的动画，不需要任何js。</p>\n<h3 id=\"灯光部分\"><a href=\"#灯光部分\" class=\"headerlink\" title=\"灯光部分\"></a>灯光部分</h3><p>灯光部分我使用了一个<code>div</code>将灯和灯光包裹起来，这样做为了方便调整位置，同时也可以方便的调整灯光的大小。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;lightBox&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;light&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>// 灯泡</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;lampLight&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>// 灯光</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>灯光主题很简单，这里就不多说了。</p>\n<p>下面就是样式部分：</p>\n<p>我的设计思路是这样的：灯泡部分设置一个宽高，然后使用<code>border-radius</code>，使得灯泡呈现一个圆形。然后灯光我们使用一个盒子，设置一个宽高，然后使用<code>border-radius</code>，使得灯光呈现一个圆形，但是灯光这个盒子的大小比灯泡的盒子大得多，这样就可以使得灯光有一定的阴影效果。</p>\n<p>我们将整个灯光的大盒子居中，但不是垂直居中，因为下面还有一个跳动的小球。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.lightBox</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">20%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.light</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">249</span>, <span class=\"number\">159</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.lampLight</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">16%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">60px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">50px</span> solid <span class=\"built_in\">rgb</span>(<span class=\"number\">251</span>, <span class=\"number\">232</span>, <span class=\"number\">124</span>);</span><br><span class=\"line\">    <span class=\"attribute\">border-top</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后灯光的效果就出来了：<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab0fa55f7f1e4b7f8ca434690e8f38bd~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"小球部分\"><a href=\"#小球部分\" class=\"headerlink\" title=\"小球部分\"></a>小球部分</h3><p>接下来就是小球的跳动部分，在这里我们使用一个稍大的长方形盒子，将三个小球放在盒子顶部，并设置一定间距，在盒子下面我们设置三个阴影。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;father&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 加载小球 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ball1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ball2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ball3&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 小球阴影 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">CLASS</span>=<span class=\"string\">&quot;ballShadow1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">CLASS</span>=<span class=\"string\">&quot;ballShadow2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">CLASS</span>=<span class=\"string\">&quot;ballShadow3&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后我们设置一下样式：</p>\n<p>首先就是整个大盒子的样式，我们给这个大盒子设置150px的宽度,70px高度，然后设置一个背景颜色，这样就可以看到这个大盒子的位置了。</p>\n<p>但是后期我们并不需要这个背景颜色，此时设置背景颜色只是为了更好的观察。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"comment\">/* 居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">80px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 设置长宽 */</span></span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">160px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 背景色 */</span></span><br><span class=\"line\">    <span class=\"comment\">/* background-color: #ccc; */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是给小球设置一些样式，我们给小球设置一个宽高，然后设置一个背景颜色，这样就可以看到小球的位置了，前面我们还说到要讲小球均匀分布，所以这里还需要设置一些外边距。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ball1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#0ff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">10px</span>;// **<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: bounce <span class=\"number\">2s</span> ease-in-out infinite;// **<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"attribute\">animation-delay</span>: <span class=\"number\">0s</span>;// **<span class=\"number\">3</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码只是第一个小球的样式,我们可以看到，在第一个小球上面我们设置小球的位置，但是每一个小球的位置都不一样，所以我这样设置：第一个小球左边距为10px,后面的每个小球依次比前一个小球多60px。这里我就不重复写了。</p>\n<p>然后我们设置小球的动画，这里我们使用的是CSS3的动画，我们设置一个动画名字为bounce，动画时间为2s，动画的效果为ease-in-out，动画的次数为无限次。</p>\n<p>然后我们设置小球的动画延迟，这里我们设置第一个小球的动画延迟为0s，第二个小球的动画延迟为0.5s，第三个小球的动画延迟为1s。</p>\n<p>接下来我们为小球设置动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> bounce&#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">50%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"阴影部分\"><a href=\"#阴影部分\" class=\"headerlink\" title=\"阴影部分\"></a>阴影部分</h3><p>在效果图里面还有小球跳动的阴影，这里我们也给小球设置一个阴影，在父盒子下面设置三个盒子，长宽比例为2：1，然后设置一个背景颜色，边框使用<code>border-radius:50%</code>,这样就可以看到阴影的位置了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ballShadow1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#ededed</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: box_shadow <span class=\"number\">2s</span> ease-in-out <span class=\"number\">0s</span> infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的，我这里展示的是第一个小球跳动的阴影。我们可以看到，阴影的位置是在小球的下面，所以我们设置了<code>bottom: 2px;</code>，然后我们设置了一个动画，动画的名字为box_shadow，动画的时间为2s，动画的效果为ease-in-out，动画的延迟为0s，动画的次数为无限次。</p>\n<p>后面的两个小球只需要设置一下位置就可以了，这里我就不重复写了。</p>\n<p>接下来我们设置阴影的动画：</p>\n<p>在日常生活中物体距离光源的距离会引起物体的阴影变化（大小，颜色深浅），我们这里使用缩放来实现阴影大小的变化，使用设置深一点的颜色来体现颜色的变化。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">@keyframes</span> box_shadow &#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: <span class=\"number\">#ededed</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">50%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">0.5</span>,<span class=\"number\">0.5</span>);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: <span class=\"number\">#999999</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: <span class=\"number\">#ededed</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这里我们就完成了一个简单的小球跳动的效果，这里我们使用了CSS3的动画，这里我们使用了<code>@keyframes</code>来设置动画，然后我们使用<code>animation</code>来设置动画的属性，这里我们使用了<code>animation-delay</code>来设置动画的延迟，这样我们就可以实现小球跳动的效果了。</p>\n<p>这样一个小小的demo，不仅可以给我带来乐趣，也在无形之中让我进一步巩固了知识。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"跳动小球加载动画\"><a href=\"#跳动小球加载动画\" class=\"headerlink\" title=\"跳动小球加载动画\"></a>跳动小球加载动画</h1><p>在网页开发中，加载动画是必不可缺的一个设计；因为在一些资源加载的时候需要让用户等待一段时间，为了使用户有更好的交互体验，一个使人身心愉悦的加载动画变必不可少。</p>\n<p>今天为大家带来的就是一个小求跳动加载动画</p>\n<h2 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h2><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e66a755d7b6f4841934dfa6158a558db~tplv-k3u1fbpfcp-watermark.image\" alt=\"码上掘金动画1.gif\"></p>\n<p>就如效果图上面多战士出来的，我们大致可以分为两部分：一部分是上面的灯，另一部分则是下面跳动的小球。</p>\n<p>设计思路也很简单，上面的小灯打下来的灯光，使得下面下面跳动的小球有一定的阴影，并且根据小球距离灯的距离远近，其阴影也随之变化。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>话不多说，直接开始通过代码实现，这是一个纯html与css实现的动画，不需要任何js。</p>\n<h3 id=\"灯光部分\"><a href=\"#灯光部分\" class=\"headerlink\" title=\"灯光部分\"></a>灯光部分</h3><p>灯光部分我使用了一个<code>div</code>将灯和灯光包裹起来，这样做为了方便调整位置，同时也可以方便的调整灯光的大小。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;lightBox&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;light&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>// 灯泡</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;lampLight&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>// 灯光</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>灯光主题很简单，这里就不多说了。</p>\n<p>下面就是样式部分：</p>\n<p>我的设计思路是这样的：灯泡部分设置一个宽高，然后使用<code>border-radius</code>，使得灯泡呈现一个圆形。然后灯光我们使用一个盒子，设置一个宽高，然后使用<code>border-radius</code>，使得灯光呈现一个圆形，但是灯光这个盒子的大小比灯泡的盒子大得多，这样就可以使得灯光有一定的阴影效果。</p>\n<p>我们将整个灯光的大盒子居中，但不是垂直居中，因为下面还有一个跳动的小球。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.lightBox</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">20%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.light</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">10px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">249</span>, <span class=\"number\">159</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.lampLight</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">16%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">60px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">50px</span> solid <span class=\"built_in\">rgb</span>(<span class=\"number\">251</span>, <span class=\"number\">232</span>, <span class=\"number\">124</span>);</span><br><span class=\"line\">    <span class=\"attribute\">border-top</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后灯光的效果就出来了：<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab0fa55f7f1e4b7f8ca434690e8f38bd~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"小球部分\"><a href=\"#小球部分\" class=\"headerlink\" title=\"小球部分\"></a>小球部分</h3><p>接下来就是小球的跳动部分，在这里我们使用一个稍大的长方形盒子，将三个小球放在盒子顶部，并设置一定间距，在盒子下面我们设置三个阴影。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;father&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 加载小球 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ball1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ball2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ball3&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 小球阴影 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">CLASS</span>=<span class=\"string\">&quot;ballShadow1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">CLASS</span>=<span class=\"string\">&quot;ballShadow2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">CLASS</span>=<span class=\"string\">&quot;ballShadow3&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后我们设置一下样式：</p>\n<p>首先就是整个大盒子的样式，我们给这个大盒子设置150px的宽度,70px高度，然后设置一个背景颜色，这样就可以看到这个大盒子的位置了。</p>\n<p>但是后期我们并不需要这个背景颜色，此时设置背景颜色只是为了更好的观察。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.father</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"comment\">/* 居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">80px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 设置长宽 */</span></span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">160px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">70px</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 背景色 */</span></span><br><span class=\"line\">    <span class=\"comment\">/* background-color: #ccc; */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是给小球设置一些样式，我们给小球设置一个宽高，然后设置一个背景颜色，这样就可以看到小球的位置了，前面我们还说到要讲小球均匀分布，所以这里还需要设置一些外边距。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ball1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#0ff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">10px</span>;// **<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: bounce <span class=\"number\">2s</span> ease-in-out infinite;// **<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"attribute\">animation-delay</span>: <span class=\"number\">0s</span>;// **<span class=\"number\">3</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码只是第一个小球的样式,我们可以看到，在第一个小球上面我们设置小球的位置，但是每一个小球的位置都不一样，所以我这样设置：第一个小球左边距为10px,后面的每个小球依次比前一个小球多60px。这里我就不重复写了。</p>\n<p>然后我们设置小球的动画，这里我们使用的是CSS3的动画，我们设置一个动画名字为bounce，动画时间为2s，动画的效果为ease-in-out，动画的次数为无限次。</p>\n<p>然后我们设置小球的动画延迟，这里我们设置第一个小球的动画延迟为0s，第二个小球的动画延迟为0.5s，第三个小球的动画延迟为1s。</p>\n<p>接下来我们为小球设置动画：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@keyframes</span> bounce&#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">50%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">top</span>:<span class=\"number\">0px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"阴影部分\"><a href=\"#阴影部分\" class=\"headerlink\" title=\"阴影部分\"></a>阴影部分</h3><p>在效果图里面还有小球跳动的阴影，这里我们也给小球设置一个阴影，在父盒子下面设置三个盒子，长宽比例为2：1，然后设置一个背景颜色，边框使用<code>border-radius:50%</code>,这样就可以看到阴影的位置了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.ballShadow1</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#ededed</span>;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: box_shadow <span class=\"number\">2s</span> ease-in-out <span class=\"number\">0s</span> infinite;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的，我这里展示的是第一个小球跳动的阴影。我们可以看到，阴影的位置是在小球的下面，所以我们设置了<code>bottom: 2px;</code>，然后我们设置了一个动画，动画的名字为box_shadow，动画的时间为2s，动画的效果为ease-in-out，动画的延迟为0s，动画的次数为无限次。</p>\n<p>后面的两个小球只需要设置一下位置就可以了，这里我就不重复写了。</p>\n<p>接下来我们设置阴影的动画：</p>\n<p>在日常生活中物体距离光源的距离会引起物体的阴影变化（大小，颜色深浅），我们这里使用缩放来实现阴影大小的变化，使用设置深一点的颜色来体现颜色的变化。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">@keyframes</span> box_shadow &#123;</span><br><span class=\"line\">    <span class=\"number\">0%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: <span class=\"number\">#ededed</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">50%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">0.5</span>,<span class=\"number\">0.5</span>);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: <span class=\"number\">#999999</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"number\">100%</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: <span class=\"number\">#ededed</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>这里我们就完成了一个简单的小球跳动的效果，这里我们使用了CSS3的动画，这里我们使用了<code>@keyframes</code>来设置动画，然后我们使用<code>animation</code>来设置动画的属性，这里我们使用了<code>animation-delay</code>来设置动画的延迟，这样我们就可以实现小球跳动的效果了。</p>\n<p>这样一个小小的demo，不仅可以给我带来乐趣，也在无形之中让我进一步巩固了知识。</p>\n"},{"title":"青训营-快乐出发","date":"2022-09-13T16:00:00.000Z","_content":"# 青训营-快乐出发\n\n第一次参加字节的青训营，偶然间在沸点看见这个活动，每天打卡的形式吸引了我。本来我是一个自觉性不是很强的人，我感觉通过这个每日打卡可以进一步监督我的学习\n\n## 目标【50天】\n\n- [ ] 每天打卡\n- [ ] 将js学习精通\n- [ ] 开始学习vue\n- [ ] 每天复习前天所学习的知识\n\n## 每天坚持要做的事情\n\n- 认真上课\n- 保持看书写代码的习惯\n- 每天复习前天所学习的知识\n- 开学之后，利用课余时间去自习室学习\n\n## 每周要做的事情\n\n- 至少运动三次\n- 检查这一周的学习成果\n\n冲冲冲！！！","source":"_posts/青训营-快乐出发.md","raw":"---\ntitle: 青训营-快乐出发\ndate: 2022-9-14\ntags: [随笔]\ncategories: [随笔]\n---\n# 青训营-快乐出发\n\n第一次参加字节的青训营，偶然间在沸点看见这个活动，每天打卡的形式吸引了我。本来我是一个自觉性不是很强的人，我感觉通过这个每日打卡可以进一步监督我的学习\n\n## 目标【50天】\n\n- [ ] 每天打卡\n- [ ] 将js学习精通\n- [ ] 开始学习vue\n- [ ] 每天复习前天所学习的知识\n\n## 每天坚持要做的事情\n\n- 认真上课\n- 保持看书写代码的习惯\n- 每天复习前天所学习的知识\n- 开学之后，利用课余时间去自习室学习\n\n## 每周要做的事情\n\n- 至少运动三次\n- 检查这一周的学习成果\n\n冲冲冲！！！","slug":"青训营-快乐出发","published":1,"updated":"2023-01-08T11:39:55.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhr002g9kbm9lik6v5k","content":"<h1 id=\"青训营-快乐出发\"><a href=\"#青训营-快乐出发\" class=\"headerlink\" title=\"青训营-快乐出发\"></a>青训营-快乐出发</h1><p>第一次参加字节的青训营，偶然间在沸点看见这个活动，每天打卡的形式吸引了我。本来我是一个自觉性不是很强的人，我感觉通过这个每日打卡可以进一步监督我的学习</p>\n<h2 id=\"目标【50天】\"><a href=\"#目标【50天】\" class=\"headerlink\" title=\"目标【50天】\"></a>目标【50天】</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 每天打卡</li>\n<li><input disabled=\"\" type=\"checkbox\"> 将js学习精通</li>\n<li><input disabled=\"\" type=\"checkbox\"> 开始学习vue</li>\n<li><input disabled=\"\" type=\"checkbox\"> 每天复习前天所学习的知识</li>\n</ul>\n<h2 id=\"每天坚持要做的事情\"><a href=\"#每天坚持要做的事情\" class=\"headerlink\" title=\"每天坚持要做的事情\"></a>每天坚持要做的事情</h2><ul>\n<li>认真上课</li>\n<li>保持看书写代码的习惯</li>\n<li>每天复习前天所学习的知识</li>\n<li>开学之后，利用课余时间去自习室学习</li>\n</ul>\n<h2 id=\"每周要做的事情\"><a href=\"#每周要做的事情\" class=\"headerlink\" title=\"每周要做的事情\"></a>每周要做的事情</h2><ul>\n<li>至少运动三次</li>\n<li>检查这一周的学习成果</li>\n</ul>\n<p>冲冲冲！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"青训营-快乐出发\"><a href=\"#青训营-快乐出发\" class=\"headerlink\" title=\"青训营-快乐出发\"></a>青训营-快乐出发</h1><p>第一次参加字节的青训营，偶然间在沸点看见这个活动，每天打卡的形式吸引了我。本来我是一个自觉性不是很强的人，我感觉通过这个每日打卡可以进一步监督我的学习</p>\n<h2 id=\"目标【50天】\"><a href=\"#目标【50天】\" class=\"headerlink\" title=\"目标【50天】\"></a>目标【50天】</h2><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 每天打卡</li>\n<li><input disabled=\"\" type=\"checkbox\"> 将js学习精通</li>\n<li><input disabled=\"\" type=\"checkbox\"> 开始学习vue</li>\n<li><input disabled=\"\" type=\"checkbox\"> 每天复习前天所学习的知识</li>\n</ul>\n<h2 id=\"每天坚持要做的事情\"><a href=\"#每天坚持要做的事情\" class=\"headerlink\" title=\"每天坚持要做的事情\"></a>每天坚持要做的事情</h2><ul>\n<li>认真上课</li>\n<li>保持看书写代码的习惯</li>\n<li>每天复习前天所学习的知识</li>\n<li>开学之后，利用课余时间去自习室学习</li>\n</ul>\n<h2 id=\"每周要做的事情\"><a href=\"#每周要做的事情\" class=\"headerlink\" title=\"每周要做的事情\"></a>每周要做的事情</h2><ul>\n<li>至少运动三次</li>\n<li>检查这一周的学习成果</li>\n</ul>\n<p>冲冲冲！！！</p>\n"},{"title":"Set的基本使用","data":["2023-3-15"],"_content":"\n# Set的基本使用\n\nSet作为ES6新出的一种数据类型，它是一种特殊的集合，它里面没有键名，并且在Set中，相同的元素只会出现一次。\n\n## Set的增删改查\n\n### Set的创建\n\nSet不是原始数据类型，所以我们同样需要使用`new`关键字来创建。\n\n就像这样：\n\n```js\nlet s1 = new Set([1, 2, 3, 4, 5]);\n```\n\n在创建Set的时候，我们使用`New`关键字然后后面跟上`Set()`在这里面，我们可以选择个ISet传入一个参数，当然这个参数一般都是数组类型的，这个传入的数组将被作为Set的初始值，当然，我们也可以不给Set传入参数，此时Set的值为0。\n\n### Set添加元素\n\n在Map中我们使用`map.set(key,value)`给Map添加元素，在Set中，我们将会使用`set.add(value)`。就像这样：\n\n```js\nlet s3 = new Set();\ns3.add(2);\nconsole.log(s3); // 2\n```\n\n使用这个方法返回的是Set本身。\n\n### Set删除元素\n\n我们使用`set.delete(value)`来删除Set中指定的元素，如果Set中存在该元素，那么就返回true，删除成功；否则Set中不存在该元素，删除失败，返回false.\n\n```js\nlet s4 = new Set([1, 2])\nvar isTrue = s4.delete(1);\nvar isTrue2 = s4.delete(3);\nconsole.log(isTrue, isTrue2); // true false\n```\n\n在删除`1`这个元素的时候，找到了该元素，删除成功，返回一个布尔值`true`，但是在删除`3`这个元素的时候，在该Set里面并没有，删除失败，返回一个布尔值`false`。\n\n### 判断Set是否含有指定元素\n\n我们需要判断某个元素是否在Set中时，我们可以使用`set.has(value)`。它的返回值也是一个布尔值，包含返回`true`，不包含返回`false`。\n\n```js\nlet s5 = new Set([\"2\",\"3\"]);\nlet flag = s5.has(\"3\");\nlet flag2 = s5.has(3);\nconsole.log(flag,flag2); // true  false\n```\n\n### 清空整个Set\n\n如果我们需要将整个Set进行清空，那么我们只需要使用`set.clear()`方法即可，这个使用方法与Map一致。\n\n```js\nlet s6 = new Set([1,2,3,4]);\nconsole.log(s6); // Set(4) { 1, 2, 3, 4 }\ns6.clear();\nconsole.log(s6); // Set(0) {}\n```\n\n### 获取Set元素的个数\n\n我们也可以使用`set.size`来获取Set元素的个数，这个`size`是Set的一个属性，而不是方法，所以我们在使用的时候可以不用加上`()`。\n\n```js\nlet s7 = new Set([1, 2, 3, 4, 5, 6]);\nvar length = s7.size;\nconsole.log(length);  // 6\n```\n\n## Set的迭代\n\nSet的迭代其实与Map相差不大，Map上面的迭代方法在Set这里也能使用。这里是我写的另一篇[Map使用技巧](https://juejin.cn/post/7210301826939764792)。\n\n在Set中我们可以使用下面三种方法进行遍历。\n\n- set.keys()： 遍历并返回一个包含所有值的可迭代对象，\n- set.values()：所得到的结果与`set.keys()`一样，这里主要是为了与Map兼容\n- set.entries()：遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。\n\n## Set的一个使用场景\n\n因为Set是不包含重复元素的，所以我们可以使用Set来给数组去重，但盘【】哦、2图 是如果数组里面是一些对象类型的数据，比如这样`[{\"anme\":1},{\"name\":1}]`这样并不能通过Set去重，因为在Set看来，这两个是不一样的。\n\n数组去重：\n\n```js\nlet arr = [1,2,2,3,4,4,5,5,6,7,8,9,9];\nlet set = new Set();\nfor (const i of arr) {\n    set.add(i);\n}\narr = Array.from(set);\nconsole.log(arr);\n\n// 结果\n\n// [\n//   1, 2, 3, 4, 5,\n//   6, 7, 8, 9\n// ]\n```\n\n这样我们就通过Set成功将数组给去重了。","source":"_posts/ES6/Set.md","raw":"---\ntitle: Set的基本使用\ndata: [2023-3-15]\ntags: [前端]\ncategories: [ES6]\n---\n\n# Set的基本使用\n\nSet作为ES6新出的一种数据类型，它是一种特殊的集合，它里面没有键名，并且在Set中，相同的元素只会出现一次。\n\n## Set的增删改查\n\n### Set的创建\n\nSet不是原始数据类型，所以我们同样需要使用`new`关键字来创建。\n\n就像这样：\n\n```js\nlet s1 = new Set([1, 2, 3, 4, 5]);\n```\n\n在创建Set的时候，我们使用`New`关键字然后后面跟上`Set()`在这里面，我们可以选择个ISet传入一个参数，当然这个参数一般都是数组类型的，这个传入的数组将被作为Set的初始值，当然，我们也可以不给Set传入参数，此时Set的值为0。\n\n### Set添加元素\n\n在Map中我们使用`map.set(key,value)`给Map添加元素，在Set中，我们将会使用`set.add(value)`。就像这样：\n\n```js\nlet s3 = new Set();\ns3.add(2);\nconsole.log(s3); // 2\n```\n\n使用这个方法返回的是Set本身。\n\n### Set删除元素\n\n我们使用`set.delete(value)`来删除Set中指定的元素，如果Set中存在该元素，那么就返回true，删除成功；否则Set中不存在该元素，删除失败，返回false.\n\n```js\nlet s4 = new Set([1, 2])\nvar isTrue = s4.delete(1);\nvar isTrue2 = s4.delete(3);\nconsole.log(isTrue, isTrue2); // true false\n```\n\n在删除`1`这个元素的时候，找到了该元素，删除成功，返回一个布尔值`true`，但是在删除`3`这个元素的时候，在该Set里面并没有，删除失败，返回一个布尔值`false`。\n\n### 判断Set是否含有指定元素\n\n我们需要判断某个元素是否在Set中时，我们可以使用`set.has(value)`。它的返回值也是一个布尔值，包含返回`true`，不包含返回`false`。\n\n```js\nlet s5 = new Set([\"2\",\"3\"]);\nlet flag = s5.has(\"3\");\nlet flag2 = s5.has(3);\nconsole.log(flag,flag2); // true  false\n```\n\n### 清空整个Set\n\n如果我们需要将整个Set进行清空，那么我们只需要使用`set.clear()`方法即可，这个使用方法与Map一致。\n\n```js\nlet s6 = new Set([1,2,3,4]);\nconsole.log(s6); // Set(4) { 1, 2, 3, 4 }\ns6.clear();\nconsole.log(s6); // Set(0) {}\n```\n\n### 获取Set元素的个数\n\n我们也可以使用`set.size`来获取Set元素的个数，这个`size`是Set的一个属性，而不是方法，所以我们在使用的时候可以不用加上`()`。\n\n```js\nlet s7 = new Set([1, 2, 3, 4, 5, 6]);\nvar length = s7.size;\nconsole.log(length);  // 6\n```\n\n## Set的迭代\n\nSet的迭代其实与Map相差不大，Map上面的迭代方法在Set这里也能使用。这里是我写的另一篇[Map使用技巧](https://juejin.cn/post/7210301826939764792)。\n\n在Set中我们可以使用下面三种方法进行遍历。\n\n- set.keys()： 遍历并返回一个包含所有值的可迭代对象，\n- set.values()：所得到的结果与`set.keys()`一样，这里主要是为了与Map兼容\n- set.entries()：遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。\n\n## Set的一个使用场景\n\n因为Set是不包含重复元素的，所以我们可以使用Set来给数组去重，但盘【】哦、2图 是如果数组里面是一些对象类型的数据，比如这样`[{\"anme\":1},{\"name\":1}]`这样并不能通过Set去重，因为在Set看来，这两个是不一样的。\n\n数组去重：\n\n```js\nlet arr = [1,2,2,3,4,4,5,5,6,7,8,9,9];\nlet set = new Set();\nfor (const i of arr) {\n    set.add(i);\n}\narr = Array.from(set);\nconsole.log(arr);\n\n// 结果\n\n// [\n//   1, 2, 3, 4, 5,\n//   6, 7, 8, 9\n// ]\n```\n\n这样我们就通过Set成功将数组给去重了。","slug":"ES6/Set","published":1,"date":"2023-03-15T00:44:37.599Z","updated":"2023-03-15T11:57:52.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhs002k9kbm4b02hxsn","content":"<h1 id=\"Set的基本使用\"><a href=\"#Set的基本使用\" class=\"headerlink\" title=\"Set的基本使用\"></a>Set的基本使用</h1><p>Set作为ES6新出的一种数据类型，它是一种特殊的集合，它里面没有键名，并且在Set中，相同的元素只会出现一次。</p>\n<h2 id=\"Set的增删改查\"><a href=\"#Set的增删改查\" class=\"headerlink\" title=\"Set的增删改查\"></a>Set的增删改查</h2><h3 id=\"Set的创建\"><a href=\"#Set的创建\" class=\"headerlink\" title=\"Set的创建\"></a>Set的创建</h3><p>Set不是原始数据类型，所以我们同样需要使用<code>new</code>关键字来创建。</p>\n<p>就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>在创建Set的时候，我们使用<code>New</code>关键字然后后面跟上<code>Set()</code>在这里面，我们可以选择个ISet传入一个参数，当然这个参数一般都是数组类型的，这个传入的数组将被作为Set的初始值，当然，我们也可以不给Set传入参数，此时Set的值为0。</p>\n<h3 id=\"Set添加元素\"><a href=\"#Set添加元素\" class=\"headerlink\" title=\"Set添加元素\"></a>Set添加元素</h3><p>在Map中我们使用<code>map.set(key,value)</code>给Map添加元素，在Set中，我们将会使用<code>set.add(value)</code>。就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\">s3.<span class=\"title function_\">add</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s3); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>使用这个方法返回的是Set本身。</p>\n<h3 id=\"Set删除元素\"><a href=\"#Set删除元素\" class=\"headerlink\" title=\"Set删除元素\"></a>Set删除元素</h3><p>我们使用<code>set.delete(value)</code>来删除Set中指定的元素，如果Set中存在该元素，那么就返回true，删除成功；否则Set中不存在该元素，删除失败，返回false.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s4 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"keyword\">var</span> isTrue = s4.<span class=\"title function_\">delete</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> isTrue2 = s4.<span class=\"title function_\">delete</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(isTrue, isTrue2); <span class=\"comment\">// true false</span></span><br></pre></td></tr></table></figure>\n\n<p>在删除<code>1</code>这个元素的时候，找到了该元素，删除成功，返回一个布尔值<code>true</code>，但是在删除<code>3</code>这个元素的时候，在该Set里面并没有，删除失败，返回一个布尔值<code>false</code>。</p>\n<h3 id=\"判断Set是否含有指定元素\"><a href=\"#判断Set是否含有指定元素\" class=\"headerlink\" title=\"判断Set是否含有指定元素\"></a>判断Set是否含有指定元素</h3><p>我们需要判断某个元素是否在Set中时，我们可以使用<code>set.has(value)</code>。它的返回值也是一个布尔值，包含返回<code>true</code>，不包含返回<code>false</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s5 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;3&quot;</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = s5.<span class=\"title function_\">has</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag2 = s5.<span class=\"title function_\">has</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(flag,flag2); <span class=\"comment\">// true  false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"清空整个Set\"><a href=\"#清空整个Set\" class=\"headerlink\" title=\"清空整个Set\"></a>清空整个Set</h3><p>如果我们需要将整个Set进行清空，那么我们只需要使用<code>set.clear()</code>方法即可，这个使用方法与Map一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s6 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s6); <span class=\"comment\">// Set(4) &#123; 1, 2, 3, 4 &#125;</span></span><br><span class=\"line\">s6.<span class=\"title function_\">clear</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s6); <span class=\"comment\">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取Set元素的个数\"><a href=\"#获取Set元素的个数\" class=\"headerlink\" title=\"获取Set元素的个数\"></a>获取Set元素的个数</h3><p>我们也可以使用<code>set.size</code>来获取Set元素的个数，这个<code>size</code>是Set的一个属性，而不是方法，所以我们在使用的时候可以不用加上<code>()</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s7 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> length = s7.<span class=\"property\">size</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(length);  <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set的迭代\"><a href=\"#Set的迭代\" class=\"headerlink\" title=\"Set的迭代\"></a>Set的迭代</h2><p>Set的迭代其实与Map相差不大，Map上面的迭代方法在Set这里也能使用。这里是我写的另一篇<a href=\"https://juejin.cn/post/7210301826939764792\">Map使用技巧</a>。</p>\n<p>在Set中我们可以使用下面三种方法进行遍历。</p>\n<ul>\n<li>set.keys()： 遍历并返回一个包含所有值的可迭代对象，</li>\n<li>set.values()：所得到的结果与<code>set.keys()</code>一样，这里主要是为了与Map兼容</li>\n<li>set.entries()：遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。</li>\n</ul>\n<h2 id=\"Set的一个使用场景\"><a href=\"#Set的一个使用场景\" class=\"headerlink\" title=\"Set的一个使用场景\"></a>Set的一个使用场景</h2><p>因为Set是不包含重复元素的，所以我们可以使用Set来给数组去重，但盘【】哦、2图 是如果数组里面是一些对象类型的数据，比如这样<code>[&#123;&quot;anme&quot;:1&#125;,&#123;&quot;name&quot;:1&#125;]</code>这样并不能通过Set去重，因为在Set看来，这两个是不一样的。</p>\n<p>数组去重：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    set.<span class=\"title function_\">add</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(set);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [</span></span><br><span class=\"line\"><span class=\"comment\">//   1, 2, 3, 4, 5,</span></span><br><span class=\"line\"><span class=\"comment\">//   6, 7, 8, 9</span></span><br><span class=\"line\"><span class=\"comment\">// ]</span></span><br></pre></td></tr></table></figure>\n\n<p>这样我们就通过Set成功将数组给去重了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Set的基本使用\"><a href=\"#Set的基本使用\" class=\"headerlink\" title=\"Set的基本使用\"></a>Set的基本使用</h1><p>Set作为ES6新出的一种数据类型，它是一种特殊的集合，它里面没有键名，并且在Set中，相同的元素只会出现一次。</p>\n<h2 id=\"Set的增删改查\"><a href=\"#Set的增删改查\" class=\"headerlink\" title=\"Set的增删改查\"></a>Set的增删改查</h2><h3 id=\"Set的创建\"><a href=\"#Set的创建\" class=\"headerlink\" title=\"Set的创建\"></a>Set的创建</h3><p>Set不是原始数据类型，所以我们同样需要使用<code>new</code>关键字来创建。</p>\n<p>就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>在创建Set的时候，我们使用<code>New</code>关键字然后后面跟上<code>Set()</code>在这里面，我们可以选择个ISet传入一个参数，当然这个参数一般都是数组类型的，这个传入的数组将被作为Set的初始值，当然，我们也可以不给Set传入参数，此时Set的值为0。</p>\n<h3 id=\"Set添加元素\"><a href=\"#Set添加元素\" class=\"headerlink\" title=\"Set添加元素\"></a>Set添加元素</h3><p>在Map中我们使用<code>map.set(key,value)</code>给Map添加元素，在Set中，我们将会使用<code>set.add(value)</code>。就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\">s3.<span class=\"title function_\">add</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s3); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>使用这个方法返回的是Set本身。</p>\n<h3 id=\"Set删除元素\"><a href=\"#Set删除元素\" class=\"headerlink\" title=\"Set删除元素\"></a>Set删除元素</h3><p>我们使用<code>set.delete(value)</code>来删除Set中指定的元素，如果Set中存在该元素，那么就返回true，删除成功；否则Set中不存在该元素，删除失败，返回false.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s4 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"keyword\">var</span> isTrue = s4.<span class=\"title function_\">delete</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> isTrue2 = s4.<span class=\"title function_\">delete</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(isTrue, isTrue2); <span class=\"comment\">// true false</span></span><br></pre></td></tr></table></figure>\n\n<p>在删除<code>1</code>这个元素的时候，找到了该元素，删除成功，返回一个布尔值<code>true</code>，但是在删除<code>3</code>这个元素的时候，在该Set里面并没有，删除失败，返回一个布尔值<code>false</code>。</p>\n<h3 id=\"判断Set是否含有指定元素\"><a href=\"#判断Set是否含有指定元素\" class=\"headerlink\" title=\"判断Set是否含有指定元素\"></a>判断Set是否含有指定元素</h3><p>我们需要判断某个元素是否在Set中时，我们可以使用<code>set.has(value)</code>。它的返回值也是一个布尔值，包含返回<code>true</code>，不包含返回<code>false</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s5 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;3&quot;</span>]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = s5.<span class=\"title function_\">has</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag2 = s5.<span class=\"title function_\">has</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(flag,flag2); <span class=\"comment\">// true  false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"清空整个Set\"><a href=\"#清空整个Set\" class=\"headerlink\" title=\"清空整个Set\"></a>清空整个Set</h3><p>如果我们需要将整个Set进行清空，那么我们只需要使用<code>set.clear()</code>方法即可，这个使用方法与Map一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s6 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s6); <span class=\"comment\">// Set(4) &#123; 1, 2, 3, 4 &#125;</span></span><br><span class=\"line\">s6.<span class=\"title function_\">clear</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s6); <span class=\"comment\">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取Set元素的个数\"><a href=\"#获取Set元素的个数\" class=\"headerlink\" title=\"获取Set元素的个数\"></a>获取Set元素的个数</h3><p>我们也可以使用<code>set.size</code>来获取Set元素的个数，这个<code>size</code>是Set的一个属性，而不是方法，所以我们在使用的时候可以不用加上<code>()</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s7 = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> length = s7.<span class=\"property\">size</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(length);  <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Set的迭代\"><a href=\"#Set的迭代\" class=\"headerlink\" title=\"Set的迭代\"></a>Set的迭代</h2><p>Set的迭代其实与Map相差不大，Map上面的迭代方法在Set这里也能使用。这里是我写的另一篇<a href=\"https://juejin.cn/post/7210301826939764792\">Map使用技巧</a>。</p>\n<p>在Set中我们可以使用下面三种方法进行遍历。</p>\n<ul>\n<li>set.keys()： 遍历并返回一个包含所有值的可迭代对象，</li>\n<li>set.values()：所得到的结果与<code>set.keys()</code>一样，这里主要是为了与Map兼容</li>\n<li>set.entries()：遍历并返回一个包含所有的实体 [value, value] 的可迭代对象，它的存在也是为了兼容 Map。</li>\n</ul>\n<h2 id=\"Set的一个使用场景\"><a href=\"#Set的一个使用场景\" class=\"headerlink\" title=\"Set的一个使用场景\"></a>Set的一个使用场景</h2><p>因为Set是不包含重复元素的，所以我们可以使用Set来给数组去重，但盘【】哦、2图 是如果数组里面是一些对象类型的数据，比如这样<code>[&#123;&quot;anme&quot;:1&#125;,&#123;&quot;name&quot;:1&#125;]</code>这样并不能通过Set去重，因为在Set看来，这两个是不一样的。</p>\n<p>数组去重：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    set.<span class=\"title function_\">add</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(set);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [</span></span><br><span class=\"line\"><span class=\"comment\">//   1, 2, 3, 4, 5,</span></span><br><span class=\"line\"><span class=\"comment\">//   6, 7, 8, 9</span></span><br><span class=\"line\"><span class=\"comment\">// ]</span></span><br></pre></td></tr></table></figure>\n\n<p>这样我们就通过Set成功将数组给去重了。</p>\n"},{"title":"AJAX常见一些问题的处理","date":"2022-10-22T16:00:00.000Z","_content":"# AJAX常见一些问题的处理\n\n在用户体验中，可能会存在这样的问题，当服务器半天没有返回数据的时候，用户可能会多次进行请求。这就会导致浏览器增加许多的请求，这样就会导致服务器的压力增大，而且用户体验也会变差。\n\n## 1. 取消请求\n\n当用户多次点击按钮的时候，会导致浏览器发送多次请求，这样就会导致服务器压力增大，而且用户体验也会变差。  \n为了解决这个问题，就需要将用户多与的请求给取消掉，只保留第一次请求。\n\n这样就可以极大的缓解服务器的压力，而且用户体验也会变好。\n\n### 1.1 代码实现\n\n```js\nbtn.onclick = function(){\n    // 1. 创建XMLHttpRequest对象\n    var xhr = new XMLHttpRequest();\n    // 2.取消请求\n    xhr.abort();\n}\n```\n\n上面的代码中，我们只需要在发送请求之前，调用`abort()`方法就可以了。\n\n也就是说，我们如果要取消用户的请求，只需要使用`abort()`方法,这个方法是`XMLHttpRequest`对象自带的方法。\n\n## 2. 超时处理\n\n当然实际的情况往往是很复杂的，也就会出现这样一种情况，当用户点击按钮发送请求之后，因为服务器的问题，很久都没有返回数据。但是我们不能让用户一直干等着。  \n这个时候，我们就需要给用户一个提示，告诉用户，服务器没有返回数据，你可以等待，也可以取消。\n\n这个时候我们使用`timeout`属性就可以了。\n\n### 2.1 代码实现\n\n```js\n    const xhr = new XMLHttpRequest;\n    // 设置超时时间 超过时间不响应  取消请求\n    xhr.timeout = 2000;\n    // 超时处理\n    xhr.ontimeout = function(){\n        console.log('请求超时');\n    };\n    // 网络异常回调\n    xhr.onerror = function(){\n        console.log('网络异常');\n    };\n```\n\n代码解释：\n\n上面的代码中我们通过`timeout`属性设置了超时时间，当超过这个时间的时候，就会触发`ontimeout`事件。当用户因为网络问题导致不能正常请求的时候，就会触发`onerror`事件。\n\n`timeout`属性是用来设置超时时间的，单位是毫秒。  \n`ontimeout`属性是用来设置超时处理的。在这个事件中，我们可以做一些处理，比如提示用户，服务器没有返回数据。  \n`onerror`属性是用来设置网络异常处理的。在这个事件中，我们可以做一些处理，比如提示用户，网络异常。\n\n## 结尾\n\n本文主要讲解了`XMLHttpRequest`对象的取消请求和超时处理。\n\n好了今天的分享就到这里了。如果你觉得本文对你有帮助，欢迎点赞和分享。","source":"_posts/JavaScript/AJAX常见一些问题的处理.md","raw":"---\ntitle: AJAX常见一些问题的处理\ndate: 2022-10-23\ntags: [前端]\ncategories: [AJAX]\n---\n# AJAX常见一些问题的处理\n\n在用户体验中，可能会存在这样的问题，当服务器半天没有返回数据的时候，用户可能会多次进行请求。这就会导致浏览器增加许多的请求，这样就会导致服务器的压力增大，而且用户体验也会变差。\n\n## 1. 取消请求\n\n当用户多次点击按钮的时候，会导致浏览器发送多次请求，这样就会导致服务器压力增大，而且用户体验也会变差。  \n为了解决这个问题，就需要将用户多与的请求给取消掉，只保留第一次请求。\n\n这样就可以极大的缓解服务器的压力，而且用户体验也会变好。\n\n### 1.1 代码实现\n\n```js\nbtn.onclick = function(){\n    // 1. 创建XMLHttpRequest对象\n    var xhr = new XMLHttpRequest();\n    // 2.取消请求\n    xhr.abort();\n}\n```\n\n上面的代码中，我们只需要在发送请求之前，调用`abort()`方法就可以了。\n\n也就是说，我们如果要取消用户的请求，只需要使用`abort()`方法,这个方法是`XMLHttpRequest`对象自带的方法。\n\n## 2. 超时处理\n\n当然实际的情况往往是很复杂的，也就会出现这样一种情况，当用户点击按钮发送请求之后，因为服务器的问题，很久都没有返回数据。但是我们不能让用户一直干等着。  \n这个时候，我们就需要给用户一个提示，告诉用户，服务器没有返回数据，你可以等待，也可以取消。\n\n这个时候我们使用`timeout`属性就可以了。\n\n### 2.1 代码实现\n\n```js\n    const xhr = new XMLHttpRequest;\n    // 设置超时时间 超过时间不响应  取消请求\n    xhr.timeout = 2000;\n    // 超时处理\n    xhr.ontimeout = function(){\n        console.log('请求超时');\n    };\n    // 网络异常回调\n    xhr.onerror = function(){\n        console.log('网络异常');\n    };\n```\n\n代码解释：\n\n上面的代码中我们通过`timeout`属性设置了超时时间，当超过这个时间的时候，就会触发`ontimeout`事件。当用户因为网络问题导致不能正常请求的时候，就会触发`onerror`事件。\n\n`timeout`属性是用来设置超时时间的，单位是毫秒。  \n`ontimeout`属性是用来设置超时处理的。在这个事件中，我们可以做一些处理，比如提示用户，服务器没有返回数据。  \n`onerror`属性是用来设置网络异常处理的。在这个事件中，我们可以做一些处理，比如提示用户，网络异常。\n\n## 结尾\n\n本文主要讲解了`XMLHttpRequest`对象的取消请求和超时处理。\n\n好了今天的分享就到这里了。如果你觉得本文对你有帮助，欢迎点赞和分享。","slug":"JavaScript/AJAX常见一些问题的处理","published":1,"updated":"2023-01-09T11:51:20.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmht002n9kbmdgrmac25","content":"<h1 id=\"AJAX常见一些问题的处理\"><a href=\"#AJAX常见一些问题的处理\" class=\"headerlink\" title=\"AJAX常见一些问题的处理\"></a>AJAX常见一些问题的处理</h1><p>在用户体验中，可能会存在这样的问题，当服务器半天没有返回数据的时候，用户可能会多次进行请求。这就会导致浏览器增加许多的请求，这样就会导致服务器的压力增大，而且用户体验也会变差。</p>\n<h2 id=\"1-取消请求\"><a href=\"#1-取消请求\" class=\"headerlink\" title=\"1. 取消请求\"></a>1. 取消请求</h2><p>当用户多次点击按钮的时候，会导致浏览器发送多次请求，这样就会导致服务器压力增大，而且用户体验也会变差。<br>为了解决这个问题，就需要将用户多与的请求给取消掉，只保留第一次请求。</p>\n<p>这样就可以极大的缓解服务器的压力，而且用户体验也会变好。</p>\n<h3 id=\"1-1-代码实现\"><a href=\"#1-1-代码实现\" class=\"headerlink\" title=\"1.1 代码实现\"></a>1.1 代码实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建XMLHttpRequest对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 2.取消请求</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">abort</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中，我们只需要在发送请求之前，调用<code>abort()</code>方法就可以了。</p>\n<p>也就是说，我们如果要取消用户的请求，只需要使用<code>abort()</code>方法,这个方法是<code>XMLHttpRequest</code>对象自带的方法。</p>\n<h2 id=\"2-超时处理\"><a href=\"#2-超时处理\" class=\"headerlink\" title=\"2. 超时处理\"></a>2. 超时处理</h2><p>当然实际的情况往往是很复杂的，也就会出现这样一种情况，当用户点击按钮发送请求之后，因为服务器的问题，很久都没有返回数据。但是我们不能让用户一直干等着。<br>这个时候，我们就需要给用户一个提示，告诉用户，服务器没有返回数据，你可以等待，也可以取消。</p>\n<p>这个时候我们使用<code>timeout</code>属性就可以了。</p>\n<h3 id=\"2-1-代码实现\"><a href=\"#2-1-代码实现\" class=\"headerlink\" title=\"2.1 代码实现\"></a>2.1 代码实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置超时时间 超过时间不响应  取消请求</span></span><br><span class=\"line\">xhr.<span class=\"property\">timeout</span> = <span class=\"number\">2000</span>;</span><br><span class=\"line\"><span class=\"comment\">// 超时处理</span></span><br><span class=\"line\">xhr.<span class=\"property\">ontimeout</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;请求超时&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 网络异常回调</span></span><br><span class=\"line\">xhr.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;网络异常&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：</p>\n<p>上面的代码中我们通过<code>timeout</code>属性设置了超时时间，当超过这个时间的时候，就会触发<code>ontimeout</code>事件。当用户因为网络问题导致不能正常请求的时候，就会触发<code>onerror</code>事件。</p>\n<p><code>timeout</code>属性是用来设置超时时间的，单位是毫秒。<br><code>ontimeout</code>属性是用来设置超时处理的。在这个事件中，我们可以做一些处理，比如提示用户，服务器没有返回数据。<br><code>onerror</code>属性是用来设置网络异常处理的。在这个事件中，我们可以做一些处理，比如提示用户，网络异常。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>本文主要讲解了<code>XMLHttpRequest</code>对象的取消请求和超时处理。</p>\n<p>好了今天的分享就到这里了。如果你觉得本文对你有帮助，欢迎点赞和分享。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AJAX常见一些问题的处理\"><a href=\"#AJAX常见一些问题的处理\" class=\"headerlink\" title=\"AJAX常见一些问题的处理\"></a>AJAX常见一些问题的处理</h1><p>在用户体验中，可能会存在这样的问题，当服务器半天没有返回数据的时候，用户可能会多次进行请求。这就会导致浏览器增加许多的请求，这样就会导致服务器的压力增大，而且用户体验也会变差。</p>\n<h2 id=\"1-取消请求\"><a href=\"#1-取消请求\" class=\"headerlink\" title=\"1. 取消请求\"></a>1. 取消请求</h2><p>当用户多次点击按钮的时候，会导致浏览器发送多次请求，这样就会导致服务器压力增大，而且用户体验也会变差。<br>为了解决这个问题，就需要将用户多与的请求给取消掉，只保留第一次请求。</p>\n<p>这样就可以极大的缓解服务器的压力，而且用户体验也会变好。</p>\n<h3 id=\"1-1-代码实现\"><a href=\"#1-1-代码实现\" class=\"headerlink\" title=\"1.1 代码实现\"></a>1.1 代码实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建XMLHttpRequest对象</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 2.取消请求</span></span><br><span class=\"line\">    xhr.<span class=\"title function_\">abort</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中，我们只需要在发送请求之前，调用<code>abort()</code>方法就可以了。</p>\n<p>也就是说，我们如果要取消用户的请求，只需要使用<code>abort()</code>方法,这个方法是<code>XMLHttpRequest</code>对象自带的方法。</p>\n<h2 id=\"2-超时处理\"><a href=\"#2-超时处理\" class=\"headerlink\" title=\"2. 超时处理\"></a>2. 超时处理</h2><p>当然实际的情况往往是很复杂的，也就会出现这样一种情况，当用户点击按钮发送请求之后，因为服务器的问题，很久都没有返回数据。但是我们不能让用户一直干等着。<br>这个时候，我们就需要给用户一个提示，告诉用户，服务器没有返回数据，你可以等待，也可以取消。</p>\n<p>这个时候我们使用<code>timeout</code>属性就可以了。</p>\n<h3 id=\"2-1-代码实现\"><a href=\"#2-1-代码实现\" class=\"headerlink\" title=\"2.1 代码实现\"></a>2.1 代码实现</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置超时时间 超过时间不响应  取消请求</span></span><br><span class=\"line\">xhr.<span class=\"property\">timeout</span> = <span class=\"number\">2000</span>;</span><br><span class=\"line\"><span class=\"comment\">// 超时处理</span></span><br><span class=\"line\">xhr.<span class=\"property\">ontimeout</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;请求超时&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 网络异常回调</span></span><br><span class=\"line\">xhr.<span class=\"property\">onerror</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;网络异常&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>代码解释：</p>\n<p>上面的代码中我们通过<code>timeout</code>属性设置了超时时间，当超过这个时间的时候，就会触发<code>ontimeout</code>事件。当用户因为网络问题导致不能正常请求的时候，就会触发<code>onerror</code>事件。</p>\n<p><code>timeout</code>属性是用来设置超时时间的，单位是毫秒。<br><code>ontimeout</code>属性是用来设置超时处理的。在这个事件中，我们可以做一些处理，比如提示用户，服务器没有返回数据。<br><code>onerror</code>属性是用来设置网络异常处理的。在这个事件中，我们可以做一些处理，比如提示用户，网络异常。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>本文主要讲解了<code>XMLHttpRequest</code>对象的取消请求和超时处理。</p>\n<p>好了今天的分享就到这里了。如果你觉得本文对你有帮助，欢迎点赞和分享。</p>\n"},{"title":"JS中的内置对象之Data","date":"2022-09-27T16:00:00.000Z","_content":"# 内置对象Date\n\nDate对象在实际开发中，也使用得非常频繁，它是一个内置对象，用于表示日期和时间。\n\nDate是用来处理日期和时间的对象，但是与Math对象不同的是：Date是一个构造函数，需要实例化之后才能使用。\n\n接下来第一步：创建Date对象\n\n## 创建Date对象\n\n创建Date对象有两种方法：\n\n- 创建时不传参数：  \n  在不传递参数的情况下，最后创建的结果是返回系统当前的时间对象\n\n    var date = new Date();\n    console.log(date); // Wed Sep 28 2022 18:06:49 GMT+0800 (中国标准时间)\n    console.log(typeof date); // object\n\n- 创建时传递参数：  \n  传递参数时表示创建指定时间的对象，参数可以是字符串，也可以是数字，还可以是时间戳。我们按照传递参数的类型来分别讲解。\n\n1. 参数为字符串\n\n    var date = new Date(\"2022-09-28 18:06:49\");\n    var date = new Date(\"2022/09/28 18:06:49\");\n    var date = new Date(\"2022-09-28T18:06:49\");\n    var date = new Date(\"2022/09/28T18:06:49\");\n    var date = new Date(\"2022-09-28\");\n    var date = new Date(\"2022/09/28\");\n    var date = new Date(\"2022-09-28T00:00:00\");\n    var date = new Date(\"2022/09/28T00:00:00\");\n\n通过上面的代码，我们可以看到在将时间字符串作为参数传入的时候，我们要遵循的格式就是：年月日  具体时间，其中年月日之间使用`-`或者`/`连接，具体时间使用`:`连接；年月日和具体时间的连接可以使用`空格`隔开或者`T`隔开。\n\n2. 参数为多个数字\n\n    var date = new Date(x,y,z,a,b,c,d);\n\n- x：表示年份，必须传递，否则会报错\n- y: 表示月份，从0开始，0表示1月，1表示2月，以此类推，如果不传递，默认为0\n- z: 表示日期，如果不传递，默认为1\n- a: 表示小时，如果不传递，默认为0\n- b: 表示分钟，如果不传递，默认为0\n- c: 表示秒，如果不传递，默认为0\n- d: 表示毫秒，如果不传递，默认为0\n\n多个参数之间我们使用逗号间隔，如果不传递的参数，会使用默认值（年份除外，年份必须传参）。\n\n3. 参数为时间戳\n\n    var date = new Date(时间戳);\n\n## 日期的格式化\n\n在实际开发中，我们经常需要将日期格式化，比如：将日期格式化为：2022-09-28 18:06:49，这个时候我们就需要使用到Date对象的format方法。\n\n或者我们需要获取日期的指定部分，这个时候就需要用到Date对象自带的方法了。\n\n### Date对象自带的方法\n\n|      方法名       |      含义      |         备注         |\n| :---------------: | :------------: | :------------------: |\n|   getFullYear()   |    获取年份    |                      |\n|    getMonth()     |  获取月:0-11   |      0代表一月       |\n|     getDate()     |  获取日：1-31  |                      |\n|     getDay()      | 获取星期：0-6  | 0代表周日；1代表周一 |\n|    getHours()     | 获取小时：0-23 |                      |\n|   getMinutes()    | 获取分钟：0-59 |                      |\n|   getSeconds()    |  获取秒：0-59  |                      |\n| getMilliseconds() |    获取毫秒    |     1s = 1000ms      |\n\n## 获取时间戳\n\n什么是时间戳呢？\n\n时间戳就是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 = 1000毫秒）。\n\n那为什么需要时间戳呢？\n\n这是因为在计算机中，时间是以数字的形式存储的，而不是以字符串的形式存储的，所以我们需要将时间转换为数字，这个数字就是时间戳。  \n而时间戳的存在就是为了统一时间的单位。\n\n如何获取时间戳呢？\n\n下面集中常见的方法：\n\n- +new Date()：获取当前时间的时间戳\n\n    value = +new Date();\n\n- Date对象的getTime方法\n\n    var date = new Date();\n\n- Date对象的valueOf方法\n\n    var date = new Date();\n\n这三种方法都可以获取当前时间的时间戳。使用频率从上往下一次递减。","source":"_posts/JavaScript/# 内置对象Date.md","raw":"---\ntitle: JS中的内置对象之Data\ndate: 2022-9-28\ntags: 前端\ncategories: JavaScript\n---\n# 内置对象Date\n\nDate对象在实际开发中，也使用得非常频繁，它是一个内置对象，用于表示日期和时间。\n\nDate是用来处理日期和时间的对象，但是与Math对象不同的是：Date是一个构造函数，需要实例化之后才能使用。\n\n接下来第一步：创建Date对象\n\n## 创建Date对象\n\n创建Date对象有两种方法：\n\n- 创建时不传参数：  \n  在不传递参数的情况下，最后创建的结果是返回系统当前的时间对象\n\n    var date = new Date();\n    console.log(date); // Wed Sep 28 2022 18:06:49 GMT+0800 (中国标准时间)\n    console.log(typeof date); // object\n\n- 创建时传递参数：  \n  传递参数时表示创建指定时间的对象，参数可以是字符串，也可以是数字，还可以是时间戳。我们按照传递参数的类型来分别讲解。\n\n1. 参数为字符串\n\n    var date = new Date(\"2022-09-28 18:06:49\");\n    var date = new Date(\"2022/09/28 18:06:49\");\n    var date = new Date(\"2022-09-28T18:06:49\");\n    var date = new Date(\"2022/09/28T18:06:49\");\n    var date = new Date(\"2022-09-28\");\n    var date = new Date(\"2022/09/28\");\n    var date = new Date(\"2022-09-28T00:00:00\");\n    var date = new Date(\"2022/09/28T00:00:00\");\n\n通过上面的代码，我们可以看到在将时间字符串作为参数传入的时候，我们要遵循的格式就是：年月日  具体时间，其中年月日之间使用`-`或者`/`连接，具体时间使用`:`连接；年月日和具体时间的连接可以使用`空格`隔开或者`T`隔开。\n\n2. 参数为多个数字\n\n    var date = new Date(x,y,z,a,b,c,d);\n\n- x：表示年份，必须传递，否则会报错\n- y: 表示月份，从0开始，0表示1月，1表示2月，以此类推，如果不传递，默认为0\n- z: 表示日期，如果不传递，默认为1\n- a: 表示小时，如果不传递，默认为0\n- b: 表示分钟，如果不传递，默认为0\n- c: 表示秒，如果不传递，默认为0\n- d: 表示毫秒，如果不传递，默认为0\n\n多个参数之间我们使用逗号间隔，如果不传递的参数，会使用默认值（年份除外，年份必须传参）。\n\n3. 参数为时间戳\n\n    var date = new Date(时间戳);\n\n## 日期的格式化\n\n在实际开发中，我们经常需要将日期格式化，比如：将日期格式化为：2022-09-28 18:06:49，这个时候我们就需要使用到Date对象的format方法。\n\n或者我们需要获取日期的指定部分，这个时候就需要用到Date对象自带的方法了。\n\n### Date对象自带的方法\n\n|      方法名       |      含义      |         备注         |\n| :---------------: | :------------: | :------------------: |\n|   getFullYear()   |    获取年份    |                      |\n|    getMonth()     |  获取月:0-11   |      0代表一月       |\n|     getDate()     |  获取日：1-31  |                      |\n|     getDay()      | 获取星期：0-6  | 0代表周日；1代表周一 |\n|    getHours()     | 获取小时：0-23 |                      |\n|   getMinutes()    | 获取分钟：0-59 |                      |\n|   getSeconds()    |  获取秒：0-59  |                      |\n| getMilliseconds() |    获取毫秒    |     1s = 1000ms      |\n\n## 获取时间戳\n\n什么是时间戳呢？\n\n时间戳就是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 = 1000毫秒）。\n\n那为什么需要时间戳呢？\n\n这是因为在计算机中，时间是以数字的形式存储的，而不是以字符串的形式存储的，所以我们需要将时间转换为数字，这个数字就是时间戳。  \n而时间戳的存在就是为了统一时间的单位。\n\n如何获取时间戳呢？\n\n下面集中常见的方法：\n\n- +new Date()：获取当前时间的时间戳\n\n    value = +new Date();\n\n- Date对象的getTime方法\n\n    var date = new Date();\n\n- Date对象的valueOf方法\n\n    var date = new Date();\n\n这三种方法都可以获取当前时间的时间戳。使用频率从上往下一次递减。","slug":"JavaScript/# 内置对象Date","published":1,"updated":"2023-01-08T11:10:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhu002q9kbmd75i3o1f","content":"<h1 id=\"内置对象Date\"><a href=\"#内置对象Date\" class=\"headerlink\" title=\"内置对象Date\"></a>内置对象Date</h1><p>Date对象在实际开发中，也使用得非常频繁，它是一个内置对象，用于表示日期和时间。</p>\n<p>Date是用来处理日期和时间的对象，但是与Math对象不同的是：Date是一个构造函数，需要实例化之后才能使用。</p>\n<p>接下来第一步：创建Date对象</p>\n<h2 id=\"创建Date对象\"><a href=\"#创建Date对象\" class=\"headerlink\" title=\"创建Date对象\"></a>创建Date对象</h2><p>创建Date对象有两种方法：</p>\n<ul>\n<li><p>创建时不传参数：<br>在不传递参数的情况下，最后创建的结果是返回系统当前的时间对象</p>\n<p>  var date &#x3D; new Date();<br>  console.log(date); &#x2F;&#x2F; Wed Sep 28 2022 18:06:49 GMT+0800 (中国标准时间)<br>  console.log(typeof date); &#x2F;&#x2F; object</p>\n</li>\n<li><p>创建时传递参数：<br>传递参数时表示创建指定时间的对象，参数可以是字符串，也可以是数字，还可以是时间戳。我们按照传递参数的类型来分别讲解。</p>\n</li>\n</ul>\n<ol>\n<li><p>参数为字符串</p>\n<p> var date &#x3D; new Date(“2022-09-28 18:06:49”);<br> var date &#x3D; new Date(“2022&#x2F;09&#x2F;28 18:06:49”);<br> var date &#x3D; new Date(“2022-09-28T18:06:49”);<br> var date &#x3D; new Date(“2022&#x2F;09&#x2F;28T18:06:49”);<br> var date &#x3D; new Date(“2022-09-28”);<br> var date &#x3D; new Date(“2022&#x2F;09&#x2F;28”);<br> var date &#x3D; new Date(“2022-09-28T00:00:00”);<br> var date &#x3D; new Date(“2022&#x2F;09&#x2F;28T00:00:00”);</p>\n</li>\n</ol>\n<p>通过上面的代码，我们可以看到在将时间字符串作为参数传入的时候，我们要遵循的格式就是：年月日  具体时间，其中年月日之间使用<code>-</code>或者<code>/</code>连接，具体时间使用<code>:</code>连接；年月日和具体时间的连接可以使用<code>空格</code>隔开或者<code>T</code>隔开。</p>\n<ol start=\"2\">\n<li><p>参数为多个数字</p>\n<p> var date &#x3D; new Date(x,y,z,a,b,c,d);</p>\n</li>\n</ol>\n<ul>\n<li>x：表示年份，必须传递，否则会报错</li>\n<li>y: 表示月份，从0开始，0表示1月，1表示2月，以此类推，如果不传递，默认为0</li>\n<li>z: 表示日期，如果不传递，默认为1</li>\n<li>a: 表示小时，如果不传递，默认为0</li>\n<li>b: 表示分钟，如果不传递，默认为0</li>\n<li>c: 表示秒，如果不传递，默认为0</li>\n<li>d: 表示毫秒，如果不传递，默认为0</li>\n</ul>\n<p>多个参数之间我们使用逗号间隔，如果不传递的参数，会使用默认值（年份除外，年份必须传参）。</p>\n<ol start=\"3\">\n<li><p>参数为时间戳</p>\n<p> var date &#x3D; new Date(时间戳);</p>\n</li>\n</ol>\n<h2 id=\"日期的格式化\"><a href=\"#日期的格式化\" class=\"headerlink\" title=\"日期的格式化\"></a>日期的格式化</h2><p>在实际开发中，我们经常需要将日期格式化，比如：将日期格式化为：2022-09-28 18:06:49，这个时候我们就需要使用到Date对象的format方法。</p>\n<p>或者我们需要获取日期的指定部分，这个时候就需要用到Date对象自带的方法了。</p>\n<h3 id=\"Date对象自带的方法\"><a href=\"#Date对象自带的方法\" class=\"headerlink\" title=\"Date对象自带的方法\"></a>Date对象自带的方法</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">getFullYear()</td>\n<td align=\"center\">获取年份</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getMonth()</td>\n<td align=\"center\">获取月:0-11</td>\n<td align=\"center\">0代表一月</td>\n</tr>\n<tr>\n<td align=\"center\">getDate()</td>\n<td align=\"center\">获取日：1-31</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getDay()</td>\n<td align=\"center\">获取星期：0-6</td>\n<td align=\"center\">0代表周日；1代表周一</td>\n</tr>\n<tr>\n<td align=\"center\">getHours()</td>\n<td align=\"center\">获取小时：0-23</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getMinutes()</td>\n<td align=\"center\">获取分钟：0-59</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getSeconds()</td>\n<td align=\"center\">获取秒：0-59</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getMilliseconds()</td>\n<td align=\"center\">获取毫秒</td>\n<td align=\"center\">1s &#x3D; 1000ms</td>\n</tr>\n</tbody></table>\n<h2 id=\"获取时间戳\"><a href=\"#获取时间戳\" class=\"headerlink\" title=\"获取时间戳\"></a>获取时间戳</h2><p>什么是时间戳呢？</p>\n<p>时间戳就是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 &#x3D; 1000毫秒）。</p>\n<p>那为什么需要时间戳呢？</p>\n<p>这是因为在计算机中，时间是以数字的形式存储的，而不是以字符串的形式存储的，所以我们需要将时间转换为数字，这个数字就是时间戳。<br>而时间戳的存在就是为了统一时间的单位。</p>\n<p>如何获取时间戳呢？</p>\n<p>下面集中常见的方法：</p>\n<ul>\n<li><p>+new Date()：获取当前时间的时间戳</p>\n<p>  value &#x3D; +new Date();</p>\n</li>\n<li><p>Date对象的getTime方法</p>\n<p>  var date &#x3D; new Date();</p>\n</li>\n<li><p>Date对象的valueOf方法</p>\n<p>  var date &#x3D; new Date();</p>\n</li>\n</ul>\n<p>这三种方法都可以获取当前时间的时间戳。使用频率从上往下一次递减。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内置对象Date\"><a href=\"#内置对象Date\" class=\"headerlink\" title=\"内置对象Date\"></a>内置对象Date</h1><p>Date对象在实际开发中，也使用得非常频繁，它是一个内置对象，用于表示日期和时间。</p>\n<p>Date是用来处理日期和时间的对象，但是与Math对象不同的是：Date是一个构造函数，需要实例化之后才能使用。</p>\n<p>接下来第一步：创建Date对象</p>\n<h2 id=\"创建Date对象\"><a href=\"#创建Date对象\" class=\"headerlink\" title=\"创建Date对象\"></a>创建Date对象</h2><p>创建Date对象有两种方法：</p>\n<ul>\n<li><p>创建时不传参数：<br>在不传递参数的情况下，最后创建的结果是返回系统当前的时间对象</p>\n<p>  var date &#x3D; new Date();<br>  console.log(date); &#x2F;&#x2F; Wed Sep 28 2022 18:06:49 GMT+0800 (中国标准时间)<br>  console.log(typeof date); &#x2F;&#x2F; object</p>\n</li>\n<li><p>创建时传递参数：<br>传递参数时表示创建指定时间的对象，参数可以是字符串，也可以是数字，还可以是时间戳。我们按照传递参数的类型来分别讲解。</p>\n</li>\n</ul>\n<ol>\n<li><p>参数为字符串</p>\n<p> var date &#x3D; new Date(“2022-09-28 18:06:49”);<br> var date &#x3D; new Date(“2022&#x2F;09&#x2F;28 18:06:49”);<br> var date &#x3D; new Date(“2022-09-28T18:06:49”);<br> var date &#x3D; new Date(“2022&#x2F;09&#x2F;28T18:06:49”);<br> var date &#x3D; new Date(“2022-09-28”);<br> var date &#x3D; new Date(“2022&#x2F;09&#x2F;28”);<br> var date &#x3D; new Date(“2022-09-28T00:00:00”);<br> var date &#x3D; new Date(“2022&#x2F;09&#x2F;28T00:00:00”);</p>\n</li>\n</ol>\n<p>通过上面的代码，我们可以看到在将时间字符串作为参数传入的时候，我们要遵循的格式就是：年月日  具体时间，其中年月日之间使用<code>-</code>或者<code>/</code>连接，具体时间使用<code>:</code>连接；年月日和具体时间的连接可以使用<code>空格</code>隔开或者<code>T</code>隔开。</p>\n<ol start=\"2\">\n<li><p>参数为多个数字</p>\n<p> var date &#x3D; new Date(x,y,z,a,b,c,d);</p>\n</li>\n</ol>\n<ul>\n<li>x：表示年份，必须传递，否则会报错</li>\n<li>y: 表示月份，从0开始，0表示1月，1表示2月，以此类推，如果不传递，默认为0</li>\n<li>z: 表示日期，如果不传递，默认为1</li>\n<li>a: 表示小时，如果不传递，默认为0</li>\n<li>b: 表示分钟，如果不传递，默认为0</li>\n<li>c: 表示秒，如果不传递，默认为0</li>\n<li>d: 表示毫秒，如果不传递，默认为0</li>\n</ul>\n<p>多个参数之间我们使用逗号间隔，如果不传递的参数，会使用默认值（年份除外，年份必须传参）。</p>\n<ol start=\"3\">\n<li><p>参数为时间戳</p>\n<p> var date &#x3D; new Date(时间戳);</p>\n</li>\n</ol>\n<h2 id=\"日期的格式化\"><a href=\"#日期的格式化\" class=\"headerlink\" title=\"日期的格式化\"></a>日期的格式化</h2><p>在实际开发中，我们经常需要将日期格式化，比如：将日期格式化为：2022-09-28 18:06:49，这个时候我们就需要使用到Date对象的format方法。</p>\n<p>或者我们需要获取日期的指定部分，这个时候就需要用到Date对象自带的方法了。</p>\n<h3 id=\"Date对象自带的方法\"><a href=\"#Date对象自带的方法\" class=\"headerlink\" title=\"Date对象自带的方法\"></a>Date对象自带的方法</h3><table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">含义</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">getFullYear()</td>\n<td align=\"center\">获取年份</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getMonth()</td>\n<td align=\"center\">获取月:0-11</td>\n<td align=\"center\">0代表一月</td>\n</tr>\n<tr>\n<td align=\"center\">getDate()</td>\n<td align=\"center\">获取日：1-31</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getDay()</td>\n<td align=\"center\">获取星期：0-6</td>\n<td align=\"center\">0代表周日；1代表周一</td>\n</tr>\n<tr>\n<td align=\"center\">getHours()</td>\n<td align=\"center\">获取小时：0-23</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getMinutes()</td>\n<td align=\"center\">获取分钟：0-59</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getSeconds()</td>\n<td align=\"center\">获取秒：0-59</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">getMilliseconds()</td>\n<td align=\"center\">获取毫秒</td>\n<td align=\"center\">1s &#x3D; 1000ms</td>\n</tr>\n</tbody></table>\n<h2 id=\"获取时间戳\"><a href=\"#获取时间戳\" class=\"headerlink\" title=\"获取时间戳\"></a>获取时间戳</h2><p>什么是时间戳呢？</p>\n<p>时间戳就是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 &#x3D; 1000毫秒）。</p>\n<p>那为什么需要时间戳呢？</p>\n<p>这是因为在计算机中，时间是以数字的形式存储的，而不是以字符串的形式存储的，所以我们需要将时间转换为数字，这个数字就是时间戳。<br>而时间戳的存在就是为了统一时间的单位。</p>\n<p>如何获取时间戳呢？</p>\n<p>下面集中常见的方法：</p>\n<ul>\n<li><p>+new Date()：获取当前时间的时间戳</p>\n<p>  value &#x3D; +new Date();</p>\n</li>\n<li><p>Date对象的getTime方法</p>\n<p>  var date &#x3D; new Date();</p>\n</li>\n<li><p>Date对象的valueOf方法</p>\n<p>  var date &#x3D; new Date();</p>\n</li>\n</ul>\n<p>这三种方法都可以获取当前时间的时间戳。使用频率从上往下一次递减。</p>\n"},{"title":"DOM事件流","date":"2022-09-18T16:00:00.000Z","_content":"\n# DOM事件流\n\n什么是事件流呢?\n\n在这里我们解释一下，事件流描述的是从页面中接收事件的顺序。\n\n事件的发生在元素节点之间会按照一定的顺序传播，这个传播的顺序就是DOM事件流。（事件传播的过程称之为事件流）\n\n## DOM事件流的阶段\n\n1. 事件捕获阶段\n2. 当前目标阶段\n3. 冒泡阶段\n\n*事件捕获阶段：*\n\n当我们给一个元素节点绑定事件之后，我们触发这个事件，他并不会立刻从这个元素节点开始执行事件，而是要从最外层的父元素开始，一层一层的向下传播，直到触发的元素节点，这个过程就是事件捕获阶段。\n\n比如我们在`body`里面放了一个`div`,并且给这个`div`绑定了一个点击事件，党我们点击这个`div`的时候，并不会立刻执行这个点击事件，而是从最外层（document）到最里层（div）的顺序执行，这个过程就是事件捕获阶段。【document --> element html --> element body --> element div】\n\n这就是事件捕获阶段的流程。\n\n## 当前目标阶段\n\n这就是事件的执行阶段，前面我们通过事件捕获，找到事件的位置，现在我们就开始执行这个事件。\n\n该阶段执行完成之后，继续执行下一阶段。\n\n## 冒泡阶段\n\n前面事件捕获阶段是从外往里，而冒泡阶段就是从里往外进行传播。\n\n## 小知识：\n\n最开始，ie提出了事件冒泡，事件最开始有具体的元素接受，然后逐级向上传播到最外层，而后来网景公司提出了事件捕获，事件最开始由最外层的元素接受，然后逐级向下传播到最具体的元素。JavaScript为了兼容，干脆把两个都实现了，事件流就是两个流程的合并。","source":"_posts/JavaScript/#DOM事件流.md","raw":"---\ntitle: DOM事件流\ndate: 2022-9-19\ntags: 前端\ncategories: JavaScript\n---\n\n# DOM事件流\n\n什么是事件流呢?\n\n在这里我们解释一下，事件流描述的是从页面中接收事件的顺序。\n\n事件的发生在元素节点之间会按照一定的顺序传播，这个传播的顺序就是DOM事件流。（事件传播的过程称之为事件流）\n\n## DOM事件流的阶段\n\n1. 事件捕获阶段\n2. 当前目标阶段\n3. 冒泡阶段\n\n*事件捕获阶段：*\n\n当我们给一个元素节点绑定事件之后，我们触发这个事件，他并不会立刻从这个元素节点开始执行事件，而是要从最外层的父元素开始，一层一层的向下传播，直到触发的元素节点，这个过程就是事件捕获阶段。\n\n比如我们在`body`里面放了一个`div`,并且给这个`div`绑定了一个点击事件，党我们点击这个`div`的时候，并不会立刻执行这个点击事件，而是从最外层（document）到最里层（div）的顺序执行，这个过程就是事件捕获阶段。【document --> element html --> element body --> element div】\n\n这就是事件捕获阶段的流程。\n\n## 当前目标阶段\n\n这就是事件的执行阶段，前面我们通过事件捕获，找到事件的位置，现在我们就开始执行这个事件。\n\n该阶段执行完成之后，继续执行下一阶段。\n\n## 冒泡阶段\n\n前面事件捕获阶段是从外往里，而冒泡阶段就是从里往外进行传播。\n\n## 小知识：\n\n最开始，ie提出了事件冒泡，事件最开始有具体的元素接受，然后逐级向上传播到最外层，而后来网景公司提出了事件捕获，事件最开始由最外层的元素接受，然后逐级向下传播到最具体的元素。JavaScript为了兼容，干脆把两个都实现了，事件流就是两个流程的合并。","slug":"JavaScript/#DOM事件流","published":1,"updated":"2023-01-08T11:10:51.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhv002u9kbmgj0kcbnx","content":"<h1 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h1><p>什么是事件流呢?</p>\n<p>在这里我们解释一下，事件流描述的是从页面中接收事件的顺序。</p>\n<p>事件的发生在元素节点之间会按照一定的顺序传播，这个传播的顺序就是DOM事件流。（事件传播的过程称之为事件流）</p>\n<h2 id=\"DOM事件流的阶段\"><a href=\"#DOM事件流的阶段\" class=\"headerlink\" title=\"DOM事件流的阶段\"></a>DOM事件流的阶段</h2><ol>\n<li>事件捕获阶段</li>\n<li>当前目标阶段</li>\n<li>冒泡阶段</li>\n</ol>\n<p><em>事件捕获阶段：</em></p>\n<p>当我们给一个元素节点绑定事件之后，我们触发这个事件，他并不会立刻从这个元素节点开始执行事件，而是要从最外层的父元素开始，一层一层的向下传播，直到触发的元素节点，这个过程就是事件捕获阶段。</p>\n<p>比如我们在<code>body</code>里面放了一个<code>div</code>,并且给这个<code>div</code>绑定了一个点击事件，党我们点击这个<code>div</code>的时候，并不会立刻执行这个点击事件，而是从最外层（document）到最里层（div）的顺序执行，这个过程就是事件捕获阶段。【document –&gt; element html –&gt; element body –&gt; element div】</p>\n<p>这就是事件捕获阶段的流程。</p>\n<h2 id=\"当前目标阶段\"><a href=\"#当前目标阶段\" class=\"headerlink\" title=\"当前目标阶段\"></a>当前目标阶段</h2><p>这就是事件的执行阶段，前面我们通过事件捕获，找到事件的位置，现在我们就开始执行这个事件。</p>\n<p>该阶段执行完成之后，继续执行下一阶段。</p>\n<h2 id=\"冒泡阶段\"><a href=\"#冒泡阶段\" class=\"headerlink\" title=\"冒泡阶段\"></a>冒泡阶段</h2><p>前面事件捕获阶段是从外往里，而冒泡阶段就是从里往外进行传播。</p>\n<h2 id=\"小知识：\"><a href=\"#小知识：\" class=\"headerlink\" title=\"小知识：\"></a>小知识：</h2><p>最开始，ie提出了事件冒泡，事件最开始有具体的元素接受，然后逐级向上传播到最外层，而后来网景公司提出了事件捕获，事件最开始由最外层的元素接受，然后逐级向下传播到最具体的元素。JavaScript为了兼容，干脆把两个都实现了，事件流就是两个流程的合并。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DOM事件流\"><a href=\"#DOM事件流\" class=\"headerlink\" title=\"DOM事件流\"></a>DOM事件流</h1><p>什么是事件流呢?</p>\n<p>在这里我们解释一下，事件流描述的是从页面中接收事件的顺序。</p>\n<p>事件的发生在元素节点之间会按照一定的顺序传播，这个传播的顺序就是DOM事件流。（事件传播的过程称之为事件流）</p>\n<h2 id=\"DOM事件流的阶段\"><a href=\"#DOM事件流的阶段\" class=\"headerlink\" title=\"DOM事件流的阶段\"></a>DOM事件流的阶段</h2><ol>\n<li>事件捕获阶段</li>\n<li>当前目标阶段</li>\n<li>冒泡阶段</li>\n</ol>\n<p><em>事件捕获阶段：</em></p>\n<p>当我们给一个元素节点绑定事件之后，我们触发这个事件，他并不会立刻从这个元素节点开始执行事件，而是要从最外层的父元素开始，一层一层的向下传播，直到触发的元素节点，这个过程就是事件捕获阶段。</p>\n<p>比如我们在<code>body</code>里面放了一个<code>div</code>,并且给这个<code>div</code>绑定了一个点击事件，党我们点击这个<code>div</code>的时候，并不会立刻执行这个点击事件，而是从最外层（document）到最里层（div）的顺序执行，这个过程就是事件捕获阶段。【document –&gt; element html –&gt; element body –&gt; element div】</p>\n<p>这就是事件捕获阶段的流程。</p>\n<h2 id=\"当前目标阶段\"><a href=\"#当前目标阶段\" class=\"headerlink\" title=\"当前目标阶段\"></a>当前目标阶段</h2><p>这就是事件的执行阶段，前面我们通过事件捕获，找到事件的位置，现在我们就开始执行这个事件。</p>\n<p>该阶段执行完成之后，继续执行下一阶段。</p>\n<h2 id=\"冒泡阶段\"><a href=\"#冒泡阶段\" class=\"headerlink\" title=\"冒泡阶段\"></a>冒泡阶段</h2><p>前面事件捕获阶段是从外往里，而冒泡阶段就是从里往外进行传播。</p>\n<h2 id=\"小知识：\"><a href=\"#小知识：\" class=\"headerlink\" title=\"小知识：\"></a>小知识：</h2><p>最开始，ie提出了事件冒泡，事件最开始有具体的元素接受，然后逐级向上传播到最外层，而后来网景公司提出了事件捕获，事件最开始由最外层的元素接受，然后逐级向下传播到最具体的元素。JavaScript为了兼容，干脆把两个都实现了，事件流就是两个流程的合并。</p>\n"},{"title":"AJAX的基本使用","date":"2022-10-21T16:00:00.000Z","_content":"# AJAX的基本使用\n\n## 1. 什么是AJAX\n\nAJAX是Asynchronous JavaScript and XML的缩写，意思是异步的JavaScript和XML。\n\n在实际开发当中，我们经常会更新网页中的数据，但是又不想更新一部分数据，将整个页面进行更新，这个时候就需要用到我们今天讲得ajax技术了。\n\nAJAX 是一种用于创建快速动态网页的技术。\n\n通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n## 2. AJAX的基本原理\n\nAJAX的基本原理是通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。\n\n### 使用AJAX的步骤\n\n- 创建一个XMLHttpRequest实例化对象\n- 初始化\n- 发送请求\n- 更新网页\n\n首先，第一步，我们需要创建一个XMLHttpRequest对象，这个对象是AJAX的核心，通过这个对象，我们可以向服务器发送请求，获取服务器返回的数据。\n\n```javascript\nvar xhr = new XMLHttpRequest();\n```\n\n通过上面的代码，我们成功创建了一个`XMLHttpRequest`对象，接下来我们需要初始化这个对象，初始化的时候，我们需要指定请求的类型，请求的URL，以及是否异步发送请求。\n\n第二步，初始化`XMLHttpRequest`对象\n\n```javascript\nxhr.open(\"get\", \"http://localhost:8080/ajax\", true);\n```\n\n在初始化这一步，我们使用`XMLHttpRequest`对象的`open()`方法，这个方法接收三个参数，第一个参数是请求的类型，第二个参数是请求的URL，第三个参数是是否异步发送请求。 \n第一个参数，请求的类型，一般有两种，一种是`get`，一种是`post`，`get`是从服务器上获取数据，`post`是向服务器发送数据。  \n当第三个参数为`true`的时候，表示异步发送请求，当第三个参数为`false`的时候，表示同步发送请求。\n\n第三步，发送请求\n\n```javascript\nxhr.send();\n```\n\n在发送请求的时候，我们使用`XMLHttpRequest`对象的`send()`方法，这个方法接收一个参数，这个参数就是要发送到服务器的数据。  \n如果是`get`请求，这个参数可以省略。但是如果是`post`请求，这个参数不可以省略。\n\n第四步，更新网页\n\n在这一步，我们需要判断请求是否请求成功，然后我们将服务器返回的数据拿到，然后通过javascript来操作DOM，来更新页面。\n\n```javascript\nxhr.onreadystatechange = function () {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n        var data = xhr.responseText;\n        console.log(data);\n    }\n}\n```\n\n在这一步，我们使用`XMLHttpRequest`对象的`onreadystatechange`事件，这个事件会在`XMLHttpRequest`对象的`readyState`属性发生改变的时候触发。\n\n那么什么是`readyState`呢？`readyState`属性表示`XMLHttpRequest`对象的状态，它有五种状态，分别是：\n\n- 0：请求未初始化\n- 1：服务器连接已建立\n- 2：请求已接收\n- 3：请求处理中\n- 4：请求已完成，且响应已就绪\n\n那么整个请求过程中，`readyState`属性的变化有四个阶段：\n\n- 0 -> 1\n- 1 -> 2\n- 2 -> 3\n- 3 -> 4\n\n也就是说，在完整的请求过程中，会触发四次`onreadystatechange`事件。\n\n上面代码中`xhr.readyState == 4 && xhr.status == 200`表示。只有当`readyState`属性为4的时候，表示请求已经完成，且响应已经就绪，这个时候我们才能拿到服务器返回的数据。  \n然后进行更新页面。","source":"_posts/JavaScript/AJAX的基本使用.md","raw":"---\ntitle: AJAX的基本使用\ndate: 2022-10-22\ntags: [前端]\ncategories: [AJAX]\n---\n# AJAX的基本使用\n\n## 1. 什么是AJAX\n\nAJAX是Asynchronous JavaScript and XML的缩写，意思是异步的JavaScript和XML。\n\n在实际开发当中，我们经常会更新网页中的数据，但是又不想更新一部分数据，将整个页面进行更新，这个时候就需要用到我们今天讲得ajax技术了。\n\nAJAX 是一种用于创建快速动态网页的技术。\n\n通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n## 2. AJAX的基本原理\n\nAJAX的基本原理是通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。\n\n### 使用AJAX的步骤\n\n- 创建一个XMLHttpRequest实例化对象\n- 初始化\n- 发送请求\n- 更新网页\n\n首先，第一步，我们需要创建一个XMLHttpRequest对象，这个对象是AJAX的核心，通过这个对象，我们可以向服务器发送请求，获取服务器返回的数据。\n\n```javascript\nvar xhr = new XMLHttpRequest();\n```\n\n通过上面的代码，我们成功创建了一个`XMLHttpRequest`对象，接下来我们需要初始化这个对象，初始化的时候，我们需要指定请求的类型，请求的URL，以及是否异步发送请求。\n\n第二步，初始化`XMLHttpRequest`对象\n\n```javascript\nxhr.open(\"get\", \"http://localhost:8080/ajax\", true);\n```\n\n在初始化这一步，我们使用`XMLHttpRequest`对象的`open()`方法，这个方法接收三个参数，第一个参数是请求的类型，第二个参数是请求的URL，第三个参数是是否异步发送请求。 \n第一个参数，请求的类型，一般有两种，一种是`get`，一种是`post`，`get`是从服务器上获取数据，`post`是向服务器发送数据。  \n当第三个参数为`true`的时候，表示异步发送请求，当第三个参数为`false`的时候，表示同步发送请求。\n\n第三步，发送请求\n\n```javascript\nxhr.send();\n```\n\n在发送请求的时候，我们使用`XMLHttpRequest`对象的`send()`方法，这个方法接收一个参数，这个参数就是要发送到服务器的数据。  \n如果是`get`请求，这个参数可以省略。但是如果是`post`请求，这个参数不可以省略。\n\n第四步，更新网页\n\n在这一步，我们需要判断请求是否请求成功，然后我们将服务器返回的数据拿到，然后通过javascript来操作DOM，来更新页面。\n\n```javascript\nxhr.onreadystatechange = function () {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n        var data = xhr.responseText;\n        console.log(data);\n    }\n}\n```\n\n在这一步，我们使用`XMLHttpRequest`对象的`onreadystatechange`事件，这个事件会在`XMLHttpRequest`对象的`readyState`属性发生改变的时候触发。\n\n那么什么是`readyState`呢？`readyState`属性表示`XMLHttpRequest`对象的状态，它有五种状态，分别是：\n\n- 0：请求未初始化\n- 1：服务器连接已建立\n- 2：请求已接收\n- 3：请求处理中\n- 4：请求已完成，且响应已就绪\n\n那么整个请求过程中，`readyState`属性的变化有四个阶段：\n\n- 0 -> 1\n- 1 -> 2\n- 2 -> 3\n- 3 -> 4\n\n也就是说，在完整的请求过程中，会触发四次`onreadystatechange`事件。\n\n上面代码中`xhr.readyState == 4 && xhr.status == 200`表示。只有当`readyState`属性为4的时候，表示请求已经完成，且响应已经就绪，这个时候我们才能拿到服务器返回的数据。  \n然后进行更新页面。","slug":"JavaScript/AJAX的基本使用","published":1,"updated":"2023-01-09T11:52:14.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhw002x9kbmd1xy0gj6","content":"<h1 id=\"AJAX的基本使用\"><a href=\"#AJAX的基本使用\" class=\"headerlink\" title=\"AJAX的基本使用\"></a>AJAX的基本使用</h1><h2 id=\"1-什么是AJAX\"><a href=\"#1-什么是AJAX\" class=\"headerlink\" title=\"1. 什么是AJAX\"></a>1. 什么是AJAX</h2><p>AJAX是Asynchronous JavaScript and XML的缩写，意思是异步的JavaScript和XML。</p>\n<p>在实际开发当中，我们经常会更新网页中的数据，但是又不想更新一部分数据，将整个页面进行更新，这个时候就需要用到我们今天讲得ajax技术了。</p>\n<p>AJAX 是一种用于创建快速动态网页的技术。</p>\n<p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>\n<h2 id=\"2-AJAX的基本原理\"><a href=\"#2-AJAX的基本原理\" class=\"headerlink\" title=\"2. AJAX的基本原理\"></a>2. AJAX的基本原理</h2><p>AJAX的基本原理是通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。</p>\n<h3 id=\"使用AJAX的步骤\"><a href=\"#使用AJAX的步骤\" class=\"headerlink\" title=\"使用AJAX的步骤\"></a>使用AJAX的步骤</h3><ul>\n<li>创建一个XMLHttpRequest实例化对象</li>\n<li>初始化</li>\n<li>发送请求</li>\n<li>更新网页</li>\n</ul>\n<p>首先，第一步，我们需要创建一个XMLHttpRequest对象，这个对象是AJAX的核心，通过这个对象，我们可以向服务器发送请求，获取服务器返回的数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的代码，我们成功创建了一个<code>XMLHttpRequest</code>对象，接下来我们需要初始化这个对象，初始化的时候，我们需要指定请求的类型，请求的URL，以及是否异步发送请求。</p>\n<p>第二步，初始化<code>XMLHttpRequest</code>对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;get&quot;</span>, <span class=\"string\">&quot;http://localhost:8080/ajax&quot;</span>, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在初始化这一步，我们使用<code>XMLHttpRequest</code>对象的<code>open()</code>方法，这个方法接收三个参数，第一个参数是请求的类型，第二个参数是请求的URL，第三个参数是是否异步发送请求。<br>第一个参数，请求的类型，一般有两种，一种是<code>get</code>，一种是<code>post</code>，<code>get</code>是从服务器上获取数据，<code>post</code>是向服务器发送数据。<br>当第三个参数为<code>true</code>的时候，表示异步发送请求，当第三个参数为<code>false</code>的时候，表示同步发送请求。</p>\n<p>第三步，发送请求</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.<span class=\"title function_\">send</span>();</span><br></pre></td></tr></table></figure>\n\n<p>在发送请求的时候，我们使用<code>XMLHttpRequest</code>对象的<code>send()</code>方法，这个方法接收一个参数，这个参数就是要发送到服务器的数据。<br>如果是<code>get</code>请求，这个参数可以省略。但是如果是<code>post</code>请求，这个参数不可以省略。</p>\n<p>第四步，更新网页</p>\n<p>在这一步，我们需要判断请求是否请求成功，然后我们将服务器返回的数据拿到，然后通过javascript来操作DOM，来更新页面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xhr.<span class=\"property\">readyState</span> == <span class=\"number\">4</span> &amp;&amp; xhr.<span class=\"property\">status</span> == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = xhr.<span class=\"property\">responseText</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这一步，我们使用<code>XMLHttpRequest</code>对象的<code>onreadystatechange</code>事件，这个事件会在<code>XMLHttpRequest</code>对象的<code>readyState</code>属性发生改变的时候触发。</p>\n<p>那么什么是<code>readyState</code>呢？<code>readyState</code>属性表示<code>XMLHttpRequest</code>对象的状态，它有五种状态，分别是：</p>\n<ul>\n<li>0：请求未初始化</li>\n<li>1：服务器连接已建立</li>\n<li>2：请求已接收</li>\n<li>3：请求处理中</li>\n<li>4：请求已完成，且响应已就绪</li>\n</ul>\n<p>那么整个请求过程中，<code>readyState</code>属性的变化有四个阶段：</p>\n<ul>\n<li>0 -&gt; 1</li>\n<li>1 -&gt; 2</li>\n<li>2 -&gt; 3</li>\n<li>3 -&gt; 4</li>\n</ul>\n<p>也就是说，在完整的请求过程中，会触发四次<code>onreadystatechange</code>事件。</p>\n<p>上面代码中<code>xhr.readyState == 4 &amp;&amp; xhr.status == 200</code>表示。只有当<code>readyState</code>属性为4的时候，表示请求已经完成，且响应已经就绪，这个时候我们才能拿到服务器返回的数据。<br>然后进行更新页面。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AJAX的基本使用\"><a href=\"#AJAX的基本使用\" class=\"headerlink\" title=\"AJAX的基本使用\"></a>AJAX的基本使用</h1><h2 id=\"1-什么是AJAX\"><a href=\"#1-什么是AJAX\" class=\"headerlink\" title=\"1. 什么是AJAX\"></a>1. 什么是AJAX</h2><p>AJAX是Asynchronous JavaScript and XML的缩写，意思是异步的JavaScript和XML。</p>\n<p>在实际开发当中，我们经常会更新网页中的数据，但是又不想更新一部分数据，将整个页面进行更新，这个时候就需要用到我们今天讲得ajax技术了。</p>\n<p>AJAX 是一种用于创建快速动态网页的技术。</p>\n<p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>\n<h2 id=\"2-AJAX的基本原理\"><a href=\"#2-AJAX的基本原理\" class=\"headerlink\" title=\"2. AJAX的基本原理\"></a>2. AJAX的基本原理</h2><p>AJAX的基本原理是通过XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。</p>\n<h3 id=\"使用AJAX的步骤\"><a href=\"#使用AJAX的步骤\" class=\"headerlink\" title=\"使用AJAX的步骤\"></a>使用AJAX的步骤</h3><ul>\n<li>创建一个XMLHttpRequest实例化对象</li>\n<li>初始化</li>\n<li>发送请求</li>\n<li>更新网页</li>\n</ul>\n<p>首先，第一步，我们需要创建一个XMLHttpRequest对象，这个对象是AJAX的核心，通过这个对象，我们可以向服务器发送请求，获取服务器返回的数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的代码，我们成功创建了一个<code>XMLHttpRequest</code>对象，接下来我们需要初始化这个对象，初始化的时候，我们需要指定请求的类型，请求的URL，以及是否异步发送请求。</p>\n<p>第二步，初始化<code>XMLHttpRequest</code>对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;get&quot;</span>, <span class=\"string\">&quot;http://localhost:8080/ajax&quot;</span>, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在初始化这一步，我们使用<code>XMLHttpRequest</code>对象的<code>open()</code>方法，这个方法接收三个参数，第一个参数是请求的类型，第二个参数是请求的URL，第三个参数是是否异步发送请求。<br>第一个参数，请求的类型，一般有两种，一种是<code>get</code>，一种是<code>post</code>，<code>get</code>是从服务器上获取数据，<code>post</code>是向服务器发送数据。<br>当第三个参数为<code>true</code>的时候，表示异步发送请求，当第三个参数为<code>false</code>的时候，表示同步发送请求。</p>\n<p>第三步，发送请求</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.<span class=\"title function_\">send</span>();</span><br></pre></td></tr></table></figure>\n\n<p>在发送请求的时候，我们使用<code>XMLHttpRequest</code>对象的<code>send()</code>方法，这个方法接收一个参数，这个参数就是要发送到服务器的数据。<br>如果是<code>get</code>请求，这个参数可以省略。但是如果是<code>post</code>请求，这个参数不可以省略。</p>\n<p>第四步，更新网页</p>\n<p>在这一步，我们需要判断请求是否请求成功，然后我们将服务器返回的数据拿到，然后通过javascript来操作DOM，来更新页面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xhr.<span class=\"property\">readyState</span> == <span class=\"number\">4</span> &amp;&amp; xhr.<span class=\"property\">status</span> == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> data = xhr.<span class=\"property\">responseText</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这一步，我们使用<code>XMLHttpRequest</code>对象的<code>onreadystatechange</code>事件，这个事件会在<code>XMLHttpRequest</code>对象的<code>readyState</code>属性发生改变的时候触发。</p>\n<p>那么什么是<code>readyState</code>呢？<code>readyState</code>属性表示<code>XMLHttpRequest</code>对象的状态，它有五种状态，分别是：</p>\n<ul>\n<li>0：请求未初始化</li>\n<li>1：服务器连接已建立</li>\n<li>2：请求已接收</li>\n<li>3：请求处理中</li>\n<li>4：请求已完成，且响应已就绪</li>\n</ul>\n<p>那么整个请求过程中，<code>readyState</code>属性的变化有四个阶段：</p>\n<ul>\n<li>0 -&gt; 1</li>\n<li>1 -&gt; 2</li>\n<li>2 -&gt; 3</li>\n<li>3 -&gt; 4</li>\n</ul>\n<p>也就是说，在完整的请求过程中，会触发四次<code>onreadystatechange</code>事件。</p>\n<p>上面代码中<code>xhr.readyState == 4 &amp;&amp; xhr.status == 200</code>表示。只有当<code>readyState</code>属性为4的时候，表示请求已经完成，且响应已经就绪，这个时候我们才能拿到服务器返回的数据。<br>然后进行更新页面。</p>\n"},{"title":"Map数据类型","date":"2023-03-13T16:00:00.000Z","categroies":["ES6"],"_content":"[TOC]\n# Map\n\n在Map这种数据类型里面，我们可以使用各种数据类型作为Map的键名，打破了之前对象只能使用一部分数据类型作为键名的限制。\n\n## 创建Map\n\nMap不是一种原始数据类型，所以我们需要使用`new`关键字来创建，在创建Map数据类型的时候，需要将Map大写。\n\n```js\nlet m = new Map();\n```\n\n就像这样，我们创建出了Map对象。\n\n## Map的增删改查\n\n### 给Map对象赋值\n\n给Map对象赋值，我们使用`set`方法，并且这个方法返回的是Map对象本省，所以如果需要对Map对象赋多个值，我们可以链式赋值。\n\n就像这样：\n\n```js\np.set(\"2\", \"q\")\n   .set(\"3\", \"w\")\n   .set(\"4\", \"e\");\n```\n\n我们这样就给Map对象赋值了三个。\n\n### 获取Map对象指定key的value\n\n通过get方法可以获取到指定键名的值，`map.get(键名)`就可以得到对应的值，如果不存在该key,那么就返回undefined。\n\n```js\np.get(\"2\"); // \"q\"\np.get(\"-1\"); // undefined\n```\n\n### 判断Map对象是否拥有这个`key`\n\n我们使用`has(key)`方法来判断Map对象是否拥有这个`key`，如果存在那么返回`true`，如果不存在就返回`false`。\n\n例如：\n\n```js\np.has(\"2\"); // true\np.has(\"-1\");  // false\n```\n\n### 删除Map对象指定的键名及其数据\n\n我们可以使用`delete(key)`来删除我们指定的`key`的数据。\n\n```js\np.delete(\"2\"); // 删除key值为“2”的元素\np.has(\"2\"); // false\n```\n\n### 清空整个Map\n\n我们使用`clea()r`直接将这个Map清空。\n\n```js\np.clear();\nvar i = p.size; // 0\n```\n\n### 获取整个Map的长度\n\n我们使用`size`属性来获取Map的数据长度。\n\n```js\nlet count = p.size;\n```\n\n## Map迭代\n\n在Map中，我们可以直接使用for   of变量，但是这样遍历的结果是数组形式的。\n\n如果我们需要一些其他的遍历。\n\n这里有三种方法：\n\n- map.keys():返回一个包含所有键的可遍历对象\n- map.value():返回一个包含所有值（value）的可遍历对象\n- map.enties():返回一个包含所有实体（[key:value]）的可遍历对象\n\n我们举一个例子：\n\n```js\nlet mp = new Map();\nmp.set(\"1\", \"q\")\n    .set(\"2\",\"w\")\n    .set(\"3\",\"e\");\nlet x1 = mp.keys();\nlet x2 = mp.values();\nlet x3 = mp.entries();\nfor (const i of x1) {\n    console.log(i);\n}\nconsole.log(\"--------------\");\nfor (const i of x2) {\n    console.log(i);\n}\nconsole.log(\"--------------\");\nfor (const i of x3) {\n    console.log(i);\n}\n```\n\n最后运行结果：\n\n```结果\n1\n2\n3\n--------------\nq\nw\ne\n--------------\n[ '1', 'q' ]\n[ '2', 'w' ]\n[ '3', 'e' ]\n```\n\n**注意：**\n\n在Map中，遍历的顺序适合我们插入值的顺序是有关的，也就是说遍历Map是按照插入顺序进行遍历的。这一点也与Object不同。\n\n## 从对象创建Map\n\n在创建Map的时候，我们可以给Map传入一个数组的参数，里面包含一些键值对的数组。就像这样：\n\n```js\nlet mp = new Map([\n\t[\"1\",\"q\"],\n\t[\"2\",\"w\"]\n])\n```\n\n这样创建出来的Map就已经初始化了。\n\n在对象中有这样一个方法：`Object.entries(对象)`这个方法可以将对象里面的每一个元素都转换为键值对的数组，并且返回一个数组，我们可以利用这个方法将对象转换为Map。\n\n```js\nvar obj = {\n    \"1\": \"q\",\n    \"2\": \"w\",\n    \"3\": \"e\"\n}\n\nlet m1 = new Map(Object.entries(obj));\nlet x4 = m1.entries();\nfor (const i of x4) {\n    console.log(i);\n}\n\n// 结果\n\n// [ '1', 'q' ]\n// [ '2', 'w' ]\n// [ '3', 'e' ]\n```\n\n## 从Map创建对象\n\n前面我们使用`Object.entries(obj)`的方法创建了对象，我们现在可以使用`Object.fromEntries(arr)`来创建对象。\n\n`Object.fromEntries(arr)`需要传入的参数是一个键值对的数组。就类似于这样的：`[[q:w],[e:r],[t:y]]`。\n\n这样的格式是不是很眼熟，是的，我们在Map中使用`map.entries()`得到的结果就是这样的。\n\n所以从Map创建对象，我们可以这样做：\n\n```js\nlet mp1 = new Map();\nmp1.set(\"1\", \"q\")\n    .set(\"2\", \"w\")\n    .set(\"3\", \"e\");\n\nlet obj1 = Object.fromEntries(mp1.entries());\nconsole.log(obj1);\n\n// 结果\n\n{ '1': 'q', '2': 'w', '3': 'e' }\n```","source":"_posts/ES6/map.md","raw":"---\ntitle: Map数据类型\ndate: [2023-3-14]\ntags: [前端]\ncategroies: [ES6]\n---\n[TOC]\n# Map\n\n在Map这种数据类型里面，我们可以使用各种数据类型作为Map的键名，打破了之前对象只能使用一部分数据类型作为键名的限制。\n\n## 创建Map\n\nMap不是一种原始数据类型，所以我们需要使用`new`关键字来创建，在创建Map数据类型的时候，需要将Map大写。\n\n```js\nlet m = new Map();\n```\n\n就像这样，我们创建出了Map对象。\n\n## Map的增删改查\n\n### 给Map对象赋值\n\n给Map对象赋值，我们使用`set`方法，并且这个方法返回的是Map对象本省，所以如果需要对Map对象赋多个值，我们可以链式赋值。\n\n就像这样：\n\n```js\np.set(\"2\", \"q\")\n   .set(\"3\", \"w\")\n   .set(\"4\", \"e\");\n```\n\n我们这样就给Map对象赋值了三个。\n\n### 获取Map对象指定key的value\n\n通过get方法可以获取到指定键名的值，`map.get(键名)`就可以得到对应的值，如果不存在该key,那么就返回undefined。\n\n```js\np.get(\"2\"); // \"q\"\np.get(\"-1\"); // undefined\n```\n\n### 判断Map对象是否拥有这个`key`\n\n我们使用`has(key)`方法来判断Map对象是否拥有这个`key`，如果存在那么返回`true`，如果不存在就返回`false`。\n\n例如：\n\n```js\np.has(\"2\"); // true\np.has(\"-1\");  // false\n```\n\n### 删除Map对象指定的键名及其数据\n\n我们可以使用`delete(key)`来删除我们指定的`key`的数据。\n\n```js\np.delete(\"2\"); // 删除key值为“2”的元素\np.has(\"2\"); // false\n```\n\n### 清空整个Map\n\n我们使用`clea()r`直接将这个Map清空。\n\n```js\np.clear();\nvar i = p.size; // 0\n```\n\n### 获取整个Map的长度\n\n我们使用`size`属性来获取Map的数据长度。\n\n```js\nlet count = p.size;\n```\n\n## Map迭代\n\n在Map中，我们可以直接使用for   of变量，但是这样遍历的结果是数组形式的。\n\n如果我们需要一些其他的遍历。\n\n这里有三种方法：\n\n- map.keys():返回一个包含所有键的可遍历对象\n- map.value():返回一个包含所有值（value）的可遍历对象\n- map.enties():返回一个包含所有实体（[key:value]）的可遍历对象\n\n我们举一个例子：\n\n```js\nlet mp = new Map();\nmp.set(\"1\", \"q\")\n    .set(\"2\",\"w\")\n    .set(\"3\",\"e\");\nlet x1 = mp.keys();\nlet x2 = mp.values();\nlet x3 = mp.entries();\nfor (const i of x1) {\n    console.log(i);\n}\nconsole.log(\"--------------\");\nfor (const i of x2) {\n    console.log(i);\n}\nconsole.log(\"--------------\");\nfor (const i of x3) {\n    console.log(i);\n}\n```\n\n最后运行结果：\n\n```结果\n1\n2\n3\n--------------\nq\nw\ne\n--------------\n[ '1', 'q' ]\n[ '2', 'w' ]\n[ '3', 'e' ]\n```\n\n**注意：**\n\n在Map中，遍历的顺序适合我们插入值的顺序是有关的，也就是说遍历Map是按照插入顺序进行遍历的。这一点也与Object不同。\n\n## 从对象创建Map\n\n在创建Map的时候，我们可以给Map传入一个数组的参数，里面包含一些键值对的数组。就像这样：\n\n```js\nlet mp = new Map([\n\t[\"1\",\"q\"],\n\t[\"2\",\"w\"]\n])\n```\n\n这样创建出来的Map就已经初始化了。\n\n在对象中有这样一个方法：`Object.entries(对象)`这个方法可以将对象里面的每一个元素都转换为键值对的数组，并且返回一个数组，我们可以利用这个方法将对象转换为Map。\n\n```js\nvar obj = {\n    \"1\": \"q\",\n    \"2\": \"w\",\n    \"3\": \"e\"\n}\n\nlet m1 = new Map(Object.entries(obj));\nlet x4 = m1.entries();\nfor (const i of x4) {\n    console.log(i);\n}\n\n// 结果\n\n// [ '1', 'q' ]\n// [ '2', 'w' ]\n// [ '3', 'e' ]\n```\n\n## 从Map创建对象\n\n前面我们使用`Object.entries(obj)`的方法创建了对象，我们现在可以使用`Object.fromEntries(arr)`来创建对象。\n\n`Object.fromEntries(arr)`需要传入的参数是一个键值对的数组。就类似于这样的：`[[q:w],[e:r],[t:y]]`。\n\n这样的格式是不是很眼熟，是的，我们在Map中使用`map.entries()`得到的结果就是这样的。\n\n所以从Map创建对象，我们可以这样做：\n\n```js\nlet mp1 = new Map();\nmp1.set(\"1\", \"q\")\n    .set(\"2\", \"w\")\n    .set(\"3\", \"e\");\n\nlet obj1 = Object.fromEntries(mp1.entries());\nconsole.log(obj1);\n\n// 结果\n\n{ '1': 'q', '2': 'w', '3': 'e' }\n```","slug":"ES6/map","published":1,"updated":"2023-03-16T07:19:53.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhx00309kbm0hjv6zbo","content":"<p>[TOC]</p>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><p>在Map这种数据类型里面，我们可以使用各种数据类型作为Map的键名，打破了之前对象只能使用一部分数据类型作为键名的限制。</p>\n<h2 id=\"创建Map\"><a href=\"#创建Map\" class=\"headerlink\" title=\"创建Map\"></a>创建Map</h2><p>Map不是一种原始数据类型，所以我们需要使用<code>new</code>关键字来创建，在创建Map数据类型的时候，需要将Map大写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> m = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br></pre></td></tr></table></figure>\n\n<p>就像这样，我们创建出了Map对象。</p>\n<h2 id=\"Map的增删改查\"><a href=\"#Map的增删改查\" class=\"headerlink\" title=\"Map的增删改查\"></a>Map的增删改查</h2><h3 id=\"给Map对象赋值\"><a href=\"#给Map对象赋值\" class=\"headerlink\" title=\"给Map对象赋值\"></a>给Map对象赋值</h3><p>给Map对象赋值，我们使用<code>set</code>方法，并且这个方法返回的是Map对象本省，所以如果需要对Map对象赋多个值，我们可以链式赋值。</p>\n<p>就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;q&quot;</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;4&quot;</span>, <span class=\"string\">&quot;e&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们这样就给Map对象赋值了三个。</p>\n<h3 id=\"获取Map对象指定key的value\"><a href=\"#获取Map对象指定key的value\" class=\"headerlink\" title=\"获取Map对象指定key的value\"></a>获取Map对象指定key的value</h3><p>通过get方法可以获取到指定键名的值，<code>map.get(键名)</code>就可以得到对应的值，如果不存在该key,那么就返回undefined。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;2&quot;</span>); <span class=\"comment\">// &quot;q&quot;</span></span><br><span class=\"line\">p.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;-1&quot;</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"判断Map对象是否拥有这个key\"><a href=\"#判断Map对象是否拥有这个key\" class=\"headerlink\" title=\"判断Map对象是否拥有这个key\"></a>判断Map对象是否拥有这个<code>key</code></h3><p>我们使用<code>has(key)</code>方法来判断Map对象是否拥有这个<code>key</code>，如果存在那么返回<code>true</code>，如果不存在就返回<code>false</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">has</span>(<span class=\"string\">&quot;2&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">p.<span class=\"title function_\">has</span>(<span class=\"string\">&quot;-1&quot;</span>);  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除Map对象指定的键名及其数据\"><a href=\"#删除Map对象指定的键名及其数据\" class=\"headerlink\" title=\"删除Map对象指定的键名及其数据\"></a>删除Map对象指定的键名及其数据</h3><p>我们可以使用<code>delete(key)</code>来删除我们指定的<code>key</code>的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">delete</span>(<span class=\"string\">&quot;2&quot;</span>); <span class=\"comment\">// 删除key值为“2”的元素</span></span><br><span class=\"line\">p.<span class=\"title function_\">has</span>(<span class=\"string\">&quot;2&quot;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"清空整个Map\"><a href=\"#清空整个Map\" class=\"headerlink\" title=\"清空整个Map\"></a>清空整个Map</h3><p>我们使用<code>clea()r</code>直接将这个Map清空。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">clear</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = p.<span class=\"property\">size</span>; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取整个Map的长度\"><a href=\"#获取整个Map的长度\" class=\"headerlink\" title=\"获取整个Map的长度\"></a>获取整个Map的长度</h3><p>我们使用<code>size</code>属性来获取Map的数据长度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> count = p.<span class=\"property\">size</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map迭代\"><a href=\"#Map迭代\" class=\"headerlink\" title=\"Map迭代\"></a>Map迭代</h2><p>在Map中，我们可以直接使用for   of变量，但是这样遍历的结果是数组形式的。</p>\n<p>如果我们需要一些其他的遍历。</p>\n<p>这里有三种方法：</p>\n<ul>\n<li>map.keys():返回一个包含所有键的可遍历对象</li>\n<li>map.value():返回一个包含所有值（value）的可遍历对象</li>\n<li>map.enties():返回一个包含所有实体（[key:value]）的可遍历对象</li>\n</ul>\n<p>我们举一个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mp = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">mp.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;q&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;e&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> x1 = mp.<span class=\"title function_\">keys</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> x2 = mp.<span class=\"title function_\">values</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> x3 = mp.<span class=\"title function_\">entries</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> x1) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> x2) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> x3) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">--------------</span><br><span class=\"line\">q</span><br><span class=\"line\">w</span><br><span class=\"line\">e</span><br><span class=\"line\">--------------</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;q&#x27; ]</span><br><span class=\"line\">[ &#x27;2&#x27;, &#x27;w&#x27; ]</span><br><span class=\"line\">[ &#x27;3&#x27;, &#x27;e&#x27; ]</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>在Map中，遍历的顺序适合我们插入值的顺序是有关的，也就是说遍历Map是按照插入顺序进行遍历的。这一点也与Object不同。</p>\n<h2 id=\"从对象创建Map\"><a href=\"#从对象创建Map\" class=\"headerlink\" title=\"从对象创建Map\"></a>从对象创建Map</h2><p>在创建Map的时候，我们可以给Map传入一个数组的参数，里面包含一些键值对的数组。就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mp = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>([</span><br><span class=\"line\">\t[<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;q&quot;</span>],</span><br><span class=\"line\">\t[<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;w&quot;</span>]</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n\n<p>这样创建出来的Map就已经初始化了。</p>\n<p>在对象中有这样一个方法：<code>Object.entries(对象)</code>这个方法可以将对象里面的每一个元素都转换为键值对的数组，并且返回一个数组，我们可以利用这个方法将对象转换为Map。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;1&quot;</span>: <span class=\"string\">&quot;q&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;2&quot;</span>: <span class=\"string\">&quot;w&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;3&quot;</span>: <span class=\"string\">&quot;e&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> m1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">entries</span>(obj));</span><br><span class=\"line\"><span class=\"keyword\">let</span> x4 = m1.<span class=\"title function_\">entries</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> x4) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [ &#x27;1&#x27;, &#x27;q&#x27; ]</span></span><br><span class=\"line\"><span class=\"comment\">// [ &#x27;2&#x27;, &#x27;w&#x27; ]</span></span><br><span class=\"line\"><span class=\"comment\">// [ &#x27;3&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"从Map创建对象\"><a href=\"#从Map创建对象\" class=\"headerlink\" title=\"从Map创建对象\"></a>从Map创建对象</h2><p>前面我们使用<code>Object.entries(obj)</code>的方法创建了对象，我们现在可以使用<code>Object.fromEntries(arr)</code>来创建对象。</p>\n<p><code>Object.fromEntries(arr)</code>需要传入的参数是一个键值对的数组。就类似于这样的：<code>[[q:w],[e:r],[t:y]]</code>。</p>\n<p>这样的格式是不是很眼熟，是的，我们在Map中使用<code>map.entries()</code>得到的结果就是这样的。</p>\n<p>所以从Map创建对象，我们可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">mp1.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;q&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;e&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = <span class=\"title class_\">Object</span>.<span class=\"title function_\">fromEntries</span>(mp1.<span class=\"title function_\">entries</span>());</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123; <span class=\"string\">&#x27;1&#x27;</span>: <span class=\"string\">&#x27;q&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>: <span class=\"string\">&#x27;w&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>: <span class=\"string\">&#x27;e&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><p>在Map这种数据类型里面，我们可以使用各种数据类型作为Map的键名，打破了之前对象只能使用一部分数据类型作为键名的限制。</p>\n<h2 id=\"创建Map\"><a href=\"#创建Map\" class=\"headerlink\" title=\"创建Map\"></a>创建Map</h2><p>Map不是一种原始数据类型，所以我们需要使用<code>new</code>关键字来创建，在创建Map数据类型的时候，需要将Map大写。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> m = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br></pre></td></tr></table></figure>\n\n<p>就像这样，我们创建出了Map对象。</p>\n<h2 id=\"Map的增删改查\"><a href=\"#Map的增删改查\" class=\"headerlink\" title=\"Map的增删改查\"></a>Map的增删改查</h2><h3 id=\"给Map对象赋值\"><a href=\"#给Map对象赋值\" class=\"headerlink\" title=\"给Map对象赋值\"></a>给Map对象赋值</h3><p>给Map对象赋值，我们使用<code>set</code>方法，并且这个方法返回的是Map对象本省，所以如果需要对Map对象赋多个值，我们可以链式赋值。</p>\n<p>就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;q&quot;</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">   .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;4&quot;</span>, <span class=\"string\">&quot;e&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们这样就给Map对象赋值了三个。</p>\n<h3 id=\"获取Map对象指定key的value\"><a href=\"#获取Map对象指定key的value\" class=\"headerlink\" title=\"获取Map对象指定key的value\"></a>获取Map对象指定key的value</h3><p>通过get方法可以获取到指定键名的值，<code>map.get(键名)</code>就可以得到对应的值，如果不存在该key,那么就返回undefined。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;2&quot;</span>); <span class=\"comment\">// &quot;q&quot;</span></span><br><span class=\"line\">p.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;-1&quot;</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"判断Map对象是否拥有这个key\"><a href=\"#判断Map对象是否拥有这个key\" class=\"headerlink\" title=\"判断Map对象是否拥有这个key\"></a>判断Map对象是否拥有这个<code>key</code></h3><p>我们使用<code>has(key)</code>方法来判断Map对象是否拥有这个<code>key</code>，如果存在那么返回<code>true</code>，如果不存在就返回<code>false</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">has</span>(<span class=\"string\">&quot;2&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">p.<span class=\"title function_\">has</span>(<span class=\"string\">&quot;-1&quot;</span>);  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除Map对象指定的键名及其数据\"><a href=\"#删除Map对象指定的键名及其数据\" class=\"headerlink\" title=\"删除Map对象指定的键名及其数据\"></a>删除Map对象指定的键名及其数据</h3><p>我们可以使用<code>delete(key)</code>来删除我们指定的<code>key</code>的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">delete</span>(<span class=\"string\">&quot;2&quot;</span>); <span class=\"comment\">// 删除key值为“2”的元素</span></span><br><span class=\"line\">p.<span class=\"title function_\">has</span>(<span class=\"string\">&quot;2&quot;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"清空整个Map\"><a href=\"#清空整个Map\" class=\"headerlink\" title=\"清空整个Map\"></a>清空整个Map</h3><p>我们使用<code>clea()r</code>直接将这个Map清空。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.<span class=\"title function_\">clear</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = p.<span class=\"property\">size</span>; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取整个Map的长度\"><a href=\"#获取整个Map的长度\" class=\"headerlink\" title=\"获取整个Map的长度\"></a>获取整个Map的长度</h3><p>我们使用<code>size</code>属性来获取Map的数据长度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> count = p.<span class=\"property\">size</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map迭代\"><a href=\"#Map迭代\" class=\"headerlink\" title=\"Map迭代\"></a>Map迭代</h2><p>在Map中，我们可以直接使用for   of变量，但是这样遍历的结果是数组形式的。</p>\n<p>如果我们需要一些其他的遍历。</p>\n<p>这里有三种方法：</p>\n<ul>\n<li>map.keys():返回一个包含所有键的可遍历对象</li>\n<li>map.value():返回一个包含所有值（value）的可遍历对象</li>\n<li>map.enties():返回一个包含所有实体（[key:value]）的可遍历对象</li>\n</ul>\n<p>我们举一个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mp = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">mp.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;q&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;e&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> x1 = mp.<span class=\"title function_\">keys</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> x2 = mp.<span class=\"title function_\">values</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> x3 = mp.<span class=\"title function_\">entries</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> x1) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> x2) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> x3) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">--------------</span><br><span class=\"line\">q</span><br><span class=\"line\">w</span><br><span class=\"line\">e</span><br><span class=\"line\">--------------</span><br><span class=\"line\">[ &#x27;1&#x27;, &#x27;q&#x27; ]</span><br><span class=\"line\">[ &#x27;2&#x27;, &#x27;w&#x27; ]</span><br><span class=\"line\">[ &#x27;3&#x27;, &#x27;e&#x27; ]</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>在Map中，遍历的顺序适合我们插入值的顺序是有关的，也就是说遍历Map是按照插入顺序进行遍历的。这一点也与Object不同。</p>\n<h2 id=\"从对象创建Map\"><a href=\"#从对象创建Map\" class=\"headerlink\" title=\"从对象创建Map\"></a>从对象创建Map</h2><p>在创建Map的时候，我们可以给Map传入一个数组的参数，里面包含一些键值对的数组。就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mp = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>([</span><br><span class=\"line\">\t[<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;q&quot;</span>],</span><br><span class=\"line\">\t[<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;w&quot;</span>]</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n\n<p>这样创建出来的Map就已经初始化了。</p>\n<p>在对象中有这样一个方法：<code>Object.entries(对象)</code>这个方法可以将对象里面的每一个元素都转换为键值对的数组，并且返回一个数组，我们可以利用这个方法将对象转换为Map。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;1&quot;</span>: <span class=\"string\">&quot;q&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;2&quot;</span>: <span class=\"string\">&quot;w&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;3&quot;</span>: <span class=\"string\">&quot;e&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> m1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">entries</span>(obj));</span><br><span class=\"line\"><span class=\"keyword\">let</span> x4 = m1.<span class=\"title function_\">entries</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> x4) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [ &#x27;1&#x27;, &#x27;q&#x27; ]</span></span><br><span class=\"line\"><span class=\"comment\">// [ &#x27;2&#x27;, &#x27;w&#x27; ]</span></span><br><span class=\"line\"><span class=\"comment\">// [ &#x27;3&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"从Map创建对象\"><a href=\"#从Map创建对象\" class=\"headerlink\" title=\"从Map创建对象\"></a>从Map创建对象</h2><p>前面我们使用<code>Object.entries(obj)</code>的方法创建了对象，我们现在可以使用<code>Object.fromEntries(arr)</code>来创建对象。</p>\n<p><code>Object.fromEntries(arr)</code>需要传入的参数是一个键值对的数组。就类似于这样的：<code>[[q:w],[e:r],[t:y]]</code>。</p>\n<p>这样的格式是不是很眼熟，是的，我们在Map中使用<code>map.entries()</code>得到的结果就是这样的。</p>\n<p>所以从Map创建对象，我们可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mp1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Map</span>();</span><br><span class=\"line\">mp1.<span class=\"title function_\">set</span>(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;q&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">set</span>(<span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;e&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = <span class=\"title class_\">Object</span>.<span class=\"title function_\">fromEntries</span>(mp1.<span class=\"title function_\">entries</span>());</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123; <span class=\"string\">&#x27;1&#x27;</span>: <span class=\"string\">&#x27;q&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>: <span class=\"string\">&#x27;w&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>: <span class=\"string\">&#x27;e&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>"},{"title":"BOM基础","date":"2022-09-22T16:00:00.000Z","_content":"# BOM基础\n\n## BOM概述\n\n`BOM`就是浏览器对象模型，它提供了独立于内容与浏览器窗口进行交换的对象，其核心是`window`。\n\nBOM是一系列的对象构成，每个对象都提供了一些特定的功能，这些对象都是`window`的属性。\n\nBOM是没有标准的，这就会导致BOM的兼容性比较差。 \n\n## BOM的组成\n\n- document\n- location\n- navigation\n- screen\n- history\n\n## window对象\n\n`window`对象是BOM的核心，它代表浏览器的一个实例，它是全局对象，所有的`全局变量`都是它的属性，所有的`全局函数`都是它的方法。\n\n之前使用的`alert()`、`confirm()`、`prompt()`、`setTimeout()`、`setInterval()`等方法都是`window`对象的方法。\n\n**注意**\n\n在声明全局变量的时候，尽量不要使用`name`作为变量名。因为在`window`对象里面，包含一个特殊的属性`window.name`。如果使用`name`作为变量名，那么`window.name`就会被覆盖。\n\n## location对象\n\n`location`对象是`window`对象的属性，它代表当前窗口的URL信息。并且他可以解析URL，返回的值也是一个对象。\n\n### location对象的属性\n\n| location对象属性  |               返回值                |\n| :---------------: | :---------------------------------: |\n|   location.href   |         获取或者设置整个URL         |\n|   location.host   |          返回主机（域名）           |\n|   location.port   | 返回端口号，如果未填写 返回空字符串 |\n| location.pathname |              返回路径               |\n|  location.search  |              返回参数               |\n|   location.hash   |  返回片段 #后面内容 常见于链接锚点  |\n\n### location对象的方法\n\n|  location对象方法  |                          返回值                          |\n| :----------------: | :------------------------------------------------------: |\n| location.assign()  | 跟href一样，可以跳转页面（也成为重定向页面）（记录历史） |\n| location.replace() |      替换当前页面，因为不记录历史，所以不能后退界面      |\n| location.reload()  |  重新加载页面，相当于刷新，如果参数为true  则为强制刷新  |\n\n## navigator对象\n\n`navigator`对象是`window`对象的属性，它代表浏览器的信息。  \n我们最常用的就是useAgent属性，它可以返回由客户机发送服务器的user-agent头部的值。\n\n## history对象\n\nwindow对象给我们提供了一个history对象，它可以让我们操作浏览器的历史记录。该对象包含了用户（在浏览器窗口中）访问过得URL。\n\n| history对象方法 |                           作用                           |\n| :-------------: | :------------------------------------------------------: |\n|     back()      |                       可以回退功能                       |\n|    forward()    |                         前进功能                         |\n|    go(参数)     | 前进后退功能，参数如果是1 前进一个页面  -1  后退一个页面 |","source":"_posts/JavaScript/BOM基础.md","raw":"---\ntitle: BOM基础\ndate: 2022-9-23\ntags: [前端]\ncategories: [BOM]\n---\n# BOM基础\n\n## BOM概述\n\n`BOM`就是浏览器对象模型，它提供了独立于内容与浏览器窗口进行交换的对象，其核心是`window`。\n\nBOM是一系列的对象构成，每个对象都提供了一些特定的功能，这些对象都是`window`的属性。\n\nBOM是没有标准的，这就会导致BOM的兼容性比较差。 \n\n## BOM的组成\n\n- document\n- location\n- navigation\n- screen\n- history\n\n## window对象\n\n`window`对象是BOM的核心，它代表浏览器的一个实例，它是全局对象，所有的`全局变量`都是它的属性，所有的`全局函数`都是它的方法。\n\n之前使用的`alert()`、`confirm()`、`prompt()`、`setTimeout()`、`setInterval()`等方法都是`window`对象的方法。\n\n**注意**\n\n在声明全局变量的时候，尽量不要使用`name`作为变量名。因为在`window`对象里面，包含一个特殊的属性`window.name`。如果使用`name`作为变量名，那么`window.name`就会被覆盖。\n\n## location对象\n\n`location`对象是`window`对象的属性，它代表当前窗口的URL信息。并且他可以解析URL，返回的值也是一个对象。\n\n### location对象的属性\n\n| location对象属性  |               返回值                |\n| :---------------: | :---------------------------------: |\n|   location.href   |         获取或者设置整个URL         |\n|   location.host   |          返回主机（域名）           |\n|   location.port   | 返回端口号，如果未填写 返回空字符串 |\n| location.pathname |              返回路径               |\n|  location.search  |              返回参数               |\n|   location.hash   |  返回片段 #后面内容 常见于链接锚点  |\n\n### location对象的方法\n\n|  location对象方法  |                          返回值                          |\n| :----------------: | :------------------------------------------------------: |\n| location.assign()  | 跟href一样，可以跳转页面（也成为重定向页面）（记录历史） |\n| location.replace() |      替换当前页面，因为不记录历史，所以不能后退界面      |\n| location.reload()  |  重新加载页面，相当于刷新，如果参数为true  则为强制刷新  |\n\n## navigator对象\n\n`navigator`对象是`window`对象的属性，它代表浏览器的信息。  \n我们最常用的就是useAgent属性，它可以返回由客户机发送服务器的user-agent头部的值。\n\n## history对象\n\nwindow对象给我们提供了一个history对象，它可以让我们操作浏览器的历史记录。该对象包含了用户（在浏览器窗口中）访问过得URL。\n\n| history对象方法 |                           作用                           |\n| :-------------: | :------------------------------------------------------: |\n|     back()      |                       可以回退功能                       |\n|    forward()    |                         前进功能                         |\n|    go(参数)     | 前进后退功能，参数如果是1 前进一个页面  -1  后退一个页面 |","slug":"JavaScript/BOM基础","published":1,"updated":"2023-01-09T11:55:25.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhy00349kbmhoqa244t","content":"<h1 id=\"BOM基础\"><a href=\"#BOM基础\" class=\"headerlink\" title=\"BOM基础\"></a>BOM基础</h1><h2 id=\"BOM概述\"><a href=\"#BOM概述\" class=\"headerlink\" title=\"BOM概述\"></a>BOM概述</h2><p><code>BOM</code>就是浏览器对象模型，它提供了独立于内容与浏览器窗口进行交换的对象，其核心是<code>window</code>。</p>\n<p>BOM是一系列的对象构成，每个对象都提供了一些特定的功能，这些对象都是<code>window</code>的属性。</p>\n<p>BOM是没有标准的，这就会导致BOM的兼容性比较差。 </p>\n<h2 id=\"BOM的组成\"><a href=\"#BOM的组成\" class=\"headerlink\" title=\"BOM的组成\"></a>BOM的组成</h2><ul>\n<li>document</li>\n<li>location</li>\n<li>navigation</li>\n<li>screen</li>\n<li>history</li>\n</ul>\n<h2 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h2><p><code>window</code>对象是BOM的核心，它代表浏览器的一个实例，它是全局对象，所有的<code>全局变量</code>都是它的属性，所有的<code>全局函数</code>都是它的方法。</p>\n<p>之前使用的<code>alert()</code>、<code>confirm()</code>、<code>prompt()</code>、<code>setTimeout()</code>、<code>setInterval()</code>等方法都是<code>window</code>对象的方法。</p>\n<p><strong>注意</strong></p>\n<p>在声明全局变量的时候，尽量不要使用<code>name</code>作为变量名。因为在<code>window</code>对象里面，包含一个特殊的属性<code>window.name</code>。如果使用<code>name</code>作为变量名，那么<code>window.name</code>就会被覆盖。</p>\n<h2 id=\"location对象\"><a href=\"#location对象\" class=\"headerlink\" title=\"location对象\"></a>location对象</h2><p><code>location</code>对象是<code>window</code>对象的属性，它代表当前窗口的URL信息。并且他可以解析URL，返回的值也是一个对象。</p>\n<h3 id=\"location对象的属性\"><a href=\"#location对象的属性\" class=\"headerlink\" title=\"location对象的属性\"></a>location对象的属性</h3><table>\n<thead>\n<tr>\n<th align=\"center\">location对象属性</th>\n<th align=\"center\">返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">location.href</td>\n<td align=\"center\">获取或者设置整个URL</td>\n</tr>\n<tr>\n<td align=\"center\">location.host</td>\n<td align=\"center\">返回主机（域名）</td>\n</tr>\n<tr>\n<td align=\"center\">location.port</td>\n<td align=\"center\">返回端口号，如果未填写 返回空字符串</td>\n</tr>\n<tr>\n<td align=\"center\">location.pathname</td>\n<td align=\"center\">返回路径</td>\n</tr>\n<tr>\n<td align=\"center\">location.search</td>\n<td align=\"center\">返回参数</td>\n</tr>\n<tr>\n<td align=\"center\">location.hash</td>\n<td align=\"center\">返回片段 #后面内容 常见于链接锚点</td>\n</tr>\n</tbody></table>\n<h3 id=\"location对象的方法\"><a href=\"#location对象的方法\" class=\"headerlink\" title=\"location对象的方法\"></a>location对象的方法</h3><table>\n<thead>\n<tr>\n<th align=\"center\">location对象方法</th>\n<th align=\"center\">返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">location.assign()</td>\n<td align=\"center\">跟href一样，可以跳转页面（也成为重定向页面）（记录历史）</td>\n</tr>\n<tr>\n<td align=\"center\">location.replace()</td>\n<td align=\"center\">替换当前页面，因为不记录历史，所以不能后退界面</td>\n</tr>\n<tr>\n<td align=\"center\">location.reload()</td>\n<td align=\"center\">重新加载页面，相当于刷新，如果参数为true  则为强制刷新</td>\n</tr>\n</tbody></table>\n<h2 id=\"navigator对象\"><a href=\"#navigator对象\" class=\"headerlink\" title=\"navigator对象\"></a>navigator对象</h2><p><code>navigator</code>对象是<code>window</code>对象的属性，它代表浏览器的信息。<br>我们最常用的就是useAgent属性，它可以返回由客户机发送服务器的user-agent头部的值。</p>\n<h2 id=\"history对象\"><a href=\"#history对象\" class=\"headerlink\" title=\"history对象\"></a>history对象</h2><p>window对象给我们提供了一个history对象，它可以让我们操作浏览器的历史记录。该对象包含了用户（在浏览器窗口中）访问过得URL。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">history对象方法</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">back()</td>\n<td align=\"center\">可以回退功能</td>\n</tr>\n<tr>\n<td align=\"center\">forward()</td>\n<td align=\"center\">前进功能</td>\n</tr>\n<tr>\n<td align=\"center\">go(参数)</td>\n<td align=\"center\">前进后退功能，参数如果是1 前进一个页面  -1  后退一个页面</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BOM基础\"><a href=\"#BOM基础\" class=\"headerlink\" title=\"BOM基础\"></a>BOM基础</h1><h2 id=\"BOM概述\"><a href=\"#BOM概述\" class=\"headerlink\" title=\"BOM概述\"></a>BOM概述</h2><p><code>BOM</code>就是浏览器对象模型，它提供了独立于内容与浏览器窗口进行交换的对象，其核心是<code>window</code>。</p>\n<p>BOM是一系列的对象构成，每个对象都提供了一些特定的功能，这些对象都是<code>window</code>的属性。</p>\n<p>BOM是没有标准的，这就会导致BOM的兼容性比较差。 </p>\n<h2 id=\"BOM的组成\"><a href=\"#BOM的组成\" class=\"headerlink\" title=\"BOM的组成\"></a>BOM的组成</h2><ul>\n<li>document</li>\n<li>location</li>\n<li>navigation</li>\n<li>screen</li>\n<li>history</li>\n</ul>\n<h2 id=\"window对象\"><a href=\"#window对象\" class=\"headerlink\" title=\"window对象\"></a>window对象</h2><p><code>window</code>对象是BOM的核心，它代表浏览器的一个实例，它是全局对象，所有的<code>全局变量</code>都是它的属性，所有的<code>全局函数</code>都是它的方法。</p>\n<p>之前使用的<code>alert()</code>、<code>confirm()</code>、<code>prompt()</code>、<code>setTimeout()</code>、<code>setInterval()</code>等方法都是<code>window</code>对象的方法。</p>\n<p><strong>注意</strong></p>\n<p>在声明全局变量的时候，尽量不要使用<code>name</code>作为变量名。因为在<code>window</code>对象里面，包含一个特殊的属性<code>window.name</code>。如果使用<code>name</code>作为变量名，那么<code>window.name</code>就会被覆盖。</p>\n<h2 id=\"location对象\"><a href=\"#location对象\" class=\"headerlink\" title=\"location对象\"></a>location对象</h2><p><code>location</code>对象是<code>window</code>对象的属性，它代表当前窗口的URL信息。并且他可以解析URL，返回的值也是一个对象。</p>\n<h3 id=\"location对象的属性\"><a href=\"#location对象的属性\" class=\"headerlink\" title=\"location对象的属性\"></a>location对象的属性</h3><table>\n<thead>\n<tr>\n<th align=\"center\">location对象属性</th>\n<th align=\"center\">返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">location.href</td>\n<td align=\"center\">获取或者设置整个URL</td>\n</tr>\n<tr>\n<td align=\"center\">location.host</td>\n<td align=\"center\">返回主机（域名）</td>\n</tr>\n<tr>\n<td align=\"center\">location.port</td>\n<td align=\"center\">返回端口号，如果未填写 返回空字符串</td>\n</tr>\n<tr>\n<td align=\"center\">location.pathname</td>\n<td align=\"center\">返回路径</td>\n</tr>\n<tr>\n<td align=\"center\">location.search</td>\n<td align=\"center\">返回参数</td>\n</tr>\n<tr>\n<td align=\"center\">location.hash</td>\n<td align=\"center\">返回片段 #后面内容 常见于链接锚点</td>\n</tr>\n</tbody></table>\n<h3 id=\"location对象的方法\"><a href=\"#location对象的方法\" class=\"headerlink\" title=\"location对象的方法\"></a>location对象的方法</h3><table>\n<thead>\n<tr>\n<th align=\"center\">location对象方法</th>\n<th align=\"center\">返回值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">location.assign()</td>\n<td align=\"center\">跟href一样，可以跳转页面（也成为重定向页面）（记录历史）</td>\n</tr>\n<tr>\n<td align=\"center\">location.replace()</td>\n<td align=\"center\">替换当前页面，因为不记录历史，所以不能后退界面</td>\n</tr>\n<tr>\n<td align=\"center\">location.reload()</td>\n<td align=\"center\">重新加载页面，相当于刷新，如果参数为true  则为强制刷新</td>\n</tr>\n</tbody></table>\n<h2 id=\"navigator对象\"><a href=\"#navigator对象\" class=\"headerlink\" title=\"navigator对象\"></a>navigator对象</h2><p><code>navigator</code>对象是<code>window</code>对象的属性，它代表浏览器的信息。<br>我们最常用的就是useAgent属性，它可以返回由客户机发送服务器的user-agent头部的值。</p>\n<h2 id=\"history对象\"><a href=\"#history对象\" class=\"headerlink\" title=\"history对象\"></a>history对象</h2><p>window对象给我们提供了一个history对象，它可以让我们操作浏览器的历史记录。该对象包含了用户（在浏览器窗口中）访问过得URL。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">history对象方法</th>\n<th align=\"center\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">back()</td>\n<td align=\"center\">可以回退功能</td>\n</tr>\n<tr>\n<td align=\"center\">forward()</td>\n<td align=\"center\">前进功能</td>\n</tr>\n<tr>\n<td align=\"center\">go(参数)</td>\n<td align=\"center\">前进后退功能，参数如果是1 前进一个页面  -1  后退一个页面</td>\n</tr>\n</tbody></table>\n"},{"title":"Symbol基础","data":["2023-3-9"],"_content":"\n# Symbol\n\nsymbol是es6提出了的一种原始数据类型，用来表示独一无二的值。并且不可以通过new关键字创建。\n\nsymbol可以通过`symbol（）`这个函数创建。\n\n## Symbol的一些基本知识\n\n### Symbol的创建\n\n```js\nvar s = Symbol();\nconsole.log(s); // Symbol()\nconsole.log(typeof s); // symbol\n```\n\n### 给Symbol附带一个参数进行创建\n\n是不是很奇怪，为什么我们定义了一个Symbol类型的值，但是我们没有给那个symbol变量赋值，最后却输出了一个`Symbol()`。这个其实只是一个标记，如果我们在使用`Symbol`这个函数创建变量的时候，传入一个参数，那么最后输出的时候，这个参数就会带着输出，这样就可以方便我么分别不同的Symbol值。\n\n就像这样：\n\n```js\nvar s2 = Symbol(\"我是一个Symbol类型\");\nconsole.log(s2);  // Symbol(我是一个Symbol类型)\n```\n\n### 不能使用new关键字创建\n\n前面我们提到，Symbol是通过Symbol这个函数进行创建的，Symbol并不是一个对象，而是一个基本数据类型，如果使用new关键字进行创建就会报错。\n\n```js\nvar s3 = new Symbol();\n```\n\n报错信息：\n\n```error\nvar s3 = new Symbol();\n         ^\nTypeError: Symbol is not a constructor\n    at new Symbol (<anonymous>)\n```\n\n这就证明我们创建Symbol不能通过new关键字创建。\n\n### 如果Symbol创建传参为一个对象，则输出时使用toString()方法将内容输出\n\n```js\nvar obj = {\n    toString() {\n        return '海绵宝宝';\n    }\n};\nvar s4 = Symbol(obj);\nconsole.log(s4); // Symbol(海绵宝宝)\n```\n\n最后输出的结果就是：`Symbol(海绵宝宝)`。\n\n### 每一个Symbol都是独一无二的\n\n尽管我们给多个Symbol函数传入相同的参数，但是他们却是不相等的。\n\n```js\nvar s5 = Symbol(\"test\");\nvar s6 = Symbol(\"test\");\nconsole.log(s5 === s6);  // false\n```\n\n可以看到最后的结果是false，这是因为Symbol出现的原因就是为了解决每个变量都不同的问题。\n\n### Symbol不可以与其他数据类型进行运算\n\n这个Symbol不能与其他数据类型进行运算，包括其本身也不行。\n\n```js\nvar s6 = Symbol(\"12\");\nvar s7 = Symbol(\"34\");\nconsole.log(s6 + s7);\n```\n\n报错：\n\n```error\nconsole.log(s6 + s7);\n               ^\nTypeError: Cannot convert a Symbol value to a number\n```\n\n### Symbol可以显示转换为字符串\n\n也就是说我们可以直接将Symbol类型的值调用String方法直接转换为字符串。\n\n```js\nvar s8 = Symbol(\"海绵宝宝\");\nconsole.log(String(s8));  // 'Symbol(\"海绵宝宝\")'\nconsole.log(s8.toString()); // 'Symbol(\"海绵宝宝\")'\n```\n\n**注意：**\n\nSymbol作为对象不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回\n\n### 创建多个相同的Symbol\n\n如果在开发中我们需要创建多个相同的Symbol，那么我们可以使用`Symbol.for`这个方法。\n\n```js\nlet s9 = Symbol.for(\"12\");\nlet s10 = Symbol.for(\"12\");\nconsole.log(s9 === s10); // true\n```\n\n## Symbol的常用场景\n\n### 作为属性名使用\n\n在对象中，我们可能需要一个表示独一无二的变量，这个时候就可以用到Symbol。\n\n实例：\n\n```js\n// 第一种写法\nvar oop = {};\nlet s13 = Symbol('key');\noop[s13] = '海绵宝宝';\n// 第二种写法\nvar oop1 = { [s13]: '海绵宝宝' };\n// 第三种写法\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: '海绵宝宝' });\n```\n\n这个时候对象里面的该属性就是独一无二的。\n\n### 作为独一无二的变量\n\n有的时候我们并不需要知道这个变量里面存的值是什么，我们只想将这几个变量区分开来，保证他们是独一无二的。这个时候也可以将Symbol派上用场。\n\n### 其他一些使用场景\n\n- 私有属性和方法：在类的实现中，可以使用Symbol来定义私有属性和方法，这样可以避免与其他属性和方法的命名冲突。\n\n- 迭代器：Symbol可以作为迭代器的方法名，用于迭代对象中的值。\n\n- 定义常量：Symbol定义的常量是唯一的，可以用作枚举类型。\n\n- 事件名称：在发布/订阅模式中，可以使用Symbol来定义事件名称，确保事件的唯一性。\n\n- 用作标记：Symbol可以用作标记，用于区分不同的代码块或函数。","source":"_posts/ES6/Symbol.md","raw":"---\ntitle: Symbol基础\ndata: [2023-3-9]\ntags: [前端]\ncategories: [ES6]\n---\n\n# Symbol\n\nsymbol是es6提出了的一种原始数据类型，用来表示独一无二的值。并且不可以通过new关键字创建。\n\nsymbol可以通过`symbol（）`这个函数创建。\n\n## Symbol的一些基本知识\n\n### Symbol的创建\n\n```js\nvar s = Symbol();\nconsole.log(s); // Symbol()\nconsole.log(typeof s); // symbol\n```\n\n### 给Symbol附带一个参数进行创建\n\n是不是很奇怪，为什么我们定义了一个Symbol类型的值，但是我们没有给那个symbol变量赋值，最后却输出了一个`Symbol()`。这个其实只是一个标记，如果我们在使用`Symbol`这个函数创建变量的时候，传入一个参数，那么最后输出的时候，这个参数就会带着输出，这样就可以方便我么分别不同的Symbol值。\n\n就像这样：\n\n```js\nvar s2 = Symbol(\"我是一个Symbol类型\");\nconsole.log(s2);  // Symbol(我是一个Symbol类型)\n```\n\n### 不能使用new关键字创建\n\n前面我们提到，Symbol是通过Symbol这个函数进行创建的，Symbol并不是一个对象，而是一个基本数据类型，如果使用new关键字进行创建就会报错。\n\n```js\nvar s3 = new Symbol();\n```\n\n报错信息：\n\n```error\nvar s3 = new Symbol();\n         ^\nTypeError: Symbol is not a constructor\n    at new Symbol (<anonymous>)\n```\n\n这就证明我们创建Symbol不能通过new关键字创建。\n\n### 如果Symbol创建传参为一个对象，则输出时使用toString()方法将内容输出\n\n```js\nvar obj = {\n    toString() {\n        return '海绵宝宝';\n    }\n};\nvar s4 = Symbol(obj);\nconsole.log(s4); // Symbol(海绵宝宝)\n```\n\n最后输出的结果就是：`Symbol(海绵宝宝)`。\n\n### 每一个Symbol都是独一无二的\n\n尽管我们给多个Symbol函数传入相同的参数，但是他们却是不相等的。\n\n```js\nvar s5 = Symbol(\"test\");\nvar s6 = Symbol(\"test\");\nconsole.log(s5 === s6);  // false\n```\n\n可以看到最后的结果是false，这是因为Symbol出现的原因就是为了解决每个变量都不同的问题。\n\n### Symbol不可以与其他数据类型进行运算\n\n这个Symbol不能与其他数据类型进行运算，包括其本身也不行。\n\n```js\nvar s6 = Symbol(\"12\");\nvar s7 = Symbol(\"34\");\nconsole.log(s6 + s7);\n```\n\n报错：\n\n```error\nconsole.log(s6 + s7);\n               ^\nTypeError: Cannot convert a Symbol value to a number\n```\n\n### Symbol可以显示转换为字符串\n\n也就是说我们可以直接将Symbol类型的值调用String方法直接转换为字符串。\n\n```js\nvar s8 = Symbol(\"海绵宝宝\");\nconsole.log(String(s8));  // 'Symbol(\"海绵宝宝\")'\nconsole.log(s8.toString()); // 'Symbol(\"海绵宝宝\")'\n```\n\n**注意：**\n\nSymbol作为对象不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回\n\n### 创建多个相同的Symbol\n\n如果在开发中我们需要创建多个相同的Symbol，那么我们可以使用`Symbol.for`这个方法。\n\n```js\nlet s9 = Symbol.for(\"12\");\nlet s10 = Symbol.for(\"12\");\nconsole.log(s9 === s10); // true\n```\n\n## Symbol的常用场景\n\n### 作为属性名使用\n\n在对象中，我们可能需要一个表示独一无二的变量，这个时候就可以用到Symbol。\n\n实例：\n\n```js\n// 第一种写法\nvar oop = {};\nlet s13 = Symbol('key');\noop[s13] = '海绵宝宝';\n// 第二种写法\nvar oop1 = { [s13]: '海绵宝宝' };\n// 第三种写法\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: '海绵宝宝' });\n```\n\n这个时候对象里面的该属性就是独一无二的。\n\n### 作为独一无二的变量\n\n有的时候我们并不需要知道这个变量里面存的值是什么，我们只想将这几个变量区分开来，保证他们是独一无二的。这个时候也可以将Symbol派上用场。\n\n### 其他一些使用场景\n\n- 私有属性和方法：在类的实现中，可以使用Symbol来定义私有属性和方法，这样可以避免与其他属性和方法的命名冲突。\n\n- 迭代器：Symbol可以作为迭代器的方法名，用于迭代对象中的值。\n\n- 定义常量：Symbol定义的常量是唯一的，可以用作枚举类型。\n\n- 事件名称：在发布/订阅模式中，可以使用Symbol来定义事件名称，确保事件的唯一性。\n\n- 用作标记：Symbol可以用作标记，用于区分不同的代码块或函数。","slug":"ES6/Symbol","published":1,"date":"2023-03-09T12:05:04.855Z","updated":"2023-03-10T01:11:37.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmhz00379kbm5lqlduez","content":"<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><p>symbol是es6提出了的一种原始数据类型，用来表示独一无二的值。并且不可以通过new关键字创建。</p>\n<p>symbol可以通过<code>symbol（）</code>这个函数创建。</p>\n<h2 id=\"Symbol的一些基本知识\"><a href=\"#Symbol的一些基本知识\" class=\"headerlink\" title=\"Symbol的一些基本知识\"></a>Symbol的一些基本知识</h2><h3 id=\"Symbol的创建\"><a href=\"#Symbol的创建\" class=\"headerlink\" title=\"Symbol的创建\"></a>Symbol的创建</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s); <span class=\"comment\">// Symbol()</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> s); <span class=\"comment\">// symbol</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"给Symbol附带一个参数进行创建\"><a href=\"#给Symbol附带一个参数进行创建\" class=\"headerlink\" title=\"给Symbol附带一个参数进行创建\"></a>给Symbol附带一个参数进行创建</h3><p>是不是很奇怪，为什么我们定义了一个Symbol类型的值，但是我们没有给那个symbol变量赋值，最后却输出了一个<code>Symbol()</code>。这个其实只是一个标记，如果我们在使用<code>Symbol</code>这个函数创建变量的时候，传入一个参数，那么最后输出的时候，这个参数就会带着输出，这样就可以方便我么分别不同的Symbol值。</p>\n<p>就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;我是一个Symbol类型&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s2);  <span class=\"comment\">// Symbol(我是一个Symbol类型)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不能使用new关键字创建\"><a href=\"#不能使用new关键字创建\" class=\"headerlink\" title=\"不能使用new关键字创建\"></a>不能使用new关键字创建</h3><p>前面我们提到，Symbol是通过Symbol这个函数进行创建的，Symbol并不是一个对象，而是一个基本数据类型，如果使用new关键字进行创建就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Symbol</span>();</span><br></pre></td></tr></table></figure>\n\n<p>报错信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s3 = new Symbol();</span><br><span class=\"line\">         ^</span><br><span class=\"line\">TypeError: Symbol is not a constructor</span><br><span class=\"line\">    at new Symbol (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>这就证明我们创建Symbol不能通过new关键字创建。</p>\n<h3 id=\"如果Symbol创建传参为一个对象，则输出时使用toString-方法将内容输出\"><a href=\"#如果Symbol创建传参为一个对象，则输出时使用toString-方法将内容输出\" class=\"headerlink\" title=\"如果Symbol创建传参为一个对象，则输出时使用toString()方法将内容输出\"></a>如果Symbol创建传参为一个对象，则输出时使用toString()方法将内容输出</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"title function_\">toString</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;海绵宝宝&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"title class_\">Symbol</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s4); <span class=\"comment\">// Symbol(海绵宝宝)</span></span><br></pre></td></tr></table></figure>\n\n<p>最后输出的结果就是：<code>Symbol(海绵宝宝)</code>。</p>\n<h3 id=\"每一个Symbol都是独一无二的\"><a href=\"#每一个Symbol都是独一无二的\" class=\"headerlink\" title=\"每一个Symbol都是独一无二的\"></a>每一个Symbol都是独一无二的</h3><p>尽管我们给多个Symbol函数传入相同的参数，但是他们却是不相等的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s5 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> s6 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s5 === s6);  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到最后的结果是false，这是因为Symbol出现的原因就是为了解决每个变量都不同的问题。</p>\n<h3 id=\"Symbol不可以与其他数据类型进行运算\"><a href=\"#Symbol不可以与其他数据类型进行运算\" class=\"headerlink\" title=\"Symbol不可以与其他数据类型进行运算\"></a>Symbol不可以与其他数据类型进行运算</h3><p>这个Symbol不能与其他数据类型进行运算，包括其本身也不行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s6 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;12&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> s7 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;34&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s6 + s7);</span><br></pre></td></tr></table></figure>\n\n<p>报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(s6 + s7);</span><br><span class=\"line\">               ^</span><br><span class=\"line\">TypeError: Cannot convert a Symbol value to a number</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol可以显示转换为字符串\"><a href=\"#Symbol可以显示转换为字符串\" class=\"headerlink\" title=\"Symbol可以显示转换为字符串\"></a>Symbol可以显示转换为字符串</h3><p>也就是说我们可以直接将Symbol类型的值调用String方法直接转换为字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s8 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;海绵宝宝&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">String</span>(s8));  <span class=\"comment\">// &#x27;Symbol(&quot;海绵宝宝&quot;)&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s8.<span class=\"title function_\">toString</span>()); <span class=\"comment\">// &#x27;Symbol(&quot;海绵宝宝&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>Symbol作为对象不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回</p>\n<h3 id=\"创建多个相同的Symbol\"><a href=\"#创建多个相同的Symbol\" class=\"headerlink\" title=\"创建多个相同的Symbol\"></a>创建多个相同的Symbol</h3><p>如果在开发中我们需要创建多个相同的Symbol，那么我们可以使用<code>Symbol.for</code>这个方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s9 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&quot;12&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s10 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&quot;12&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s9 === s10); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Symbol的常用场景\"><a href=\"#Symbol的常用场景\" class=\"headerlink\" title=\"Symbol的常用场景\"></a>Symbol的常用场景</h2><h3 id=\"作为属性名使用\"><a href=\"#作为属性名使用\" class=\"headerlink\" title=\"作为属性名使用\"></a>作为属性名使用</h3><p>在对象中，我们可能需要一个表示独一无二的变量，这个时候就可以用到Symbol。</p>\n<p>实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oop = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s13 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;key&#x27;</span>);</span><br><span class=\"line\">oop[s13] = <span class=\"string\">&#x27;海绵宝宝&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oop1 = &#123; [s13]: <span class=\"string\">&#x27;海绵宝宝&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 第三种写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(a, mySymbol, &#123; <span class=\"attr\">value</span>: <span class=\"string\">&#x27;海绵宝宝&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候对象里面的该属性就是独一无二的。</p>\n<h3 id=\"作为独一无二的变量\"><a href=\"#作为独一无二的变量\" class=\"headerlink\" title=\"作为独一无二的变量\"></a>作为独一无二的变量</h3><p>有的时候我们并不需要知道这个变量里面存的值是什么，我们只想将这几个变量区分开来，保证他们是独一无二的。这个时候也可以将Symbol派上用场。</p>\n<h3 id=\"其他一些使用场景\"><a href=\"#其他一些使用场景\" class=\"headerlink\" title=\"其他一些使用场景\"></a>其他一些使用场景</h3><ul>\n<li><p>私有属性和方法：在类的实现中，可以使用Symbol来定义私有属性和方法，这样可以避免与其他属性和方法的命名冲突。</p>\n</li>\n<li><p>迭代器：Symbol可以作为迭代器的方法名，用于迭代对象中的值。</p>\n</li>\n<li><p>定义常量：Symbol定义的常量是唯一的，可以用作枚举类型。</p>\n</li>\n<li><p>事件名称：在发布&#x2F;订阅模式中，可以使用Symbol来定义事件名称，确保事件的唯一性。</p>\n</li>\n<li><p>用作标记：Symbol可以用作标记，用于区分不同的代码块或函数。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><p>symbol是es6提出了的一种原始数据类型，用来表示独一无二的值。并且不可以通过new关键字创建。</p>\n<p>symbol可以通过<code>symbol（）</code>这个函数创建。</p>\n<h2 id=\"Symbol的一些基本知识\"><a href=\"#Symbol的一些基本知识\" class=\"headerlink\" title=\"Symbol的一些基本知识\"></a>Symbol的一些基本知识</h2><h3 id=\"Symbol的创建\"><a href=\"#Symbol的创建\" class=\"headerlink\" title=\"Symbol的创建\"></a>Symbol的创建</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s); <span class=\"comment\">// Symbol()</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> s); <span class=\"comment\">// symbol</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"给Symbol附带一个参数进行创建\"><a href=\"#给Symbol附带一个参数进行创建\" class=\"headerlink\" title=\"给Symbol附带一个参数进行创建\"></a>给Symbol附带一个参数进行创建</h3><p>是不是很奇怪，为什么我们定义了一个Symbol类型的值，但是我们没有给那个symbol变量赋值，最后却输出了一个<code>Symbol()</code>。这个其实只是一个标记，如果我们在使用<code>Symbol</code>这个函数创建变量的时候，传入一个参数，那么最后输出的时候，这个参数就会带着输出，这样就可以方便我么分别不同的Symbol值。</p>\n<p>就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s2 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;我是一个Symbol类型&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s2);  <span class=\"comment\">// Symbol(我是一个Symbol类型)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不能使用new关键字创建\"><a href=\"#不能使用new关键字创建\" class=\"headerlink\" title=\"不能使用new关键字创建\"></a>不能使用new关键字创建</h3><p>前面我们提到，Symbol是通过Symbol这个函数进行创建的，Symbol并不是一个对象，而是一个基本数据类型，如果使用new关键字进行创建就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Symbol</span>();</span><br></pre></td></tr></table></figure>\n\n<p>报错信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s3 = new Symbol();</span><br><span class=\"line\">         ^</span><br><span class=\"line\">TypeError: Symbol is not a constructor</span><br><span class=\"line\">    at new Symbol (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure>\n\n<p>这就证明我们创建Symbol不能通过new关键字创建。</p>\n<h3 id=\"如果Symbol创建传参为一个对象，则输出时使用toString-方法将内容输出\"><a href=\"#如果Symbol创建传参为一个对象，则输出时使用toString-方法将内容输出\" class=\"headerlink\" title=\"如果Symbol创建传参为一个对象，则输出时使用toString()方法将内容输出\"></a>如果Symbol创建传参为一个对象，则输出时使用toString()方法将内容输出</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"title function_\">toString</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;海绵宝宝&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s4 = <span class=\"title class_\">Symbol</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s4); <span class=\"comment\">// Symbol(海绵宝宝)</span></span><br></pre></td></tr></table></figure>\n\n<p>最后输出的结果就是：<code>Symbol(海绵宝宝)</code>。</p>\n<h3 id=\"每一个Symbol都是独一无二的\"><a href=\"#每一个Symbol都是独一无二的\" class=\"headerlink\" title=\"每一个Symbol都是独一无二的\"></a>每一个Symbol都是独一无二的</h3><p>尽管我们给多个Symbol函数传入相同的参数，但是他们却是不相等的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s5 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> s6 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s5 === s6);  <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到最后的结果是false，这是因为Symbol出现的原因就是为了解决每个变量都不同的问题。</p>\n<h3 id=\"Symbol不可以与其他数据类型进行运算\"><a href=\"#Symbol不可以与其他数据类型进行运算\" class=\"headerlink\" title=\"Symbol不可以与其他数据类型进行运算\"></a>Symbol不可以与其他数据类型进行运算</h3><p>这个Symbol不能与其他数据类型进行运算，包括其本身也不行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s6 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;12&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> s7 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;34&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s6 + s7);</span><br></pre></td></tr></table></figure>\n\n<p>报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(s6 + s7);</span><br><span class=\"line\">               ^</span><br><span class=\"line\">TypeError: Cannot convert a Symbol value to a number</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol可以显示转换为字符串\"><a href=\"#Symbol可以显示转换为字符串\" class=\"headerlink\" title=\"Symbol可以显示转换为字符串\"></a>Symbol可以显示转换为字符串</h3><p>也就是说我们可以直接将Symbol类型的值调用String方法直接转换为字符串。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s8 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;海绵宝宝&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">String</span>(s8));  <span class=\"comment\">// &#x27;Symbol(&quot;海绵宝宝&quot;)&#x27;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s8.<span class=\"title function_\">toString</span>()); <span class=\"comment\">// &#x27;Symbol(&quot;海绵宝宝&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>Symbol作为对象不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回</p>\n<h3 id=\"创建多个相同的Symbol\"><a href=\"#创建多个相同的Symbol\" class=\"headerlink\" title=\"创建多个相同的Symbol\"></a>创建多个相同的Symbol</h3><p>如果在开发中我们需要创建多个相同的Symbol，那么我们可以使用<code>Symbol.for</code>这个方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s9 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&quot;12&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s10 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(<span class=\"string\">&quot;12&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s9 === s10); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Symbol的常用场景\"><a href=\"#Symbol的常用场景\" class=\"headerlink\" title=\"Symbol的常用场景\"></a>Symbol的常用场景</h2><h3 id=\"作为属性名使用\"><a href=\"#作为属性名使用\" class=\"headerlink\" title=\"作为属性名使用\"></a>作为属性名使用</h3><p>在对象中，我们可能需要一个表示独一无二的变量，这个时候就可以用到Symbol。</p>\n<p>实例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oop = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s13 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;key&#x27;</span>);</span><br><span class=\"line\">oop[s13] = <span class=\"string\">&#x27;海绵宝宝&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 第二种写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oop1 = &#123; [s13]: <span class=\"string\">&#x27;海绵宝宝&#x27;</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 第三种写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(a, mySymbol, &#123; <span class=\"attr\">value</span>: <span class=\"string\">&#x27;海绵宝宝&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这个时候对象里面的该属性就是独一无二的。</p>\n<h3 id=\"作为独一无二的变量\"><a href=\"#作为独一无二的变量\" class=\"headerlink\" title=\"作为独一无二的变量\"></a>作为独一无二的变量</h3><p>有的时候我们并不需要知道这个变量里面存的值是什么，我们只想将这几个变量区分开来，保证他们是独一无二的。这个时候也可以将Symbol派上用场。</p>\n<h3 id=\"其他一些使用场景\"><a href=\"#其他一些使用场景\" class=\"headerlink\" title=\"其他一些使用场景\"></a>其他一些使用场景</h3><ul>\n<li><p>私有属性和方法：在类的实现中，可以使用Symbol来定义私有属性和方法，这样可以避免与其他属性和方法的命名冲突。</p>\n</li>\n<li><p>迭代器：Symbol可以作为迭代器的方法名，用于迭代对象中的值。</p>\n</li>\n<li><p>定义常量：Symbol定义的常量是唯一的，可以用作枚举类型。</p>\n</li>\n<li><p>事件名称：在发布&#x2F;订阅模式中，可以使用Symbol来定义事件名称，确保事件的唯一性。</p>\n</li>\n<li><p>用作标记：Symbol可以用作标记，用于区分不同的代码块或函数。</p>\n</li>\n</ul>\n"},{"title":"BOM常见的方法","date":"2022-09-21T16:00:00.000Z","_content":"# BOM常见的方法\n\n## window对象常见的事件\n\n### 窗口加载事件`onload`\n\n    window.onload = function(){}\n    \n    或者\n    \n    window.addEventListener('load', function(){})\n\nwindow.onload是窗口（页面）加载事件，党文档内容（图像、脚本文件、css、文件）完全加载完成之后，才会触发该函数。\n\n通过`onload`事件，我们就可以将js代码写在页面元素的上面了，这样就不会因为页面元素还没有加载完毕，导致js代码失效的问题。\n\n**注意：**\n\n`window.onload`传统注册事件的方法只能写一次，如果有多个，那么只会一最后一个`window.onload`为准生效。\n\n但是如果使用方法监听绑定事件的方式，那么就可以写多个`window.onload`。不会有限制。\n\n### 窗口加载事件`DOMContentLoaded`\n\n    window.addEventListener('DOMContentLoaded', function(){})\n\n`DOMContentLoaded`是DOM内容加载完成之后触发的事件，不会等待样式表、图像、子框架的加载。\n\n在实际开发中，我们可能会遇到这样一个问题：某一个页面的图片特别多，要是等待页面全部加载完毕之后，再加载用户的交互代码，这样等待的时间太长，会造成不好的用户体验。\n\n而`DOMContentLoaded`就是为了解决这个问题而出现的。\n\n### 窗口大小改变事件`onresize`\n\n    window.onresize = function(){}\n    \n    或者\n    \n    window.addEventListener('resize', function(){})\n\n当浏览器的窗口大小发生变化的时候，就会触发该事件（函数处理）。\n\n我们可以利用这个事件来完成事件响应式布局。window.innerWidth(宽度)和window.innerHeight(高度)可以获取到当前窗口的宽度和高度。\n\n### 定时器\n\n- `setTimeout()`：定时器，只执行一次\n\n    window.setTimeout(function(){}, 1000)// 1000毫秒后执行\n\n    setInterval(function(){}, 1000)\n\nsetTimeout()方法用于设置一个定时器，该定时器到时间之后执行调用函数。(window可以省略)\n\nsetTimeout()的函数可以直接写函数，也可以写函数名来调用函数。\n\nsetTimeout()调用的这个函数我们称作`回调函数`，普通的函数，我们都是按照代码顺序直接调用，但是在`setTimeout()`里面，这个函数需要等待的时间结束之后，采取调用这个函数，就是时间结束之后，再回过头去调用这个函数。\n\n页面中，可能有多个定时器，为了防止混淆，我们经常会将定时器的id保存起来，以便后面使用。\n\n    var timer = setTimeout(function(){}, 1000)\n\n**停止定时器**\n\n```\n    window.clearTimeout(定时器名字)// 清除定时器\n    (window可以省略)\n```\n\n- `setInterval()`：定时器，可以重复执行\n\n```\n    window.setInterval(回调函数,间隔时间);\n```\n每隔设定的间隔时间，就去调用一次回调函数。(重复调用这个函数)\n\n**停止定时器**\n\n```\n    window.clearInterval(定时器名字)// 清除定时器\n    (window可以省略)\n```","source":"_posts/JavaScript/BOM常见的方法.md","raw":"---\ntitle: BOM常见的方法\ndate: 2022-9-22\ntags: [前端]\ncategories: [BOM]\n---\n# BOM常见的方法\n\n## window对象常见的事件\n\n### 窗口加载事件`onload`\n\n    window.onload = function(){}\n    \n    或者\n    \n    window.addEventListener('load', function(){})\n\nwindow.onload是窗口（页面）加载事件，党文档内容（图像、脚本文件、css、文件）完全加载完成之后，才会触发该函数。\n\n通过`onload`事件，我们就可以将js代码写在页面元素的上面了，这样就不会因为页面元素还没有加载完毕，导致js代码失效的问题。\n\n**注意：**\n\n`window.onload`传统注册事件的方法只能写一次，如果有多个，那么只会一最后一个`window.onload`为准生效。\n\n但是如果使用方法监听绑定事件的方式，那么就可以写多个`window.onload`。不会有限制。\n\n### 窗口加载事件`DOMContentLoaded`\n\n    window.addEventListener('DOMContentLoaded', function(){})\n\n`DOMContentLoaded`是DOM内容加载完成之后触发的事件，不会等待样式表、图像、子框架的加载。\n\n在实际开发中，我们可能会遇到这样一个问题：某一个页面的图片特别多，要是等待页面全部加载完毕之后，再加载用户的交互代码，这样等待的时间太长，会造成不好的用户体验。\n\n而`DOMContentLoaded`就是为了解决这个问题而出现的。\n\n### 窗口大小改变事件`onresize`\n\n    window.onresize = function(){}\n    \n    或者\n    \n    window.addEventListener('resize', function(){})\n\n当浏览器的窗口大小发生变化的时候，就会触发该事件（函数处理）。\n\n我们可以利用这个事件来完成事件响应式布局。window.innerWidth(宽度)和window.innerHeight(高度)可以获取到当前窗口的宽度和高度。\n\n### 定时器\n\n- `setTimeout()`：定时器，只执行一次\n\n    window.setTimeout(function(){}, 1000)// 1000毫秒后执行\n\n    setInterval(function(){}, 1000)\n\nsetTimeout()方法用于设置一个定时器，该定时器到时间之后执行调用函数。(window可以省略)\n\nsetTimeout()的函数可以直接写函数，也可以写函数名来调用函数。\n\nsetTimeout()调用的这个函数我们称作`回调函数`，普通的函数，我们都是按照代码顺序直接调用，但是在`setTimeout()`里面，这个函数需要等待的时间结束之后，采取调用这个函数，就是时间结束之后，再回过头去调用这个函数。\n\n页面中，可能有多个定时器，为了防止混淆，我们经常会将定时器的id保存起来，以便后面使用。\n\n    var timer = setTimeout(function(){}, 1000)\n\n**停止定时器**\n\n```\n    window.clearTimeout(定时器名字)// 清除定时器\n    (window可以省略)\n```\n\n- `setInterval()`：定时器，可以重复执行\n\n```\n    window.setInterval(回调函数,间隔时间);\n```\n每隔设定的间隔时间，就去调用一次回调函数。(重复调用这个函数)\n\n**停止定时器**\n\n```\n    window.clearInterval(定时器名字)// 清除定时器\n    (window可以省略)\n```","slug":"JavaScript/BOM常见的方法","published":1,"updated":"2023-01-10T02:55:38.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi0003b9kbmbuord7kc","content":"<h1 id=\"BOM常见的方法\"><a href=\"#BOM常见的方法\" class=\"headerlink\" title=\"BOM常见的方法\"></a>BOM常见的方法</h1><h2 id=\"window对象常见的事件\"><a href=\"#window对象常见的事件\" class=\"headerlink\" title=\"window对象常见的事件\"></a>window对象常见的事件</h2><h3 id=\"窗口加载事件onload\"><a href=\"#窗口加载事件onload\" class=\"headerlink\" title=\"窗口加载事件onload\"></a>窗口加载事件<code>onload</code></h3><pre><code>window.onload = function()&#123;&#125;\n\n或者\n\nwindow.addEventListener(&#39;load&#39;, function()&#123;&#125;)\n</code></pre>\n<p>window.onload是窗口（页面）加载事件，党文档内容（图像、脚本文件、css、文件）完全加载完成之后，才会触发该函数。</p>\n<p>通过<code>onload</code>事件，我们就可以将js代码写在页面元素的上面了，这样就不会因为页面元素还没有加载完毕，导致js代码失效的问题。</p>\n<p><strong>注意：</strong></p>\n<p><code>window.onload</code>传统注册事件的方法只能写一次，如果有多个，那么只会一最后一个<code>window.onload</code>为准生效。</p>\n<p>但是如果使用方法监听绑定事件的方式，那么就可以写多个<code>window.onload</code>。不会有限制。</p>\n<h3 id=\"窗口加载事件DOMContentLoaded\"><a href=\"#窗口加载事件DOMContentLoaded\" class=\"headerlink\" title=\"窗口加载事件DOMContentLoaded\"></a>窗口加载事件<code>DOMContentLoaded</code></h3><pre><code>window.addEventListener(&#39;DOMContentLoaded&#39;, function()&#123;&#125;)\n</code></pre>\n<p><code>DOMContentLoaded</code>是DOM内容加载完成之后触发的事件，不会等待样式表、图像、子框架的加载。</p>\n<p>在实际开发中，我们可能会遇到这样一个问题：某一个页面的图片特别多，要是等待页面全部加载完毕之后，再加载用户的交互代码，这样等待的时间太长，会造成不好的用户体验。</p>\n<p>而<code>DOMContentLoaded</code>就是为了解决这个问题而出现的。</p>\n<h3 id=\"窗口大小改变事件onresize\"><a href=\"#窗口大小改变事件onresize\" class=\"headerlink\" title=\"窗口大小改变事件onresize\"></a>窗口大小改变事件<code>onresize</code></h3><pre><code>window.onresize = function()&#123;&#125;\n\n或者\n\nwindow.addEventListener(&#39;resize&#39;, function()&#123;&#125;)\n</code></pre>\n<p>当浏览器的窗口大小发生变化的时候，就会触发该事件（函数处理）。</p>\n<p>我们可以利用这个事件来完成事件响应式布局。window.innerWidth(宽度)和window.innerHeight(高度)可以获取到当前窗口的宽度和高度。</p>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><ul>\n<li><p><code>setTimeout()</code>：定时器，只执行一次</p>\n<p>  window.setTimeout(function(){}, 1000)&#x2F;&#x2F; 1000毫秒后执行</p>\n<p>  setInterval(function(){}, 1000)</p>\n</li>\n</ul>\n<p>setTimeout()方法用于设置一个定时器，该定时器到时间之后执行调用函数。(window可以省略)</p>\n<p>setTimeout()的函数可以直接写函数，也可以写函数名来调用函数。</p>\n<p>setTimeout()调用的这个函数我们称作<code>回调函数</code>，普通的函数，我们都是按照代码顺序直接调用，但是在<code>setTimeout()</code>里面，这个函数需要等待的时间结束之后，采取调用这个函数，就是时间结束之后，再回过头去调用这个函数。</p>\n<p>页面中，可能有多个定时器，为了防止混淆，我们经常会将定时器的id保存起来，以便后面使用。</p>\n<pre><code>var timer = setTimeout(function()&#123;&#125;, 1000)\n</code></pre>\n<p><strong>停止定时器</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.clearTimeout(定时器名字)// 清除定时器</span><br><span class=\"line\">(window可以省略)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>setInterval()</code>：定时器，可以重复执行</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.setInterval(回调函数,间隔时间);</span><br></pre></td></tr></table></figure>\n<p>每隔设定的间隔时间，就去调用一次回调函数。(重复调用这个函数)</p>\n<p><strong>停止定时器</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.clearInterval(定时器名字)// 清除定时器</span><br><span class=\"line\">(window可以省略)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BOM常见的方法\"><a href=\"#BOM常见的方法\" class=\"headerlink\" title=\"BOM常见的方法\"></a>BOM常见的方法</h1><h2 id=\"window对象常见的事件\"><a href=\"#window对象常见的事件\" class=\"headerlink\" title=\"window对象常见的事件\"></a>window对象常见的事件</h2><h3 id=\"窗口加载事件onload\"><a href=\"#窗口加载事件onload\" class=\"headerlink\" title=\"窗口加载事件onload\"></a>窗口加载事件<code>onload</code></h3><pre><code>window.onload = function()&#123;&#125;\n\n或者\n\nwindow.addEventListener(&#39;load&#39;, function()&#123;&#125;)\n</code></pre>\n<p>window.onload是窗口（页面）加载事件，党文档内容（图像、脚本文件、css、文件）完全加载完成之后，才会触发该函数。</p>\n<p>通过<code>onload</code>事件，我们就可以将js代码写在页面元素的上面了，这样就不会因为页面元素还没有加载完毕，导致js代码失效的问题。</p>\n<p><strong>注意：</strong></p>\n<p><code>window.onload</code>传统注册事件的方法只能写一次，如果有多个，那么只会一最后一个<code>window.onload</code>为准生效。</p>\n<p>但是如果使用方法监听绑定事件的方式，那么就可以写多个<code>window.onload</code>。不会有限制。</p>\n<h3 id=\"窗口加载事件DOMContentLoaded\"><a href=\"#窗口加载事件DOMContentLoaded\" class=\"headerlink\" title=\"窗口加载事件DOMContentLoaded\"></a>窗口加载事件<code>DOMContentLoaded</code></h3><pre><code>window.addEventListener(&#39;DOMContentLoaded&#39;, function()&#123;&#125;)\n</code></pre>\n<p><code>DOMContentLoaded</code>是DOM内容加载完成之后触发的事件，不会等待样式表、图像、子框架的加载。</p>\n<p>在实际开发中，我们可能会遇到这样一个问题：某一个页面的图片特别多，要是等待页面全部加载完毕之后，再加载用户的交互代码，这样等待的时间太长，会造成不好的用户体验。</p>\n<p>而<code>DOMContentLoaded</code>就是为了解决这个问题而出现的。</p>\n<h3 id=\"窗口大小改变事件onresize\"><a href=\"#窗口大小改变事件onresize\" class=\"headerlink\" title=\"窗口大小改变事件onresize\"></a>窗口大小改变事件<code>onresize</code></h3><pre><code>window.onresize = function()&#123;&#125;\n\n或者\n\nwindow.addEventListener(&#39;resize&#39;, function()&#123;&#125;)\n</code></pre>\n<p>当浏览器的窗口大小发生变化的时候，就会触发该事件（函数处理）。</p>\n<p>我们可以利用这个事件来完成事件响应式布局。window.innerWidth(宽度)和window.innerHeight(高度)可以获取到当前窗口的宽度和高度。</p>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><ul>\n<li><p><code>setTimeout()</code>：定时器，只执行一次</p>\n<p>  window.setTimeout(function(){}, 1000)&#x2F;&#x2F; 1000毫秒后执行</p>\n<p>  setInterval(function(){}, 1000)</p>\n</li>\n</ul>\n<p>setTimeout()方法用于设置一个定时器，该定时器到时间之后执行调用函数。(window可以省略)</p>\n<p>setTimeout()的函数可以直接写函数，也可以写函数名来调用函数。</p>\n<p>setTimeout()调用的这个函数我们称作<code>回调函数</code>，普通的函数，我们都是按照代码顺序直接调用，但是在<code>setTimeout()</code>里面，这个函数需要等待的时间结束之后，采取调用这个函数，就是时间结束之后，再回过头去调用这个函数。</p>\n<p>页面中，可能有多个定时器，为了防止混淆，我们经常会将定时器的id保存起来，以便后面使用。</p>\n<pre><code>var timer = setTimeout(function()&#123;&#125;, 1000)\n</code></pre>\n<p><strong>停止定时器</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.clearTimeout(定时器名字)// 清除定时器</span><br><span class=\"line\">(window可以省略)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>setInterval()</code>：定时器，可以重复执行</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.setInterval(回调函数,间隔时间);</span><br></pre></td></tr></table></figure>\n<p>每隔设定的间隔时间，就去调用一次回调函数。(重复调用这个函数)</p>\n<p><strong>停止定时器</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.clearInterval(定时器名字)// 清除定时器</span><br><span class=\"line\">(window可以省略)</span><br></pre></td></tr></table></figure>"},{"title":"DOM事件","date":"2022-09-08T16:00:00.000Z","_content":"\n# DOM事件\n\n## 什么是事件\n\n在JavaScript中，我们可以创建动态界面，但是我们需要用户的交互，比如鼠标点击，键盘输入等等，这些都是事件，我们可以通过事件来触发一些动作，比如点击按钮，弹出一个对话框，或者是改变页面的样式等等。这些交互，浏览器会给用户反馈，这些反馈就可以看做是`事件`。也就是事件是可以被JavaScript侦测到的一种行为。\n\n## 事件三要素\n\n事件是由三个要素组成的，分别是事件源、事件类型、事件处理程序。\n\n下面我分别来解释一下三要素是什么：\n\n### 事件源\n\n事件源就是触发事件的对象，比如网页的按钮，文本框，图片等等，这些都是事件源。\n\n通过事件源我们可以给事件源绑定事件。\n\n### 事件类型\n\n事件类型就是事件的类型，比如鼠标点击、移动、悬停事件，键盘输入事件等等，这些都是事件类型。\n\n### 事件处理程序\n\n事件处理程序就是事件触发后执行的代码，比如点击按钮后弹出一个对话框，这个对话框就是事件处理程序。\n\n事件处理程序通常是一个函数，当然这个函数可以是匿名函数，也可以是具名函数。\n\n## 事件执行步骤\n\n1. 获取事件源\n2. 注册事件（绑定事件）\n3. 添加事件处理程序（通过函数执行）\n\n## 例子：\n\n`点击按钮弹出对话框`\n\n    <div>123123</div>\n\n我们的任务：点击这个div然后弹出一个对话框（hello）。\n\n首先我们要获取这个div，然后给这个div绑定一个点击事件，最后添加一个事件处理程序，这个事件处理程序就是弹出一个对话框。\n\n    // 获取事件源\n    var div = document.getElementsByTagName('div')[0];\n    // 绑定事件（onclick）\n    div.onclick = function(){\n        // 事件处理程序\n        alert('hello');\n    }","source":"_posts/JavaScript/DOM事件.md","raw":"---\ntitle: DOM事件\ndate: 2022-9-9\ntags: [前端]\ncategories: [DOM]\n---\n\n# DOM事件\n\n## 什么是事件\n\n在JavaScript中，我们可以创建动态界面，但是我们需要用户的交互，比如鼠标点击，键盘输入等等，这些都是事件，我们可以通过事件来触发一些动作，比如点击按钮，弹出一个对话框，或者是改变页面的样式等等。这些交互，浏览器会给用户反馈，这些反馈就可以看做是`事件`。也就是事件是可以被JavaScript侦测到的一种行为。\n\n## 事件三要素\n\n事件是由三个要素组成的，分别是事件源、事件类型、事件处理程序。\n\n下面我分别来解释一下三要素是什么：\n\n### 事件源\n\n事件源就是触发事件的对象，比如网页的按钮，文本框，图片等等，这些都是事件源。\n\n通过事件源我们可以给事件源绑定事件。\n\n### 事件类型\n\n事件类型就是事件的类型，比如鼠标点击、移动、悬停事件，键盘输入事件等等，这些都是事件类型。\n\n### 事件处理程序\n\n事件处理程序就是事件触发后执行的代码，比如点击按钮后弹出一个对话框，这个对话框就是事件处理程序。\n\n事件处理程序通常是一个函数，当然这个函数可以是匿名函数，也可以是具名函数。\n\n## 事件执行步骤\n\n1. 获取事件源\n2. 注册事件（绑定事件）\n3. 添加事件处理程序（通过函数执行）\n\n## 例子：\n\n`点击按钮弹出对话框`\n\n    <div>123123</div>\n\n我们的任务：点击这个div然后弹出一个对话框（hello）。\n\n首先我们要获取这个div，然后给这个div绑定一个点击事件，最后添加一个事件处理程序，这个事件处理程序就是弹出一个对话框。\n\n    // 获取事件源\n    var div = document.getElementsByTagName('div')[0];\n    // 绑定事件（onclick）\n    div.onclick = function(){\n        // 事件处理程序\n        alert('hello');\n    }","slug":"JavaScript/DOM事件","published":1,"updated":"2023-01-09T12:04:20.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi0003e9kbm3li32a43","content":"<h1 id=\"DOM事件\"><a href=\"#DOM事件\" class=\"headerlink\" title=\"DOM事件\"></a>DOM事件</h1><h2 id=\"什么是事件\"><a href=\"#什么是事件\" class=\"headerlink\" title=\"什么是事件\"></a>什么是事件</h2><p>在JavaScript中，我们可以创建动态界面，但是我们需要用户的交互，比如鼠标点击，键盘输入等等，这些都是事件，我们可以通过事件来触发一些动作，比如点击按钮，弹出一个对话框，或者是改变页面的样式等等。这些交互，浏览器会给用户反馈，这些反馈就可以看做是<code>事件</code>。也就是事件是可以被JavaScript侦测到的一种行为。</p>\n<h2 id=\"事件三要素\"><a href=\"#事件三要素\" class=\"headerlink\" title=\"事件三要素\"></a>事件三要素</h2><p>事件是由三个要素组成的，分别是事件源、事件类型、事件处理程序。</p>\n<p>下面我分别来解释一下三要素是什么：</p>\n<h3 id=\"事件源\"><a href=\"#事件源\" class=\"headerlink\" title=\"事件源\"></a>事件源</h3><p>事件源就是触发事件的对象，比如网页的按钮，文本框，图片等等，这些都是事件源。</p>\n<p>通过事件源我们可以给事件源绑定事件。</p>\n<h3 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h3><p>事件类型就是事件的类型，比如鼠标点击、移动、悬停事件，键盘输入事件等等，这些都是事件类型。</p>\n<h3 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h3><p>事件处理程序就是事件触发后执行的代码，比如点击按钮后弹出一个对话框，这个对话框就是事件处理程序。</p>\n<p>事件处理程序通常是一个函数，当然这个函数可以是匿名函数，也可以是具名函数。</p>\n<h2 id=\"事件执行步骤\"><a href=\"#事件执行步骤\" class=\"headerlink\" title=\"事件执行步骤\"></a>事件执行步骤</h2><ol>\n<li>获取事件源</li>\n<li>注册事件（绑定事件）</li>\n<li>添加事件处理程序（通过函数执行）</li>\n</ol>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><p><code>点击按钮弹出对话框</code></p>\n<pre><code>&lt;div&gt;123123&lt;/div&gt;\n</code></pre>\n<p>我们的任务：点击这个div然后弹出一个对话框（hello）。</p>\n<p>首先我们要获取这个div，然后给这个div绑定一个点击事件，最后添加一个事件处理程序，这个事件处理程序就是弹出一个对话框。</p>\n<pre><code>// 获取事件源\nvar div = document.getElementsByTagName(&#39;div&#39;)[0];\n// 绑定事件（onclick）\ndiv.onclick = function()&#123;\n    // 事件处理程序\n    alert(&#39;hello&#39;);\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DOM事件\"><a href=\"#DOM事件\" class=\"headerlink\" title=\"DOM事件\"></a>DOM事件</h1><h2 id=\"什么是事件\"><a href=\"#什么是事件\" class=\"headerlink\" title=\"什么是事件\"></a>什么是事件</h2><p>在JavaScript中，我们可以创建动态界面，但是我们需要用户的交互，比如鼠标点击，键盘输入等等，这些都是事件，我们可以通过事件来触发一些动作，比如点击按钮，弹出一个对话框，或者是改变页面的样式等等。这些交互，浏览器会给用户反馈，这些反馈就可以看做是<code>事件</code>。也就是事件是可以被JavaScript侦测到的一种行为。</p>\n<h2 id=\"事件三要素\"><a href=\"#事件三要素\" class=\"headerlink\" title=\"事件三要素\"></a>事件三要素</h2><p>事件是由三个要素组成的，分别是事件源、事件类型、事件处理程序。</p>\n<p>下面我分别来解释一下三要素是什么：</p>\n<h3 id=\"事件源\"><a href=\"#事件源\" class=\"headerlink\" title=\"事件源\"></a>事件源</h3><p>事件源就是触发事件的对象，比如网页的按钮，文本框，图片等等，这些都是事件源。</p>\n<p>通过事件源我们可以给事件源绑定事件。</p>\n<h3 id=\"事件类型\"><a href=\"#事件类型\" class=\"headerlink\" title=\"事件类型\"></a>事件类型</h3><p>事件类型就是事件的类型，比如鼠标点击、移动、悬停事件，键盘输入事件等等，这些都是事件类型。</p>\n<h3 id=\"事件处理程序\"><a href=\"#事件处理程序\" class=\"headerlink\" title=\"事件处理程序\"></a>事件处理程序</h3><p>事件处理程序就是事件触发后执行的代码，比如点击按钮后弹出一个对话框，这个对话框就是事件处理程序。</p>\n<p>事件处理程序通常是一个函数，当然这个函数可以是匿名函数，也可以是具名函数。</p>\n<h2 id=\"事件执行步骤\"><a href=\"#事件执行步骤\" class=\"headerlink\" title=\"事件执行步骤\"></a>事件执行步骤</h2><ol>\n<li>获取事件源</li>\n<li>注册事件（绑定事件）</li>\n<li>添加事件处理程序（通过函数执行）</li>\n</ol>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><p><code>点击按钮弹出对话框</code></p>\n<pre><code>&lt;div&gt;123123&lt;/div&gt;\n</code></pre>\n<p>我们的任务：点击这个div然后弹出一个对话框（hello）。</p>\n<p>首先我们要获取这个div，然后给这个div绑定一个点击事件，最后添加一个事件处理程序，这个事件处理程序就是弹出一个对话框。</p>\n<pre><code>// 获取事件源\nvar div = document.getElementsByTagName(&#39;div&#39;)[0];\n// 绑定事件（onclick）\ndiv.onclick = function()&#123;\n    // 事件处理程序\n    alert(&#39;hello&#39;);\n&#125;\n</code></pre>\n"},{"title":"JSON对象","_content":"# JSON对象\n## 1.JSON\n\n在JSON对象当中，每个对象只有一个值，这个值可以是数组或者对象，也有可能是一个原始类型的值。整个对象只能是一个值，不能是两个或者多个值。\n\nJSON对象对值的类型和格式有着严格要求：\n\n- 复合类型的值只能是数组或者对象，不能是函数、正则表达式、日期对象。\n- 原始类型的值只有四种：字符串、数值（必须为十进制）、布尔值、null（不能使用NaN、Infinity、-Infinity、undefined）\n- 字符串必须使用双引号表示、不能使用单引号\n- 对象的键名必须放在双引号里面\n- 数组或者对象的最后一个成员后面，不能加逗号\n\n```JavaScript\n[\"one\", \"two\", \"three\"]\n\n{ \"one\": 1, \"two\": 2, \"three\": 3 }\n\n{\"names\": [\"张三\", \"李四\"] }\n\n[ { \"name\": \"张三\"}, {\"name\": \"李四\"} ]\n```\n\nnull、空数组、空对象都是合法的JSON对象\n\n## 2JSON对象的一些方法\n\n### 2.1 JSON.stringify()\n\n使用`JSON.stringify()`方法将一个值转换为JSON对象，并且可以使用`JSON.parse()`方法还原。\n\n```javascript\nvar str = \"abc\";\nconsole.log(str);// abc\nvar json = JSON.stringify(str);\nconsole.log(json); // \"abc\"\nvar obj = JSON.parse(json);\nconsole.log(obj); // abc\n```\n\n注意：\n- 经过`JSON.stringify()`转换的原始类型字符串，转换结果会带有双引号\n\n```javasscript\nJSON.stringify('foo') === \"foo\" // false\nJSON.stringify('foo') === \"\\\"foo\\\"\" // true\n```\n\n这里可以看到，转换之后的结果与原始值加双引号并不相等，而是等于原始值加`\"\\\"\"\\\"`。那这是因为什么呢？\n\n这是因为，内层的双引号告诉引擎：这是一个字符串，不然后面还原的时候，引擎就不知道这是一个布尔值还是一个字符串。\n\n如果某个对象的属性值是函数、undefined、XML对象，那么这些属性不能作为JSON对象的值，所以使用这个方法的时候，这些属性会被`JSON.stringify()`自动过滤。\n\n如果某个数组的成员是`undefinded`或者函数，那么这些都会被`JSON.stringify()`转换为`null`。\n\n正则对象会被转换成空对象。\n\n`JSON.stringify()`对象还会忽略对象不可遍历的属性。\n\n### 2.2 JSON.stringify()的第二个参数\n\n`JSON.stringify()`方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。但是这第二个参数只对对象有作用。\n\n```js\nvar obj = {\n    \"a\": 1,\n    \"b\": 2,\n    \"c\": 3\n}\n\nvar arr = ['a', 'b'];\n\nvar json = JSON.stringify(obj, arr);\nconsole.log(json);// {\"a\":1,\"b\":2}\n```","source":"_posts/JavaScript/JSON对象.md","raw":"---\ntitle: JSON对象\ntags: [前端]\ncategories: [JavaScript]\n---\n# JSON对象\n## 1.JSON\n\n在JSON对象当中，每个对象只有一个值，这个值可以是数组或者对象，也有可能是一个原始类型的值。整个对象只能是一个值，不能是两个或者多个值。\n\nJSON对象对值的类型和格式有着严格要求：\n\n- 复合类型的值只能是数组或者对象，不能是函数、正则表达式、日期对象。\n- 原始类型的值只有四种：字符串、数值（必须为十进制）、布尔值、null（不能使用NaN、Infinity、-Infinity、undefined）\n- 字符串必须使用双引号表示、不能使用单引号\n- 对象的键名必须放在双引号里面\n- 数组或者对象的最后一个成员后面，不能加逗号\n\n```JavaScript\n[\"one\", \"two\", \"three\"]\n\n{ \"one\": 1, \"two\": 2, \"three\": 3 }\n\n{\"names\": [\"张三\", \"李四\"] }\n\n[ { \"name\": \"张三\"}, {\"name\": \"李四\"} ]\n```\n\nnull、空数组、空对象都是合法的JSON对象\n\n## 2JSON对象的一些方法\n\n### 2.1 JSON.stringify()\n\n使用`JSON.stringify()`方法将一个值转换为JSON对象，并且可以使用`JSON.parse()`方法还原。\n\n```javascript\nvar str = \"abc\";\nconsole.log(str);// abc\nvar json = JSON.stringify(str);\nconsole.log(json); // \"abc\"\nvar obj = JSON.parse(json);\nconsole.log(obj); // abc\n```\n\n注意：\n- 经过`JSON.stringify()`转换的原始类型字符串，转换结果会带有双引号\n\n```javasscript\nJSON.stringify('foo') === \"foo\" // false\nJSON.stringify('foo') === \"\\\"foo\\\"\" // true\n```\n\n这里可以看到，转换之后的结果与原始值加双引号并不相等，而是等于原始值加`\"\\\"\"\\\"`。那这是因为什么呢？\n\n这是因为，内层的双引号告诉引擎：这是一个字符串，不然后面还原的时候，引擎就不知道这是一个布尔值还是一个字符串。\n\n如果某个对象的属性值是函数、undefined、XML对象，那么这些属性不能作为JSON对象的值，所以使用这个方法的时候，这些属性会被`JSON.stringify()`自动过滤。\n\n如果某个数组的成员是`undefinded`或者函数，那么这些都会被`JSON.stringify()`转换为`null`。\n\n正则对象会被转换成空对象。\n\n`JSON.stringify()`对象还会忽略对象不可遍历的属性。\n\n### 2.2 JSON.stringify()的第二个参数\n\n`JSON.stringify()`方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。但是这第二个参数只对对象有作用。\n\n```js\nvar obj = {\n    \"a\": 1,\n    \"b\": 2,\n    \"c\": 3\n}\n\nvar arr = ['a', 'b'];\n\nvar json = JSON.stringify(obj, arr);\nconsole.log(json);// {\"a\":1,\"b\":2}\n```","slug":"JavaScript/JSON对象","published":1,"date":"2023-01-09T14:00:27.894Z","updated":"2023-01-10T04:29:56.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi2003i9kbmhy3xfv34","content":"<h1 id=\"JSON对象\"><a href=\"#JSON对象\" class=\"headerlink\" title=\"JSON对象\"></a>JSON对象</h1><h2 id=\"1-JSON\"><a href=\"#1-JSON\" class=\"headerlink\" title=\"1.JSON\"></a>1.JSON</h2><p>在JSON对象当中，每个对象只有一个值，这个值可以是数组或者对象，也有可能是一个原始类型的值。整个对象只能是一个值，不能是两个或者多个值。</p>\n<p>JSON对象对值的类型和格式有着严格要求：</p>\n<ul>\n<li>复合类型的值只能是数组或者对象，不能是函数、正则表达式、日期对象。</li>\n<li>原始类型的值只有四种：字符串、数值（必须为十进制）、布尔值、null（不能使用NaN、Infinity、-Infinity、undefined）</li>\n<li>字符串必须使用双引号表示、不能使用单引号</li>\n<li>对象的键名必须放在双引号里面</li>\n<li>数组或者对象的最后一个成员后面，不能加逗号</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&quot;one&quot;</span>, <span class=\"string\">&quot;two&quot;</span>, <span class=\"string\">&quot;three&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; <span class=\"string\">&quot;one&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;two&quot;</span>: <span class=\"number\">2</span>, <span class=\"string\">&quot;three&quot;</span>: <span class=\"number\">3</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;names&quot;</span>: [<span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[ &#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;张三&quot;</span>&#125;, &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;李四&quot;</span>&#125; ]</span><br></pre></td></tr></table></figure>\n\n<p>null、空数组、空对象都是合法的JSON对象</p>\n<h2 id=\"2JSON对象的一些方法\"><a href=\"#2JSON对象的一些方法\" class=\"headerlink\" title=\"2JSON对象的一些方法\"></a>2JSON对象的一些方法</h2><h3 id=\"2-1-JSON-stringify\"><a href=\"#2-1-JSON-stringify\" class=\"headerlink\" title=\"2.1 JSON.stringify()\"></a>2.1 JSON.stringify()</h3><p>使用<code>JSON.stringify()</code>方法将一个值转换为JSON对象，并且可以使用<code>JSON.parse()</code>方法还原。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// abc</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> json = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(str);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(json); <span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(json);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj); <span class=\"comment\">// abc</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>经过<code>JSON.stringify()</code>转换的原始类型字符串，转换结果会带有双引号</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify(&#x27;foo&#x27;) === &quot;foo&quot; // false</span><br><span class=\"line\">JSON.stringify(&#x27;foo&#x27;) === &quot;\\&quot;foo\\&quot;&quot; // true</span><br></pre></td></tr></table></figure>\n\n<p>这里可以看到，转换之后的结果与原始值加双引号并不相等，而是等于原始值加<code>&quot;\\&quot;&quot;\\&quot;</code>。那这是因为什么呢？</p>\n<p>这是因为，内层的双引号告诉引擎：这是一个字符串，不然后面还原的时候，引擎就不知道这是一个布尔值还是一个字符串。</p>\n<p>如果某个对象的属性值是函数、undefined、XML对象，那么这些属性不能作为JSON对象的值，所以使用这个方法的时候，这些属性会被<code>JSON.stringify()</code>自动过滤。</p>\n<p>如果某个数组的成员是<code>undefinded</code>或者函数，那么这些都会被<code>JSON.stringify()</code>转换为<code>null</code>。</p>\n<p>正则对象会被转换成空对象。</p>\n<p><code>JSON.stringify()</code>对象还会忽略对象不可遍历的属性。</p>\n<h3 id=\"2-2-JSON-stringify-的第二个参数\"><a href=\"#2-2-JSON-stringify-的第二个参数\" class=\"headerlink\" title=\"2.2 JSON.stringify()的第二个参数\"></a>2.2 JSON.stringify()的第二个参数</h3><p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。但是这第二个参数只对对象有作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;a&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;b&quot;</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;c&quot;</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> json = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(obj, arr);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(json);<span class=\"comment\">// &#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JSON对象\"><a href=\"#JSON对象\" class=\"headerlink\" title=\"JSON对象\"></a>JSON对象</h1><h2 id=\"1-JSON\"><a href=\"#1-JSON\" class=\"headerlink\" title=\"1.JSON\"></a>1.JSON</h2><p>在JSON对象当中，每个对象只有一个值，这个值可以是数组或者对象，也有可能是一个原始类型的值。整个对象只能是一个值，不能是两个或者多个值。</p>\n<p>JSON对象对值的类型和格式有着严格要求：</p>\n<ul>\n<li>复合类型的值只能是数组或者对象，不能是函数、正则表达式、日期对象。</li>\n<li>原始类型的值只有四种：字符串、数值（必须为十进制）、布尔值、null（不能使用NaN、Infinity、-Infinity、undefined）</li>\n<li>字符串必须使用双引号表示、不能使用单引号</li>\n<li>对象的键名必须放在双引号里面</li>\n<li>数组或者对象的最后一个成员后面，不能加逗号</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">&quot;one&quot;</span>, <span class=\"string\">&quot;two&quot;</span>, <span class=\"string\">&quot;three&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; <span class=\"string\">&quot;one&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;two&quot;</span>: <span class=\"number\">2</span>, <span class=\"string\">&quot;three&quot;</span>: <span class=\"number\">3</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">&quot;names&quot;</span>: [<span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>] &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[ &#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;张三&quot;</span>&#125;, &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;李四&quot;</span>&#125; ]</span><br></pre></td></tr></table></figure>\n\n<p>null、空数组、空对象都是合法的JSON对象</p>\n<h2 id=\"2JSON对象的一些方法\"><a href=\"#2JSON对象的一些方法\" class=\"headerlink\" title=\"2JSON对象的一些方法\"></a>2JSON对象的一些方法</h2><h3 id=\"2-1-JSON-stringify\"><a href=\"#2-1-JSON-stringify\" class=\"headerlink\" title=\"2.1 JSON.stringify()\"></a>2.1 JSON.stringify()</h3><p>使用<code>JSON.stringify()</code>方法将一个值转换为JSON对象，并且可以使用<code>JSON.parse()</code>方法还原。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// abc</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> json = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(str);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(json); <span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(json);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj); <span class=\"comment\">// abc</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>经过<code>JSON.stringify()</code>转换的原始类型字符串，转换结果会带有双引号</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify(&#x27;foo&#x27;) === &quot;foo&quot; // false</span><br><span class=\"line\">JSON.stringify(&#x27;foo&#x27;) === &quot;\\&quot;foo\\&quot;&quot; // true</span><br></pre></td></tr></table></figure>\n\n<p>这里可以看到，转换之后的结果与原始值加双引号并不相等，而是等于原始值加<code>&quot;\\&quot;&quot;\\&quot;</code>。那这是因为什么呢？</p>\n<p>这是因为，内层的双引号告诉引擎：这是一个字符串，不然后面还原的时候，引擎就不知道这是一个布尔值还是一个字符串。</p>\n<p>如果某个对象的属性值是函数、undefined、XML对象，那么这些属性不能作为JSON对象的值，所以使用这个方法的时候，这些属性会被<code>JSON.stringify()</code>自动过滤。</p>\n<p>如果某个数组的成员是<code>undefinded</code>或者函数，那么这些都会被<code>JSON.stringify()</code>转换为<code>null</code>。</p>\n<p>正则对象会被转换成空对象。</p>\n<p><code>JSON.stringify()</code>对象还会忽略对象不可遍历的属性。</p>\n<h3 id=\"2-2-JSON-stringify-的第二个参数\"><a href=\"#2-2-JSON-stringify-的第二个参数\" class=\"headerlink\" title=\"2.2 JSON.stringify()的第二个参数\"></a>2.2 JSON.stringify()的第二个参数</h3><p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。但是这第二个参数只对对象有作用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;a&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;b&quot;</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;c&quot;</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> json = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(obj, arr);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(json);<span class=\"comment\">// &#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;</span></span><br></pre></td></tr></table></figure>"},{"title":"JavaScript的深拷贝与浅拷贝","date":"2022-09-21T16:00:00.000Z","_content":"# JS的执行机制\n\n## JS是单线程\n\nJS是单线程的，也就是说JS代码是按顺序执行的，一行一行执行的，不会出现同时执行多行代码的情况。\n\n也就是JavaScript同一时间内只能做一件事情，如果有多个任务，就必须排队，前一个任务结束，才能执行后一个任务。（比如我们对某个DOM元素进行添加删除操作室，不同同时进行，要按照顺序执行）\n\n这样就会导致一个问题：如果js执行时间过长，就会给用户一种页面加载很慢的感觉（页面渲染不连贯，页面加载阻塞）。\n\n为了解决这样一个问题，HTML5提出了Web Worker标准，允许JavaScript脚本创建多个线程，于是出现了JS的同步和异步。\n\n## 同步\n\n同步就是按照顺序执行，前一个任务结束，才能执行后一个任务。  \n程序执行的顺序与代码的顺序是一致的、同步的。\n\n同步任务都放在主线程上执行，形成了一个`执行栈`。\n\n```js\n    console.log('1');\n    setTimeout(function(){\n        console.log('2');\n    },0);\n    console.log('3');\n```\n\n在上面的代码中，同步任务有：\n|         同步任务          |\n| :-----------------------: |\n|     console.log('1');     |\n| setTimeout(function(),0); |\n|     console.log('3');     |\n\n其中setTimeout里面的函数异步任务，它会在主线程上执行完同步任务后，将异步任务放到`任务队列`中，等待主线程空闲后，再执行。\n\n## 异步\n\n异步就是不按照顺序执行，前一个任务结束，不一定要执行后一个任务。\n\nJavaScript的异步是通过回调函数来实现的。\n\n异步任务我们放在任务队列（消息队列）里面。\n\n常见的异步任务有以下三类：\n\n- 普通事件：比如click、scroll、mousemove等\n- 资源加载：比如图片加载、音频加载、文件加载等\n- 定时器：比如setTimeout、setInterval等\n\n二者的本质区别就是在程序在条流水线上各个流程的执行顺序不同。\n\n## 执行机制\n\n1. 先执行`执行栈里面的同步任务`。\n2. 如果遇到异步任务，就将异步任务放到`任务队列`中。继续执行下面的同步任务。\n3. 当执行栈里面的同步任务执行完毕，就会将任务队列里面的异步任务按照次序放到执行栈中执行。\n\n在主线程将异步任务添加到任务队列的过程中，有一个异步进程处理，当带有异步任务的同步任务执行完毕之后才会添加到任务队列中。\n\n当主线程执行完毕之后，会去任务队列中取出异步任务，放到执行栈中执行。去任务队列获取异步任务的这个过程，会一次又一次的执行。\n\n也就是主线程不断的重复获得任务、执行任务、再获取任务、在执行任务、、、，这种机制就被成为`事件循环`。","source":"_posts/JavaScript/JS的执行机制.md","raw":"---\ntitle: JavaScript的深拷贝与浅拷贝\ndate: 2022-9-22\ntags: [前端]\ncategories: [JavaScript]\n---\n# JS的执行机制\n\n## JS是单线程\n\nJS是单线程的，也就是说JS代码是按顺序执行的，一行一行执行的，不会出现同时执行多行代码的情况。\n\n也就是JavaScript同一时间内只能做一件事情，如果有多个任务，就必须排队，前一个任务结束，才能执行后一个任务。（比如我们对某个DOM元素进行添加删除操作室，不同同时进行，要按照顺序执行）\n\n这样就会导致一个问题：如果js执行时间过长，就会给用户一种页面加载很慢的感觉（页面渲染不连贯，页面加载阻塞）。\n\n为了解决这样一个问题，HTML5提出了Web Worker标准，允许JavaScript脚本创建多个线程，于是出现了JS的同步和异步。\n\n## 同步\n\n同步就是按照顺序执行，前一个任务结束，才能执行后一个任务。  \n程序执行的顺序与代码的顺序是一致的、同步的。\n\n同步任务都放在主线程上执行，形成了一个`执行栈`。\n\n```js\n    console.log('1');\n    setTimeout(function(){\n        console.log('2');\n    },0);\n    console.log('3');\n```\n\n在上面的代码中，同步任务有：\n|         同步任务          |\n| :-----------------------: |\n|     console.log('1');     |\n| setTimeout(function(),0); |\n|     console.log('3');     |\n\n其中setTimeout里面的函数异步任务，它会在主线程上执行完同步任务后，将异步任务放到`任务队列`中，等待主线程空闲后，再执行。\n\n## 异步\n\n异步就是不按照顺序执行，前一个任务结束，不一定要执行后一个任务。\n\nJavaScript的异步是通过回调函数来实现的。\n\n异步任务我们放在任务队列（消息队列）里面。\n\n常见的异步任务有以下三类：\n\n- 普通事件：比如click、scroll、mousemove等\n- 资源加载：比如图片加载、音频加载、文件加载等\n- 定时器：比如setTimeout、setInterval等\n\n二者的本质区别就是在程序在条流水线上各个流程的执行顺序不同。\n\n## 执行机制\n\n1. 先执行`执行栈里面的同步任务`。\n2. 如果遇到异步任务，就将异步任务放到`任务队列`中。继续执行下面的同步任务。\n3. 当执行栈里面的同步任务执行完毕，就会将任务队列里面的异步任务按照次序放到执行栈中执行。\n\n在主线程将异步任务添加到任务队列的过程中，有一个异步进程处理，当带有异步任务的同步任务执行完毕之后才会添加到任务队列中。\n\n当主线程执行完毕之后，会去任务队列中取出异步任务，放到执行栈中执行。去任务队列获取异步任务的这个过程，会一次又一次的执行。\n\n也就是主线程不断的重复获得任务、执行任务、再获取任务、在执行任务、、、，这种机制就被成为`事件循环`。","slug":"JavaScript/JS的执行机制","published":1,"updated":"2023-01-09T12:18:00.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi3003l9kbmhbcfgvyp","content":"<h1 id=\"JS的执行机制\"><a href=\"#JS的执行机制\" class=\"headerlink\" title=\"JS的执行机制\"></a>JS的执行机制</h1><h2 id=\"JS是单线程\"><a href=\"#JS是单线程\" class=\"headerlink\" title=\"JS是单线程\"></a>JS是单线程</h2><p>JS是单线程的，也就是说JS代码是按顺序执行的，一行一行执行的，不会出现同时执行多行代码的情况。</p>\n<p>也就是JavaScript同一时间内只能做一件事情，如果有多个任务，就必须排队，前一个任务结束，才能执行后一个任务。（比如我们对某个DOM元素进行添加删除操作室，不同同时进行，要按照顺序执行）</p>\n<p>这样就会导致一个问题：如果js执行时间过长，就会给用户一种页面加载很慢的感觉（页面渲染不连贯，页面加载阻塞）。</p>\n<p>为了解决这样一个问题，HTML5提出了Web Worker标准，允许JavaScript脚本创建多个线程，于是出现了JS的同步和异步。</p>\n<h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><p>同步就是按照顺序执行，前一个任务结束，才能执行后一个任务。<br>程序执行的顺序与代码的顺序是一致的、同步的。</p>\n<p>同步任务都放在主线程上执行，形成了一个<code>执行栈</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;2&#x27;</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，同步任务有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">同步任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">console.log(‘1’);</td>\n</tr>\n<tr>\n<td align=\"center\">setTimeout(function(),0);</td>\n</tr>\n<tr>\n<td align=\"center\">console.log(‘3’);</td>\n</tr>\n</tbody></table>\n<p>其中setTimeout里面的函数异步任务，它会在主线程上执行完同步任务后，将异步任务放到<code>任务队列</code>中，等待主线程空闲后，再执行。</p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>异步就是不按照顺序执行，前一个任务结束，不一定要执行后一个任务。</p>\n<p>JavaScript的异步是通过回调函数来实现的。</p>\n<p>异步任务我们放在任务队列（消息队列）里面。</p>\n<p>常见的异步任务有以下三类：</p>\n<ul>\n<li>普通事件：比如click、scroll、mousemove等</li>\n<li>资源加载：比如图片加载、音频加载、文件加载等</li>\n<li>定时器：比如setTimeout、setInterval等</li>\n</ul>\n<p>二者的本质区别就是在程序在条流水线上各个流程的执行顺序不同。</p>\n<h2 id=\"执行机制\"><a href=\"#执行机制\" class=\"headerlink\" title=\"执行机制\"></a>执行机制</h2><ol>\n<li>先执行<code>执行栈里面的同步任务</code>。</li>\n<li>如果遇到异步任务，就将异步任务放到<code>任务队列</code>中。继续执行下面的同步任务。</li>\n<li>当执行栈里面的同步任务执行完毕，就会将任务队列里面的异步任务按照次序放到执行栈中执行。</li>\n</ol>\n<p>在主线程将异步任务添加到任务队列的过程中，有一个异步进程处理，当带有异步任务的同步任务执行完毕之后才会添加到任务队列中。</p>\n<p>当主线程执行完毕之后，会去任务队列中取出异步任务，放到执行栈中执行。去任务队列获取异步任务的这个过程，会一次又一次的执行。</p>\n<p>也就是主线程不断的重复获得任务、执行任务、再获取任务、在执行任务、、、，这种机制就被成为<code>事件循环</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JS的执行机制\"><a href=\"#JS的执行机制\" class=\"headerlink\" title=\"JS的执行机制\"></a>JS的执行机制</h1><h2 id=\"JS是单线程\"><a href=\"#JS是单线程\" class=\"headerlink\" title=\"JS是单线程\"></a>JS是单线程</h2><p>JS是单线程的，也就是说JS代码是按顺序执行的，一行一行执行的，不会出现同时执行多行代码的情况。</p>\n<p>也就是JavaScript同一时间内只能做一件事情，如果有多个任务，就必须排队，前一个任务结束，才能执行后一个任务。（比如我们对某个DOM元素进行添加删除操作室，不同同时进行，要按照顺序执行）</p>\n<p>这样就会导致一个问题：如果js执行时间过长，就会给用户一种页面加载很慢的感觉（页面渲染不连贯，页面加载阻塞）。</p>\n<p>为了解决这样一个问题，HTML5提出了Web Worker标准，允许JavaScript脚本创建多个线程，于是出现了JS的同步和异步。</p>\n<h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><p>同步就是按照顺序执行，前一个任务结束，才能执行后一个任务。<br>程序执行的顺序与代码的顺序是一致的、同步的。</p>\n<p>同步任务都放在主线程上执行，形成了一个<code>执行栈</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;2&#x27;</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;3&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，同步任务有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">同步任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">console.log(‘1’);</td>\n</tr>\n<tr>\n<td align=\"center\">setTimeout(function(),0);</td>\n</tr>\n<tr>\n<td align=\"center\">console.log(‘3’);</td>\n</tr>\n</tbody></table>\n<p>其中setTimeout里面的函数异步任务，它会在主线程上执行完同步任务后，将异步任务放到<code>任务队列</code>中，等待主线程空闲后，再执行。</p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>异步就是不按照顺序执行，前一个任务结束，不一定要执行后一个任务。</p>\n<p>JavaScript的异步是通过回调函数来实现的。</p>\n<p>异步任务我们放在任务队列（消息队列）里面。</p>\n<p>常见的异步任务有以下三类：</p>\n<ul>\n<li>普通事件：比如click、scroll、mousemove等</li>\n<li>资源加载：比如图片加载、音频加载、文件加载等</li>\n<li>定时器：比如setTimeout、setInterval等</li>\n</ul>\n<p>二者的本质区别就是在程序在条流水线上各个流程的执行顺序不同。</p>\n<h2 id=\"执行机制\"><a href=\"#执行机制\" class=\"headerlink\" title=\"执行机制\"></a>执行机制</h2><ol>\n<li>先执行<code>执行栈里面的同步任务</code>。</li>\n<li>如果遇到异步任务，就将异步任务放到<code>任务队列</code>中。继续执行下面的同步任务。</li>\n<li>当执行栈里面的同步任务执行完毕，就会将任务队列里面的异步任务按照次序放到执行栈中执行。</li>\n</ol>\n<p>在主线程将异步任务添加到任务队列的过程中，有一个异步进程处理，当带有异步任务的同步任务执行完毕之后才会添加到任务队列中。</p>\n<p>当主线程执行完毕之后，会去任务队列中取出异步任务，放到执行栈中执行。去任务队列获取异步任务的这个过程，会一次又一次的执行。</p>\n<p>也就是主线程不断的重复获得任务、执行任务、再获取任务、在执行任务、、、，这种机制就被成为<code>事件循环</code>。</p>\n"},{"title":"JavaScript  ES5中的继承","date":"2023-05-17T16:00:00.000Z","_content":"# JavaScript  ES5中的继承\n\n1. 对象和函数的原型\n2. new 、constructor\n3. 原型链的查找顺序\n4. 原型链实现的继承\n5. 借用构造函数实现继承\n6. 寄生组合实现继承\n\n# 1. 对象和函数的原型\n\n- 获取对象的原型方式\n    1. obj.__proto__：有兼容性问题\n    2. Object.getPrototyprOf(obj)\n\n当我们想获取一个属性的值时，如果在自己的对象中查找，找到直接返回，否则沿着原型链向上查找。\n\n在JavaScript中，每一个对象都有一个特殊内置属性[[prototype]]\n\n## 1.1函数的原型\n\n所有的函数都有一个prototype属性，不是__proto__。\n\n1. 将函数看成是一个普通的对象时，它是具备__proto__（隐式原型）\n\n```jsx\nfunction foo() { }\nconsole.log(foo.__proto__);\n```\n\n1. 将函数看成一个函数的时候，它是具备prototype的\n\n```jsx\nfunction foo() { }\nconsole.log(foo.prototype);\n```\n\n对象是没有`prototype`原型的，这个是显式原型。\n\n这个原型的作用是用来构建对象时，给对象设置隐式原型。\n\n# 2. new、constructor\n\n## 2.1 new操作符\n\n1. 创建空对象\n2. 将这个空对象赋值给this\n3. 将函数的显式原型赋值给对象，作为该对象的隐式原型\n    1. `obj.__proto__ = Person.prototype`\n4. 执行函数体代码\n5. 将这个对象默认返回\n\n**原型的作用：**\n\n- 多个对象拥有共同的值，我们可以将它放到构造函数对象的原型里面，有构造函数创建出来的对象，都可以共享这些属性。\n\n## 2.2 constructor属性\n\n默认情况下，原型对象上有一个constructor属性，这个constructor指向当前函数对象。\n\n## 2.3 重写原型对象\n\n当我们需要向原型对象添加过多的属性，我们可以选择重写原型。\n\n```jsx\nfunction Perso(){\n\t\n}\n\nPerson.prototype = {\n\tmessage:\"11\",\n\tinfo:{name:\"11\",age:30},\n\trunning: function (){},\n\teating: function(){},\n\tconstructor:Person, //添加constructor属性\n}\n```\n\n但是上面这种方式添加constructor属性，会导致constructor可以被遍历。\n\n更好的方式通过Object.defineProperty():`Object.defineProperty(Person.prototype,”constructor”,{value:Person})`\n\n# 3. 面向对象的特征-继承\n\n在ES5中实现继承。\n\n使用原型链。\n\n## 3.1 什么是原型链\n\n我们从一个对象获取属性时，如果在当前对象中没有查找到，就会顺着原型向上查找，一层一层向上查找，这就原型链。\n\n原型链的顶层为Object。\n\n在Object中的原型中，值为null，该对象上有很多默认的属性和方法。\n\n## 3.2 通过原型链实现方法继承\n\n- 方式一： 父类的原型直接赋值给子类的原型（错误）\n\n这样会导致子类修改原型对象的时候，将父类的原型对象也更改了。\n\n- 方法二：创建一个父类的实例对象（new Person()），用这个实例作为子类的原型独享。\n\n```jsx\n// 定一个构造函数\nfunction Person (name,age){\n    this.name = name;\n    this.age = age;\n}\n\n// 定义学生类\nfunction Student(name,age,id,score){\n    this.name = name;\n    this.age = age;\n    this.id = id;\n    this.score = score;\n}\n\nvar p = new Person(\"hmbb\",12);\nStudent.prototype = p;\nStudent.prototype.studying = function (){\n    console.log(\"learning\");\n}\n\nvar stu1 = new Student(\"hmbb\",12,111,100);\nstu1.studying();\n```\n\n**原型链存在的弊端：某些属性保存在p对象上**\n\n- 直接打印对象，看不到我们想要的属性\n- 会被多个对象共享\n- 不能给Person传递参数\n\n## 3.3借用构造函数实现属性继承\n\n在子类的函数内部调用父类的函数。\n\n```jsx\n// 定一个构造函数\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\n// 定义学生类\nfunction Student(name, age, id, score) {\n    Person.call(this, [name, age]);\n    // this.name = name;\n    // this.age = age;\n    this.id = id;\n    this.score = score;\n}\n```\n\n## 3.4 组合继承\n\n组合继承是JavaScript最常用的继承方式之一。 \n\n## 3.5创造原型对象的方法\n\n**满足的条件**\n\n1. 必须创建出一个对象\n2. 这个对象的隐式原型必须指向父类的显示原型\n3. 将这个对象赋值给予子类的显式原型\n\n方案一：(不好)\n\n```jsx\nvar p = new Person();\n Student.prototype = p;\n```\n\n方案二：\n\n```jsx\nvar obj = {};\nObject.setPrototype(obj,Person.prototype);\nStudent.prototype = obj;\n```\n\n方案三：\n\n```jsx\nfunction F(){};\nF.prototype = Person.prototype;\nStudent.prototype = new F();\n```\n\n方案四：\n\n```jsx\nvar obj = Object.create(Person.prototype);\n```\n\n使用Object.create()方法创建对象，并且将这个对象的原型指向传入的那个原型对象。\n\n**封装实践**","source":"_posts/JavaScript/JavaScriptES5中的继承.md","raw":"---\ntitle: JavaScript  ES5中的继承\ndate: [2023-5-18]\ntags: [前端]\ncategories: [JavaScript]\n---\n# JavaScript  ES5中的继承\n\n1. 对象和函数的原型\n2. new 、constructor\n3. 原型链的查找顺序\n4. 原型链实现的继承\n5. 借用构造函数实现继承\n6. 寄生组合实现继承\n\n# 1. 对象和函数的原型\n\n- 获取对象的原型方式\n    1. obj.__proto__：有兼容性问题\n    2. Object.getPrototyprOf(obj)\n\n当我们想获取一个属性的值时，如果在自己的对象中查找，找到直接返回，否则沿着原型链向上查找。\n\n在JavaScript中，每一个对象都有一个特殊内置属性[[prototype]]\n\n## 1.1函数的原型\n\n所有的函数都有一个prototype属性，不是__proto__。\n\n1. 将函数看成是一个普通的对象时，它是具备__proto__（隐式原型）\n\n```jsx\nfunction foo() { }\nconsole.log(foo.__proto__);\n```\n\n1. 将函数看成一个函数的时候，它是具备prototype的\n\n```jsx\nfunction foo() { }\nconsole.log(foo.prototype);\n```\n\n对象是没有`prototype`原型的，这个是显式原型。\n\n这个原型的作用是用来构建对象时，给对象设置隐式原型。\n\n# 2. new、constructor\n\n## 2.1 new操作符\n\n1. 创建空对象\n2. 将这个空对象赋值给this\n3. 将函数的显式原型赋值给对象，作为该对象的隐式原型\n    1. `obj.__proto__ = Person.prototype`\n4. 执行函数体代码\n5. 将这个对象默认返回\n\n**原型的作用：**\n\n- 多个对象拥有共同的值，我们可以将它放到构造函数对象的原型里面，有构造函数创建出来的对象，都可以共享这些属性。\n\n## 2.2 constructor属性\n\n默认情况下，原型对象上有一个constructor属性，这个constructor指向当前函数对象。\n\n## 2.3 重写原型对象\n\n当我们需要向原型对象添加过多的属性，我们可以选择重写原型。\n\n```jsx\nfunction Perso(){\n\t\n}\n\nPerson.prototype = {\n\tmessage:\"11\",\n\tinfo:{name:\"11\",age:30},\n\trunning: function (){},\n\teating: function(){},\n\tconstructor:Person, //添加constructor属性\n}\n```\n\n但是上面这种方式添加constructor属性，会导致constructor可以被遍历。\n\n更好的方式通过Object.defineProperty():`Object.defineProperty(Person.prototype,”constructor”,{value:Person})`\n\n# 3. 面向对象的特征-继承\n\n在ES5中实现继承。\n\n使用原型链。\n\n## 3.1 什么是原型链\n\n我们从一个对象获取属性时，如果在当前对象中没有查找到，就会顺着原型向上查找，一层一层向上查找，这就原型链。\n\n原型链的顶层为Object。\n\n在Object中的原型中，值为null，该对象上有很多默认的属性和方法。\n\n## 3.2 通过原型链实现方法继承\n\n- 方式一： 父类的原型直接赋值给子类的原型（错误）\n\n这样会导致子类修改原型对象的时候，将父类的原型对象也更改了。\n\n- 方法二：创建一个父类的实例对象（new Person()），用这个实例作为子类的原型独享。\n\n```jsx\n// 定一个构造函数\nfunction Person (name,age){\n    this.name = name;\n    this.age = age;\n}\n\n// 定义学生类\nfunction Student(name,age,id,score){\n    this.name = name;\n    this.age = age;\n    this.id = id;\n    this.score = score;\n}\n\nvar p = new Person(\"hmbb\",12);\nStudent.prototype = p;\nStudent.prototype.studying = function (){\n    console.log(\"learning\");\n}\n\nvar stu1 = new Student(\"hmbb\",12,111,100);\nstu1.studying();\n```\n\n**原型链存在的弊端：某些属性保存在p对象上**\n\n- 直接打印对象，看不到我们想要的属性\n- 会被多个对象共享\n- 不能给Person传递参数\n\n## 3.3借用构造函数实现属性继承\n\n在子类的函数内部调用父类的函数。\n\n```jsx\n// 定一个构造函数\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\n// 定义学生类\nfunction Student(name, age, id, score) {\n    Person.call(this, [name, age]);\n    // this.name = name;\n    // this.age = age;\n    this.id = id;\n    this.score = score;\n}\n```\n\n## 3.4 组合继承\n\n组合继承是JavaScript最常用的继承方式之一。 \n\n## 3.5创造原型对象的方法\n\n**满足的条件**\n\n1. 必须创建出一个对象\n2. 这个对象的隐式原型必须指向父类的显示原型\n3. 将这个对象赋值给予子类的显式原型\n\n方案一：(不好)\n\n```jsx\nvar p = new Person();\n Student.prototype = p;\n```\n\n方案二：\n\n```jsx\nvar obj = {};\nObject.setPrototype(obj,Person.prototype);\nStudent.prototype = obj;\n```\n\n方案三：\n\n```jsx\nfunction F(){};\nF.prototype = Person.prototype;\nStudent.prototype = new F();\n```\n\n方案四：\n\n```jsx\nvar obj = Object.create(Person.prototype);\n```\n\n使用Object.create()方法创建对象，并且将这个对象的原型指向传入的那个原型对象。\n\n**封装实践**","slug":"JavaScript/JavaScriptES5中的继承","published":1,"updated":"2023-05-22T11:38:17.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi4003p9kbm1cm4h7c1","content":"<h1 id=\"JavaScript-ES5中的继承\"><a href=\"#JavaScript-ES5中的继承\" class=\"headerlink\" title=\"JavaScript  ES5中的继承\"></a>JavaScript  ES5中的继承</h1><ol>\n<li>对象和函数的原型</li>\n<li>new 、constructor</li>\n<li>原型链的查找顺序</li>\n<li>原型链实现的继承</li>\n<li>借用构造函数实现继承</li>\n<li>寄生组合实现继承</li>\n</ol>\n<h1 id=\"1-对象和函数的原型\"><a href=\"#1-对象和函数的原型\" class=\"headerlink\" title=\"1. 对象和函数的原型\"></a>1. 对象和函数的原型</h1><ul>\n<li>获取对象的原型方式<ol>\n<li>obj.__proto__：有兼容性问题</li>\n<li>Object.getPrototyprOf(obj)</li>\n</ol>\n</li>\n</ul>\n<p>当我们想获取一个属性的值时，如果在自己的对象中查找，找到直接返回，否则沿着原型链向上查找。</p>\n<p>在JavaScript中，每一个对象都有一个特殊内置属性[[prototype]]</p>\n<h2 id=\"1-1函数的原型\"><a href=\"#1-1函数的原型\" class=\"headerlink\" title=\"1.1函数的原型\"></a>1.1函数的原型</h2><p>所有的函数都有一个prototype属性，不是__proto__。</p>\n<ol>\n<li>将函数看成是一个普通的对象时，它是具备__proto__（隐式原型）</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo.<span class=\"property\">__proto__</span>);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>将函数看成一个函数的时候，它是具备prototype的</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br></pre></td></tr></table></figure>\n\n<p>对象是没有<code>prototype</code>原型的，这个是显式原型。</p>\n<p>这个原型的作用是用来构建对象时，给对象设置隐式原型。</p>\n<h1 id=\"2-new、constructor\"><a href=\"#2-new、constructor\" class=\"headerlink\" title=\"2. new、constructor\"></a>2. new、constructor</h1><h2 id=\"2-1-new操作符\"><a href=\"#2-1-new操作符\" class=\"headerlink\" title=\"2.1 new操作符\"></a>2.1 new操作符</h2><ol>\n<li>创建空对象</li>\n<li>将这个空对象赋值给this</li>\n<li>将函数的显式原型赋值给对象，作为该对象的隐式原型<ol>\n<li><code>obj.__proto__ = Person.prototype</code></li>\n</ol>\n</li>\n<li>执行函数体代码</li>\n<li>将这个对象默认返回</li>\n</ol>\n<p><strong>原型的作用：</strong></p>\n<ul>\n<li>多个对象拥有共同的值，我们可以将它放到构造函数对象的原型里面，有构造函数创建出来的对象，都可以共享这些属性。</li>\n</ul>\n<h2 id=\"2-2-constructor属性\"><a href=\"#2-2-constructor属性\" class=\"headerlink\" title=\"2.2 constructor属性\"></a>2.2 constructor属性</h2><p>默认情况下，原型对象上有一个constructor属性，这个constructor指向当前函数对象。</p>\n<h2 id=\"2-3-重写原型对象\"><a href=\"#2-3-重写原型对象\" class=\"headerlink\" title=\"2.3 重写原型对象\"></a>2.3 重写原型对象</h2><p>当我们需要向原型对象添加过多的属性，我们可以选择重写原型。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Perso</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">message</span>:<span class=\"string\">&quot;11&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">info</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;11&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">\t<span class=\"attr\">running</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>)&#123;&#125;,</span><br><span class=\"line\">\t<span class=\"attr\">eating</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;,</span><br><span class=\"line\">\t<span class=\"attr\">constructor</span>:<span class=\"title class_\">Person</span>, <span class=\"comment\">//添加constructor属性</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是上面这种方式添加constructor属性，会导致constructor可以被遍历。</p>\n<p>更好的方式通过Object.defineProperty():<code>Object.defineProperty(Person.prototype,”constructor”,&#123;value:Person&#125;)</code></p>\n<h1 id=\"3-面向对象的特征-继承\"><a href=\"#3-面向对象的特征-继承\" class=\"headerlink\" title=\"3. 面向对象的特征-继承\"></a>3. 面向对象的特征-继承</h1><p>在ES5中实现继承。</p>\n<p>使用原型链。</p>\n<h2 id=\"3-1-什么是原型链\"><a href=\"#3-1-什么是原型链\" class=\"headerlink\" title=\"3.1 什么是原型链\"></a>3.1 什么是原型链</h2><p>我们从一个对象获取属性时，如果在当前对象中没有查找到，就会顺着原型向上查找，一层一层向上查找，这就原型链。</p>\n<p>原型链的顶层为Object。</p>\n<p>在Object中的原型中，值为null，该对象上有很多默认的属性和方法。</p>\n<h2 id=\"3-2-通过原型链实现方法继承\"><a href=\"#3-2-通过原型链实现方法继承\" class=\"headerlink\" title=\"3.2 通过原型链实现方法继承\"></a>3.2 通过原型链实现方法继承</h2><ul>\n<li>方式一： 父类的原型直接赋值给子类的原型（错误）</li>\n</ul>\n<p>这样会导致子类修改原型对象的时候，将父类的原型对象也更改了。</p>\n<ul>\n<li>方法二：创建一个父类的实例对象（new Person()），用这个实例作为子类的原型独享。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定一个构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span> (name,age)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义学生类</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Student</span>(<span class=\"params\">name,age,id,score</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = id;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">score</span> = score;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;hmbb&quot;</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = p;</span><br><span class=\"line\"><span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">studying</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;learning&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stu1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;hmbb&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">111</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">stu1.<span class=\"title function_\">studying</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>原型链存在的弊端：某些属性保存在p对象上</strong></p>\n<ul>\n<li>直接打印对象，看不到我们想要的属性</li>\n<li>会被多个对象共享</li>\n<li>不能给Person传递参数</li>\n</ul>\n<h2 id=\"3-3借用构造函数实现属性继承\"><a href=\"#3-3借用构造函数实现属性继承\" class=\"headerlink\" title=\"3.3借用构造函数实现属性继承\"></a>3.3借用构造函数实现属性继承</h2><p>在子类的函数内部调用父类的函数。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定一个构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义学生类</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Student</span>(<span class=\"params\">name, age, id, score</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Person</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, [name, age]);</span><br><span class=\"line\">    <span class=\"comment\">// this.name = name;</span></span><br><span class=\"line\">    <span class=\"comment\">// this.age = age;</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = id;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">score</span> = score;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4-组合继承\"><a href=\"#3-4-组合继承\" class=\"headerlink\" title=\"3.4 组合继承\"></a>3.4 组合继承</h2><p>组合继承是JavaScript最常用的继承方式之一。 </p>\n<h2 id=\"3-5创造原型对象的方法\"><a href=\"#3-5创造原型对象的方法\" class=\"headerlink\" title=\"3.5创造原型对象的方法\"></a>3.5创造原型对象的方法</h2><p><strong>满足的条件</strong></p>\n<ol>\n<li>必须创建出一个对象</li>\n<li>这个对象的隐式原型必须指向父类的显示原型</li>\n<li>将这个对象赋值给予子类的显式原型</li>\n</ol>\n<p>方案一：(不好)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"> <span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = p;</span><br></pre></td></tr></table></figure>\n\n<p>方案二：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">setPrototype</span>(obj,<span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\"><span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = obj;</span><br></pre></td></tr></table></figure>\n\n<p>方案三：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>)&#123;&#125;;</span><br><span class=\"line\">F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\"><span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();</span><br></pre></td></tr></table></figure>\n\n<p>方案四：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用Object.create()方法创建对象，并且将这个对象的原型指向传入的那个原型对象。</p>\n<p><strong>封装实践</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-ES5中的继承\"><a href=\"#JavaScript-ES5中的继承\" class=\"headerlink\" title=\"JavaScript  ES5中的继承\"></a>JavaScript  ES5中的继承</h1><ol>\n<li>对象和函数的原型</li>\n<li>new 、constructor</li>\n<li>原型链的查找顺序</li>\n<li>原型链实现的继承</li>\n<li>借用构造函数实现继承</li>\n<li>寄生组合实现继承</li>\n</ol>\n<h1 id=\"1-对象和函数的原型\"><a href=\"#1-对象和函数的原型\" class=\"headerlink\" title=\"1. 对象和函数的原型\"></a>1. 对象和函数的原型</h1><ul>\n<li>获取对象的原型方式<ol>\n<li>obj.__proto__：有兼容性问题</li>\n<li>Object.getPrototyprOf(obj)</li>\n</ol>\n</li>\n</ul>\n<p>当我们想获取一个属性的值时，如果在自己的对象中查找，找到直接返回，否则沿着原型链向上查找。</p>\n<p>在JavaScript中，每一个对象都有一个特殊内置属性[[prototype]]</p>\n<h2 id=\"1-1函数的原型\"><a href=\"#1-1函数的原型\" class=\"headerlink\" title=\"1.1函数的原型\"></a>1.1函数的原型</h2><p>所有的函数都有一个prototype属性，不是__proto__。</p>\n<ol>\n<li>将函数看成是一个普通的对象时，它是具备__proto__（隐式原型）</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo.<span class=\"property\">__proto__</span>);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>将函数看成一个函数的时候，它是具备prototype的</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br></pre></td></tr></table></figure>\n\n<p>对象是没有<code>prototype</code>原型的，这个是显式原型。</p>\n<p>这个原型的作用是用来构建对象时，给对象设置隐式原型。</p>\n<h1 id=\"2-new、constructor\"><a href=\"#2-new、constructor\" class=\"headerlink\" title=\"2. new、constructor\"></a>2. new、constructor</h1><h2 id=\"2-1-new操作符\"><a href=\"#2-1-new操作符\" class=\"headerlink\" title=\"2.1 new操作符\"></a>2.1 new操作符</h2><ol>\n<li>创建空对象</li>\n<li>将这个空对象赋值给this</li>\n<li>将函数的显式原型赋值给对象，作为该对象的隐式原型<ol>\n<li><code>obj.__proto__ = Person.prototype</code></li>\n</ol>\n</li>\n<li>执行函数体代码</li>\n<li>将这个对象默认返回</li>\n</ol>\n<p><strong>原型的作用：</strong></p>\n<ul>\n<li>多个对象拥有共同的值，我们可以将它放到构造函数对象的原型里面，有构造函数创建出来的对象，都可以共享这些属性。</li>\n</ul>\n<h2 id=\"2-2-constructor属性\"><a href=\"#2-2-constructor属性\" class=\"headerlink\" title=\"2.2 constructor属性\"></a>2.2 constructor属性</h2><p>默认情况下，原型对象上有一个constructor属性，这个constructor指向当前函数对象。</p>\n<h2 id=\"2-3-重写原型对象\"><a href=\"#2-3-重写原型对象\" class=\"headerlink\" title=\"2.3 重写原型对象\"></a>2.3 重写原型对象</h2><p>当我们需要向原型对象添加过多的属性，我们可以选择重写原型。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Perso</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">message</span>:<span class=\"string\">&quot;11&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">info</span>:&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;11&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">\t<span class=\"attr\">running</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>)&#123;&#125;,</span><br><span class=\"line\">\t<span class=\"attr\">eating</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;,</span><br><span class=\"line\">\t<span class=\"attr\">constructor</span>:<span class=\"title class_\">Person</span>, <span class=\"comment\">//添加constructor属性</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是上面这种方式添加constructor属性，会导致constructor可以被遍历。</p>\n<p>更好的方式通过Object.defineProperty():<code>Object.defineProperty(Person.prototype,”constructor”,&#123;value:Person&#125;)</code></p>\n<h1 id=\"3-面向对象的特征-继承\"><a href=\"#3-面向对象的特征-继承\" class=\"headerlink\" title=\"3. 面向对象的特征-继承\"></a>3. 面向对象的特征-继承</h1><p>在ES5中实现继承。</p>\n<p>使用原型链。</p>\n<h2 id=\"3-1-什么是原型链\"><a href=\"#3-1-什么是原型链\" class=\"headerlink\" title=\"3.1 什么是原型链\"></a>3.1 什么是原型链</h2><p>我们从一个对象获取属性时，如果在当前对象中没有查找到，就会顺着原型向上查找，一层一层向上查找，这就原型链。</p>\n<p>原型链的顶层为Object。</p>\n<p>在Object中的原型中，值为null，该对象上有很多默认的属性和方法。</p>\n<h2 id=\"3-2-通过原型链实现方法继承\"><a href=\"#3-2-通过原型链实现方法继承\" class=\"headerlink\" title=\"3.2 通过原型链实现方法继承\"></a>3.2 通过原型链实现方法继承</h2><ul>\n<li>方式一： 父类的原型直接赋值给子类的原型（错误）</li>\n</ul>\n<p>这样会导致子类修改原型对象的时候，将父类的原型对象也更改了。</p>\n<ul>\n<li>方法二：创建一个父类的实例对象（new Person()），用这个实例作为子类的原型独享。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定一个构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span> (name,age)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义学生类</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Student</span>(<span class=\"params\">name,age,id,score</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = id;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">score</span> = score;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;hmbb&quot;</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = p;</span><br><span class=\"line\"><span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">studying</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;learning&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stu1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;hmbb&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">111</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">stu1.<span class=\"title function_\">studying</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>原型链存在的弊端：某些属性保存在p对象上</strong></p>\n<ul>\n<li>直接打印对象，看不到我们想要的属性</li>\n<li>会被多个对象共享</li>\n<li>不能给Person传递参数</li>\n</ul>\n<h2 id=\"3-3借用构造函数实现属性继承\"><a href=\"#3-3借用构造函数实现属性继承\" class=\"headerlink\" title=\"3.3借用构造函数实现属性继承\"></a>3.3借用构造函数实现属性继承</h2><p>在子类的函数内部调用父类的函数。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定一个构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义学生类</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Student</span>(<span class=\"params\">name, age, id, score</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Person</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, [name, age]);</span><br><span class=\"line\">    <span class=\"comment\">// this.name = name;</span></span><br><span class=\"line\">    <span class=\"comment\">// this.age = age;</span></span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">id</span> = id;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">score</span> = score;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4-组合继承\"><a href=\"#3-4-组合继承\" class=\"headerlink\" title=\"3.4 组合继承\"></a>3.4 组合继承</h2><p>组合继承是JavaScript最常用的继承方式之一。 </p>\n<h2 id=\"3-5创造原型对象的方法\"><a href=\"#3-5创造原型对象的方法\" class=\"headerlink\" title=\"3.5创造原型对象的方法\"></a>3.5创造原型对象的方法</h2><p><strong>满足的条件</strong></p>\n<ol>\n<li>必须创建出一个对象</li>\n<li>这个对象的隐式原型必须指向父类的显示原型</li>\n<li>将这个对象赋值给予子类的显式原型</li>\n</ol>\n<p>方案一：(不好)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"> <span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = p;</span><br></pre></td></tr></table></figure>\n\n<p>方案二：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">setPrototype</span>(obj,<span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\"><span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = obj;</span><br></pre></td></tr></table></figure>\n\n<p>方案三：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>)&#123;&#125;;</span><br><span class=\"line\">F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\"><span class=\"title class_\">Student</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();</span><br></pre></td></tr></table></figure>\n\n<p>方案四：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用Object.create()方法创建对象，并且将这个对象的原型指向传入的那个原型对象。</p>\n<p><strong>封装实践</strong></p>\n"},{"title":"JavaScript中ES6第二弹","date":"2023-05-21T16:00:00.000Z","_content":"# JavaScript中ES6第二弹\n\n- 模板字符串\n- ES6函数增强用法\n- 展开运算符使用\n- Symbol类型\n- 数据结构-Set\n- 数据结构-Map\n\n# 1.模板字符串\n\n## 1.1 模板字符串基本使用\n\n我们使用模板字符串可以将一些动态的数据与字符串组合在一起。\n\n```jsx\nconst info = `this is my name:${name}`;\n```\n\n使用反引号来编写字符串，使用`${}`编写动态数据\n\n# 2. ES6的函数增强\n\n## 2.1 函数的默认参数\n\n```jsx\nfunction foo(arg1 = \"默认值1\",arg2 = \"默认值2\"){\n\t// 函数体\n}\n```\n\n当调用函数的时候，没有给对应参数传递参数的时候，JS就会使用默认值。\n\n**注意事项：**\n\n- 有默认参数的形参尽量写在后面\n- 有默认参数的形参，不会计算在length之内的（并且后面的所有参数都不会计算在length之内）。比如一个函数全有默认参数，那么参数长度就为0。\n- 如果参数还有剩余参数，那么剩余参数放在最后面。（默认参数的位置放在剩余参数前面）\n\n默认参数也可以和解构一起使用：\n\n```jsx\nconst obj = {\n\tname:\"as\",\n\tage:12,\n}\n\nfunction foo({name,age} = obj){\n\t// 方法体\n}\n\n// 如果传入的是一个空对象\nfunction foo1({name = \"asd\",age = 12} = {}){\n\t// 方法体\n}\n```\n\n## 2.2 箭头函数\n\n箭头函数没有显式原型，不可以将箭头函数作为构造函数，不可以使用new来构造新的对象。\n\n```jsx\nvar foo = () => {\n\t// 函数体\n}\n\nconsole.log(foo.prototype); // undefined\n```\n\n# 3. 展开语法\n\n- 可以函数调用/数组构造时，将数组表达式或者String在语法层面展开\n- 在构造字面量的时候，将对象表达式以key-value的方式展开\n\n```jsx\nconst name = [\"as\",\"qw\",\"sf\"]\nconsole.log(...name); // as qw sf\n\nconst str = \"zmlzmlz\";\nconsole.log(...str); // z m l z m l z\n\n// ES9之后还可以展开对象(在构建字面量时)\nconst obj = {\n\tname:\"qwe\",\n\tage:18,\n}\nconst info = {\n\t...obj,\n\theight:1.99,\n}\nconsole.log(info);\n\n// 结果\n//{name: 'qwe', age: 18, height: 1.99}\n//age\n//: \n//18\n//height\n//: \n//1.99\n//name\n//: \n//\"qwe\"\n//[[Prototype]]\n//: \n//Object\n```\n\n## 3.2 引用类型拷贝\n\n赋值引用类型：\n\n```jsx\nconst obj = {\n\tname:\"qwe\",\n\tage:18,\n}\n\nlet info = obj;\ninfo.name = \"asd\";\nconsole.log(obj.name); // \"asd\"\n```\n\n引用赋值存在的问题，多个变量操作的都是同一个对象，一个改编，全部改变。\n\n**浅拷贝：**\n\n```jsx\nconst obj = {\n\tname:\"qwe\",\n\tage:18,\n\tfirend:{\n\t\tname:\"zmlzml\",\n\t}\n}\n\nlet info = {\n\t...obj,\n}\n\ninfo.name = \"hmbb\";\ninfo.firend.name = \"pai\",\nconsole.log(info.name); // hmbb\nconsole.log(obj.name); // qwe\n\nconsole.log(info.firend.name); // pai\nconsole.log(obj.firend.name);  // pai\n```\n\n之前的操作同一对象的问题有所改善，但是还没有完全解决。\n\n**深拷贝：**\n\n方法一：第三方库\n\n方法二：自己实现\n\n方式三：利用现有的js机制，实现深拷贝JSON\n\n```jsx\nconst obj = {\n\tname:\"qwe\",\n\tage:18,\n\tfirend:{\n\t\tname:\"zmlzml\",\n\t}\n}\n\nconst info = JSON.parse(JSON.stringify(obj));\n\ninfo.firend.name = \"hmbb\";\nconsole.log(info.firend.name); // \"hmbb\"\nconsole.log(obj.firend.name); // \"zmlzml\"\n```\n\n# 3. 数值表示\n\n- 二进制：0b\n- 八进制：0o\n- 十六进制：0x\n\nES2021新增特性：当数字过长时，可以使用`_`作为连接符。\n\n# 4.Symbol基本使用\n\n解决了对象属性名的命名冲突。\n\nSymbol用于生成一个独一无二的值。\n\n```jsx\nconst s1 = Symbol();\n\nlet obj = {\n\t[s1]:\"asda\",\n}\n\nconsole.log(obj);\n```\n\n在Symbol创建的时候，可以传入一个描述。ES2019新增。\n\n```jsx\nconst s1 = Symbol();\nconst s2 = Symbol()';\n\n// 加入对象中\nconst obj = {\n\t[s1]:\"asd\",\n}\n\nObject.defineProperty(obj,si,{\n\tvalue :\"aaa\",\n})\n\n// 或者Symbol对应的key\nconsole.log(Object.keys(obj)); // 获取不到Symbol\nconsole.log(Object.getOwnPropetySymbols(obj));\n\n// Symbol的描述(创建的时候传入)\nconst s3 = Symbol(\"描述\");\nconsole.log(s3.description);\n```\n\n即使创建的时候，传入的描述是一样的，但是创建出来的Symbol还是不一样。\n\n生成相同的Symbol：\n\n- 使用Symbol.for方法创建相同的Symbol\n    - 如果有相同的key(传入的描述)，通过Symbol.for可以生成相同的Symbol值\n- 使用Symbol.keyFor方法获取对象的key\n\n```jsx\nconst s1 = Symbol(\"aaa\");\nconst s2 = Symbol.for(s1.description);\nconst s3 = Symbol.for(s1.description);\n\nconsole.log(s3 === s2); // true\n```\n\n# 5. Set与WeakSet的基本使用\n\n**SET**\n\nset里面存放的数据是不会重复的，所以我们可以利用这个特性给数组去重。\n\n创建一个空set:\n\n```jsx\nconst arr = new set();\n```\n\n给set添加元素：\n\n```jsx\nconst arr = new Set();\nlet obj = {\n\tname:\"asd\",\n\tage:18,\n}\n\narr.add(\"str\");\narr.add(12);\narr.add(obj);\n\nconsole.log(arr);\n```\n\n用处：给数组去重\n\n```jsx\nlet arr = [1,2,2,3,4,4,5,5,6,7,8,9,9];\nlet set = new Set();\nfor (const i of arr) {\n    set.add(i);\n}\narr = Array.from(set);\nconsole.log(arr);\n```\n\nset常见的属性以及方法：\n\n- size：获取set里面的元素个数\n- add()：添加元素\n- delete(value):从set删除指定与元素\n- has(value)：是否包含某个元素\n- clean():清空整个Set\n- for  each遍历\n- for  of遍历\n\n**WEAKSET**\n\n与Set类似，也是不能存放重复的数据。\n\n与Set的区别：\n\n- WeakSet只能存放对象类型，不可以存放基本数据类型\n- WeakSet对元素的引用是弱引用，若没有其他引用对其某个元素的一弄，那么GC（垃圾回收机制）就会对该对象进行回收。\n\n```jsx\n// 默认情况下，都为强引用\nlet obj1 = {\n    name: \"qw\",\n}\nlet obj2 = {\n    name: \"asd\",\n}\nlet obj3 = {\n    name: \"er\",\n}\nlet arr = [obj1, obj2, obj3];\nobj1 = null;\nobj2 = null;\nobj3 = null;\n// 对象赋值为空之后，arr依然对其有引用，所以不会被GC回收\n```\n\n只能存放对象：\n\n```jsx\nlet obj1 = {\n    name: \"qw\",\n}\nlet obj2 = {\n    name: \"asd\",\n}\nlet obj3 = {\n    name: \"er\",\n}\n\n// 区别一：WeakSet只能存放对象\nconst ws = new WeakSet();\nws.add(obj1);\nws.add(obj2);\n// ws.add(12);  报错\nconsole.log(ws);\n```\n\n常见的方法：\n\n- add():添加元素\n- delete（value）：删除指定元素\n- has（value）：是否包含某个元素\n\n**注意：**\n\nWeakSet不能被遍历，因为里面的元素可能下一秒就被GC回收了，所以存放在WeakSet的元素是没有办法获取的。\n\n# 6. Map与WeakMap的基本使用\n\n**Map**\n\nMap与对象有点类似，都是以键值对存储。用于存储映射关系。\n\n但是对象Key只能用字符串或者Symbol，而Map可以用任何数据形式作为Key。 \n\n- 对象使用对象作为Key，会导致Key值为Object，最后一个为Object的键值对会覆盖之前的数据。\n    \n    ```jsx\n    let obj = {\n    \tname:\"q\",\n    }\n    let obj2 = {\n    \tname:\"s\",\n    }\n    \n    let test = {\n    \t[obj]:\"12\",\n    \t[obj2]:\"zml\",\n    }\n    \n    console.log(test); // [object Object]: \"zml\"\n    ```\n    \n\nMap常见的属性及其方法：\n\n- size：获取Map中元素的个数\n- set(key,value)：添加元素，返回整个Map对象\n- get(key)：根据key获取Map中的value\n- has（key）:根据key判断该元素是否在Map中\n- delete（key）:根据key删除指定元素\n- clear():清空所有元素\n- forEach（callback,[,thisArg]）：遍历元素\n\n**WeakMap:**\n\nWeakMap的key只能使用对象，不接受其他的类型作为key。\n\nWeakMap对对象的引用是弱引用，如果没有其他引用指向该对象，该对象就会被GC回收。\n\nWeakMap常见方法：\n\n- set(key,value)：添加元素，返回整个WeakMap对象\n- get(key)：根据key获取WeakMap中的value\n- has（key）:根据key判断该元素是否在Weak Map中\n- delete（key）:根据key删除指定元素\n\nWeakMap不支持遍历。\n\n# 7. ES7~ES13新特性\n\n## 7.1 字符串填充方法\n\n```jsx\nconst str1 = \"5\";\nconst str2 = \"5\";\n\nstr1.padStart(2, \"0\");\nstr2.padEnd(2, \"0\");\nconsole.log(`${str1}, ${str2}`);\n```\n\n通常用于时间的格式化。","source":"_posts/JavaScript/JavaScriptES6第二弹.md","raw":"---\ntitle: JavaScript中ES6第二弹\ndate: [2023-5-22]\ntags: [前端]\ncategories: [JavaScript]\n---\n# JavaScript中ES6第二弹\n\n- 模板字符串\n- ES6函数增强用法\n- 展开运算符使用\n- Symbol类型\n- 数据结构-Set\n- 数据结构-Map\n\n# 1.模板字符串\n\n## 1.1 模板字符串基本使用\n\n我们使用模板字符串可以将一些动态的数据与字符串组合在一起。\n\n```jsx\nconst info = `this is my name:${name}`;\n```\n\n使用反引号来编写字符串，使用`${}`编写动态数据\n\n# 2. ES6的函数增强\n\n## 2.1 函数的默认参数\n\n```jsx\nfunction foo(arg1 = \"默认值1\",arg2 = \"默认值2\"){\n\t// 函数体\n}\n```\n\n当调用函数的时候，没有给对应参数传递参数的时候，JS就会使用默认值。\n\n**注意事项：**\n\n- 有默认参数的形参尽量写在后面\n- 有默认参数的形参，不会计算在length之内的（并且后面的所有参数都不会计算在length之内）。比如一个函数全有默认参数，那么参数长度就为0。\n- 如果参数还有剩余参数，那么剩余参数放在最后面。（默认参数的位置放在剩余参数前面）\n\n默认参数也可以和解构一起使用：\n\n```jsx\nconst obj = {\n\tname:\"as\",\n\tage:12,\n}\n\nfunction foo({name,age} = obj){\n\t// 方法体\n}\n\n// 如果传入的是一个空对象\nfunction foo1({name = \"asd\",age = 12} = {}){\n\t// 方法体\n}\n```\n\n## 2.2 箭头函数\n\n箭头函数没有显式原型，不可以将箭头函数作为构造函数，不可以使用new来构造新的对象。\n\n```jsx\nvar foo = () => {\n\t// 函数体\n}\n\nconsole.log(foo.prototype); // undefined\n```\n\n# 3. 展开语法\n\n- 可以函数调用/数组构造时，将数组表达式或者String在语法层面展开\n- 在构造字面量的时候，将对象表达式以key-value的方式展开\n\n```jsx\nconst name = [\"as\",\"qw\",\"sf\"]\nconsole.log(...name); // as qw sf\n\nconst str = \"zmlzmlz\";\nconsole.log(...str); // z m l z m l z\n\n// ES9之后还可以展开对象(在构建字面量时)\nconst obj = {\n\tname:\"qwe\",\n\tage:18,\n}\nconst info = {\n\t...obj,\n\theight:1.99,\n}\nconsole.log(info);\n\n// 结果\n//{name: 'qwe', age: 18, height: 1.99}\n//age\n//: \n//18\n//height\n//: \n//1.99\n//name\n//: \n//\"qwe\"\n//[[Prototype]]\n//: \n//Object\n```\n\n## 3.2 引用类型拷贝\n\n赋值引用类型：\n\n```jsx\nconst obj = {\n\tname:\"qwe\",\n\tage:18,\n}\n\nlet info = obj;\ninfo.name = \"asd\";\nconsole.log(obj.name); // \"asd\"\n```\n\n引用赋值存在的问题，多个变量操作的都是同一个对象，一个改编，全部改变。\n\n**浅拷贝：**\n\n```jsx\nconst obj = {\n\tname:\"qwe\",\n\tage:18,\n\tfirend:{\n\t\tname:\"zmlzml\",\n\t}\n}\n\nlet info = {\n\t...obj,\n}\n\ninfo.name = \"hmbb\";\ninfo.firend.name = \"pai\",\nconsole.log(info.name); // hmbb\nconsole.log(obj.name); // qwe\n\nconsole.log(info.firend.name); // pai\nconsole.log(obj.firend.name);  // pai\n```\n\n之前的操作同一对象的问题有所改善，但是还没有完全解决。\n\n**深拷贝：**\n\n方法一：第三方库\n\n方法二：自己实现\n\n方式三：利用现有的js机制，实现深拷贝JSON\n\n```jsx\nconst obj = {\n\tname:\"qwe\",\n\tage:18,\n\tfirend:{\n\t\tname:\"zmlzml\",\n\t}\n}\n\nconst info = JSON.parse(JSON.stringify(obj));\n\ninfo.firend.name = \"hmbb\";\nconsole.log(info.firend.name); // \"hmbb\"\nconsole.log(obj.firend.name); // \"zmlzml\"\n```\n\n# 3. 数值表示\n\n- 二进制：0b\n- 八进制：0o\n- 十六进制：0x\n\nES2021新增特性：当数字过长时，可以使用`_`作为连接符。\n\n# 4.Symbol基本使用\n\n解决了对象属性名的命名冲突。\n\nSymbol用于生成一个独一无二的值。\n\n```jsx\nconst s1 = Symbol();\n\nlet obj = {\n\t[s1]:\"asda\",\n}\n\nconsole.log(obj);\n```\n\n在Symbol创建的时候，可以传入一个描述。ES2019新增。\n\n```jsx\nconst s1 = Symbol();\nconst s2 = Symbol()';\n\n// 加入对象中\nconst obj = {\n\t[s1]:\"asd\",\n}\n\nObject.defineProperty(obj,si,{\n\tvalue :\"aaa\",\n})\n\n// 或者Symbol对应的key\nconsole.log(Object.keys(obj)); // 获取不到Symbol\nconsole.log(Object.getOwnPropetySymbols(obj));\n\n// Symbol的描述(创建的时候传入)\nconst s3 = Symbol(\"描述\");\nconsole.log(s3.description);\n```\n\n即使创建的时候，传入的描述是一样的，但是创建出来的Symbol还是不一样。\n\n生成相同的Symbol：\n\n- 使用Symbol.for方法创建相同的Symbol\n    - 如果有相同的key(传入的描述)，通过Symbol.for可以生成相同的Symbol值\n- 使用Symbol.keyFor方法获取对象的key\n\n```jsx\nconst s1 = Symbol(\"aaa\");\nconst s2 = Symbol.for(s1.description);\nconst s3 = Symbol.for(s1.description);\n\nconsole.log(s3 === s2); // true\n```\n\n# 5. Set与WeakSet的基本使用\n\n**SET**\n\nset里面存放的数据是不会重复的，所以我们可以利用这个特性给数组去重。\n\n创建一个空set:\n\n```jsx\nconst arr = new set();\n```\n\n给set添加元素：\n\n```jsx\nconst arr = new Set();\nlet obj = {\n\tname:\"asd\",\n\tage:18,\n}\n\narr.add(\"str\");\narr.add(12);\narr.add(obj);\n\nconsole.log(arr);\n```\n\n用处：给数组去重\n\n```jsx\nlet arr = [1,2,2,3,4,4,5,5,6,7,8,9,9];\nlet set = new Set();\nfor (const i of arr) {\n    set.add(i);\n}\narr = Array.from(set);\nconsole.log(arr);\n```\n\nset常见的属性以及方法：\n\n- size：获取set里面的元素个数\n- add()：添加元素\n- delete(value):从set删除指定与元素\n- has(value)：是否包含某个元素\n- clean():清空整个Set\n- for  each遍历\n- for  of遍历\n\n**WEAKSET**\n\n与Set类似，也是不能存放重复的数据。\n\n与Set的区别：\n\n- WeakSet只能存放对象类型，不可以存放基本数据类型\n- WeakSet对元素的引用是弱引用，若没有其他引用对其某个元素的一弄，那么GC（垃圾回收机制）就会对该对象进行回收。\n\n```jsx\n// 默认情况下，都为强引用\nlet obj1 = {\n    name: \"qw\",\n}\nlet obj2 = {\n    name: \"asd\",\n}\nlet obj3 = {\n    name: \"er\",\n}\nlet arr = [obj1, obj2, obj3];\nobj1 = null;\nobj2 = null;\nobj3 = null;\n// 对象赋值为空之后，arr依然对其有引用，所以不会被GC回收\n```\n\n只能存放对象：\n\n```jsx\nlet obj1 = {\n    name: \"qw\",\n}\nlet obj2 = {\n    name: \"asd\",\n}\nlet obj3 = {\n    name: \"er\",\n}\n\n// 区别一：WeakSet只能存放对象\nconst ws = new WeakSet();\nws.add(obj1);\nws.add(obj2);\n// ws.add(12);  报错\nconsole.log(ws);\n```\n\n常见的方法：\n\n- add():添加元素\n- delete（value）：删除指定元素\n- has（value）：是否包含某个元素\n\n**注意：**\n\nWeakSet不能被遍历，因为里面的元素可能下一秒就被GC回收了，所以存放在WeakSet的元素是没有办法获取的。\n\n# 6. Map与WeakMap的基本使用\n\n**Map**\n\nMap与对象有点类似，都是以键值对存储。用于存储映射关系。\n\n但是对象Key只能用字符串或者Symbol，而Map可以用任何数据形式作为Key。 \n\n- 对象使用对象作为Key，会导致Key值为Object，最后一个为Object的键值对会覆盖之前的数据。\n    \n    ```jsx\n    let obj = {\n    \tname:\"q\",\n    }\n    let obj2 = {\n    \tname:\"s\",\n    }\n    \n    let test = {\n    \t[obj]:\"12\",\n    \t[obj2]:\"zml\",\n    }\n    \n    console.log(test); // [object Object]: \"zml\"\n    ```\n    \n\nMap常见的属性及其方法：\n\n- size：获取Map中元素的个数\n- set(key,value)：添加元素，返回整个Map对象\n- get(key)：根据key获取Map中的value\n- has（key）:根据key判断该元素是否在Map中\n- delete（key）:根据key删除指定元素\n- clear():清空所有元素\n- forEach（callback,[,thisArg]）：遍历元素\n\n**WeakMap:**\n\nWeakMap的key只能使用对象，不接受其他的类型作为key。\n\nWeakMap对对象的引用是弱引用，如果没有其他引用指向该对象，该对象就会被GC回收。\n\nWeakMap常见方法：\n\n- set(key,value)：添加元素，返回整个WeakMap对象\n- get(key)：根据key获取WeakMap中的value\n- has（key）:根据key判断该元素是否在Weak Map中\n- delete（key）:根据key删除指定元素\n\nWeakMap不支持遍历。\n\n# 7. ES7~ES13新特性\n\n## 7.1 字符串填充方法\n\n```jsx\nconst str1 = \"5\";\nconst str2 = \"5\";\n\nstr1.padStart(2, \"0\");\nstr2.padEnd(2, \"0\");\nconsole.log(`${str1}, ${str2}`);\n```\n\n通常用于时间的格式化。","slug":"JavaScript/JavaScriptES6第二弹","published":1,"updated":"2023-05-23T08:36:17.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi5003s9kbm6eyo425n","content":"<h1 id=\"JavaScript中ES6第二弹\"><a href=\"#JavaScript中ES6第二弹\" class=\"headerlink\" title=\"JavaScript中ES6第二弹\"></a>JavaScript中ES6第二弹</h1><ul>\n<li>模板字符串</li>\n<li>ES6函数增强用法</li>\n<li>展开运算符使用</li>\n<li>Symbol类型</li>\n<li>数据结构-Set</li>\n<li>数据结构-Map</li>\n</ul>\n<h1 id=\"1-模板字符串\"><a href=\"#1-模板字符串\" class=\"headerlink\" title=\"1.模板字符串\"></a>1.模板字符串</h1><h2 id=\"1-1-模板字符串基本使用\"><a href=\"#1-1-模板字符串基本使用\" class=\"headerlink\" title=\"1.1 模板字符串基本使用\"></a>1.1 模板字符串基本使用</h2><p>我们使用模板字符串可以将一些动态的数据与字符串组合在一起。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> info = <span class=\"string\">`this is my name:<span class=\"subst\">$&#123;name&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用反引号来编写字符串，使用<code>$&#123;&#125;</code>编写动态数据</p>\n<h1 id=\"2-ES6的函数增强\"><a href=\"#2-ES6的函数增强\" class=\"headerlink\" title=\"2. ES6的函数增强\"></a>2. ES6的函数增强</h1><h2 id=\"2-1-函数的默认参数\"><a href=\"#2-1-函数的默认参数\" class=\"headerlink\" title=\"2.1 函数的默认参数\"></a>2.1 函数的默认参数</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">arg1 = <span class=\"string\">&quot;默认值1&quot;</span>,arg2 = <span class=\"string\">&quot;默认值2&quot;</span></span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 函数体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用函数的时候，没有给对应参数传递参数的时候，JS就会使用默认值。</p>\n<p><strong>注意事项：</strong></p>\n<ul>\n<li>有默认参数的形参尽量写在后面</li>\n<li>有默认参数的形参，不会计算在length之内的（并且后面的所有参数都不会计算在length之内）。比如一个函数全有默认参数，那么参数长度就为0。</li>\n<li>如果参数还有剩余参数，那么剩余参数放在最后面。（默认参数的位置放在剩余参数前面）</li>\n</ul>\n<p>默认参数也可以和解构一起使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;as&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">12</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">&#123;name,age&#125; = obj</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果传入的是一个空对象</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo1</span>(<span class=\"params\">&#123;name = <span class=\"string\">&quot;asd&quot;</span>,age = <span class=\"number\">12</span>&#125; = &#123;&#125;</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-箭头函数\"><a href=\"#2-2-箭头函数\" class=\"headerlink\" title=\"2.2 箭头函数\"></a>2.2 箭头函数</h2><p>箭头函数没有显式原型，不可以将箭头函数作为构造函数，不可以使用new来构造新的对象。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title function_\">foo</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 函数体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-展开语法\"><a href=\"#3-展开语法\" class=\"headerlink\" title=\"3. 展开语法\"></a>3. 展开语法</h1><ul>\n<li>可以函数调用&#x2F;数组构造时，将数组表达式或者String在语法层面展开</li>\n<li>在构造字面量的时候，将对象表达式以key-value的方式展开</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = [<span class=\"string\">&quot;as&quot;</span>,<span class=\"string\">&quot;qw&quot;</span>,<span class=\"string\">&quot;sf&quot;</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(...name); <span class=\"comment\">// as qw sf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;zmlzmlz&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(...str); <span class=\"comment\">// z m l z m l z</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES9之后还可以展开对象(在构建字面量时)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;qwe&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> info = &#123;</span><br><span class=\"line\">\t...obj,</span><br><span class=\"line\">\t<span class=\"attr\">height</span>:<span class=\"number\">1.99</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(info);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;name: &#x27;qwe&#x27;, age: 18, height: 1.99&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//age</span></span><br><span class=\"line\"><span class=\"comment\">//: </span></span><br><span class=\"line\"><span class=\"comment\">//18</span></span><br><span class=\"line\"><span class=\"comment\">//height</span></span><br><span class=\"line\"><span class=\"comment\">//: </span></span><br><span class=\"line\"><span class=\"comment\">//1.99</span></span><br><span class=\"line\"><span class=\"comment\">//name</span></span><br><span class=\"line\"><span class=\"comment\">//: </span></span><br><span class=\"line\"><span class=\"comment\">//&quot;qwe&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//[[Prototype]]</span></span><br><span class=\"line\"><span class=\"comment\">//: </span></span><br><span class=\"line\"><span class=\"comment\">//Object</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-引用类型拷贝\"><a href=\"#3-2-引用类型拷贝\" class=\"headerlink\" title=\"3.2 引用类型拷贝\"></a>3.2 引用类型拷贝</h2><p>赋值引用类型：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;qwe&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> info = obj;</span><br><span class=\"line\">info.<span class=\"property\">name</span> = <span class=\"string\">&quot;asd&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>); <span class=\"comment\">// &quot;asd&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>引用赋值存在的问题，多个变量操作的都是同一个对象，一个改编，全部改变。</p>\n<p><strong>浅拷贝：</strong></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;qwe&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">\t<span class=\"attr\">firend</span>:&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;zmlzml&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> info = &#123;</span><br><span class=\"line\">\t...obj,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">info.<span class=\"property\">name</span> = <span class=\"string\">&quot;hmbb&quot;</span>;</span><br><span class=\"line\">info.<span class=\"property\">firend</span>.<span class=\"property\">name</span> = <span class=\"string\">&quot;pai&quot;</span>,</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(info.<span class=\"property\">name</span>); <span class=\"comment\">// hmbb</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>); <span class=\"comment\">// qwe</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(info.<span class=\"property\">firend</span>.<span class=\"property\">name</span>); <span class=\"comment\">// pai</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">firend</span>.<span class=\"property\">name</span>);  <span class=\"comment\">// pai</span></span><br></pre></td></tr></table></figure>\n\n<p>之前的操作同一对象的问题有所改善，但是还没有完全解决。</p>\n<p><strong>深拷贝：</strong></p>\n<p>方法一：第三方库</p>\n<p>方法二：自己实现</p>\n<p>方式三：利用现有的js机制，实现深拷贝JSON</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;qwe&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">\t<span class=\"attr\">firend</span>:&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;zmlzml&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> info = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(obj));</span><br><span class=\"line\"></span><br><span class=\"line\">info.<span class=\"property\">firend</span>.<span class=\"property\">name</span> = <span class=\"string\">&quot;hmbb&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(info.<span class=\"property\">firend</span>.<span class=\"property\">name</span>); <span class=\"comment\">// &quot;hmbb&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">firend</span>.<span class=\"property\">name</span>); <span class=\"comment\">// &quot;zmlzml&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-数值表示\"><a href=\"#3-数值表示\" class=\"headerlink\" title=\"3. 数值表示\"></a>3. 数值表示</h1><ul>\n<li>二进制：0b</li>\n<li>八进制：0o</li>\n<li>十六进制：0x</li>\n</ul>\n<p>ES2021新增特性：当数字过长时，可以使用<code>_</code>作为连接符。</p>\n<h1 id=\"4-Symbol基本使用\"><a href=\"#4-Symbol基本使用\" class=\"headerlink\" title=\"4.Symbol基本使用\"></a>4.Symbol基本使用</h1><p>解决了对象属性名的命名冲突。</p>\n<p>Symbol用于生成一个独一无二的值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\t[s1]:<span class=\"string\">&quot;asda&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj);</span><br></pre></td></tr></table></figure>\n\n<p>在Symbol创建的时候，可以传入一个描述。ES2019新增。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>()<span class=\"string\">&#x27;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// 加入对象中</span></span><br><span class=\"line\"><span class=\"string\">const obj = &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t[s1]:&quot;asd&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Object.defineProperty(obj,si,&#123;</span></span><br><span class=\"line\"><span class=\"string\">\tvalue :&quot;aaa&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&#125;)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// 或者Symbol对应的key</span></span><br><span class=\"line\"><span class=\"string\">console.log(Object.keys(obj)); // 获取不到Symbol</span></span><br><span class=\"line\"><span class=\"string\">console.log(Object.getOwnPropetySymbols(obj));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// Symbol的描述(创建的时候传入)</span></span><br><span class=\"line\"><span class=\"string\">const s3 = Symbol(&quot;描述&quot;);</span></span><br><span class=\"line\"><span class=\"string\">console.log(s3.description);</span></span><br></pre></td></tr></table></figure>\n\n<p>即使创建的时候，传入的描述是一样的，但是创建出来的Symbol还是不一样。</p>\n<p>生成相同的Symbol：</p>\n<ul>\n<li>使用Symbol.for方法创建相同的Symbol<ul>\n<li>如果有相同的key(传入的描述)，通过Symbol.for可以生成相同的Symbol值</li>\n</ul>\n</li>\n<li>使用Symbol.keyFor方法获取对象的key</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(s1.<span class=\"property\">description</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> s3 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(s1.<span class=\"property\">description</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s3 === s2); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-Set与WeakSet的基本使用\"><a href=\"#5-Set与WeakSet的基本使用\" class=\"headerlink\" title=\"5. Set与WeakSet的基本使用\"></a>5. Set与WeakSet的基本使用</h1><p><strong>SET</strong></p>\n<p>set里面存放的数据是不会重复的，所以我们可以利用这个特性给数组去重。</p>\n<p>创建一个空set:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"title function_\">set</span>();</span><br></pre></td></tr></table></figure>\n\n<p>给set添加元素：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;asd&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">arr.<span class=\"title function_\">add</span>(<span class=\"string\">&quot;str&quot;</span>);</span><br><span class=\"line\">arr.<span class=\"title function_\">add</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\">arr.<span class=\"title function_\">add</span>(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br></pre></td></tr></table></figure>\n\n<p>用处：给数组去重</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    set.<span class=\"title function_\">add</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(set);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br></pre></td></tr></table></figure>\n\n<p>set常见的属性以及方法：</p>\n<ul>\n<li>size：获取set里面的元素个数</li>\n<li>add()：添加元素</li>\n<li>delete(value):从set删除指定与元素</li>\n<li>has(value)：是否包含某个元素</li>\n<li>clean():清空整个Set</li>\n<li>for  each遍历</li>\n<li>for  of遍历</li>\n</ul>\n<p><strong>WEAKSET</strong></p>\n<p>与Set类似，也是不能存放重复的数据。</p>\n<p>与Set的区别：</p>\n<ul>\n<li>WeakSet只能存放对象类型，不可以存放基本数据类型</li>\n<li>WeakSet对元素的引用是弱引用，若没有其他引用对其某个元素的一弄，那么GC（垃圾回收机制）就会对该对象进行回收。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认情况下，都为强引用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;qw&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;asd&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj3 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;er&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [obj1, obj2, obj3];</span><br><span class=\"line\">obj1 = <span class=\"literal\">null</span>;</span><br><span class=\"line\">obj2 = <span class=\"literal\">null</span>;</span><br><span class=\"line\">obj3 = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// 对象赋值为空之后，arr依然对其有引用，所以不会被GC回收</span></span><br></pre></td></tr></table></figure>\n\n<p>只能存放对象：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;qw&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;asd&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj3 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;er&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 区别一：WeakSet只能存放对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakSet</span>();</span><br><span class=\"line\">ws.<span class=\"title function_\">add</span>(obj1);</span><br><span class=\"line\">ws.<span class=\"title function_\">add</span>(obj2);</span><br><span class=\"line\"><span class=\"comment\">// ws.add(12);  报错</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(ws);</span><br></pre></td></tr></table></figure>\n\n<p>常见的方法：</p>\n<ul>\n<li>add():添加元素</li>\n<li>delete（value）：删除指定元素</li>\n<li>has（value）：是否包含某个元素</li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>WeakSet不能被遍历，因为里面的元素可能下一秒就被GC回收了，所以存放在WeakSet的元素是没有办法获取的。</p>\n<h1 id=\"6-Map与WeakMap的基本使用\"><a href=\"#6-Map与WeakMap的基本使用\" class=\"headerlink\" title=\"6. Map与WeakMap的基本使用\"></a>6. Map与WeakMap的基本使用</h1><p><strong>Map</strong></p>\n<p>Map与对象有点类似，都是以键值对存储。用于存储映射关系。</p>\n<p>但是对象Key只能用字符串或者Symbol，而Map可以用任何数据形式作为Key。 </p>\n<ul>\n<li><p>对象使用对象作为Key，会导致Key值为Object，最后一个为Object的键值对会覆盖之前的数据。</p>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;q&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;s&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = &#123;</span><br><span class=\"line\">\t[obj]:<span class=\"string\">&quot;12&quot;</span>,</span><br><span class=\"line\">\t[obj2]:<span class=\"string\">&quot;zml&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test); <span class=\"comment\">// [object Object]: &quot;zml&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>Map常见的属性及其方法：</p>\n<ul>\n<li>size：获取Map中元素的个数</li>\n<li>set(key,value)：添加元素，返回整个Map对象</li>\n<li>get(key)：根据key获取Map中的value</li>\n<li>has（key）:根据key判断该元素是否在Map中</li>\n<li>delete（key）:根据key删除指定元素</li>\n<li>clear():清空所有元素</li>\n<li>forEach（callback,[,thisArg]）：遍历元素</li>\n</ul>\n<p><strong>WeakMap:</strong></p>\n<p>WeakMap的key只能使用对象，不接受其他的类型作为key。</p>\n<p>WeakMap对对象的引用是弱引用，如果没有其他引用指向该对象，该对象就会被GC回收。</p>\n<p>WeakMap常见方法：</p>\n<ul>\n<li>set(key,value)：添加元素，返回整个WeakMap对象</li>\n<li>get(key)：根据key获取WeakMap中的value</li>\n<li>has（key）:根据key判断该元素是否在Weak Map中</li>\n<li>delete（key）:根据key删除指定元素</li>\n</ul>\n<p>WeakMap不支持遍历。</p>\n<h1 id=\"7-ES7-ES13新特性\"><a href=\"#7-ES7-ES13新特性\" class=\"headerlink\" title=\"7. ES7~ES13新特性\"></a>7. ES7~ES13新特性</h1><h2 id=\"7-1-字符串填充方法\"><a href=\"#7-1-字符串填充方法\" class=\"headerlink\" title=\"7.1 字符串填充方法\"></a>7.1 字符串填充方法</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str1 = <span class=\"string\">&quot;5&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str2 = <span class=\"string\">&quot;5&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">str1.<span class=\"title function_\">padStart</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">str2.<span class=\"title function_\">padEnd</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;str1&#125;</span>, <span class=\"subst\">$&#123;str2&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>通常用于时间的格式化。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript中ES6第二弹\"><a href=\"#JavaScript中ES6第二弹\" class=\"headerlink\" title=\"JavaScript中ES6第二弹\"></a>JavaScript中ES6第二弹</h1><ul>\n<li>模板字符串</li>\n<li>ES6函数增强用法</li>\n<li>展开运算符使用</li>\n<li>Symbol类型</li>\n<li>数据结构-Set</li>\n<li>数据结构-Map</li>\n</ul>\n<h1 id=\"1-模板字符串\"><a href=\"#1-模板字符串\" class=\"headerlink\" title=\"1.模板字符串\"></a>1.模板字符串</h1><h2 id=\"1-1-模板字符串基本使用\"><a href=\"#1-1-模板字符串基本使用\" class=\"headerlink\" title=\"1.1 模板字符串基本使用\"></a>1.1 模板字符串基本使用</h2><p>我们使用模板字符串可以将一些动态的数据与字符串组合在一起。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> info = <span class=\"string\">`this is my name:<span class=\"subst\">$&#123;name&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用反引号来编写字符串，使用<code>$&#123;&#125;</code>编写动态数据</p>\n<h1 id=\"2-ES6的函数增强\"><a href=\"#2-ES6的函数增强\" class=\"headerlink\" title=\"2. ES6的函数增强\"></a>2. ES6的函数增强</h1><h2 id=\"2-1-函数的默认参数\"><a href=\"#2-1-函数的默认参数\" class=\"headerlink\" title=\"2.1 函数的默认参数\"></a>2.1 函数的默认参数</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">arg1 = <span class=\"string\">&quot;默认值1&quot;</span>,arg2 = <span class=\"string\">&quot;默认值2&quot;</span></span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 函数体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当调用函数的时候，没有给对应参数传递参数的时候，JS就会使用默认值。</p>\n<p><strong>注意事项：</strong></p>\n<ul>\n<li>有默认参数的形参尽量写在后面</li>\n<li>有默认参数的形参，不会计算在length之内的（并且后面的所有参数都不会计算在length之内）。比如一个函数全有默认参数，那么参数长度就为0。</li>\n<li>如果参数还有剩余参数，那么剩余参数放在最后面。（默认参数的位置放在剩余参数前面）</li>\n</ul>\n<p>默认参数也可以和解构一起使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;as&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">12</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">&#123;name,age&#125; = obj</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果传入的是一个空对象</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo1</span>(<span class=\"params\">&#123;name = <span class=\"string\">&quot;asd&quot;</span>,age = <span class=\"number\">12</span>&#125; = &#123;&#125;</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 方法体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-箭头函数\"><a href=\"#2-2-箭头函数\" class=\"headerlink\" title=\"2.2 箭头函数\"></a>2.2 箭头函数</h2><p>箭头函数没有显式原型，不可以将箭头函数作为构造函数，不可以使用new来构造新的对象。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title function_\">foo</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 函数体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-展开语法\"><a href=\"#3-展开语法\" class=\"headerlink\" title=\"3. 展开语法\"></a>3. 展开语法</h1><ul>\n<li>可以函数调用&#x2F;数组构造时，将数组表达式或者String在语法层面展开</li>\n<li>在构造字面量的时候，将对象表达式以key-value的方式展开</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = [<span class=\"string\">&quot;as&quot;</span>,<span class=\"string\">&quot;qw&quot;</span>,<span class=\"string\">&quot;sf&quot;</span>]</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(...name); <span class=\"comment\">// as qw sf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">&quot;zmlzmlz&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(...str); <span class=\"comment\">// z m l z m l z</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES9之后还可以展开对象(在构建字面量时)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;qwe&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> info = &#123;</span><br><span class=\"line\">\t...obj,</span><br><span class=\"line\">\t<span class=\"attr\">height</span>:<span class=\"number\">1.99</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(info);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结果</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;name: &#x27;qwe&#x27;, age: 18, height: 1.99&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//age</span></span><br><span class=\"line\"><span class=\"comment\">//: </span></span><br><span class=\"line\"><span class=\"comment\">//18</span></span><br><span class=\"line\"><span class=\"comment\">//height</span></span><br><span class=\"line\"><span class=\"comment\">//: </span></span><br><span class=\"line\"><span class=\"comment\">//1.99</span></span><br><span class=\"line\"><span class=\"comment\">//name</span></span><br><span class=\"line\"><span class=\"comment\">//: </span></span><br><span class=\"line\"><span class=\"comment\">//&quot;qwe&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//[[Prototype]]</span></span><br><span class=\"line\"><span class=\"comment\">//: </span></span><br><span class=\"line\"><span class=\"comment\">//Object</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-引用类型拷贝\"><a href=\"#3-2-引用类型拷贝\" class=\"headerlink\" title=\"3.2 引用类型拷贝\"></a>3.2 引用类型拷贝</h2><p>赋值引用类型：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;qwe&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> info = obj;</span><br><span class=\"line\">info.<span class=\"property\">name</span> = <span class=\"string\">&quot;asd&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>); <span class=\"comment\">// &quot;asd&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>引用赋值存在的问题，多个变量操作的都是同一个对象，一个改编，全部改变。</p>\n<p><strong>浅拷贝：</strong></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;qwe&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">\t<span class=\"attr\">firend</span>:&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;zmlzml&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> info = &#123;</span><br><span class=\"line\">\t...obj,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">info.<span class=\"property\">name</span> = <span class=\"string\">&quot;hmbb&quot;</span>;</span><br><span class=\"line\">info.<span class=\"property\">firend</span>.<span class=\"property\">name</span> = <span class=\"string\">&quot;pai&quot;</span>,</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(info.<span class=\"property\">name</span>); <span class=\"comment\">// hmbb</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>); <span class=\"comment\">// qwe</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(info.<span class=\"property\">firend</span>.<span class=\"property\">name</span>); <span class=\"comment\">// pai</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">firend</span>.<span class=\"property\">name</span>);  <span class=\"comment\">// pai</span></span><br></pre></td></tr></table></figure>\n\n<p>之前的操作同一对象的问题有所改善，但是还没有完全解决。</p>\n<p><strong>深拷贝：</strong></p>\n<p>方法一：第三方库</p>\n<p>方法二：自己实现</p>\n<p>方式三：利用现有的js机制，实现深拷贝JSON</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;qwe&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">\t<span class=\"attr\">firend</span>:&#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;zmlzml&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> info = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(obj));</span><br><span class=\"line\"></span><br><span class=\"line\">info.<span class=\"property\">firend</span>.<span class=\"property\">name</span> = <span class=\"string\">&quot;hmbb&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(info.<span class=\"property\">firend</span>.<span class=\"property\">name</span>); <span class=\"comment\">// &quot;hmbb&quot;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">firend</span>.<span class=\"property\">name</span>); <span class=\"comment\">// &quot;zmlzml&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-数值表示\"><a href=\"#3-数值表示\" class=\"headerlink\" title=\"3. 数值表示\"></a>3. 数值表示</h1><ul>\n<li>二进制：0b</li>\n<li>八进制：0o</li>\n<li>十六进制：0x</li>\n</ul>\n<p>ES2021新增特性：当数字过长时，可以使用<code>_</code>作为连接符。</p>\n<h1 id=\"4-Symbol基本使用\"><a href=\"#4-Symbol基本使用\" class=\"headerlink\" title=\"4.Symbol基本使用\"></a>4.Symbol基本使用</h1><p>解决了对象属性名的命名冲突。</p>\n<p>Symbol用于生成一个独一无二的值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\t[s1]:<span class=\"string\">&quot;asda&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj);</span><br></pre></td></tr></table></figure>\n\n<p>在Symbol创建的时候，可以传入一个描述。ES2019新增。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>()<span class=\"string\">&#x27;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// 加入对象中</span></span><br><span class=\"line\"><span class=\"string\">const obj = &#123;</span></span><br><span class=\"line\"><span class=\"string\">\t[s1]:&quot;asd&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Object.defineProperty(obj,si,&#123;</span></span><br><span class=\"line\"><span class=\"string\">\tvalue :&quot;aaa&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&#125;)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// 或者Symbol对应的key</span></span><br><span class=\"line\"><span class=\"string\">console.log(Object.keys(obj)); // 获取不到Symbol</span></span><br><span class=\"line\"><span class=\"string\">console.log(Object.getOwnPropetySymbols(obj));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">// Symbol的描述(创建的时候传入)</span></span><br><span class=\"line\"><span class=\"string\">const s3 = Symbol(&quot;描述&quot;);</span></span><br><span class=\"line\"><span class=\"string\">console.log(s3.description);</span></span><br></pre></td></tr></table></figure>\n\n<p>即使创建的时候，传入的描述是一样的，但是创建出来的Symbol还是不一样。</p>\n<p>生成相同的Symbol：</p>\n<ul>\n<li>使用Symbol.for方法创建相同的Symbol<ul>\n<li>如果有相同的key(传入的描述)，通过Symbol.for可以生成相同的Symbol值</li>\n</ul>\n</li>\n<li>使用Symbol.keyFor方法获取对象的key</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> s1 = <span class=\"title class_\">Symbol</span>(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> s2 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(s1.<span class=\"property\">description</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> s3 = <span class=\"title class_\">Symbol</span>.<span class=\"title function_\">for</span>(s1.<span class=\"property\">description</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s3 === s2); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-Set与WeakSet的基本使用\"><a href=\"#5-Set与WeakSet的基本使用\" class=\"headerlink\" title=\"5. Set与WeakSet的基本使用\"></a>5. Set与WeakSet的基本使用</h1><p><strong>SET</strong></p>\n<p>set里面存放的数据是不会重复的，所以我们可以利用这个特性给数组去重。</p>\n<p>创建一个空set:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"title function_\">set</span>();</span><br></pre></td></tr></table></figure>\n\n<p>给set添加元素：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;asd&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">arr.<span class=\"title function_\">add</span>(<span class=\"string\">&quot;str&quot;</span>);</span><br><span class=\"line\">arr.<span class=\"title function_\">add</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\">arr.<span class=\"title function_\">add</span>(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br></pre></td></tr></table></figure>\n\n<p>用处：给数组去重</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    set.<span class=\"title function_\">add</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(set);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br></pre></td></tr></table></figure>\n\n<p>set常见的属性以及方法：</p>\n<ul>\n<li>size：获取set里面的元素个数</li>\n<li>add()：添加元素</li>\n<li>delete(value):从set删除指定与元素</li>\n<li>has(value)：是否包含某个元素</li>\n<li>clean():清空整个Set</li>\n<li>for  each遍历</li>\n<li>for  of遍历</li>\n</ul>\n<p><strong>WEAKSET</strong></p>\n<p>与Set类似，也是不能存放重复的数据。</p>\n<p>与Set的区别：</p>\n<ul>\n<li>WeakSet只能存放对象类型，不可以存放基本数据类型</li>\n<li>WeakSet对元素的引用是弱引用，若没有其他引用对其某个元素的一弄，那么GC（垃圾回收机制）就会对该对象进行回收。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认情况下，都为强引用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;qw&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;asd&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj3 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;er&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [obj1, obj2, obj3];</span><br><span class=\"line\">obj1 = <span class=\"literal\">null</span>;</span><br><span class=\"line\">obj2 = <span class=\"literal\">null</span>;</span><br><span class=\"line\">obj3 = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">// 对象赋值为空之后，arr依然对其有引用，所以不会被GC回收</span></span><br></pre></td></tr></table></figure>\n\n<p>只能存放对象：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;qw&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;asd&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj3 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&quot;er&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 区别一：WeakSet只能存放对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakSet</span>();</span><br><span class=\"line\">ws.<span class=\"title function_\">add</span>(obj1);</span><br><span class=\"line\">ws.<span class=\"title function_\">add</span>(obj2);</span><br><span class=\"line\"><span class=\"comment\">// ws.add(12);  报错</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(ws);</span><br></pre></td></tr></table></figure>\n\n<p>常见的方法：</p>\n<ul>\n<li>add():添加元素</li>\n<li>delete（value）：删除指定元素</li>\n<li>has（value）：是否包含某个元素</li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>WeakSet不能被遍历，因为里面的元素可能下一秒就被GC回收了，所以存放在WeakSet的元素是没有办法获取的。</p>\n<h1 id=\"6-Map与WeakMap的基本使用\"><a href=\"#6-Map与WeakMap的基本使用\" class=\"headerlink\" title=\"6. Map与WeakMap的基本使用\"></a>6. Map与WeakMap的基本使用</h1><p><strong>Map</strong></p>\n<p>Map与对象有点类似，都是以键值对存储。用于存储映射关系。</p>\n<p>但是对象Key只能用字符串或者Symbol，而Map可以用任何数据形式作为Key。 </p>\n<ul>\n<li><p>对象使用对象作为Key，会导致Key值为Object，最后一个为Object的键值对会覆盖之前的数据。</p>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;q&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;s&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = &#123;</span><br><span class=\"line\">\t[obj]:<span class=\"string\">&quot;12&quot;</span>,</span><br><span class=\"line\">\t[obj2]:<span class=\"string\">&quot;zml&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(test); <span class=\"comment\">// [object Object]: &quot;zml&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>Map常见的属性及其方法：</p>\n<ul>\n<li>size：获取Map中元素的个数</li>\n<li>set(key,value)：添加元素，返回整个Map对象</li>\n<li>get(key)：根据key获取Map中的value</li>\n<li>has（key）:根据key判断该元素是否在Map中</li>\n<li>delete（key）:根据key删除指定元素</li>\n<li>clear():清空所有元素</li>\n<li>forEach（callback,[,thisArg]）：遍历元素</li>\n</ul>\n<p><strong>WeakMap:</strong></p>\n<p>WeakMap的key只能使用对象，不接受其他的类型作为key。</p>\n<p>WeakMap对对象的引用是弱引用，如果没有其他引用指向该对象，该对象就会被GC回收。</p>\n<p>WeakMap常见方法：</p>\n<ul>\n<li>set(key,value)：添加元素，返回整个WeakMap对象</li>\n<li>get(key)：根据key获取WeakMap中的value</li>\n<li>has（key）:根据key判断该元素是否在Weak Map中</li>\n<li>delete（key）:根据key删除指定元素</li>\n</ul>\n<p>WeakMap不支持遍历。</p>\n<h1 id=\"7-ES7-ES13新特性\"><a href=\"#7-ES7-ES13新特性\" class=\"headerlink\" title=\"7. ES7~ES13新特性\"></a>7. ES7~ES13新特性</h1><h2 id=\"7-1-字符串填充方法\"><a href=\"#7-1-字符串填充方法\" class=\"headerlink\" title=\"7.1 字符串填充方法\"></a>7.1 字符串填充方法</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> str1 = <span class=\"string\">&quot;5&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str2 = <span class=\"string\">&quot;5&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">str1.<span class=\"title function_\">padStart</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">str2.<span class=\"title function_\">padEnd</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;str1&#125;</span>, <span class=\"subst\">$&#123;str2&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>通常用于时间的格式化。</p>\n"},{"title":"JavaScript ES6中的继承","date":"2023-05-18T16:00:00.000Z","_content":"# JavaScript ES6中的继承\n\n1. 原型继承关系图\n2. class方式定义类\n3. extends实现继承\n4. Babel的ES6转ES5 \n5. 面向对象多态理解\n6. ES6对象增强\n\n# 1. 原型继承关系图\n\n![image.png]([https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image?)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image?))\n\n对象只有隐式原型，但是函数既有显式原型，又有隐式原型。\n\n函数的隐式原型看这个函数是被谁创造出来的。\n\n中间最上面的Function Foo()是被function Function 创建出来的，所以隐式原型__proto__指向Function的显示原型。\n\n# 2.class方式定义类\n\n在ES5中定义类使用function，在ES6中定义类使用class.\n\n第一种方法：\n\n```jsx\nclass Person{\n\t// 类中的构造函数\n\t// 当我们通过new创建一个Person类时，默认调用class类中的constructor方法\n\tconstructor(name,age){\n\t\t this.name = name;\n\t\t\tthis.age = age;\n\t}\n\n\t// 类中的实例函数\n\t runing(){\n\t\tconsole.log(this.name+\"正在跑步\");\n\t}\n}\n```\n\n构造函数矛实例函数之间没有逗号间隔。 \n\n创建实例对象：\n\n```jsx\nvar p1 = new Person(\"admin\",12);\nconsole.log(p1.name,p1.age); // admin 12\np1.runing(); // admin正在跑步\nconsole.log(p1.__proto__ === Person.prototype); // true\n```\n\n第二种方法：\n\n```jsx\nvar Student = class{\n\t\n}\n// 创建实例对象\nvar p2 = new Student();\n```\n\n在class不支持函数的重载，也就是一个class里面只能有一个constructor函数。\n\n**class与function的不同点** \n\n- class定义的类，不能作为一个一个普通的函数去调用\n\n## 2.1 class中定义访问器方法\n\n```jsx\nclass Person {\n    // 类中的构造函数\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // setter\n    set name(age) {\n        this.age = age;\n    }\n\n    // getter\n    get name() {\n        return age;\n    }\n   \n};\n```\n\n## 2.2静态方法\n\n静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用static关键字来定义。\n\n```jsx\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n    // 实例方法\n    running() {\n        console.log(this.name + \"正在奔跑\");\n    }\n\n    // 静态方法\n    static eating() {\n        console.log(\"吃饭\");\n    }\n}\n\nvar p1 = new Person(\"海绵宝宝\");\np1.running();\nPerson.eating();\n```\n\n实例方法需要通过new关键字创建出的实例来调用，而静态方法可以直接调用。\n\n静态方法同样也有this，谁调用这个方法，this就指向谁。\n\n# 3.extends实现继承\n\n```jsx\n// 父类\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    running() {\n        console.log(this.name + \"正在奔跑\");\n    }\n}\n\nclass Student extends Person {\n    constructor(name, age, score) {\n        super(name, age);\n        this.score = score;\n    }\n\n    studying() {\n        console.log(this.name + \"正在学习\");\n    }\n}\n\nclass Teacher extends Person {\n    constructor(name, age, money) {\n        super(name, age);\n        this.money = money;\n    }\n    working() {\n        console.log(this.name + \"正在工作\");\n    }\n}\n\nvar stu1 = new Student(\"海绵宝宝\", 12, 100);\nconsole.log(stu1.name, stu1.age, stu1.score);\nvar tea1 = new Teacher(\"泡芙\", 22, 1000);\nconsole.log(tea1.name, tea1.age, tea1.money);\n```\n\n首先定义一个父类，子类中需要用到父类的属性时，直接使用super关键字。\n\n将共同的方法可以抽取到父类之中。\n\n我们在继承的时候：`子类 extends 父类`\n\n## 3.1 super关键字\n\nclass为我们的方法中提供了一个方法\n\n- super.menthd()：在子类调用父类的一个方法\n- super():用来调用父类的constructor方法\n\n注意\n\n- 在子类中的构造方法中使用super必须在this之前，也就是说必须先通过super调用父类的构造函数。\n- super的使用位置有三个：\n    - 子类的构造方法\n    - 实例方法\n    - 静态方法\n\n```jsx\nclass Animal {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    running() {\n        console.log(\"running\");\n    }\n    eating() {\n        console.log(\"eating\");\n    }\n\n    // 静态方法\n    static sleep() {\n        console.log(\"正在睡觉\");\n    }\n}\n\nclass Dog extends Animal {\n    constructor(name, age) {\n        super(name, age);\n    }\n    // 如果父类继承的方法达不到效果，我们可以重写方法\n    running() {\n        console.log(this.name + \"正在奔跑\");\n        // 如果要保留父类的方法，可以使用super调用父类的方法\n        super.running();\n    }\n    static sleep() {\n        console.log(this.name + \"趴着睡觉\");\n        super.sleep();\n    }\n}\n\nvar dog = new Dog(\"李长林\", 23);\ndog.running();\ndog.eating();\nDog.sleep();\n```\n\n可以看到静态方法也可以使用super。\n\n## 3.2 继承内置类\n\n我们还可以继承JavaScript内部类，比如array，我们可以在Array添加一些新方法：\n\n```jsx\n// 给数组添加一个方法，获取最后一个元素\nclass ZMLArray extends Array {\n    lastItem() {\n        return this[this.length - 1];\n    }\n}\n\nvar arr = new ZMLArray(1, 2, 3, 4,2,1,2);\nconsole.log(arr.lastItem()); // 2\n```\n\n## 3.3 类的混入mixin(了解)\n\nJavaScript继承只支持单继承。\n\n# 4.JavaScript中的多态\n\n不同的数据类型进行同一个操作，表现出不同的行为，这就是多态。\n\n- 继承是多态的前提（实现接口）。\n- 必须有父类的引用指向子类对象。\n\n```jsx\n// 计算面积\nclass shape {\n    getArea() {\n\n    }\n}\n\n// 矩形\nclass Rectangle extends shape {\n    constructor(width, height) {\n        super();\n        this.width = width;\n        this.height = height;\n    }\n    getArea() {\n        console.log(this.width * this.height);\n    }\n}\n\nclass Circle extends shape {\n    constructor(radius) {\n        super();\n        this.radius = radius;\n    }\n    getArea() {\n        console.log(Math.PI * this.radius * this.radius);\n    }\n}\n\nvar rect1 = new Rectangle(100, 200);\nvar rect2 = new Rectangle(10, 20);\n\nvar c1 = new Circle(10);\nvar ac2 = new Circle(20);\n\nfunction getShapeArea(shape) {\n    console.log(shape.getArea());\n}\n\ngetShapeArea(rect1);\ngetShapeArea(c1);\n```\n\n# 5. 对象字面量增强\n\n- 属性的简写\n- 方法的简写\n- 计算属性名\n- 解构Destrucuring:\n    - 数组解构\n    - 对象解构\n\n## 5.1 属性的简写\n\n当我们在对象里面写一个外部已经存在的变量时，我们可以直接使用简写。例如：\n\n```jsx\n// 属性的简写\nvar name = \"hmbb\";\nvar obj = {\n    // name: name;\n    name,\n}\nconsole.log(obj.name); // hmbb\n```\n\n## 5.2 方法的间隙\n\n方法的简写：这种写法绑定this。\n\n```jsx\n// 方法的简写\nrunning(){\n    // 方法体\n}\n```\n\n## 5.3 计算属性名：\n\n```jsx\n// 属性的简写\nvar key = \"address\"\nvar obj = {\n   \n    // 计算属性的简写\n    [key]: \"广州\"\n}\nconsole.log(obj.address); // 广州\n```\n\n## 5.4 解构：\n\n最简单的数组以及对象解构：\n\n```jsx\nvar name = [\"asda\", \"fwe\", \"zxcz\"];\nvar obj = { name: \"hmbb\", age: 13, height: 1.99 };\n\n// 数组的解构\nvar [name1, name2, name3] = name;\nconsole.log(name1, name2, name3);\n\n// 对象的解构\nvar { name, age, height } = obj;\nconsole.log(name, age, height);\n```\n\n**关于数组的解构**\n\n- 顺序问题：\n\n在数组里面进行解构的时候有严格的顺序问题。如果我们想要跳过一个元素：\n\n```jsx\nvar [name1,,name3] = name;\n```\n\n也就是在跳过的元素要用逗号留出位置。\n\n- 解构出数组\n\n我们解构之后剩余的元素全部放到一个新数组里面。\n\n```jsx\n var [name1,..newArr] = name;\n```\n\n这样的结果就是`name1:asda`,`newArr:[”fwe”,”zxcz”]`。\n\n- 解构的默认值\n\n当解构失败的时候，我们可以为这个值设置一个自定义的值。\n\n```jsx\nvar [name1,name2,name3 = \"undefined\"] = name;\n```\n\n如果name3解构失败，那么它的值就是undefined。\n\n**关于对象的解构**\n\n- 对象解构的顺序问题\n\n对象的解构时没有顺序的，是根据key来进行解构的。\n\n```jsx\n\nvar obj = {mame:\"ada\",age:12,height:1.99};\nvar {height,age,name} = obj;\n```\n\n对象解构是按照对象的属性名来进行一一匹配，然后解构。\n\n- 对象解构重命名\n\n将结构出来的结果，名字进行更改。\n\n```jsx\nvar {height:gaodu,age:nianling,name:mingzi} = obj;\n```\n\n进行重命名之后，调用的时候，就使用我们重命名之后的变量名进行调用\n\n- 对象解构默认值\n\n与数组的默认值一样，当解构失败的时候，可以设置一个默认值。\n\n```jsx\nvar {height:gaodu,age:nianling,name:mingzi,address:dizhi = undefined} = obj;\n```\n\n- 剩余\n\n这个与数组解构是一样的，将没有变量存放的元素，放到一个新的对象里面。\n\n```jsx\nvar {height,..newObject} = obj;\n```\n\n## 5.5解构的应用场景\n\n- 拿到变量自动进行解构之后使用\n- 对函数的参数进行解构、","source":"_posts/JavaScript/JavaScriptES6中的继承.md","raw":"---\ntitle: JavaScript ES6中的继承\ndate: [2023-5-19]\ntags: [前端]\ncategories: [JavaScript]\n---\n# JavaScript ES6中的继承\n\n1. 原型继承关系图\n2. class方式定义类\n3. extends实现继承\n4. Babel的ES6转ES5 \n5. 面向对象多态理解\n6. ES6对象增强\n\n# 1. 原型继承关系图\n\n![image.png]([https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image?)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image?))\n\n对象只有隐式原型，但是函数既有显式原型，又有隐式原型。\n\n函数的隐式原型看这个函数是被谁创造出来的。\n\n中间最上面的Function Foo()是被function Function 创建出来的，所以隐式原型__proto__指向Function的显示原型。\n\n# 2.class方式定义类\n\n在ES5中定义类使用function，在ES6中定义类使用class.\n\n第一种方法：\n\n```jsx\nclass Person{\n\t// 类中的构造函数\n\t// 当我们通过new创建一个Person类时，默认调用class类中的constructor方法\n\tconstructor(name,age){\n\t\t this.name = name;\n\t\t\tthis.age = age;\n\t}\n\n\t// 类中的实例函数\n\t runing(){\n\t\tconsole.log(this.name+\"正在跑步\");\n\t}\n}\n```\n\n构造函数矛实例函数之间没有逗号间隔。 \n\n创建实例对象：\n\n```jsx\nvar p1 = new Person(\"admin\",12);\nconsole.log(p1.name,p1.age); // admin 12\np1.runing(); // admin正在跑步\nconsole.log(p1.__proto__ === Person.prototype); // true\n```\n\n第二种方法：\n\n```jsx\nvar Student = class{\n\t\n}\n// 创建实例对象\nvar p2 = new Student();\n```\n\n在class不支持函数的重载，也就是一个class里面只能有一个constructor函数。\n\n**class与function的不同点** \n\n- class定义的类，不能作为一个一个普通的函数去调用\n\n## 2.1 class中定义访问器方法\n\n```jsx\nclass Person {\n    // 类中的构造函数\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // setter\n    set name(age) {\n        this.age = age;\n    }\n\n    // getter\n    get name() {\n        return age;\n    }\n   \n};\n```\n\n## 2.2静态方法\n\n静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用static关键字来定义。\n\n```jsx\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n    // 实例方法\n    running() {\n        console.log(this.name + \"正在奔跑\");\n    }\n\n    // 静态方法\n    static eating() {\n        console.log(\"吃饭\");\n    }\n}\n\nvar p1 = new Person(\"海绵宝宝\");\np1.running();\nPerson.eating();\n```\n\n实例方法需要通过new关键字创建出的实例来调用，而静态方法可以直接调用。\n\n静态方法同样也有this，谁调用这个方法，this就指向谁。\n\n# 3.extends实现继承\n\n```jsx\n// 父类\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    running() {\n        console.log(this.name + \"正在奔跑\");\n    }\n}\n\nclass Student extends Person {\n    constructor(name, age, score) {\n        super(name, age);\n        this.score = score;\n    }\n\n    studying() {\n        console.log(this.name + \"正在学习\");\n    }\n}\n\nclass Teacher extends Person {\n    constructor(name, age, money) {\n        super(name, age);\n        this.money = money;\n    }\n    working() {\n        console.log(this.name + \"正在工作\");\n    }\n}\n\nvar stu1 = new Student(\"海绵宝宝\", 12, 100);\nconsole.log(stu1.name, stu1.age, stu1.score);\nvar tea1 = new Teacher(\"泡芙\", 22, 1000);\nconsole.log(tea1.name, tea1.age, tea1.money);\n```\n\n首先定义一个父类，子类中需要用到父类的属性时，直接使用super关键字。\n\n将共同的方法可以抽取到父类之中。\n\n我们在继承的时候：`子类 extends 父类`\n\n## 3.1 super关键字\n\nclass为我们的方法中提供了一个方法\n\n- super.menthd()：在子类调用父类的一个方法\n- super():用来调用父类的constructor方法\n\n注意\n\n- 在子类中的构造方法中使用super必须在this之前，也就是说必须先通过super调用父类的构造函数。\n- super的使用位置有三个：\n    - 子类的构造方法\n    - 实例方法\n    - 静态方法\n\n```jsx\nclass Animal {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    running() {\n        console.log(\"running\");\n    }\n    eating() {\n        console.log(\"eating\");\n    }\n\n    // 静态方法\n    static sleep() {\n        console.log(\"正在睡觉\");\n    }\n}\n\nclass Dog extends Animal {\n    constructor(name, age) {\n        super(name, age);\n    }\n    // 如果父类继承的方法达不到效果，我们可以重写方法\n    running() {\n        console.log(this.name + \"正在奔跑\");\n        // 如果要保留父类的方法，可以使用super调用父类的方法\n        super.running();\n    }\n    static sleep() {\n        console.log(this.name + \"趴着睡觉\");\n        super.sleep();\n    }\n}\n\nvar dog = new Dog(\"李长林\", 23);\ndog.running();\ndog.eating();\nDog.sleep();\n```\n\n可以看到静态方法也可以使用super。\n\n## 3.2 继承内置类\n\n我们还可以继承JavaScript内部类，比如array，我们可以在Array添加一些新方法：\n\n```jsx\n// 给数组添加一个方法，获取最后一个元素\nclass ZMLArray extends Array {\n    lastItem() {\n        return this[this.length - 1];\n    }\n}\n\nvar arr = new ZMLArray(1, 2, 3, 4,2,1,2);\nconsole.log(arr.lastItem()); // 2\n```\n\n## 3.3 类的混入mixin(了解)\n\nJavaScript继承只支持单继承。\n\n# 4.JavaScript中的多态\n\n不同的数据类型进行同一个操作，表现出不同的行为，这就是多态。\n\n- 继承是多态的前提（实现接口）。\n- 必须有父类的引用指向子类对象。\n\n```jsx\n// 计算面积\nclass shape {\n    getArea() {\n\n    }\n}\n\n// 矩形\nclass Rectangle extends shape {\n    constructor(width, height) {\n        super();\n        this.width = width;\n        this.height = height;\n    }\n    getArea() {\n        console.log(this.width * this.height);\n    }\n}\n\nclass Circle extends shape {\n    constructor(radius) {\n        super();\n        this.radius = radius;\n    }\n    getArea() {\n        console.log(Math.PI * this.radius * this.radius);\n    }\n}\n\nvar rect1 = new Rectangle(100, 200);\nvar rect2 = new Rectangle(10, 20);\n\nvar c1 = new Circle(10);\nvar ac2 = new Circle(20);\n\nfunction getShapeArea(shape) {\n    console.log(shape.getArea());\n}\n\ngetShapeArea(rect1);\ngetShapeArea(c1);\n```\n\n# 5. 对象字面量增强\n\n- 属性的简写\n- 方法的简写\n- 计算属性名\n- 解构Destrucuring:\n    - 数组解构\n    - 对象解构\n\n## 5.1 属性的简写\n\n当我们在对象里面写一个外部已经存在的变量时，我们可以直接使用简写。例如：\n\n```jsx\n// 属性的简写\nvar name = \"hmbb\";\nvar obj = {\n    // name: name;\n    name,\n}\nconsole.log(obj.name); // hmbb\n```\n\n## 5.2 方法的间隙\n\n方法的简写：这种写法绑定this。\n\n```jsx\n// 方法的简写\nrunning(){\n    // 方法体\n}\n```\n\n## 5.3 计算属性名：\n\n```jsx\n// 属性的简写\nvar key = \"address\"\nvar obj = {\n   \n    // 计算属性的简写\n    [key]: \"广州\"\n}\nconsole.log(obj.address); // 广州\n```\n\n## 5.4 解构：\n\n最简单的数组以及对象解构：\n\n```jsx\nvar name = [\"asda\", \"fwe\", \"zxcz\"];\nvar obj = { name: \"hmbb\", age: 13, height: 1.99 };\n\n// 数组的解构\nvar [name1, name2, name3] = name;\nconsole.log(name1, name2, name3);\n\n// 对象的解构\nvar { name, age, height } = obj;\nconsole.log(name, age, height);\n```\n\n**关于数组的解构**\n\n- 顺序问题：\n\n在数组里面进行解构的时候有严格的顺序问题。如果我们想要跳过一个元素：\n\n```jsx\nvar [name1,,name3] = name;\n```\n\n也就是在跳过的元素要用逗号留出位置。\n\n- 解构出数组\n\n我们解构之后剩余的元素全部放到一个新数组里面。\n\n```jsx\n var [name1,..newArr] = name;\n```\n\n这样的结果就是`name1:asda`,`newArr:[”fwe”,”zxcz”]`。\n\n- 解构的默认值\n\n当解构失败的时候，我们可以为这个值设置一个自定义的值。\n\n```jsx\nvar [name1,name2,name3 = \"undefined\"] = name;\n```\n\n如果name3解构失败，那么它的值就是undefined。\n\n**关于对象的解构**\n\n- 对象解构的顺序问题\n\n对象的解构时没有顺序的，是根据key来进行解构的。\n\n```jsx\n\nvar obj = {mame:\"ada\",age:12,height:1.99};\nvar {height,age,name} = obj;\n```\n\n对象解构是按照对象的属性名来进行一一匹配，然后解构。\n\n- 对象解构重命名\n\n将结构出来的结果，名字进行更改。\n\n```jsx\nvar {height:gaodu,age:nianling,name:mingzi} = obj;\n```\n\n进行重命名之后，调用的时候，就使用我们重命名之后的变量名进行调用\n\n- 对象解构默认值\n\n与数组的默认值一样，当解构失败的时候，可以设置一个默认值。\n\n```jsx\nvar {height:gaodu,age:nianling,name:mingzi,address:dizhi = undefined} = obj;\n```\n\n- 剩余\n\n这个与数组解构是一样的，将没有变量存放的元素，放到一个新的对象里面。\n\n```jsx\nvar {height,..newObject} = obj;\n```\n\n## 5.5解构的应用场景\n\n- 拿到变量自动进行解构之后使用\n- 对函数的参数进行解构、","slug":"JavaScript/JavaScriptES6中的继承","published":1,"updated":"2023-05-23T08:36:04.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi6003w9kbm07c91pmz","content":"<h1 id=\"JavaScript-ES6中的继承\"><a href=\"#JavaScript-ES6中的继承\" class=\"headerlink\" title=\"JavaScript ES6中的继承\"></a>JavaScript ES6中的继承</h1><ol>\n<li>原型继承关系图</li>\n<li>class方式定义类</li>\n<li>extends实现继承</li>\n<li>Babel的ES6转ES5 </li>\n<li>面向对象多态理解</li>\n<li>ES6对象增强</li>\n</ol>\n<h1 id=\"1-原型继承关系图\"><a href=\"#1-原型继承关系图\" class=\"headerlink\" title=\"1. 原型继承关系图\"></a>1. 原型继承关系图</h1><p><img src=\"/%5Bhttps:/p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">](<a href=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image\">https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image</a>?))</p>\n<p>对象只有隐式原型，但是函数既有显式原型，又有隐式原型。</p>\n<p>函数的隐式原型看这个函数是被谁创造出来的。</p>\n<p>中间最上面的Function Foo()是被function Function 创建出来的，所以隐式原型__proto__指向Function的显示原型。</p>\n<h1 id=\"2-class方式定义类\"><a href=\"#2-class方式定义类\" class=\"headerlink\" title=\"2.class方式定义类\"></a>2.class方式定义类</h1><p>在ES5中定义类使用function，在ES6中定义类使用class.</p>\n<p>第一种方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 类中的构造函数</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当我们通过new创建一个Person类时，默认调用class类中的constructor方法</span></span><br><span class=\"line\">\t<span class=\"title function_\">constructor</span>(<span class=\"params\">name,age</span>)&#123;</span><br><span class=\"line\">\t\t <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 类中的实例函数</span></span><br><span class=\"line\">\t <span class=\"title function_\">runing</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>+<span class=\"string\">&quot;正在跑步&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造函数矛实例函数之间没有逗号间隔。 </p>\n<p>创建实例对象：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;admin&quot;</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(p1.<span class=\"property\">name</span>,p1.<span class=\"property\">age</span>); <span class=\"comment\">// admin 12</span></span><br><span class=\"line\">p1.<span class=\"title function_\">runing</span>(); <span class=\"comment\">// admin正在跑步</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(p1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>第二种方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Student</span> = <span class=\"keyword\">class</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建实例对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br></pre></td></tr></table></figure>\n\n<p>在class不支持函数的重载，也就是一个class里面只能有一个constructor函数。</p>\n<p><strong>class与function的不同点</strong> </p>\n<ul>\n<li>class定义的类，不能作为一个一个普通的函数去调用</li>\n</ul>\n<h2 id=\"2-1-class中定义访问器方法\"><a href=\"#2-1-class中定义访问器方法\" class=\"headerlink\" title=\"2.1 class中定义访问器方法\"></a>2.1 class中定义访问器方法</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类中的构造函数</span></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setter</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">name</span>(<span class=\"params\">age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">name</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2静态方法\"><a href=\"#2-2静态方法\" class=\"headerlink\" title=\"2.2静态方法\"></a>2.2静态方法</h2><p>静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用static关键字来定义。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"title function_\">running</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在奔跑&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">eating</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;吃饭&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;海绵宝宝&quot;</span>);</span><br><span class=\"line\">p1.<span class=\"title function_\">running</span>();</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"title function_\">eating</span>();</span><br></pre></td></tr></table></figure>\n\n<p>实例方法需要通过new关键字创建出的实例来调用，而静态方法可以直接调用。</p>\n<p>静态方法同样也有this，谁调用这个方法，this就指向谁。</p>\n<h1 id=\"3-extends实现继承\"><a href=\"#3-extends实现继承\" class=\"headerlink\" title=\"3.extends实现继承\"></a>3.extends实现继承</h1><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">running</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在奔跑&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age, score</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">score</span> = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">studying</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在学习&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Teacher</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age, money</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">money</span> = money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">working</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在工作&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stu1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;海绵宝宝&quot;</span>, <span class=\"number\">12</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(stu1.<span class=\"property\">name</span>, stu1.<span class=\"property\">age</span>, stu1.<span class=\"property\">score</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tea1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Teacher</span>(<span class=\"string\">&quot;泡芙&quot;</span>, <span class=\"number\">22</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tea1.<span class=\"property\">name</span>, tea1.<span class=\"property\">age</span>, tea1.<span class=\"property\">money</span>);</span><br></pre></td></tr></table></figure>\n\n<p>首先定义一个父类，子类中需要用到父类的属性时，直接使用super关键字。</p>\n<p>将共同的方法可以抽取到父类之中。</p>\n<p>我们在继承的时候：<code>子类 extends 父类</code></p>\n<h2 id=\"3-1-super关键字\"><a href=\"#3-1-super关键字\" class=\"headerlink\" title=\"3.1 super关键字\"></a>3.1 super关键字</h2><p>class为我们的方法中提供了一个方法</p>\n<ul>\n<li>super.menthd()：在子类调用父类的一个方法</li>\n<li>super():用来调用父类的constructor方法</li>\n</ul>\n<p>注意</p>\n<ul>\n<li>在子类中的构造方法中使用super必须在this之前，也就是说必须先通过super调用父类的构造函数。</li>\n<li>super的使用位置有三个：<ul>\n<li>子类的构造方法</li>\n<li>实例方法</li>\n<li>静态方法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">running</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;running&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">eating</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;eating&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">sleep</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;正在睡觉&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(name, age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果父类继承的方法达不到效果，我们可以重写方法</span></span><br><span class=\"line\">    <span class=\"title function_\">running</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在奔跑&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果要保留父类的方法，可以使用super调用父类的方法</span></span><br><span class=\"line\">        <span class=\"variable language_\">super</span>.<span class=\"title function_\">running</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">sleep</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;趴着睡觉&quot;</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>.<span class=\"title function_\">sleep</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;李长林&quot;</span>, <span class=\"number\">23</span>);</span><br><span class=\"line\">dog.<span class=\"title function_\">running</span>();</span><br><span class=\"line\">dog.<span class=\"title function_\">eating</span>();</span><br><span class=\"line\"><span class=\"title class_\">Dog</span>.<span class=\"title function_\">sleep</span>();</span><br></pre></td></tr></table></figure>\n\n<p>可以看到静态方法也可以使用super。</p>\n<h2 id=\"3-2-继承内置类\"><a href=\"#3-2-继承内置类\" class=\"headerlink\" title=\"3.2 继承内置类\"></a>3.2 继承内置类</h2><p>我们还可以继承JavaScript内部类，比如array，我们可以在Array添加一些新方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给数组添加一个方法，获取最后一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZMLArray</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Array</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">lastItem</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"title class_\">ZMLArray</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">lastItem</span>()); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-类的混入mixin-了解\"><a href=\"#3-3-类的混入mixin-了解\" class=\"headerlink\" title=\"3.3 类的混入mixin(了解)\"></a>3.3 类的混入mixin(了解)</h2><p>JavaScript继承只支持单继承。</p>\n<h1 id=\"4-JavaScript中的多态\"><a href=\"#4-JavaScript中的多态\" class=\"headerlink\" title=\"4.JavaScript中的多态\"></a>4.JavaScript中的多态</h1><p>不同的数据类型进行同一个操作，表现出不同的行为，这就是多态。</p>\n<ul>\n<li>继承是多态的前提（实现接口）。</li>\n<li>必须有父类的引用指向子类对象。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算面积</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getArea</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 矩形</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">width, height</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">width</span> = width;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">height</span> = height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">getArea</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">width</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">height</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">radius</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span> = radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">getArea</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rect1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Rectangle</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> rect2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Rectangle</span>(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ac2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getShapeArea</span>(<span class=\"params\">shape</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(shape.<span class=\"title function_\">getArea</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getShapeArea</span>(rect1);</span><br><span class=\"line\"><span class=\"title function_\">getShapeArea</span>(c1);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-对象字面量增强\"><a href=\"#5-对象字面量增强\" class=\"headerlink\" title=\"5. 对象字面量增强\"></a>5. 对象字面量增强</h1><ul>\n<li>属性的简写</li>\n<li>方法的简写</li>\n<li>计算属性名</li>\n<li>解构Destrucuring:<ul>\n<li>数组解构</li>\n<li>对象解构</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-1-属性的简写\"><a href=\"#5-1-属性的简写\" class=\"headerlink\" title=\"5.1 属性的简写\"></a>5.1 属性的简写</h2><p>当我们在对象里面写一个外部已经存在的变量时，我们可以直接使用简写。例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 属性的简写</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;hmbb&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// name: name;</span></span><br><span class=\"line\">    name,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>); <span class=\"comment\">// hmbb</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-方法的间隙\"><a href=\"#5-2-方法的间隙\" class=\"headerlink\" title=\"5.2 方法的间隙\"></a>5.2 方法的间隙</h2><p>方法的简写：这种写法绑定this。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法的简写</span></span><br><span class=\"line\"><span class=\"title function_\">running</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 方法体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-计算属性名：\"><a href=\"#5-3-计算属性名：\" class=\"headerlink\" title=\"5.3 计算属性名：\"></a>5.3 计算属性名：</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 属性的简写</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"string\">&quot;address&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// 计算属性的简写</span></span><br><span class=\"line\">    [key]: <span class=\"string\">&quot;广州&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">address</span>); <span class=\"comment\">// 广州</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4-解构：\"><a href=\"#5-4-解构：\" class=\"headerlink\" title=\"5.4 解构：\"></a>5.4 解构：</h2><p>最简单的数组以及对象解构：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = [<span class=\"string\">&quot;asda&quot;</span>, <span class=\"string\">&quot;fwe&quot;</span>, <span class=\"string\">&quot;zxcz&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;hmbb&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">13</span>, <span class=\"attr\">height</span>: <span class=\"number\">1.99</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组的解构</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [name1, name2, name3] = name;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name1, name2, name3);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的解构</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; name, age, height &#125; = obj;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name, age, height);</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于数组的解构</strong></p>\n<ul>\n<li>顺序问题：</li>\n</ul>\n<p>在数组里面进行解构的时候有严格的顺序问题。如果我们想要跳过一个元素：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [name1,,name3] = name;</span><br></pre></td></tr></table></figure>\n\n<p>也就是在跳过的元素要用逗号留出位置。</p>\n<ul>\n<li>解构出数组</li>\n</ul>\n<p>我们解构之后剩余的元素全部放到一个新数组里面。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [name1,..<span class=\"property\">newArr</span>] = name;</span><br></pre></td></tr></table></figure>\n\n<p>这样的结果就是<code>name1:asda</code>,<code>newArr:[”fwe”,”zxcz”]</code>。</p>\n<ul>\n<li>解构的默认值</li>\n</ul>\n<p>当解构失败的时候，我们可以为这个值设置一个自定义的值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [name1,name2,name3 = <span class=\"string\">&quot;undefined&quot;</span>] = name;</span><br></pre></td></tr></table></figure>\n\n<p>如果name3解构失败，那么它的值就是undefined。</p>\n<p><strong>关于对象的解构</strong></p>\n<ul>\n<li>对象解构的顺序问题</li>\n</ul>\n<p>对象的解构时没有顺序的，是根据key来进行解构的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">mame</span>:<span class=\"string\">&quot;ada&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">12</span>,<span class=\"attr\">height</span>:<span class=\"number\">1.99</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;height,age,name&#125; = obj;</span><br></pre></td></tr></table></figure>\n\n<p>对象解构是按照对象的属性名来进行一一匹配，然后解构。</p>\n<ul>\n<li>对象解构重命名</li>\n</ul>\n<p>将结构出来的结果，名字进行更改。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">height</span>:gaodu,<span class=\"attr\">age</span>:nianling,<span class=\"attr\">name</span>:mingzi&#125; = obj;</span><br></pre></td></tr></table></figure>\n\n<p>进行重命名之后，调用的时候，就使用我们重命名之后的变量名进行调用</p>\n<ul>\n<li>对象解构默认值</li>\n</ul>\n<p>与数组的默认值一样，当解构失败的时候，可以设置一个默认值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">height</span>:gaodu,<span class=\"attr\">age</span>:nianling,<span class=\"attr\">name</span>:mingzi,<span class=\"attr\">address</span>:dizhi = <span class=\"literal\">undefined</span>&#125; = obj;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>剩余</li>\n</ul>\n<p>这个与数组解构是一样的，将没有变量存放的元素，放到一个新的对象里面。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;height,..<span class=\"property\">newObject</span>&#125; = obj;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-5解构的应用场景\"><a href=\"#5-5解构的应用场景\" class=\"headerlink\" title=\"5.5解构的应用场景\"></a>5.5解构的应用场景</h2><ul>\n<li>拿到变量自动进行解构之后使用</li>\n<li>对函数的参数进行解构、</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-ES6中的继承\"><a href=\"#JavaScript-ES6中的继承\" class=\"headerlink\" title=\"JavaScript ES6中的继承\"></a>JavaScript ES6中的继承</h1><ol>\n<li>原型继承关系图</li>\n<li>class方式定义类</li>\n<li>extends实现继承</li>\n<li>Babel的ES6转ES5 </li>\n<li>面向对象多态理解</li>\n<li>ES6对象增强</li>\n</ol>\n<h1 id=\"1-原型继承关系图\"><a href=\"#1-原型继承关系图\" class=\"headerlink\" title=\"1. 原型继承关系图\"></a>1. 原型继承关系图</h1><p><img src=\"/%5Bhttps:/p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\">](<a href=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image\">https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fb1bd1e89e4f7da9ea53d3d8ba4095~tplv-k3u1fbpfcp-watermark.image</a>?))</p>\n<p>对象只有隐式原型，但是函数既有显式原型，又有隐式原型。</p>\n<p>函数的隐式原型看这个函数是被谁创造出来的。</p>\n<p>中间最上面的Function Foo()是被function Function 创建出来的，所以隐式原型__proto__指向Function的显示原型。</p>\n<h1 id=\"2-class方式定义类\"><a href=\"#2-class方式定义类\" class=\"headerlink\" title=\"2.class方式定义类\"></a>2.class方式定义类</h1><p>在ES5中定义类使用function，在ES6中定义类使用class.</p>\n<p>第一种方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 类中的构造函数</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当我们通过new创建一个Person类时，默认调用class类中的constructor方法</span></span><br><span class=\"line\">\t<span class=\"title function_\">constructor</span>(<span class=\"params\">name,age</span>)&#123;</span><br><span class=\"line\">\t\t <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 类中的实例函数</span></span><br><span class=\"line\">\t <span class=\"title function_\">runing</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>+<span class=\"string\">&quot;正在跑步&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造函数矛实例函数之间没有逗号间隔。 </p>\n<p>创建实例对象：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;admin&quot;</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(p1.<span class=\"property\">name</span>,p1.<span class=\"property\">age</span>); <span class=\"comment\">// admin 12</span></span><br><span class=\"line\">p1.<span class=\"title function_\">runing</span>(); <span class=\"comment\">// admin正在跑步</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(p1.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>第二种方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Student</span> = <span class=\"keyword\">class</span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 创建实例对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br></pre></td></tr></table></figure>\n\n<p>在class不支持函数的重载，也就是一个class里面只能有一个constructor函数。</p>\n<p><strong>class与function的不同点</strong> </p>\n<ul>\n<li>class定义的类，不能作为一个一个普通的函数去调用</li>\n</ul>\n<h2 id=\"2-1-class中定义访问器方法\"><a href=\"#2-1-class中定义访问器方法\" class=\"headerlink\" title=\"2.1 class中定义访问器方法\"></a>2.1 class中定义访问器方法</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类中的构造函数</span></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// setter</span></span><br><span class=\"line\">    <span class=\"keyword\">set</span> <span class=\"title function_\">name</span>(<span class=\"params\">age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">name</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2静态方法\"><a href=\"#2-2静态方法\" class=\"headerlink\" title=\"2.2静态方法\"></a>2.2静态方法</h2><p>静态方法通常用于定义直接使用类来执行的方法，不需要有类的实例，使用static关键字来定义。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 实例方法</span></span><br><span class=\"line\">    <span class=\"title function_\">running</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在奔跑&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">eating</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;吃饭&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;海绵宝宝&quot;</span>);</span><br><span class=\"line\">p1.<span class=\"title function_\">running</span>();</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"title function_\">eating</span>();</span><br></pre></td></tr></table></figure>\n\n<p>实例方法需要通过new关键字创建出的实例来调用，而静态方法可以直接调用。</p>\n<p>静态方法同样也有this，谁调用这个方法，this就指向谁。</p>\n<h1 id=\"3-extends实现继承\"><a href=\"#3-extends实现继承\" class=\"headerlink\" title=\"3.extends实现继承\"></a>3.extends实现继承</h1><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 父类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">running</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在奔跑&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age, score</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">score</span> = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">studying</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在学习&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Teacher</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age, money</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">money</span> = money;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">working</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在工作&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> stu1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;海绵宝宝&quot;</span>, <span class=\"number\">12</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(stu1.<span class=\"property\">name</span>, stu1.<span class=\"property\">age</span>, stu1.<span class=\"property\">score</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tea1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Teacher</span>(<span class=\"string\">&quot;泡芙&quot;</span>, <span class=\"number\">22</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tea1.<span class=\"property\">name</span>, tea1.<span class=\"property\">age</span>, tea1.<span class=\"property\">money</span>);</span><br></pre></td></tr></table></figure>\n\n<p>首先定义一个父类，子类中需要用到父类的属性时，直接使用super关键字。</p>\n<p>将共同的方法可以抽取到父类之中。</p>\n<p>我们在继承的时候：<code>子类 extends 父类</code></p>\n<h2 id=\"3-1-super关键字\"><a href=\"#3-1-super关键字\" class=\"headerlink\" title=\"3.1 super关键字\"></a>3.1 super关键字</h2><p>class为我们的方法中提供了一个方法</p>\n<ul>\n<li>super.menthd()：在子类调用父类的一个方法</li>\n<li>super():用来调用父类的constructor方法</li>\n</ul>\n<p>注意</p>\n<ul>\n<li>在子类中的构造方法中使用super必须在this之前，也就是说必须先通过super调用父类的构造函数。</li>\n<li>super的使用位置有三个：<ul>\n<li>子类的构造方法</li>\n<li>实例方法</li>\n<li>静态方法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">running</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;running&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">eating</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;eating&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">sleep</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;正在睡觉&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(name, age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果父类继承的方法达不到效果，我们可以重写方法</span></span><br><span class=\"line\">    <span class=\"title function_\">running</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;正在奔跑&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 如果要保留父类的方法，可以使用super调用父类的方法</span></span><br><span class=\"line\">        <span class=\"variable language_\">super</span>.<span class=\"title function_\">running</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">sleep</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&quot;趴着睡觉&quot;</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>.<span class=\"title function_\">sleep</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;李长林&quot;</span>, <span class=\"number\">23</span>);</span><br><span class=\"line\">dog.<span class=\"title function_\">running</span>();</span><br><span class=\"line\">dog.<span class=\"title function_\">eating</span>();</span><br><span class=\"line\"><span class=\"title class_\">Dog</span>.<span class=\"title function_\">sleep</span>();</span><br></pre></td></tr></table></figure>\n\n<p>可以看到静态方法也可以使用super。</p>\n<h2 id=\"3-2-继承内置类\"><a href=\"#3-2-继承内置类\" class=\"headerlink\" title=\"3.2 继承内置类\"></a>3.2 继承内置类</h2><p>我们还可以继承JavaScript内部类，比如array，我们可以在Array添加一些新方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给数组添加一个方法，获取最后一个元素</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ZMLArray</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Array</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">lastItem</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>[<span class=\"variable language_\">this</span>.<span class=\"property\">length</span> - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"title class_\">ZMLArray</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">lastItem</span>()); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-类的混入mixin-了解\"><a href=\"#3-3-类的混入mixin-了解\" class=\"headerlink\" title=\"3.3 类的混入mixin(了解)\"></a>3.3 类的混入mixin(了解)</h2><p>JavaScript继承只支持单继承。</p>\n<h1 id=\"4-JavaScript中的多态\"><a href=\"#4-JavaScript中的多态\" class=\"headerlink\" title=\"4.JavaScript中的多态\"></a>4.JavaScript中的多态</h1><p>不同的数据类型进行同一个操作，表现出不同的行为，这就是多态。</p>\n<ul>\n<li>继承是多态的前提（实现接口）。</li>\n<li>必须有父类的引用指向子类对象。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算面积</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">getArea</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 矩形</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">width, height</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">width</span> = width;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">height</span> = height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">getArea</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">width</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">height</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">shape</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">radius</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span> = radius;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">getArea</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span> * <span class=\"variable language_\">this</span>.<span class=\"property\">radius</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rect1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Rectangle</span>(<span class=\"number\">100</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> rect2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Rectangle</span>(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> ac2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Circle</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getShapeArea</span>(<span class=\"params\">shape</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(shape.<span class=\"title function_\">getArea</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getShapeArea</span>(rect1);</span><br><span class=\"line\"><span class=\"title function_\">getShapeArea</span>(c1);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-对象字面量增强\"><a href=\"#5-对象字面量增强\" class=\"headerlink\" title=\"5. 对象字面量增强\"></a>5. 对象字面量增强</h1><ul>\n<li>属性的简写</li>\n<li>方法的简写</li>\n<li>计算属性名</li>\n<li>解构Destrucuring:<ul>\n<li>数组解构</li>\n<li>对象解构</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-1-属性的简写\"><a href=\"#5-1-属性的简写\" class=\"headerlink\" title=\"5.1 属性的简写\"></a>5.1 属性的简写</h2><p>当我们在对象里面写一个外部已经存在的变量时，我们可以直接使用简写。例如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 属性的简写</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;hmbb&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// name: name;</span></span><br><span class=\"line\">    name,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>); <span class=\"comment\">// hmbb</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-方法的间隙\"><a href=\"#5-2-方法的间隙\" class=\"headerlink\" title=\"5.2 方法的间隙\"></a>5.2 方法的间隙</h2><p>方法的简写：这种写法绑定this。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法的简写</span></span><br><span class=\"line\"><span class=\"title function_\">running</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 方法体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-计算属性名：\"><a href=\"#5-3-计算属性名：\" class=\"headerlink\" title=\"5.3 计算属性名：\"></a>5.3 计算属性名：</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 属性的简写</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> key = <span class=\"string\">&quot;address&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// 计算属性的简写</span></span><br><span class=\"line\">    [key]: <span class=\"string\">&quot;广州&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">address</span>); <span class=\"comment\">// 广州</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4-解构：\"><a href=\"#5-4-解构：\" class=\"headerlink\" title=\"5.4 解构：\"></a>5.4 解构：</h2><p>最简单的数组以及对象解构：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = [<span class=\"string\">&quot;asda&quot;</span>, <span class=\"string\">&quot;fwe&quot;</span>, <span class=\"string\">&quot;zxcz&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;hmbb&quot;</span>, <span class=\"attr\">age</span>: <span class=\"number\">13</span>, <span class=\"attr\">height</span>: <span class=\"number\">1.99</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组的解构</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [name1, name2, name3] = name;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name1, name2, name3);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的解构</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; name, age, height &#125; = obj;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name, age, height);</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于数组的解构</strong></p>\n<ul>\n<li>顺序问题：</li>\n</ul>\n<p>在数组里面进行解构的时候有严格的顺序问题。如果我们想要跳过一个元素：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [name1,,name3] = name;</span><br></pre></td></tr></table></figure>\n\n<p>也就是在跳过的元素要用逗号留出位置。</p>\n<ul>\n<li>解构出数组</li>\n</ul>\n<p>我们解构之后剩余的元素全部放到一个新数组里面。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [name1,..<span class=\"property\">newArr</span>] = name;</span><br></pre></td></tr></table></figure>\n\n<p>这样的结果就是<code>name1:asda</code>,<code>newArr:[”fwe”,”zxcz”]</code>。</p>\n<ul>\n<li>解构的默认值</li>\n</ul>\n<p>当解构失败的时候，我们可以为这个值设置一个自定义的值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> [name1,name2,name3 = <span class=\"string\">&quot;undefined&quot;</span>] = name;</span><br></pre></td></tr></table></figure>\n\n<p>如果name3解构失败，那么它的值就是undefined。</p>\n<p><strong>关于对象的解构</strong></p>\n<ul>\n<li>对象解构的顺序问题</li>\n</ul>\n<p>对象的解构时没有顺序的，是根据key来进行解构的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">mame</span>:<span class=\"string\">&quot;ada&quot;</span>,<span class=\"attr\">age</span>:<span class=\"number\">12</span>,<span class=\"attr\">height</span>:<span class=\"number\">1.99</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;height,age,name&#125; = obj;</span><br></pre></td></tr></table></figure>\n\n<p>对象解构是按照对象的属性名来进行一一匹配，然后解构。</p>\n<ul>\n<li>对象解构重命名</li>\n</ul>\n<p>将结构出来的结果，名字进行更改。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">height</span>:gaodu,<span class=\"attr\">age</span>:nianling,<span class=\"attr\">name</span>:mingzi&#125; = obj;</span><br></pre></td></tr></table></figure>\n\n<p>进行重命名之后，调用的时候，就使用我们重命名之后的变量名进行调用</p>\n<ul>\n<li>对象解构默认值</li>\n</ul>\n<p>与数组的默认值一样，当解构失败的时候，可以设置一个默认值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">height</span>:gaodu,<span class=\"attr\">age</span>:nianling,<span class=\"attr\">name</span>:mingzi,<span class=\"attr\">address</span>:dizhi = <span class=\"literal\">undefined</span>&#125; = obj;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>剩余</li>\n</ul>\n<p>这个与数组解构是一样的，将没有变量存放的元素，放到一个新的对象里面。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;height,..<span class=\"property\">newObject</span>&#125; = obj;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-5解构的应用场景\"><a href=\"#5-5解构的应用场景\" class=\"headerlink\" title=\"5.5解构的应用场景\"></a>5.5解构的应用场景</h2><ul>\n<li>拿到变量自动进行解构之后使用</li>\n<li>对函数的参数进行解构、</li>\n</ul>\n"},{"title":"JavaScript中的块级作用域","date":"2023-05-21T16:00:00.000Z","_content":"# 块级作用域\n\n- ECMA新描述概念\n- let const的使用\n- let cons和var的区别\n- 块级作用域的使用\n- 模板字符串的详解\n- ES6函数的增强用法\n\n# 1. ECMA文档中代码执行术语解析\n\n**ES5之前的术语：**\n\n- 执行上下文栈（ECS）\n- 执行上下文（EC）\n- 变量对象（VO）\n- 全局对象（GO）\n- 激活对象（AO）\n- 作用域链（scope chain）\n\n**ES6之后的术语：**\n\n大差不差。\n\n1. **词法环境：**\n    1. 一个词法环境是由环境记录和一个外部词法环境组成。\n    2. 一个词法环境经常用于关联函数声明、代码块语句、try-catch语句，当它们的代码被执行时，词法环境被创建出出来。 \n\n执行上下文会关联的词法环境有：\n\n- 词法环境\n- 变量环境\n\n这两者在初始化时，值是一样的。\n\n两者的区别：\n\n- 词法环境用于处理let const声明的标识符。\n- 变量环境用于处理var和function声明的标识符。\n1. **环境记录：**\n    1. 声明式环境记录：声明性环境记录用于ECMAScript语言语法元素的效果，比如函数声明、变量声明和直接将标识符绑定与ECMAScript语言值关联起来的Catch子句。\n    2. 对象式环境记录：用于记录ECMAScript与元素效果，它将标识符绑定与某些对象的属性关联起来。\n\n# 2. let/const\n\n## 2.1 let/const基本使用\n\nlet与const都是用于声明变量的，使用方法与var差不多。\n\n```jsx\nlet a = 10;\nconst b = 20;\n```\n\n只是const有一点区别：\n\n- const声明的变量表示常量。\n- 它声明的变量一旦被赋值就不可以被更改。\n\n```jsx\nconst id = 001;\nid = 002; // 报错\n```\n\n- 如果声明的变量赋值是一个引用数据类型，可以更改该引用对象里面的内容，但是不可以更改该变量存储的对象地址值。\n\n```jsx\nvar obj = {\n\tname:\"adas\",\n\tage:12,\n}\n\nconst info = obj;\ninfo.name = \"qwe\"; // 成功，不报错\n```\n\n**注意：**\n\nlet与const不允许重复声明变量。\n\n```jsx\nlet name = \"as\";\nlet name = \"qw\"; // 报错\n\nconst id = \"001\";\nconst id = \"002\"; // 报错\n```\n\n## 2.2 let/const作用域提升\n\nlet/const与var另一个重要区别就是作用域提升\n\n使用let声明的变量，在赋值之前访问时会报错。\n\n但是不是在赋值之前变量都没有创建，而是\n\n**这些变量会在他们的词法环境被实例化时被创建，但是不可以访问，知道词法被绑定求值。**\n\n虽然变量在赋值之前就已经存在了，但是它并不能在赋值之前访问，所以我认为let/const没有作用域提升（作用域提升：在变量的作用域中，这个变量可以在声明之前被访问，这就是作用域提升）\n\n**所以**：let/const没有作用域提升，但是会在解析阶段被创建出来。\n\n- 暂时性死区\n    \n    从作用域顶部到变量被声明赋值之前，这一段区域该变量都不可以被访问，这就是暂时性死区。\n    \n\n暂时性死区与定义的位置没有关系，只与代码执行的顺序有关系。\n\n**注意：**\n\nlet/const不会添加到window。\n\nvar定义的变量是会默认添加到window的。\n\n## 2.3 块级作用域\n\nlet-const的块级作用域。\n\n代码块：\n\n```jsx\n{\n\t// 代码\n}\n```\n\n也就是花括号包裹起来的一块代码，包括函数内部的函数体。\n\n在ES5之前，只有全局作用域和函数作用域。\n\n使用let/const/function/class声明的变量有块级作用域。","source":"_posts/JavaScript/JavaScript中的块级作用域.md","raw":"---\ntitle: JavaScript中的块级作用域\ndate: [2023-5-22]\ntags: [前端]\ncategories: [JavaScript]\n---\n# 块级作用域\n\n- ECMA新描述概念\n- let const的使用\n- let cons和var的区别\n- 块级作用域的使用\n- 模板字符串的详解\n- ES6函数的增强用法\n\n# 1. ECMA文档中代码执行术语解析\n\n**ES5之前的术语：**\n\n- 执行上下文栈（ECS）\n- 执行上下文（EC）\n- 变量对象（VO）\n- 全局对象（GO）\n- 激活对象（AO）\n- 作用域链（scope chain）\n\n**ES6之后的术语：**\n\n大差不差。\n\n1. **词法环境：**\n    1. 一个词法环境是由环境记录和一个外部词法环境组成。\n    2. 一个词法环境经常用于关联函数声明、代码块语句、try-catch语句，当它们的代码被执行时，词法环境被创建出出来。 \n\n执行上下文会关联的词法环境有：\n\n- 词法环境\n- 变量环境\n\n这两者在初始化时，值是一样的。\n\n两者的区别：\n\n- 词法环境用于处理let const声明的标识符。\n- 变量环境用于处理var和function声明的标识符。\n1. **环境记录：**\n    1. 声明式环境记录：声明性环境记录用于ECMAScript语言语法元素的效果，比如函数声明、变量声明和直接将标识符绑定与ECMAScript语言值关联起来的Catch子句。\n    2. 对象式环境记录：用于记录ECMAScript与元素效果，它将标识符绑定与某些对象的属性关联起来。\n\n# 2. let/const\n\n## 2.1 let/const基本使用\n\nlet与const都是用于声明变量的，使用方法与var差不多。\n\n```jsx\nlet a = 10;\nconst b = 20;\n```\n\n只是const有一点区别：\n\n- const声明的变量表示常量。\n- 它声明的变量一旦被赋值就不可以被更改。\n\n```jsx\nconst id = 001;\nid = 002; // 报错\n```\n\n- 如果声明的变量赋值是一个引用数据类型，可以更改该引用对象里面的内容，但是不可以更改该变量存储的对象地址值。\n\n```jsx\nvar obj = {\n\tname:\"adas\",\n\tage:12,\n}\n\nconst info = obj;\ninfo.name = \"qwe\"; // 成功，不报错\n```\n\n**注意：**\n\nlet与const不允许重复声明变量。\n\n```jsx\nlet name = \"as\";\nlet name = \"qw\"; // 报错\n\nconst id = \"001\";\nconst id = \"002\"; // 报错\n```\n\n## 2.2 let/const作用域提升\n\nlet/const与var另一个重要区别就是作用域提升\n\n使用let声明的变量，在赋值之前访问时会报错。\n\n但是不是在赋值之前变量都没有创建，而是\n\n**这些变量会在他们的词法环境被实例化时被创建，但是不可以访问，知道词法被绑定求值。**\n\n虽然变量在赋值之前就已经存在了，但是它并不能在赋值之前访问，所以我认为let/const没有作用域提升（作用域提升：在变量的作用域中，这个变量可以在声明之前被访问，这就是作用域提升）\n\n**所以**：let/const没有作用域提升，但是会在解析阶段被创建出来。\n\n- 暂时性死区\n    \n    从作用域顶部到变量被声明赋值之前，这一段区域该变量都不可以被访问，这就是暂时性死区。\n    \n\n暂时性死区与定义的位置没有关系，只与代码执行的顺序有关系。\n\n**注意：**\n\nlet/const不会添加到window。\n\nvar定义的变量是会默认添加到window的。\n\n## 2.3 块级作用域\n\nlet-const的块级作用域。\n\n代码块：\n\n```jsx\n{\n\t// 代码\n}\n```\n\n也就是花括号包裹起来的一块代码，包括函数内部的函数体。\n\n在ES5之前，只有全局作用域和函数作用域。\n\n使用let/const/function/class声明的变量有块级作用域。","slug":"JavaScript/JavaScript中的块级作用域","published":1,"updated":"2023-05-22T11:40:04.578Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi8003z9kbm5rzuc2jt","content":"<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><ul>\n<li>ECMA新描述概念</li>\n<li>let const的使用</li>\n<li>let cons和var的区别</li>\n<li>块级作用域的使用</li>\n<li>模板字符串的详解</li>\n<li>ES6函数的增强用法</li>\n</ul>\n<h1 id=\"1-ECMA文档中代码执行术语解析\"><a href=\"#1-ECMA文档中代码执行术语解析\" class=\"headerlink\" title=\"1. ECMA文档中代码执行术语解析\"></a>1. ECMA文档中代码执行术语解析</h1><p><strong>ES5之前的术语：</strong></p>\n<ul>\n<li>执行上下文栈（ECS）</li>\n<li>执行上下文（EC）</li>\n<li>变量对象（VO）</li>\n<li>全局对象（GO）</li>\n<li>激活对象（AO）</li>\n<li>作用域链（scope chain）</li>\n</ul>\n<p><strong>ES6之后的术语：</strong></p>\n<p>大差不差。</p>\n<ol>\n<li><strong>词法环境：</strong><ol>\n<li>一个词法环境是由环境记录和一个外部词法环境组成。</li>\n<li>一个词法环境经常用于关联函数声明、代码块语句、try-catch语句，当它们的代码被执行时，词法环境被创建出出来。</li>\n</ol>\n</li>\n</ol>\n<p>执行上下文会关联的词法环境有：</p>\n<ul>\n<li>词法环境</li>\n<li>变量环境</li>\n</ul>\n<p>这两者在初始化时，值是一样的。</p>\n<p>两者的区别：</p>\n<ul>\n<li>词法环境用于处理let const声明的标识符。</li>\n<li>变量环境用于处理var和function声明的标识符。</li>\n</ul>\n<ol>\n<li><strong>环境记录：</strong><ol>\n<li>声明式环境记录：声明性环境记录用于ECMAScript语言语法元素的效果，比如函数声明、变量声明和直接将标识符绑定与ECMAScript语言值关联起来的Catch子句。</li>\n<li>对象式环境记录：用于记录ECMAScript与元素效果，它将标识符绑定与某些对象的属性关联起来。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"2-let-x2F-const\"><a href=\"#2-let-x2F-const\" class=\"headerlink\" title=\"2. let&#x2F;const\"></a>2. let&#x2F;const</h1><h2 id=\"2-1-let-x2F-const基本使用\"><a href=\"#2-1-let-x2F-const基本使用\" class=\"headerlink\" title=\"2.1 let&#x2F;const基本使用\"></a>2.1 let&#x2F;const基本使用</h2><p>let与const都是用于声明变量的，使用方法与var差不多。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<p>只是const有一点区别：</p>\n<ul>\n<li>const声明的变量表示常量。</li>\n<li>它声明的变量一旦被赋值就不可以被更改。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> id = <span class=\"number\">001</span>;</span><br><span class=\"line\">id = <span class=\"number\">002</span>; <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果声明的变量赋值是一个引用数据类型，可以更改该引用对象里面的内容，但是不可以更改该变量存储的对象地址值。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;adas&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">12</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> info = obj;</span><br><span class=\"line\">info.<span class=\"property\">name</span> = <span class=\"string\">&quot;qwe&quot;</span>; <span class=\"comment\">// 成功，不报错</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>let与const不允许重复声明变量。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&quot;as&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&quot;qw&quot;</span>; <span class=\"comment\">// 报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> id = <span class=\"string\">&quot;001&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> id = <span class=\"string\">&quot;002&quot;</span>; <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-let-x2F-const作用域提升\"><a href=\"#2-2-let-x2F-const作用域提升\" class=\"headerlink\" title=\"2.2 let&#x2F;const作用域提升\"></a>2.2 let&#x2F;const作用域提升</h2><p>let&#x2F;const与var另一个重要区别就是作用域提升</p>\n<p>使用let声明的变量，在赋值之前访问时会报错。</p>\n<p>但是不是在赋值之前变量都没有创建，而是</p>\n<p><strong>这些变量会在他们的词法环境被实例化时被创建，但是不可以访问，知道词法被绑定求值。</strong></p>\n<p>虽然变量在赋值之前就已经存在了，但是它并不能在赋值之前访问，所以我认为let&#x2F;const没有作用域提升（作用域提升：在变量的作用域中，这个变量可以在声明之前被访问，这就是作用域提升）</p>\n<p><strong>所以</strong>：let&#x2F;const没有作用域提升，但是会在解析阶段被创建出来。</p>\n<ul>\n<li><p>暂时性死区</p>\n<p>  从作用域顶部到变量被声明赋值之前，这一段区域该变量都不可以被访问，这就是暂时性死区。</p>\n</li>\n</ul>\n<p>暂时性死区与定义的位置没有关系，只与代码执行的顺序有关系。</p>\n<p><strong>注意：</strong></p>\n<p>let&#x2F;const不会添加到window。</p>\n<p>var定义的变量是会默认添加到window的。</p>\n<h2 id=\"2-3-块级作用域\"><a href=\"#2-3-块级作用域\" class=\"headerlink\" title=\"2.3 块级作用域\"></a>2.3 块级作用域</h2><p>let-const的块级作用域。</p>\n<p>代码块：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是花括号包裹起来的一块代码，包括函数内部的函数体。</p>\n<p>在ES5之前，只有全局作用域和函数作用域。</p>\n<p>使用let&#x2F;const&#x2F;function&#x2F;class声明的变量有块级作用域。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><ul>\n<li>ECMA新描述概念</li>\n<li>let const的使用</li>\n<li>let cons和var的区别</li>\n<li>块级作用域的使用</li>\n<li>模板字符串的详解</li>\n<li>ES6函数的增强用法</li>\n</ul>\n<h1 id=\"1-ECMA文档中代码执行术语解析\"><a href=\"#1-ECMA文档中代码执行术语解析\" class=\"headerlink\" title=\"1. ECMA文档中代码执行术语解析\"></a>1. ECMA文档中代码执行术语解析</h1><p><strong>ES5之前的术语：</strong></p>\n<ul>\n<li>执行上下文栈（ECS）</li>\n<li>执行上下文（EC）</li>\n<li>变量对象（VO）</li>\n<li>全局对象（GO）</li>\n<li>激活对象（AO）</li>\n<li>作用域链（scope chain）</li>\n</ul>\n<p><strong>ES6之后的术语：</strong></p>\n<p>大差不差。</p>\n<ol>\n<li><strong>词法环境：</strong><ol>\n<li>一个词法环境是由环境记录和一个外部词法环境组成。</li>\n<li>一个词法环境经常用于关联函数声明、代码块语句、try-catch语句，当它们的代码被执行时，词法环境被创建出出来。</li>\n</ol>\n</li>\n</ol>\n<p>执行上下文会关联的词法环境有：</p>\n<ul>\n<li>词法环境</li>\n<li>变量环境</li>\n</ul>\n<p>这两者在初始化时，值是一样的。</p>\n<p>两者的区别：</p>\n<ul>\n<li>词法环境用于处理let const声明的标识符。</li>\n<li>变量环境用于处理var和function声明的标识符。</li>\n</ul>\n<ol>\n<li><strong>环境记录：</strong><ol>\n<li>声明式环境记录：声明性环境记录用于ECMAScript语言语法元素的效果，比如函数声明、变量声明和直接将标识符绑定与ECMAScript语言值关联起来的Catch子句。</li>\n<li>对象式环境记录：用于记录ECMAScript与元素效果，它将标识符绑定与某些对象的属性关联起来。</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"2-let-x2F-const\"><a href=\"#2-let-x2F-const\" class=\"headerlink\" title=\"2. let&#x2F;const\"></a>2. let&#x2F;const</h1><h2 id=\"2-1-let-x2F-const基本使用\"><a href=\"#2-1-let-x2F-const基本使用\" class=\"headerlink\" title=\"2.1 let&#x2F;const基本使用\"></a>2.1 let&#x2F;const基本使用</h2><p>let与const都是用于声明变量的，使用方法与var差不多。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure>\n\n<p>只是const有一点区别：</p>\n<ul>\n<li>const声明的变量表示常量。</li>\n<li>它声明的变量一旦被赋值就不可以被更改。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> id = <span class=\"number\">001</span>;</span><br><span class=\"line\">id = <span class=\"number\">002</span>; <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果声明的变量赋值是一个引用数据类型，可以更改该引用对象里面的内容，但是不可以更改该变量存储的对象地址值。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">name</span>:<span class=\"string\">&quot;adas&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">age</span>:<span class=\"number\">12</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> info = obj;</span><br><span class=\"line\">info.<span class=\"property\">name</span> = <span class=\"string\">&quot;qwe&quot;</span>; <span class=\"comment\">// 成功，不报错</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>let与const不允许重复声明变量。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&quot;as&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&quot;qw&quot;</span>; <span class=\"comment\">// 报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> id = <span class=\"string\">&quot;001&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> id = <span class=\"string\">&quot;002&quot;</span>; <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-let-x2F-const作用域提升\"><a href=\"#2-2-let-x2F-const作用域提升\" class=\"headerlink\" title=\"2.2 let&#x2F;const作用域提升\"></a>2.2 let&#x2F;const作用域提升</h2><p>let&#x2F;const与var另一个重要区别就是作用域提升</p>\n<p>使用let声明的变量，在赋值之前访问时会报错。</p>\n<p>但是不是在赋值之前变量都没有创建，而是</p>\n<p><strong>这些变量会在他们的词法环境被实例化时被创建，但是不可以访问，知道词法被绑定求值。</strong></p>\n<p>虽然变量在赋值之前就已经存在了，但是它并不能在赋值之前访问，所以我认为let&#x2F;const没有作用域提升（作用域提升：在变量的作用域中，这个变量可以在声明之前被访问，这就是作用域提升）</p>\n<p><strong>所以</strong>：let&#x2F;const没有作用域提升，但是会在解析阶段被创建出来。</p>\n<ul>\n<li><p>暂时性死区</p>\n<p>  从作用域顶部到变量被声明赋值之前，这一段区域该变量都不可以被访问，这就是暂时性死区。</p>\n</li>\n</ul>\n<p>暂时性死区与定义的位置没有关系，只与代码执行的顺序有关系。</p>\n<p><strong>注意：</strong></p>\n<p>let&#x2F;const不会添加到window。</p>\n<p>var定义的变量是会默认添加到window的。</p>\n<h2 id=\"2-3-块级作用域\"><a href=\"#2-3-块级作用域\" class=\"headerlink\" title=\"2.3 块级作用域\"></a>2.3 块级作用域</h2><p>let-const的块级作用域。</p>\n<p>代码块：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是花括号包裹起来的一块代码，包括函数内部的函数体。</p>\n<p>在ES5之前，只有全局作用域和函数作用域。</p>\n<p>使用let&#x2F;const&#x2F;function&#x2F;class声明的变量有块级作用域。</p>\n"},{"title":"JavaScript中原型","date":"2022-10-02T16:00:00.000Z","_content":"# JavaScript中原型\n\n## 什么是原型\n\n众所周知，JavaScript是一门面向对象的编程语言，但是JavaScript中并没有类的概念，那么JavaScript是如何实现面向对象的呢？这就要从原型说起。\n\n首先我们要知道：原型存在于对象中。\n\n在JavaScript中，每个构造函数内部都有一个（prototype）属性，这个属性的值为对象，也就是原型对象。原型对象中包含了可以被对象共享的属性和方法。当我们访问一个对象的属性或者方法时，如果这个对象本身没有这个属性或者方法，那么JavaScript就会去它的原型对象中寻找，如果原型对象中也没有，那么就会去原型对象的原型对象中寻找，直到找到为止，如果最终都没有找到，那么就会返回undefined。\n\n## 原型链\n\n原型链就是原型对象的原型对象的原型对象……一直到Object.prototype为止，这就是原型链。\n\n这种一层一层的查找属性的方法就是原型链。\n\n前面我们说道JavaScript是一门没有`类`概念的编程语言，所以他就不能通过模板来创建对象。所以就出现了原型链，通过原型链来实现对象的继承。\n\n下面我们来详细解释原型链的组成。\n\n### Object.prototype\n\nObject.prototype是所有对象的原型对象，也就是说所有对象都可以访问到Object.prototype中的属性和方法。\n\n前面我们提到每个构造函数里面都有`prototype`属性，这个属性的值就是原型对象，而原型对象的原型对象就是Object.prototype。\n\n在构造函数的实例里面又有一个`__proto__`属性，这个属性的值就是构造函数的原型对象，也就是说`__proto__`属性的值就是`prototype`属性的值。\n\n简单来说就是构造函数的`prototype`指向原型对象，构造函数的实例`__proto__`属性指向Object.prototype。\n![avatar](D://桌面/插图1.png)\n\n### constructor\n\n每个原型对象都有一个`constructor`属性，这个属性指向关联构造函数。\n\n我们可以通过代码来验证这一说法：\n\n```javascript\n    function Person() {}\n    console.log(person. === Person.prototype.constructor); // true\n```\n\n既然实例对象是由构造函数构造得到的，那么是不是构造函数也有一个`constructor`呢？\n\n我们也可以通过代码来验证一下：\n\n```js\n    function Person() {}\n    var p = new Person();\n    console.log(P.constructor === Person.prototype.constructor); // true\n```\n\n但是实际上实例化对象并没有该属性，它的这个属性是从原型对象那里得到的。\n\n### 原型链顶层\n\n既然js通过原型链查找属性，前面我们也提到了如果查找到最后依旧没有找到该属性，就返回为undefined。那么原型链的顶层是什么呢？\n\n其实答案就是Object对象，既然object是对象，理所应当它也拥有__proto__属性，只是它的值比较特殊，它的值为null。\n\n```js\n    console.log(Object.prototype.__proto__); // null\n```\n\n## 总结\n\n最后：\n\n**总结一下:**\n\n- JavaScript中每个函数都有一个原型属性prototype，这个属性是一个对象，这个对象就是原型对象。\n- 普通函数的构造函数是Object(),所以所有函数都是Object的实例。`Person.prototype.__proto__ === Object.prototype`\n- 每个原型对象都有一个constructor属性，这个属性指向关联构造函数。\n- 原型链的顶层是Object对象，它的__proto__属性的值为null。","source":"_posts/JavaScript/JavaScript中原型.md","raw":"---\ntitle: JavaScript中原型\ndate: 2022-10-3\ntags: [前端]\ncategories: [JavaScript]\n---\n# JavaScript中原型\n\n## 什么是原型\n\n众所周知，JavaScript是一门面向对象的编程语言，但是JavaScript中并没有类的概念，那么JavaScript是如何实现面向对象的呢？这就要从原型说起。\n\n首先我们要知道：原型存在于对象中。\n\n在JavaScript中，每个构造函数内部都有一个（prototype）属性，这个属性的值为对象，也就是原型对象。原型对象中包含了可以被对象共享的属性和方法。当我们访问一个对象的属性或者方法时，如果这个对象本身没有这个属性或者方法，那么JavaScript就会去它的原型对象中寻找，如果原型对象中也没有，那么就会去原型对象的原型对象中寻找，直到找到为止，如果最终都没有找到，那么就会返回undefined。\n\n## 原型链\n\n原型链就是原型对象的原型对象的原型对象……一直到Object.prototype为止，这就是原型链。\n\n这种一层一层的查找属性的方法就是原型链。\n\n前面我们说道JavaScript是一门没有`类`概念的编程语言，所以他就不能通过模板来创建对象。所以就出现了原型链，通过原型链来实现对象的继承。\n\n下面我们来详细解释原型链的组成。\n\n### Object.prototype\n\nObject.prototype是所有对象的原型对象，也就是说所有对象都可以访问到Object.prototype中的属性和方法。\n\n前面我们提到每个构造函数里面都有`prototype`属性，这个属性的值就是原型对象，而原型对象的原型对象就是Object.prototype。\n\n在构造函数的实例里面又有一个`__proto__`属性，这个属性的值就是构造函数的原型对象，也就是说`__proto__`属性的值就是`prototype`属性的值。\n\n简单来说就是构造函数的`prototype`指向原型对象，构造函数的实例`__proto__`属性指向Object.prototype。\n![avatar](D://桌面/插图1.png)\n\n### constructor\n\n每个原型对象都有一个`constructor`属性，这个属性指向关联构造函数。\n\n我们可以通过代码来验证这一说法：\n\n```javascript\n    function Person() {}\n    console.log(person. === Person.prototype.constructor); // true\n```\n\n既然实例对象是由构造函数构造得到的，那么是不是构造函数也有一个`constructor`呢？\n\n我们也可以通过代码来验证一下：\n\n```js\n    function Person() {}\n    var p = new Person();\n    console.log(P.constructor === Person.prototype.constructor); // true\n```\n\n但是实际上实例化对象并没有该属性，它的这个属性是从原型对象那里得到的。\n\n### 原型链顶层\n\n既然js通过原型链查找属性，前面我们也提到了如果查找到最后依旧没有找到该属性，就返回为undefined。那么原型链的顶层是什么呢？\n\n其实答案就是Object对象，既然object是对象，理所应当它也拥有__proto__属性，只是它的值比较特殊，它的值为null。\n\n```js\n    console.log(Object.prototype.__proto__); // null\n```\n\n## 总结\n\n最后：\n\n**总结一下:**\n\n- JavaScript中每个函数都有一个原型属性prototype，这个属性是一个对象，这个对象就是原型对象。\n- 普通函数的构造函数是Object(),所以所有函数都是Object的实例。`Person.prototype.__proto__ === Object.prototype`\n- 每个原型对象都有一个constructor属性，这个属性指向关联构造函数。\n- 原型链的顶层是Object对象，它的__proto__属性的值为null。","slug":"JavaScript/JavaScript中原型","published":1,"updated":"2023-01-09T12:15:50.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi800429kbm06fs1n8k","content":"<h1 id=\"JavaScript中原型\"><a href=\"#JavaScript中原型\" class=\"headerlink\" title=\"JavaScript中原型\"></a>JavaScript中原型</h1><h2 id=\"什么是原型\"><a href=\"#什么是原型\" class=\"headerlink\" title=\"什么是原型\"></a>什么是原型</h2><p>众所周知，JavaScript是一门面向对象的编程语言，但是JavaScript中并没有类的概念，那么JavaScript是如何实现面向对象的呢？这就要从原型说起。</p>\n<p>首先我们要知道：原型存在于对象中。</p>\n<p>在JavaScript中，每个构造函数内部都有一个（prototype）属性，这个属性的值为对象，也就是原型对象。原型对象中包含了可以被对象共享的属性和方法。当我们访问一个对象的属性或者方法时，如果这个对象本身没有这个属性或者方法，那么JavaScript就会去它的原型对象中寻找，如果原型对象中也没有，那么就会去原型对象的原型对象中寻找，直到找到为止，如果最终都没有找到，那么就会返回undefined。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>原型链就是原型对象的原型对象的原型对象……一直到Object.prototype为止，这就是原型链。</p>\n<p>这种一层一层的查找属性的方法就是原型链。</p>\n<p>前面我们说道JavaScript是一门没有<code>类</code>概念的编程语言，所以他就不能通过模板来创建对象。所以就出现了原型链，通过原型链来实现对象的继承。</p>\n<p>下面我们来详细解释原型链的组成。</p>\n<h3 id=\"Object-prototype\"><a href=\"#Object-prototype\" class=\"headerlink\" title=\"Object.prototype\"></a>Object.prototype</h3><p>Object.prototype是所有对象的原型对象，也就是说所有对象都可以访问到Object.prototype中的属性和方法。</p>\n<p>前面我们提到每个构造函数里面都有<code>prototype</code>属性，这个属性的值就是原型对象，而原型对象的原型对象就是Object.prototype。</p>\n<p>在构造函数的实例里面又有一个<code>__proto__</code>属性，这个属性的值就是构造函数的原型对象，也就是说<code>__proto__</code>属性的值就是<code>prototype</code>属性的值。</p>\n<p>简单来说就是构造函数的<code>prototype</code>指向原型对象，构造函数的实例<code>__proto__</code>属性指向Object.prototype。<br><img src=\"D://桌面/插图1.png\" alt=\"avatar\"></p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><p>每个原型对象都有一个<code>constructor</code>属性，这个属性指向关联构造函数。</p>\n<p>我们可以通过代码来验证这一说法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person. === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>既然实例对象是由构造函数构造得到的，那么是不是构造函数也有一个<code>constructor</code>呢？</p>\n<p>我们也可以通过代码来验证一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(P.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但是实际上实例化对象并没有该属性，它的这个属性是从原型对象那里得到的。</p>\n<h3 id=\"原型链顶层\"><a href=\"#原型链顶层\" class=\"headerlink\" title=\"原型链顶层\"></a>原型链顶层</h3><p>既然js通过原型链查找属性，前面我们也提到了如果查找到最后依旧没有找到该属性，就返回为undefined。那么原型链的顶层是什么呢？</p>\n<p>其实答案就是Object对象，既然object是对象，理所应当它也拥有__proto__属性，只是它的值比较特殊，它的值为null。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span>); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最后：</p>\n<p><strong>总结一下:</strong></p>\n<ul>\n<li>JavaScript中每个函数都有一个原型属性prototype，这个属性是一个对象，这个对象就是原型对象。</li>\n<li>普通函数的构造函数是Object(),所以所有函数都是Object的实例。<code>Person.prototype.__proto__ === Object.prototype</code></li>\n<li>每个原型对象都有一个constructor属性，这个属性指向关联构造函数。</li>\n<li>原型链的顶层是Object对象，它的__proto__属性的值为null。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript中原型\"><a href=\"#JavaScript中原型\" class=\"headerlink\" title=\"JavaScript中原型\"></a>JavaScript中原型</h1><h2 id=\"什么是原型\"><a href=\"#什么是原型\" class=\"headerlink\" title=\"什么是原型\"></a>什么是原型</h2><p>众所周知，JavaScript是一门面向对象的编程语言，但是JavaScript中并没有类的概念，那么JavaScript是如何实现面向对象的呢？这就要从原型说起。</p>\n<p>首先我们要知道：原型存在于对象中。</p>\n<p>在JavaScript中，每个构造函数内部都有一个（prototype）属性，这个属性的值为对象，也就是原型对象。原型对象中包含了可以被对象共享的属性和方法。当我们访问一个对象的属性或者方法时，如果这个对象本身没有这个属性或者方法，那么JavaScript就会去它的原型对象中寻找，如果原型对象中也没有，那么就会去原型对象的原型对象中寻找，直到找到为止，如果最终都没有找到，那么就会返回undefined。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>原型链就是原型对象的原型对象的原型对象……一直到Object.prototype为止，这就是原型链。</p>\n<p>这种一层一层的查找属性的方法就是原型链。</p>\n<p>前面我们说道JavaScript是一门没有<code>类</code>概念的编程语言，所以他就不能通过模板来创建对象。所以就出现了原型链，通过原型链来实现对象的继承。</p>\n<p>下面我们来详细解释原型链的组成。</p>\n<h3 id=\"Object-prototype\"><a href=\"#Object-prototype\" class=\"headerlink\" title=\"Object.prototype\"></a>Object.prototype</h3><p>Object.prototype是所有对象的原型对象，也就是说所有对象都可以访问到Object.prototype中的属性和方法。</p>\n<p>前面我们提到每个构造函数里面都有<code>prototype</code>属性，这个属性的值就是原型对象，而原型对象的原型对象就是Object.prototype。</p>\n<p>在构造函数的实例里面又有一个<code>__proto__</code>属性，这个属性的值就是构造函数的原型对象，也就是说<code>__proto__</code>属性的值就是<code>prototype</code>属性的值。</p>\n<p>简单来说就是构造函数的<code>prototype</code>指向原型对象，构造函数的实例<code>__proto__</code>属性指向Object.prototype。<br><img src=\"D://桌面/插图1.png\" alt=\"avatar\"></p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><p>每个原型对象都有一个<code>constructor</code>属性，这个属性指向关联构造函数。</p>\n<p>我们可以通过代码来验证这一说法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person. === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>既然实例对象是由构造函数构造得到的，那么是不是构造函数也有一个<code>constructor</code>呢？</p>\n<p>我们也可以通过代码来验证一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(P.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但是实际上实例化对象并没有该属性，它的这个属性是从原型对象那里得到的。</p>\n<h3 id=\"原型链顶层\"><a href=\"#原型链顶层\" class=\"headerlink\" title=\"原型链顶层\"></a>原型链顶层</h3><p>既然js通过原型链查找属性，前面我们也提到了如果查找到最后依旧没有找到该属性，就返回为undefined。那么原型链的顶层是什么呢？</p>\n<p>其实答案就是Object对象，既然object是对象，理所应当它也拥有__proto__属性，只是它的值比较特殊，它的值为null。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span>); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>最后：</p>\n<p><strong>总结一下:</strong></p>\n<ul>\n<li>JavaScript中每个函数都有一个原型属性prototype，这个属性是一个对象，这个对象就是原型对象。</li>\n<li>普通函数的构造函数是Object(),所以所有函数都是Object的实例。<code>Person.prototype.__proto__ === Object.prototype</code></li>\n<li>每个原型对象都有一个constructor属性，这个属性指向关联构造函数。</li>\n<li>原型链的顶层是Object对象，它的__proto__属性的值为null。</li>\n</ul>\n"},{"title":"JavaScript内存管理和闭包","date":"2023-05-14T16:00:00.000Z","_content":"# JavaScript内存管理和闭包\n\n- JavaScript内存管理\n- 立即回收机制算法\n- 闭包的概念理解\n- 闭包的形成过程\n- 闭包的内存泄露\n\n# 1.认识内存管理\n\n# 1.1\n\n不管什么编程语法，都会占用内存，比如变量，对象。某些编程语言需要手动管理内存（手动声明某个变量占用多大内存，手动释放内存），有的编程语言也可以自动管理内存。\n\n不管什么方式管理内存，内存管理都会有如下生命周期：\n\n1. 分配申请内存\n2. 使用分配的内存\n3. 不需要使用的时候，对其进行释放\n\nJavaScript是自动管理内存的。\n\n内存我们分为两种：\n\n- 栈内存\n- 堆内存\n\n在JavaScript中，原始数据一般放在栈内存中；复杂数据类型（引用数据类型）存放在堆内存中，栈内存的变量名放的是该复杂类型在堆内存里面的引用。\n\n## 1.2 JavaScript的垃圾回收\n\n什么是垃圾回收：\n\n因为内存是有限的的，当一些内存不需要的时候，就需要对其进行释放，以便腾出更多内存。\n\n手动管理内存比较麻烦，并且容易产生内存泄露。\n\n垃圾回收的英文：Garbage Collection,简称GC。\n\n垃圾就是在运行环境中不会被使用的变量、对象等等。\n\nJavaScript的运行环境js引擎负责垃圾回收。\n\n如何知道某些东西不再使用呢？这就需要GC算法了。\n\n## 1.3常见的GC算法\n\n1. 引用计数算法（JavaScript没有用这个算法）\n\n我们创建一个对象之后，它会放在堆内存里面，里面会有一个属性`retainCount`，在栈内存有一个变量存放了这个对象的内存地址，那么`retainCount`就会加一，反之则减一，如果当这个`retainCount`变为0的时候，这个对象就会被垃圾回收机制回收释放掉。\n\n- 这个算法有一个弊端，如果存在相互引用，如果不手动处理，那么`retainCount`永远不可能为0，那么永远不会被回收。\n1. 标记清除法\n\n标记清除的核心思想：可达性\n\n这个算法会设置一个根对象（root object ），垃圾回收器会定期从这个根对象开始查找能引用到的对象，如果存在没有引用到的对象，它就会认为这是一个不可用对象，这个不可达的对象就会被清除。\n\n这个算法可以有效的解决相互引用的问题。\n\nJavaScript中主要采用标记清除法，V8引擎还用了一些其他的算法。\n\n**补充：**\n\n- 标记整理：与标记清理有点区别，他会将保留下来的一些对象放到连续的存储空间，整合空闲空间。并且可以减少内存碎片，提高内存利用率。\n- 分代收集：对象被分为新的与旧的，长期存在的对象，会变得老旧，被检查的次数就会减少。\n- 增量收集：可能对象会很多，全部遍历一遍的话，可能比较耗时，出现延迟，所以会将垃圾收集工作分为几部分来处理，每一部分逐一处理。\n- 闲时收集：在CPU空闲的时候运行，以便减少对代码执行的影响。\n\n# 2. 闭包的概念理解\n\n## 2.1 JavaScript的函数式编程\n\nJavaScript是支持函数式编程的，在JavaScript中函数式非常重要的。\n\n## 2.2 闭包的定义\n\n- 计算机科学中的闭包\n    - 这是在支持头等函数的编程语言中，实现词法绑定的一种技术；它是一种结构，它存储了一个函数和一个关联的环境，在捕获闭包的时候，它的自由变量会在捕获时确定，即使脱离了捕获时的上下文，它也可以正常运行。\n- MDN对JavaScript闭包的解释：一个内层函数访问到其外层函数的作用域，在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时创建出来。\n\n在函数体内部可以访问到外部的变量，就是因为js内部用闭包为我们做了一些事情。\n\n- 总结：\n    - 一个普通的函数，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包\n    - 广义：JavaScript中的函数都是闭包\n    \n    ```jsx\n    function foo(){\n    \t\n    } //这就是一个闭包\n    ```\n    \n    - 狭义：JavaScript中一个函数，如果访问了外层作用域的变量，那么它就是一个闭包。\n    \n    ```jsx\n    var name = \"asd\";\n    \n    function foo(){\n    \tconsole,log(name); // 引用外部的变量\n    } // 这就是一个狭义上的闭包\n    ```\n    \n\n## 2.3 闭包的形成访问过程\n\n```jsx\nfunction adderCreate(count){\n\tfunction adder(num){\n\t\tconsole.log(count+num);\n\t}\n\treturn adder;\n}\n\nvar adder5 = adderCreate(5);\nadder5(4); // 9\n```\n\n上面的代码形成了闭包。\n\n1. 执行所有代码之前，创建一个全局对象（GO），里面包含adderCreate函数，以及adder5，此时adder5为undefined。\n2. 全局作用域中的adderCreate函数，也有自己的一个作用域，里面有adder函数的地址，并且还有一个参数count，此时参数为undefined。并且这个adderCreate还有一个作用域链，里面只有一个值，为GO（全局对象）。\n3. 接着就是adder函数，它有自己的作用域（AO），在这个作用域里面有num,此时为undefined，也有自己的作用域链:（0：adderCreate,1:GO）\n4. 执行创建函数代码，此时返回一个函数，返回的是adder函数的地址，所以此时GO里面adder5的值就变为返回的这个地址。\n5. 此时GO里面的adder5就指向adderCreate里面的adder函数，此时在这个函数里面可以访问到adderCreate的变量count（因为作用域链可以向上查找），这就形成了闭包。\n\n并且上面创建的每一个函数，都可以从GO找到，所以都不会被垃圾回收机制回收，所以可能会造成内存泄露。\n\n## 2.4 闭包的内存泄露\n\n对于闭包不再使用的函数，垃圾回收机制不会自动回收，会一直存在，就会造成内存泄露。\n\n这个时候就需我们手动进行内存释放。\n\n比如`adder5 = null;`","source":"_posts/JavaScript/JavaScript内存管理和闭包.md","raw":"---\ntitle: JavaScript内存管理和闭包\ndate: 2023-05-15\ntags: [前端]\ncategories: [JavaScript]\n---\n# JavaScript内存管理和闭包\n\n- JavaScript内存管理\n- 立即回收机制算法\n- 闭包的概念理解\n- 闭包的形成过程\n- 闭包的内存泄露\n\n# 1.认识内存管理\n\n# 1.1\n\n不管什么编程语法，都会占用内存，比如变量，对象。某些编程语言需要手动管理内存（手动声明某个变量占用多大内存，手动释放内存），有的编程语言也可以自动管理内存。\n\n不管什么方式管理内存，内存管理都会有如下生命周期：\n\n1. 分配申请内存\n2. 使用分配的内存\n3. 不需要使用的时候，对其进行释放\n\nJavaScript是自动管理内存的。\n\n内存我们分为两种：\n\n- 栈内存\n- 堆内存\n\n在JavaScript中，原始数据一般放在栈内存中；复杂数据类型（引用数据类型）存放在堆内存中，栈内存的变量名放的是该复杂类型在堆内存里面的引用。\n\n## 1.2 JavaScript的垃圾回收\n\n什么是垃圾回收：\n\n因为内存是有限的的，当一些内存不需要的时候，就需要对其进行释放，以便腾出更多内存。\n\n手动管理内存比较麻烦，并且容易产生内存泄露。\n\n垃圾回收的英文：Garbage Collection,简称GC。\n\n垃圾就是在运行环境中不会被使用的变量、对象等等。\n\nJavaScript的运行环境js引擎负责垃圾回收。\n\n如何知道某些东西不再使用呢？这就需要GC算法了。\n\n## 1.3常见的GC算法\n\n1. 引用计数算法（JavaScript没有用这个算法）\n\n我们创建一个对象之后，它会放在堆内存里面，里面会有一个属性`retainCount`，在栈内存有一个变量存放了这个对象的内存地址，那么`retainCount`就会加一，反之则减一，如果当这个`retainCount`变为0的时候，这个对象就会被垃圾回收机制回收释放掉。\n\n- 这个算法有一个弊端，如果存在相互引用，如果不手动处理，那么`retainCount`永远不可能为0，那么永远不会被回收。\n1. 标记清除法\n\n标记清除的核心思想：可达性\n\n这个算法会设置一个根对象（root object ），垃圾回收器会定期从这个根对象开始查找能引用到的对象，如果存在没有引用到的对象，它就会认为这是一个不可用对象，这个不可达的对象就会被清除。\n\n这个算法可以有效的解决相互引用的问题。\n\nJavaScript中主要采用标记清除法，V8引擎还用了一些其他的算法。\n\n**补充：**\n\n- 标记整理：与标记清理有点区别，他会将保留下来的一些对象放到连续的存储空间，整合空闲空间。并且可以减少内存碎片，提高内存利用率。\n- 分代收集：对象被分为新的与旧的，长期存在的对象，会变得老旧，被检查的次数就会减少。\n- 增量收集：可能对象会很多，全部遍历一遍的话，可能比较耗时，出现延迟，所以会将垃圾收集工作分为几部分来处理，每一部分逐一处理。\n- 闲时收集：在CPU空闲的时候运行，以便减少对代码执行的影响。\n\n# 2. 闭包的概念理解\n\n## 2.1 JavaScript的函数式编程\n\nJavaScript是支持函数式编程的，在JavaScript中函数式非常重要的。\n\n## 2.2 闭包的定义\n\n- 计算机科学中的闭包\n    - 这是在支持头等函数的编程语言中，实现词法绑定的一种技术；它是一种结构，它存储了一个函数和一个关联的环境，在捕获闭包的时候，它的自由变量会在捕获时确定，即使脱离了捕获时的上下文，它也可以正常运行。\n- MDN对JavaScript闭包的解释：一个内层函数访问到其外层函数的作用域，在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时创建出来。\n\n在函数体内部可以访问到外部的变量，就是因为js内部用闭包为我们做了一些事情。\n\n- 总结：\n    - 一个普通的函数，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包\n    - 广义：JavaScript中的函数都是闭包\n    \n    ```jsx\n    function foo(){\n    \t\n    } //这就是一个闭包\n    ```\n    \n    - 狭义：JavaScript中一个函数，如果访问了外层作用域的变量，那么它就是一个闭包。\n    \n    ```jsx\n    var name = \"asd\";\n    \n    function foo(){\n    \tconsole,log(name); // 引用外部的变量\n    } // 这就是一个狭义上的闭包\n    ```\n    \n\n## 2.3 闭包的形成访问过程\n\n```jsx\nfunction adderCreate(count){\n\tfunction adder(num){\n\t\tconsole.log(count+num);\n\t}\n\treturn adder;\n}\n\nvar adder5 = adderCreate(5);\nadder5(4); // 9\n```\n\n上面的代码形成了闭包。\n\n1. 执行所有代码之前，创建一个全局对象（GO），里面包含adderCreate函数，以及adder5，此时adder5为undefined。\n2. 全局作用域中的adderCreate函数，也有自己的一个作用域，里面有adder函数的地址，并且还有一个参数count，此时参数为undefined。并且这个adderCreate还有一个作用域链，里面只有一个值，为GO（全局对象）。\n3. 接着就是adder函数，它有自己的作用域（AO），在这个作用域里面有num,此时为undefined，也有自己的作用域链:（0：adderCreate,1:GO）\n4. 执行创建函数代码，此时返回一个函数，返回的是adder函数的地址，所以此时GO里面adder5的值就变为返回的这个地址。\n5. 此时GO里面的adder5就指向adderCreate里面的adder函数，此时在这个函数里面可以访问到adderCreate的变量count（因为作用域链可以向上查找），这就形成了闭包。\n\n并且上面创建的每一个函数，都可以从GO找到，所以都不会被垃圾回收机制回收，所以可能会造成内存泄露。\n\n## 2.4 闭包的内存泄露\n\n对于闭包不再使用的函数，垃圾回收机制不会自动回收，会一直存在，就会造成内存泄露。\n\n这个时候就需我们手动进行内存释放。\n\n比如`adder5 = null;`","slug":"JavaScript/JavaScript内存管理和闭包","published":1,"updated":"2023-05-15T02:50:42.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmi900459kbm6wf05o6r","content":"<h1 id=\"JavaScript内存管理和闭包\"><a href=\"#JavaScript内存管理和闭包\" class=\"headerlink\" title=\"JavaScript内存管理和闭包\"></a>JavaScript内存管理和闭包</h1><ul>\n<li>JavaScript内存管理</li>\n<li>立即回收机制算法</li>\n<li>闭包的概念理解</li>\n<li>闭包的形成过程</li>\n<li>闭包的内存泄露</li>\n</ul>\n<h1 id=\"1-认识内存管理\"><a href=\"#1-认识内存管理\" class=\"headerlink\" title=\"1.认识内存管理\"></a>1.认识内存管理</h1><h1 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.1\"></a>1.1</h1><p>不管什么编程语法，都会占用内存，比如变量，对象。某些编程语言需要手动管理内存（手动声明某个变量占用多大内存，手动释放内存），有的编程语言也可以自动管理内存。</p>\n<p>不管什么方式管理内存，内存管理都会有如下生命周期：</p>\n<ol>\n<li>分配申请内存</li>\n<li>使用分配的内存</li>\n<li>不需要使用的时候，对其进行释放</li>\n</ol>\n<p>JavaScript是自动管理内存的。</p>\n<p>内存我们分为两种：</p>\n<ul>\n<li>栈内存</li>\n<li>堆内存</li>\n</ul>\n<p>在JavaScript中，原始数据一般放在栈内存中；复杂数据类型（引用数据类型）存放在堆内存中，栈内存的变量名放的是该复杂类型在堆内存里面的引用。</p>\n<h2 id=\"1-2-JavaScript的垃圾回收\"><a href=\"#1-2-JavaScript的垃圾回收\" class=\"headerlink\" title=\"1.2 JavaScript的垃圾回收\"></a>1.2 JavaScript的垃圾回收</h2><p>什么是垃圾回收：</p>\n<p>因为内存是有限的的，当一些内存不需要的时候，就需要对其进行释放，以便腾出更多内存。</p>\n<p>手动管理内存比较麻烦，并且容易产生内存泄露。</p>\n<p>垃圾回收的英文：Garbage Collection,简称GC。</p>\n<p>垃圾就是在运行环境中不会被使用的变量、对象等等。</p>\n<p>JavaScript的运行环境js引擎负责垃圾回收。</p>\n<p>如何知道某些东西不再使用呢？这就需要GC算法了。</p>\n<h2 id=\"1-3常见的GC算法\"><a href=\"#1-3常见的GC算法\" class=\"headerlink\" title=\"1.3常见的GC算法\"></a>1.3常见的GC算法</h2><ol>\n<li>引用计数算法（JavaScript没有用这个算法）</li>\n</ol>\n<p>我们创建一个对象之后，它会放在堆内存里面，里面会有一个属性<code>retainCount</code>，在栈内存有一个变量存放了这个对象的内存地址，那么<code>retainCount</code>就会加一，反之则减一，如果当这个<code>retainCount</code>变为0的时候，这个对象就会被垃圾回收机制回收释放掉。</p>\n<ul>\n<li>这个算法有一个弊端，如果存在相互引用，如果不手动处理，那么<code>retainCount</code>永远不可能为0，那么永远不会被回收。</li>\n</ul>\n<ol>\n<li>标记清除法</li>\n</ol>\n<p>标记清除的核心思想：可达性</p>\n<p>这个算法会设置一个根对象（root object ），垃圾回收器会定期从这个根对象开始查找能引用到的对象，如果存在没有引用到的对象，它就会认为这是一个不可用对象，这个不可达的对象就会被清除。</p>\n<p>这个算法可以有效的解决相互引用的问题。</p>\n<p>JavaScript中主要采用标记清除法，V8引擎还用了一些其他的算法。</p>\n<p><strong>补充：</strong></p>\n<ul>\n<li>标记整理：与标记清理有点区别，他会将保留下来的一些对象放到连续的存储空间，整合空闲空间。并且可以减少内存碎片，提高内存利用率。</li>\n<li>分代收集：对象被分为新的与旧的，长期存在的对象，会变得老旧，被检查的次数就会减少。</li>\n<li>增量收集：可能对象会很多，全部遍历一遍的话，可能比较耗时，出现延迟，所以会将垃圾收集工作分为几部分来处理，每一部分逐一处理。</li>\n<li>闲时收集：在CPU空闲的时候运行，以便减少对代码执行的影响。</li>\n</ul>\n<h1 id=\"2-闭包的概念理解\"><a href=\"#2-闭包的概念理解\" class=\"headerlink\" title=\"2. 闭包的概念理解\"></a>2. 闭包的概念理解</h1><h2 id=\"2-1-JavaScript的函数式编程\"><a href=\"#2-1-JavaScript的函数式编程\" class=\"headerlink\" title=\"2.1 JavaScript的函数式编程\"></a>2.1 JavaScript的函数式编程</h2><p>JavaScript是支持函数式编程的，在JavaScript中函数式非常重要的。</p>\n<h2 id=\"2-2-闭包的定义\"><a href=\"#2-2-闭包的定义\" class=\"headerlink\" title=\"2.2 闭包的定义\"></a>2.2 闭包的定义</h2><ul>\n<li>计算机科学中的闭包<ul>\n<li>这是在支持头等函数的编程语言中，实现词法绑定的一种技术；它是一种结构，它存储了一个函数和一个关联的环境，在捕获闭包的时候，它的自由变量会在捕获时确定，即使脱离了捕获时的上下文，它也可以正常运行。</li>\n</ul>\n</li>\n<li>MDN对JavaScript闭包的解释：一个内层函数访问到其外层函数的作用域，在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时创建出来。</li>\n</ul>\n<p>在函数体内部可以访问到外部的变量，就是因为js内部用闭包为我们做了一些事情。</p>\n<ul>\n<li><p>总结：</p>\n<ul>\n<li>一个普通的函数，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包</li>\n<li>广义：JavaScript中的函数都是闭包</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125; <span class=\"comment\">//这就是一个闭包</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>狭义：JavaScript中一个函数，如果访问了外层作用域的变量，那么它就是一个闭包。</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;asd&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>,<span class=\"title function_\">log</span>(name); <span class=\"comment\">// 引用外部的变量</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 这就是一个狭义上的闭包</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"2-3-闭包的形成访问过程\"><a href=\"#2-3-闭包的形成访问过程\" class=\"headerlink\" title=\"2.3 闭包的形成访问过程\"></a>2.3 闭包的形成访问过程</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">adderCreate</span>(<span class=\"params\">count</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">adder</span>(<span class=\"params\">num</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count+num);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> adder;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> adder5 = <span class=\"title function_\">adderCreate</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"title function_\">adder5</span>(<span class=\"number\">4</span>); <span class=\"comment\">// 9</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码形成了闭包。</p>\n<ol>\n<li>执行所有代码之前，创建一个全局对象（GO），里面包含adderCreate函数，以及adder5，此时adder5为undefined。</li>\n<li>全局作用域中的adderCreate函数，也有自己的一个作用域，里面有adder函数的地址，并且还有一个参数count，此时参数为undefined。并且这个adderCreate还有一个作用域链，里面只有一个值，为GO（全局对象）。</li>\n<li>接着就是adder函数，它有自己的作用域（AO），在这个作用域里面有num,此时为undefined，也有自己的作用域链:（0：adderCreate,1:GO）</li>\n<li>执行创建函数代码，此时返回一个函数，返回的是adder函数的地址，所以此时GO里面adder5的值就变为返回的这个地址。</li>\n<li>此时GO里面的adder5就指向adderCreate里面的adder函数，此时在这个函数里面可以访问到adderCreate的变量count（因为作用域链可以向上查找），这就形成了闭包。</li>\n</ol>\n<p>并且上面创建的每一个函数，都可以从GO找到，所以都不会被垃圾回收机制回收，所以可能会造成内存泄露。</p>\n<h2 id=\"2-4-闭包的内存泄露\"><a href=\"#2-4-闭包的内存泄露\" class=\"headerlink\" title=\"2.4 闭包的内存泄露\"></a>2.4 闭包的内存泄露</h2><p>对于闭包不再使用的函数，垃圾回收机制不会自动回收，会一直存在，就会造成内存泄露。</p>\n<p>这个时候就需我们手动进行内存释放。</p>\n<p>比如<code>adder5 = null;</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript内存管理和闭包\"><a href=\"#JavaScript内存管理和闭包\" class=\"headerlink\" title=\"JavaScript内存管理和闭包\"></a>JavaScript内存管理和闭包</h1><ul>\n<li>JavaScript内存管理</li>\n<li>立即回收机制算法</li>\n<li>闭包的概念理解</li>\n<li>闭包的形成过程</li>\n<li>闭包的内存泄露</li>\n</ul>\n<h1 id=\"1-认识内存管理\"><a href=\"#1-认识内存管理\" class=\"headerlink\" title=\"1.认识内存管理\"></a>1.认识内存管理</h1><h1 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1.1\"></a>1.1</h1><p>不管什么编程语法，都会占用内存，比如变量，对象。某些编程语言需要手动管理内存（手动声明某个变量占用多大内存，手动释放内存），有的编程语言也可以自动管理内存。</p>\n<p>不管什么方式管理内存，内存管理都会有如下生命周期：</p>\n<ol>\n<li>分配申请内存</li>\n<li>使用分配的内存</li>\n<li>不需要使用的时候，对其进行释放</li>\n</ol>\n<p>JavaScript是自动管理内存的。</p>\n<p>内存我们分为两种：</p>\n<ul>\n<li>栈内存</li>\n<li>堆内存</li>\n</ul>\n<p>在JavaScript中，原始数据一般放在栈内存中；复杂数据类型（引用数据类型）存放在堆内存中，栈内存的变量名放的是该复杂类型在堆内存里面的引用。</p>\n<h2 id=\"1-2-JavaScript的垃圾回收\"><a href=\"#1-2-JavaScript的垃圾回收\" class=\"headerlink\" title=\"1.2 JavaScript的垃圾回收\"></a>1.2 JavaScript的垃圾回收</h2><p>什么是垃圾回收：</p>\n<p>因为内存是有限的的，当一些内存不需要的时候，就需要对其进行释放，以便腾出更多内存。</p>\n<p>手动管理内存比较麻烦，并且容易产生内存泄露。</p>\n<p>垃圾回收的英文：Garbage Collection,简称GC。</p>\n<p>垃圾就是在运行环境中不会被使用的变量、对象等等。</p>\n<p>JavaScript的运行环境js引擎负责垃圾回收。</p>\n<p>如何知道某些东西不再使用呢？这就需要GC算法了。</p>\n<h2 id=\"1-3常见的GC算法\"><a href=\"#1-3常见的GC算法\" class=\"headerlink\" title=\"1.3常见的GC算法\"></a>1.3常见的GC算法</h2><ol>\n<li>引用计数算法（JavaScript没有用这个算法）</li>\n</ol>\n<p>我们创建一个对象之后，它会放在堆内存里面，里面会有一个属性<code>retainCount</code>，在栈内存有一个变量存放了这个对象的内存地址，那么<code>retainCount</code>就会加一，反之则减一，如果当这个<code>retainCount</code>变为0的时候，这个对象就会被垃圾回收机制回收释放掉。</p>\n<ul>\n<li>这个算法有一个弊端，如果存在相互引用，如果不手动处理，那么<code>retainCount</code>永远不可能为0，那么永远不会被回收。</li>\n</ul>\n<ol>\n<li>标记清除法</li>\n</ol>\n<p>标记清除的核心思想：可达性</p>\n<p>这个算法会设置一个根对象（root object ），垃圾回收器会定期从这个根对象开始查找能引用到的对象，如果存在没有引用到的对象，它就会认为这是一个不可用对象，这个不可达的对象就会被清除。</p>\n<p>这个算法可以有效的解决相互引用的问题。</p>\n<p>JavaScript中主要采用标记清除法，V8引擎还用了一些其他的算法。</p>\n<p><strong>补充：</strong></p>\n<ul>\n<li>标记整理：与标记清理有点区别，他会将保留下来的一些对象放到连续的存储空间，整合空闲空间。并且可以减少内存碎片，提高内存利用率。</li>\n<li>分代收集：对象被分为新的与旧的，长期存在的对象，会变得老旧，被检查的次数就会减少。</li>\n<li>增量收集：可能对象会很多，全部遍历一遍的话，可能比较耗时，出现延迟，所以会将垃圾收集工作分为几部分来处理，每一部分逐一处理。</li>\n<li>闲时收集：在CPU空闲的时候运行，以便减少对代码执行的影响。</li>\n</ul>\n<h1 id=\"2-闭包的概念理解\"><a href=\"#2-闭包的概念理解\" class=\"headerlink\" title=\"2. 闭包的概念理解\"></a>2. 闭包的概念理解</h1><h2 id=\"2-1-JavaScript的函数式编程\"><a href=\"#2-1-JavaScript的函数式编程\" class=\"headerlink\" title=\"2.1 JavaScript的函数式编程\"></a>2.1 JavaScript的函数式编程</h2><p>JavaScript是支持函数式编程的，在JavaScript中函数式非常重要的。</p>\n<h2 id=\"2-2-闭包的定义\"><a href=\"#2-2-闭包的定义\" class=\"headerlink\" title=\"2.2 闭包的定义\"></a>2.2 闭包的定义</h2><ul>\n<li>计算机科学中的闭包<ul>\n<li>这是在支持头等函数的编程语言中，实现词法绑定的一种技术；它是一种结构，它存储了一个函数和一个关联的环境，在捕获闭包的时候，它的自由变量会在捕获时确定，即使脱离了捕获时的上下文，它也可以正常运行。</li>\n</ul>\n</li>\n<li>MDN对JavaScript闭包的解释：一个内层函数访问到其外层函数的作用域，在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时创建出来。</li>\n</ul>\n<p>在函数体内部可以访问到外部的变量，就是因为js内部用闭包为我们做了一些事情。</p>\n<ul>\n<li><p>总结：</p>\n<ul>\n<li>一个普通的函数，如果它可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包</li>\n<li>广义：JavaScript中的函数都是闭包</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125; <span class=\"comment\">//这就是一个闭包</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>狭义：JavaScript中一个函数，如果访问了外层作用域的变量，那么它就是一个闭包。</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;asd&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>,<span class=\"title function_\">log</span>(name); <span class=\"comment\">// 引用外部的变量</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 这就是一个狭义上的闭包</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"2-3-闭包的形成访问过程\"><a href=\"#2-3-闭包的形成访问过程\" class=\"headerlink\" title=\"2.3 闭包的形成访问过程\"></a>2.3 闭包的形成访问过程</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">adderCreate</span>(<span class=\"params\">count</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">adder</span>(<span class=\"params\">num</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count+num);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> adder;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> adder5 = <span class=\"title function_\">adderCreate</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"title function_\">adder5</span>(<span class=\"number\">4</span>); <span class=\"comment\">// 9</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码形成了闭包。</p>\n<ol>\n<li>执行所有代码之前，创建一个全局对象（GO），里面包含adderCreate函数，以及adder5，此时adder5为undefined。</li>\n<li>全局作用域中的adderCreate函数，也有自己的一个作用域，里面有adder函数的地址，并且还有一个参数count，此时参数为undefined。并且这个adderCreate还有一个作用域链，里面只有一个值，为GO（全局对象）。</li>\n<li>接着就是adder函数，它有自己的作用域（AO），在这个作用域里面有num,此时为undefined，也有自己的作用域链:（0：adderCreate,1:GO）</li>\n<li>执行创建函数代码，此时返回一个函数，返回的是adder函数的地址，所以此时GO里面adder5的值就变为返回的这个地址。</li>\n<li>此时GO里面的adder5就指向adderCreate里面的adder函数，此时在这个函数里面可以访问到adderCreate的变量count（因为作用域链可以向上查找），这就形成了闭包。</li>\n</ol>\n<p>并且上面创建的每一个函数，都可以从GO找到，所以都不会被垃圾回收机制回收，所以可能会造成内存泄露。</p>\n<h2 id=\"2-4-闭包的内存泄露\"><a href=\"#2-4-闭包的内存泄露\" class=\"headerlink\" title=\"2.4 闭包的内存泄露\"></a>2.4 闭包的内存泄露</h2><p>对于闭包不再使用的函数，垃圾回收机制不会自动回收，会一直存在，就会造成内存泄露。</p>\n<p>这个时候就需我们手动进行内存释放。</p>\n<p>比如<code>adder5 = null;</code></p>\n"},{"title":"JavaScript函数的增强知识","date":"+020223-05-15T16:00:00.000Z","_content":"# JavaScript函数的增强知识\n\n1. 函数属性和arguments\n2. 纯函数的理解和应用\n3. 柯里化的理解和应用\n4. 组合函数理解和应用\n5. with、eval的使用\n6. 严格模式的使用\n\n# 1.函数对象的属性\n\n在JavaScript中，函数也是属于一种对象。\n\n## 1.1 函数的属性\n\n函数也可以像对象一个添加自定义属性：foo.address = “asd”;\n\n```jsx\nfunction foo(num,count,name){\n\t\n}\n```\n\n默认的函数对象中有一些自己的属性：\n\n- name属性，函数的名称\n\n```jsx\nfoo.name; // foo\n```\n\n- length属性：参数(形参)的个数\n\n```jsx\nfoo.length;// 3\n```\n\n- 额外补充：剩余参数\n\n```jsx\nfunction foo(x,y,z...arg){\n\t\n}\n```\n\n这个时候length还是为3。\n\n## 1.2 函数中的arguments\n\n在使用函数的时候，传入的参数个数多于定义函数时形式参数个数时，这些参数还是会存在于函数中，只是他们被存放在arguments中。\n\n```jsx\nfunction foo(a,b){\n\tconsole.log(arguments);\n}\n\nfoo(1,2,3,4,5); // 1,2,3,4,5\n```\n\narguments是一个传递给函数的参数的类数组对象。\n\n类数组对象就是有数组的一些属性，length等等；但是没有数组的一些方法。\n\narguments可以通过索引获取到对应的值。\n\n```jsx\narguments[0] // 1\n```\n\n- arguments转为数组的方法\n    - 遍历arguments，将其每一个元素添加进一个新数组。\n    \n    ```jsx\n    function foo1() {\n        let arr = [];\n        for (const item of arguments) {\n            arr.push(item);\n        }\n        console.log(typeof arr);\n        console.log(arr);\n    }\n    ```\n    \n    - ES6中的方式1：\n    \n    ```jsx\n    let newArr = Array.from(arguments);\n    ```\n    \n    - ES6中的方式2：解构赋值\n    \n    ```jsx\n    let newArr = [...arguments];\n    ```\n    \n    - 调用slice(不常用)\n    \n    ```jsx\n    let newArr = [].slice.call(arguments);\n    \n    ```\n    \n\n**注意：**\n\n箭头函数不绑定arguments，也就是箭头函数没有arguments。\n\n```jsx\nlet bar = () => {\n\tconsole.log(arguments); // 报错 arguments没有被定义\n}\n\nfunction foo(){\n\tlet bar = () => {\n\t\tconsolel.og(arguments); // 上层作用域的arguments\n\t}\n}\n```\n\n## 1.3函数的剩余（rest）参数\n\n如果最后一个参数是以`…`为前缀，那么他会将剩余的参数方法到该参数中，并且作为一个数组。\n\n```jsx\nfunction foo(x,y,...arg){\n\t\n};\n\nfoo(1,2,3,4,5,6);\n```\n\n默认一个函数只有一个剩余参数。\n\n**注意：**\n\n- 剩余参数只能写到其他参数最后，否则会报错。\n\n剩余参数与arguments的区别：\n\n1. 剩余参数只包含没有对应形参的实参，arguments对象包含了所有传递给函数的参数。\n2. arguments不是一个真正的数组，而rest剩余参数是一个真正的数组。\n3. arguments是早期的技术，rest剩余参数是ES6为了取代arguments出现的。\n\n# 2.函数式编程\n\n## 2.1 理解JavaScript纯函数\n\n纯函数输入相同的值，每一次输出的结构应该都相同。\n\n并且函数与I/O设备的输入无关。\n\n并且不能有语义上可观察的副作用功能。\n\n**总结：**\n\n1. 确定的输入，结果为确定的输出，结果不会改变。\n2. 函数在执行的过程中，不能产生副作用。\n\n**什么是副作用：**\n\n就是在执行一个函数的时候，出来返回函数值之外，还对其他东西产生了影响，比如修改全局变量，修改了对象的某个属性。\n\n## 2.2纯函数的作用域优势\n\n- 不需要关心外部作用域对函数的影响。\n- 调用函数时，确定的输入，一定产生确定的输出。\n\n## 2.3 柯里化概念理解\n\n把接受多个参数的函数，变成接受一个单一参数的哈数，并且返回接受余下的参数，返回结果的新函数的技术。\n\n比如:\n\n```jsx\nfunction foo(x,y,z){\n\t\n}\n\n// 下面就是经过柯里化的函数\n\nfunction foo1(x){\n\treturn function (y){\n\t\treturn function (z){\n\t\t\t\n\t\t}\n\t}\n}\n```\n\n**总结**\n\n- 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数\n- 柯里化不会调用函数，只是对函数进行一个转换\n\n```jsx\nfunction foo(x){\n\treturn function (y){\n\t\treturn function (z){\n\t\t\treturn x+y+z;\t\t\n\t\t}\n\t}\n}\n\nfoo(10)(20)(30); // 60\n```\n\n**柯里化的另一种写法：**\n\n箭头函数的写法：\n\n```jsx\nfunction foo(x){\n\treturn y => {\n\t\treturn z =>{\n\t\t\treturn x+y+z;\n\t\t}\n\t}\n}\n```\n\n还可以这样写：\n\n```jsx\nlet foo = x => y => z => x+y+z;\n```\n\n**柯里化高级-自动柯里化**\n\n封装一个函数，传入一个函数对象，返回一个柯里化完成的函数。\n\n## 2.3 组合函数\n\n在开发中你，需要将上一个函数的结果作为参数传入另一个函数。当我们需要多次执行这样的函数，我们可以使用组合函数来解决。\n\n```jsx\nfunction double(num){\n\treturn num*2;\n}\n\nfunction pow(num){\n\treturn num**2;\n}\n\nfunction composeFn(num){\n\treturn pow(double(num));\n}\n\nlet result = composeFn(2); // 16\n```\n\n## 2.4 eval函数\n\n- eval是一个特殊的函数，它可以将传入的字符串当做\n\nJavaScript代码运行\n\n- eval会将最后一直执行语句的结果作为返回值\n\n```jsx\n\neval(`console.log(\"123\")`)\n```\n\n这个字符串是可以访问全局变量的。\n\n# 3. 严格模式\n\n在支持严格模式的浏览器中国，检测到有严格模式的时候，会以更加严格的方式对代码进行检测和执行。\n\n严格模式对JavaScript语义进行了一些限制：\n\n- 通过抛出错误消除一些原有的静默错误\n- 严格模式让JS引擎在执行代码时可以进行更多的优化（不用对一些特殊语法进行处理）\n- 严格模式禁用了可能在未来版本可能会定义的一些语法。\n\n## 3.1 开启严格模式\n\n- 开启全局严格模式：在代码开始写上下面这段代码\n\n```jsx\n\"use strict\"\n```\n\n- 给某个函数开启严格模式：在函数体内部开始写上这样一段代码.\n\n```jsx\nfunction foo(){\n\t\"use strict\"\n}\n```\n\n没有指令是程序返回默认模式。\n\n在现代JavaScript中，class与module自动启用`use strict`","source":"_posts/JavaScript/JavaScript函数的增强知识.md","raw":"---\ntitle: JavaScript函数的增强知识\ndate: 20223-5-16\ntags: [前端]\ncategories: [JavaScript]\n---\n# JavaScript函数的增强知识\n\n1. 函数属性和arguments\n2. 纯函数的理解和应用\n3. 柯里化的理解和应用\n4. 组合函数理解和应用\n5. with、eval的使用\n6. 严格模式的使用\n\n# 1.函数对象的属性\n\n在JavaScript中，函数也是属于一种对象。\n\n## 1.1 函数的属性\n\n函数也可以像对象一个添加自定义属性：foo.address = “asd”;\n\n```jsx\nfunction foo(num,count,name){\n\t\n}\n```\n\n默认的函数对象中有一些自己的属性：\n\n- name属性，函数的名称\n\n```jsx\nfoo.name; // foo\n```\n\n- length属性：参数(形参)的个数\n\n```jsx\nfoo.length;// 3\n```\n\n- 额外补充：剩余参数\n\n```jsx\nfunction foo(x,y,z...arg){\n\t\n}\n```\n\n这个时候length还是为3。\n\n## 1.2 函数中的arguments\n\n在使用函数的时候，传入的参数个数多于定义函数时形式参数个数时，这些参数还是会存在于函数中，只是他们被存放在arguments中。\n\n```jsx\nfunction foo(a,b){\n\tconsole.log(arguments);\n}\n\nfoo(1,2,3,4,5); // 1,2,3,4,5\n```\n\narguments是一个传递给函数的参数的类数组对象。\n\n类数组对象就是有数组的一些属性，length等等；但是没有数组的一些方法。\n\narguments可以通过索引获取到对应的值。\n\n```jsx\narguments[0] // 1\n```\n\n- arguments转为数组的方法\n    - 遍历arguments，将其每一个元素添加进一个新数组。\n    \n    ```jsx\n    function foo1() {\n        let arr = [];\n        for (const item of arguments) {\n            arr.push(item);\n        }\n        console.log(typeof arr);\n        console.log(arr);\n    }\n    ```\n    \n    - ES6中的方式1：\n    \n    ```jsx\n    let newArr = Array.from(arguments);\n    ```\n    \n    - ES6中的方式2：解构赋值\n    \n    ```jsx\n    let newArr = [...arguments];\n    ```\n    \n    - 调用slice(不常用)\n    \n    ```jsx\n    let newArr = [].slice.call(arguments);\n    \n    ```\n    \n\n**注意：**\n\n箭头函数不绑定arguments，也就是箭头函数没有arguments。\n\n```jsx\nlet bar = () => {\n\tconsole.log(arguments); // 报错 arguments没有被定义\n}\n\nfunction foo(){\n\tlet bar = () => {\n\t\tconsolel.og(arguments); // 上层作用域的arguments\n\t}\n}\n```\n\n## 1.3函数的剩余（rest）参数\n\n如果最后一个参数是以`…`为前缀，那么他会将剩余的参数方法到该参数中，并且作为一个数组。\n\n```jsx\nfunction foo(x,y,...arg){\n\t\n};\n\nfoo(1,2,3,4,5,6);\n```\n\n默认一个函数只有一个剩余参数。\n\n**注意：**\n\n- 剩余参数只能写到其他参数最后，否则会报错。\n\n剩余参数与arguments的区别：\n\n1. 剩余参数只包含没有对应形参的实参，arguments对象包含了所有传递给函数的参数。\n2. arguments不是一个真正的数组，而rest剩余参数是一个真正的数组。\n3. arguments是早期的技术，rest剩余参数是ES6为了取代arguments出现的。\n\n# 2.函数式编程\n\n## 2.1 理解JavaScript纯函数\n\n纯函数输入相同的值，每一次输出的结构应该都相同。\n\n并且函数与I/O设备的输入无关。\n\n并且不能有语义上可观察的副作用功能。\n\n**总结：**\n\n1. 确定的输入，结果为确定的输出，结果不会改变。\n2. 函数在执行的过程中，不能产生副作用。\n\n**什么是副作用：**\n\n就是在执行一个函数的时候，出来返回函数值之外，还对其他东西产生了影响，比如修改全局变量，修改了对象的某个属性。\n\n## 2.2纯函数的作用域优势\n\n- 不需要关心外部作用域对函数的影响。\n- 调用函数时，确定的输入，一定产生确定的输出。\n\n## 2.3 柯里化概念理解\n\n把接受多个参数的函数，变成接受一个单一参数的哈数，并且返回接受余下的参数，返回结果的新函数的技术。\n\n比如:\n\n```jsx\nfunction foo(x,y,z){\n\t\n}\n\n// 下面就是经过柯里化的函数\n\nfunction foo1(x){\n\treturn function (y){\n\t\treturn function (z){\n\t\t\t\n\t\t}\n\t}\n}\n```\n\n**总结**\n\n- 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数\n- 柯里化不会调用函数，只是对函数进行一个转换\n\n```jsx\nfunction foo(x){\n\treturn function (y){\n\t\treturn function (z){\n\t\t\treturn x+y+z;\t\t\n\t\t}\n\t}\n}\n\nfoo(10)(20)(30); // 60\n```\n\n**柯里化的另一种写法：**\n\n箭头函数的写法：\n\n```jsx\nfunction foo(x){\n\treturn y => {\n\t\treturn z =>{\n\t\t\treturn x+y+z;\n\t\t}\n\t}\n}\n```\n\n还可以这样写：\n\n```jsx\nlet foo = x => y => z => x+y+z;\n```\n\n**柯里化高级-自动柯里化**\n\n封装一个函数，传入一个函数对象，返回一个柯里化完成的函数。\n\n## 2.3 组合函数\n\n在开发中你，需要将上一个函数的结果作为参数传入另一个函数。当我们需要多次执行这样的函数，我们可以使用组合函数来解决。\n\n```jsx\nfunction double(num){\n\treturn num*2;\n}\n\nfunction pow(num){\n\treturn num**2;\n}\n\nfunction composeFn(num){\n\treturn pow(double(num));\n}\n\nlet result = composeFn(2); // 16\n```\n\n## 2.4 eval函数\n\n- eval是一个特殊的函数，它可以将传入的字符串当做\n\nJavaScript代码运行\n\n- eval会将最后一直执行语句的结果作为返回值\n\n```jsx\n\neval(`console.log(\"123\")`)\n```\n\n这个字符串是可以访问全局变量的。\n\n# 3. 严格模式\n\n在支持严格模式的浏览器中国，检测到有严格模式的时候，会以更加严格的方式对代码进行检测和执行。\n\n严格模式对JavaScript语义进行了一些限制：\n\n- 通过抛出错误消除一些原有的静默错误\n- 严格模式让JS引擎在执行代码时可以进行更多的优化（不用对一些特殊语法进行处理）\n- 严格模式禁用了可能在未来版本可能会定义的一些语法。\n\n## 3.1 开启严格模式\n\n- 开启全局严格模式：在代码开始写上下面这段代码\n\n```jsx\n\"use strict\"\n```\n\n- 给某个函数开启严格模式：在函数体内部开始写上这样一段代码.\n\n```jsx\nfunction foo(){\n\t\"use strict\"\n}\n```\n\n没有指令是程序返回默认模式。\n\n在现代JavaScript中，class与module自动启用`use strict`","slug":"JavaScript/JavaScript函数的增强知识","published":1,"updated":"2023-05-16T02:30:18.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmia00489kbm7lac9cr6","content":"<h1 id=\"JavaScript函数的增强知识\"><a href=\"#JavaScript函数的增强知识\" class=\"headerlink\" title=\"JavaScript函数的增强知识\"></a>JavaScript函数的增强知识</h1><ol>\n<li>函数属性和arguments</li>\n<li>纯函数的理解和应用</li>\n<li>柯里化的理解和应用</li>\n<li>组合函数理解和应用</li>\n<li>with、eval的使用</li>\n<li>严格模式的使用</li>\n</ol>\n<h1 id=\"1-函数对象的属性\"><a href=\"#1-函数对象的属性\" class=\"headerlink\" title=\"1.函数对象的属性\"></a>1.函数对象的属性</h1><p>在JavaScript中，函数也是属于一种对象。</p>\n<h2 id=\"1-1-函数的属性\"><a href=\"#1-1-函数的属性\" class=\"headerlink\" title=\"1.1 函数的属性\"></a>1.1 函数的属性</h2><p>函数也可以像对象一个添加自定义属性：foo.address &#x3D; “asd”;</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">num,count,name</span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>默认的函数对象中有一些自己的属性：</p>\n<ul>\n<li>name属性，函数的名称</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.<span class=\"property\">name</span>; <span class=\"comment\">// foo</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>length属性：参数(形参)的个数</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.<span class=\"property\">length</span>;<span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>额外补充：剩余参数</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y,z...arg</span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候length还是为3。</p>\n<h2 id=\"1-2-函数中的arguments\"><a href=\"#1-2-函数中的arguments\" class=\"headerlink\" title=\"1.2 函数中的arguments\"></a>1.2 函数中的arguments</h2><p>在使用函数的时候，传入的参数个数多于定义函数时形式参数个数时，这些参数还是会存在于函数中，只是他们被存放在arguments中。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">a,b</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>\n\n<p>arguments是一个传递给函数的参数的类数组对象。</p>\n<p>类数组对象就是有数组的一些属性，length等等；但是没有数组的一些方法。</p>\n<p>arguments可以通过索引获取到对应的值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>arguments转为数组的方法</p>\n<ul>\n<li>遍历arguments，将其每一个元素添加进一个新数组。</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo1</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> item <span class=\"keyword\">of</span> <span class=\"variable language_\">arguments</span>) &#123;</span><br><span class=\"line\">        arr.<span class=\"title function_\">push</span>(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> arr);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6中的方式1：</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newArr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"variable language_\">arguments</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6中的方式2：解构赋值</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newArr = [...<span class=\"variable language_\">arguments</span>];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>调用slice(不常用)</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newArr = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>箭头函数不绑定arguments，也就是箭头函数没有arguments。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">bar</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">arguments</span>); <span class=\"comment\">// 报错 arguments没有被定义</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> <span class=\"title function_\">bar</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">\t\tconsolel.<span class=\"title function_\">og</span>(<span class=\"variable language_\">arguments</span>); <span class=\"comment\">// 上层作用域的arguments</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3函数的剩余（rest）参数\"><a href=\"#1-3函数的剩余（rest）参数\" class=\"headerlink\" title=\"1.3函数的剩余（rest）参数\"></a>1.3函数的剩余（rest）参数</h2><p>如果最后一个参数是以<code>…</code>为前缀，那么他会将剩余的参数方法到该参数中，并且作为一个数组。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y,...arg</span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p>默认一个函数只有一个剩余参数。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>剩余参数只能写到其他参数最后，否则会报错。</li>\n</ul>\n<p>剩余参数与arguments的区别：</p>\n<ol>\n<li>剩余参数只包含没有对应形参的实参，arguments对象包含了所有传递给函数的参数。</li>\n<li>arguments不是一个真正的数组，而rest剩余参数是一个真正的数组。</li>\n<li>arguments是早期的技术，rest剩余参数是ES6为了取代arguments出现的。</li>\n</ol>\n<h1 id=\"2-函数式编程\"><a href=\"#2-函数式编程\" class=\"headerlink\" title=\"2.函数式编程\"></a>2.函数式编程</h1><h2 id=\"2-1-理解JavaScript纯函数\"><a href=\"#2-1-理解JavaScript纯函数\" class=\"headerlink\" title=\"2.1 理解JavaScript纯函数\"></a>2.1 理解JavaScript纯函数</h2><p>纯函数输入相同的值，每一次输出的结构应该都相同。</p>\n<p>并且函数与I&#x2F;O设备的输入无关。</p>\n<p>并且不能有语义上可观察的副作用功能。</p>\n<p><strong>总结：</strong></p>\n<ol>\n<li>确定的输入，结果为确定的输出，结果不会改变。</li>\n<li>函数在执行的过程中，不能产生副作用。</li>\n</ol>\n<p><strong>什么是副作用：</strong></p>\n<p>就是在执行一个函数的时候，出来返回函数值之外，还对其他东西产生了影响，比如修改全局变量，修改了对象的某个属性。</p>\n<h2 id=\"2-2纯函数的作用域优势\"><a href=\"#2-2纯函数的作用域优势\" class=\"headerlink\" title=\"2.2纯函数的作用域优势\"></a>2.2纯函数的作用域优势</h2><ul>\n<li>不需要关心外部作用域对函数的影响。</li>\n<li>调用函数时，确定的输入，一定产生确定的输出。</li>\n</ul>\n<h2 id=\"2-3-柯里化概念理解\"><a href=\"#2-3-柯里化概念理解\" class=\"headerlink\" title=\"2.3 柯里化概念理解\"></a>2.3 柯里化概念理解</h2><p>把接受多个参数的函数，变成接受一个单一参数的哈数，并且返回接受余下的参数，返回结果的新函数的技术。</p>\n<p>比如:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y,z</span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面就是经过柯里化的函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo1</span>(<span class=\"params\">x</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">y</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">z</span>)&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<ul>\n<li>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数</li>\n<li>柯里化不会调用函数，只是对函数进行一个转换</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">y</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">z</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x+y+z;\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">10</span>)(<span class=\"number\">20</span>)(<span class=\"number\">30</span>); <span class=\"comment\">// 60</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>柯里化的另一种写法：</strong></p>\n<p>箭头函数的写法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">z</span> =&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x+y+z;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以这样写：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">foo</span> = x =&gt; <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> <span class=\"function\"><span class=\"params\">z</span> =&gt;</span> x+y+z;</span><br></pre></td></tr></table></figure>\n\n<p><strong>柯里化高级-自动柯里化</strong></p>\n<p>封装一个函数，传入一个函数对象，返回一个柯里化完成的函数。</p>\n<h2 id=\"2-3-组合函数\"><a href=\"#2-3-组合函数\" class=\"headerlink\" title=\"2.3 组合函数\"></a>2.3 组合函数</h2><p>在开发中你，需要将上一个函数的结果作为参数传入另一个函数。当我们需要多次执行这样的函数，我们可以使用组合函数来解决。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">double</span>(<span class=\"params\">num</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pow</span>(<span class=\"params\">num</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num**<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">composeFn</span>(<span class=\"params\">num</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">pow</span>(<span class=\"title function_\">double</span>(num));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">composeFn</span>(<span class=\"number\">2</span>); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-eval函数\"><a href=\"#2-4-eval函数\" class=\"headerlink\" title=\"2.4 eval函数\"></a>2.4 eval函数</h2><ul>\n<li>eval是一个特殊的函数，它可以将传入的字符串当做</li>\n</ul>\n<p>JavaScript代码运行</p>\n<ul>\n<li>eval会将最后一直执行语句的结果作为返回值</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">`console.log(&quot;123&quot;)`</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这个字符串是可以访问全局变量的。</p>\n<h1 id=\"3-严格模式\"><a href=\"#3-严格模式\" class=\"headerlink\" title=\"3. 严格模式\"></a>3. 严格模式</h1><p>在支持严格模式的浏览器中国，检测到有严格模式的时候，会以更加严格的方式对代码进行检测和执行。</p>\n<p>严格模式对JavaScript语义进行了一些限制：</p>\n<ul>\n<li>通过抛出错误消除一些原有的静默错误</li>\n<li>严格模式让JS引擎在执行代码时可以进行更多的优化（不用对一些特殊语法进行处理）</li>\n<li>严格模式禁用了可能在未来版本可能会定义的一些语法。</li>\n</ul>\n<h2 id=\"3-1-开启严格模式\"><a href=\"#3-1-开启严格模式\" class=\"headerlink\" title=\"3.1 开启严格模式\"></a>3.1 开启严格模式</h2><ul>\n<li>开启全局严格模式：在代码开始写上下面这段代码</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>给某个函数开启严格模式：在函数体内部开始写上这样一段代码.</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;use strict&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没有指令是程序返回默认模式。</p>\n<p>在现代JavaScript中，class与module自动启用<code>use strict</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript函数的增强知识\"><a href=\"#JavaScript函数的增强知识\" class=\"headerlink\" title=\"JavaScript函数的增强知识\"></a>JavaScript函数的增强知识</h1><ol>\n<li>函数属性和arguments</li>\n<li>纯函数的理解和应用</li>\n<li>柯里化的理解和应用</li>\n<li>组合函数理解和应用</li>\n<li>with、eval的使用</li>\n<li>严格模式的使用</li>\n</ol>\n<h1 id=\"1-函数对象的属性\"><a href=\"#1-函数对象的属性\" class=\"headerlink\" title=\"1.函数对象的属性\"></a>1.函数对象的属性</h1><p>在JavaScript中，函数也是属于一种对象。</p>\n<h2 id=\"1-1-函数的属性\"><a href=\"#1-1-函数的属性\" class=\"headerlink\" title=\"1.1 函数的属性\"></a>1.1 函数的属性</h2><p>函数也可以像对象一个添加自定义属性：foo.address &#x3D; “asd”;</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">num,count,name</span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>默认的函数对象中有一些自己的属性：</p>\n<ul>\n<li>name属性，函数的名称</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.<span class=\"property\">name</span>; <span class=\"comment\">// foo</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>length属性：参数(形参)的个数</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.<span class=\"property\">length</span>;<span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>额外补充：剩余参数</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y,z...arg</span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候length还是为3。</p>\n<h2 id=\"1-2-函数中的arguments\"><a href=\"#1-2-函数中的arguments\" class=\"headerlink\" title=\"1.2 函数中的arguments\"></a>1.2 函数中的arguments</h2><p>在使用函数的时候，传入的参数个数多于定义函数时形式参数个数时，这些参数还是会存在于函数中，只是他们被存放在arguments中。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">a,b</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>); <span class=\"comment\">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>\n\n<p>arguments是一个传递给函数的参数的类数组对象。</p>\n<p>类数组对象就是有数组的一些属性，length等等；但是没有数组的一些方法。</p>\n<p>arguments可以通过索引获取到对应的值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>] <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>arguments转为数组的方法</p>\n<ul>\n<li>遍历arguments，将其每一个元素添加进一个新数组。</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo1</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> item <span class=\"keyword\">of</span> <span class=\"variable language_\">arguments</span>) &#123;</span><br><span class=\"line\">        arr.<span class=\"title function_\">push</span>(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> arr);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6中的方式1：</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newArr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"variable language_\">arguments</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6中的方式2：解构赋值</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newArr = [...<span class=\"variable language_\">arguments</span>];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>调用slice(不常用)</li>\n</ul>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newArr = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>箭头函数不绑定arguments，也就是箭头函数没有arguments。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">bar</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">arguments</span>); <span class=\"comment\">// 报错 arguments没有被定义</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> <span class=\"title function_\">bar</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">\t\tconsolel.<span class=\"title function_\">og</span>(<span class=\"variable language_\">arguments</span>); <span class=\"comment\">// 上层作用域的arguments</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3函数的剩余（rest）参数\"><a href=\"#1-3函数的剩余（rest）参数\" class=\"headerlink\" title=\"1.3函数的剩余（rest）参数\"></a>1.3函数的剩余（rest）参数</h2><p>如果最后一个参数是以<code>…</code>为前缀，那么他会将剩余的参数方法到该参数中，并且作为一个数组。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y,...arg</span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p>默认一个函数只有一个剩余参数。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>剩余参数只能写到其他参数最后，否则会报错。</li>\n</ul>\n<p>剩余参数与arguments的区别：</p>\n<ol>\n<li>剩余参数只包含没有对应形参的实参，arguments对象包含了所有传递给函数的参数。</li>\n<li>arguments不是一个真正的数组，而rest剩余参数是一个真正的数组。</li>\n<li>arguments是早期的技术，rest剩余参数是ES6为了取代arguments出现的。</li>\n</ol>\n<h1 id=\"2-函数式编程\"><a href=\"#2-函数式编程\" class=\"headerlink\" title=\"2.函数式编程\"></a>2.函数式编程</h1><h2 id=\"2-1-理解JavaScript纯函数\"><a href=\"#2-1-理解JavaScript纯函数\" class=\"headerlink\" title=\"2.1 理解JavaScript纯函数\"></a>2.1 理解JavaScript纯函数</h2><p>纯函数输入相同的值，每一次输出的结构应该都相同。</p>\n<p>并且函数与I&#x2F;O设备的输入无关。</p>\n<p>并且不能有语义上可观察的副作用功能。</p>\n<p><strong>总结：</strong></p>\n<ol>\n<li>确定的输入，结果为确定的输出，结果不会改变。</li>\n<li>函数在执行的过程中，不能产生副作用。</li>\n</ol>\n<p><strong>什么是副作用：</strong></p>\n<p>就是在执行一个函数的时候，出来返回函数值之外，还对其他东西产生了影响，比如修改全局变量，修改了对象的某个属性。</p>\n<h2 id=\"2-2纯函数的作用域优势\"><a href=\"#2-2纯函数的作用域优势\" class=\"headerlink\" title=\"2.2纯函数的作用域优势\"></a>2.2纯函数的作用域优势</h2><ul>\n<li>不需要关心外部作用域对函数的影响。</li>\n<li>调用函数时，确定的输入，一定产生确定的输出。</li>\n</ul>\n<h2 id=\"2-3-柯里化概念理解\"><a href=\"#2-3-柯里化概念理解\" class=\"headerlink\" title=\"2.3 柯里化概念理解\"></a>2.3 柯里化概念理解</h2><p>把接受多个参数的函数，变成接受一个单一参数的哈数，并且返回接受余下的参数，返回结果的新函数的技术。</p>\n<p>比如:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x,y,z</span>)&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面就是经过柯里化的函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo1</span>(<span class=\"params\">x</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">y</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">z</span>)&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<ul>\n<li>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数</li>\n<li>柯里化不会调用函数，只是对函数进行一个转换</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">y</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">z</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x+y+z;\t\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(<span class=\"number\">10</span>)(<span class=\"number\">20</span>)(<span class=\"number\">30</span>); <span class=\"comment\">// 60</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>柯里化的另一种写法：</strong></p>\n<p>箭头函数的写法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\">x</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">z</span> =&gt;</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> x+y+z;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还可以这样写：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"title function_\">foo</span> = x =&gt; <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> <span class=\"function\"><span class=\"params\">z</span> =&gt;</span> x+y+z;</span><br></pre></td></tr></table></figure>\n\n<p><strong>柯里化高级-自动柯里化</strong></p>\n<p>封装一个函数，传入一个函数对象，返回一个柯里化完成的函数。</p>\n<h2 id=\"2-3-组合函数\"><a href=\"#2-3-组合函数\" class=\"headerlink\" title=\"2.3 组合函数\"></a>2.3 组合函数</h2><p>在开发中你，需要将上一个函数的结果作为参数传入另一个函数。当我们需要多次执行这样的函数，我们可以使用组合函数来解决。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">double</span>(<span class=\"params\">num</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">pow</span>(<span class=\"params\">num</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num**<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">composeFn</span>(<span class=\"params\">num</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">pow</span>(<span class=\"title function_\">double</span>(num));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">composeFn</span>(<span class=\"number\">2</span>); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-eval函数\"><a href=\"#2-4-eval函数\" class=\"headerlink\" title=\"2.4 eval函数\"></a>2.4 eval函数</h2><ul>\n<li>eval是一个特殊的函数，它可以将传入的字符串当做</li>\n</ul>\n<p>JavaScript代码运行</p>\n<ul>\n<li>eval会将最后一直执行语句的结果作为返回值</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">`console.log(&quot;123&quot;)`</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这个字符串是可以访问全局变量的。</p>\n<h1 id=\"3-严格模式\"><a href=\"#3-严格模式\" class=\"headerlink\" title=\"3. 严格模式\"></a>3. 严格模式</h1><p>在支持严格模式的浏览器中国，检测到有严格模式的时候，会以更加严格的方式对代码进行检测和执行。</p>\n<p>严格模式对JavaScript语义进行了一些限制：</p>\n<ul>\n<li>通过抛出错误消除一些原有的静默错误</li>\n<li>严格模式让JS引擎在执行代码时可以进行更多的优化（不用对一些特殊语法进行处理）</li>\n<li>严格模式禁用了可能在未来版本可能会定义的一些语法。</li>\n</ul>\n<h2 id=\"3-1-开启严格模式\"><a href=\"#3-1-开启严格模式\" class=\"headerlink\" title=\"3.1 开启严格模式\"></a>3.1 开启严格模式</h2><ul>\n<li>开启全局严格模式：在代码开始写上下面这段代码</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>给某个函数开启严格模式：在函数体内部开始写上这样一段代码.</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;use strict&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>没有指令是程序返回默认模式。</p>\n<p>在现代JavaScript中，class与module自动启用<code>use strict</code></p>\n"},{"title":"JavaScript的深拷贝与浅拷贝","date":"2022-08-25T16:00:00.000Z","_content":"# JavaScript的浅拷贝与深拷贝\n\n首先这个浅拷贝与深拷贝是针对引用值复制来谈的。\n\n我们知道在JavaScript中，数据类型分为基本数据类型和引用（对象）数据类型。\n\n1. 基本数据类型的特点就是他们的数据是直接存储在栈（stack）里面的.\n2. 引用数据类型的就不一样了，引用数据类型他们在栈里面存放的是该对象的地址，而不是该对象的值。这个地址指向的是一个堆的内存地址，这个内存地址里面存放的是该对象的值。\n\n## 赋值与浅拷贝的区别\n\n前面我们有讲述过原始值复制，那么这个复制与引用复制，这两种复制的区别是什么呢？\n\n其实我们只要知道，两者复制最后都是复制栈里面的值。在原始值中，复制的是变量的值；但是在引用值复制里面，复制的是栈里面的地址，但是真正的数据没有被复制。\n\n引用值这样复制就会导致一个问题：复制之后的原始值与之前的原始值是相互独立的，这就是说，两者的改变不会影响到另一个；但是引用值则不同，因为他们在栈里面的地址相同，意味着他们指向的对象是同一个对象。这就导致明明修改的是另一个对象数据，但是实际上之前那个对象也被修改了。\n\n例如：\n\n    let message = {\n        name: '海绵宝宝',\n        age: 18,\n    };\n    let message2 = message;\n    message2.name = '小海绵';\n    console.log(message); // { name: '小海绵', age: 18 }\n\n这里我们明明修改的是message2，但是message里面的`name`也被修改了，因为message2和message本质上都是指向内存里面的同一个对象。\n\n## 浅拷贝\n\n为了解决上面出现的这种问题，我们就需要用到浅拷贝。\n\n那么什么是浅拷贝呢？\n\n前面我们看到引用值在使用`=`复制时，并没有达到两个对象互相独立的效果，这是因为我们复制的是栈里面的地址，而不是对象的值。既然如此，那么我们可以直接将对象里面的各个属性单独复制出来吗？\n\n答案是可以的。\n\n- 第一种方法：for···in···\n  \n我们使用for循环，遍历对象的属性，然后再将每个属性复制出来。\n\n    let message = {\n        name: '海绵宝宝',\n        age: 18,\n    };\n    let message2 = {};\n    for (let key in message) {\n        message2[key] = message[key];\n    }\n    console.log(message2); // { name: '海绵宝宝', age: 18 }\n\n- 第二种方法：Object.assign\n\n这里我们可以Object.assign，将对象的属性复制出来。\n\n**语法：**\n\n    Object.assign(dest,[src1,src2,...])\n\n- dest：目标对象(我们要复制到的对象)\n- `scr1,scr2,...`：源对象(我们要复制的对象)\n- 返回值：返回目标对象\n\n例如：\n\n    ```\n    let message = {\n        name: '海绵宝宝',\n        age: 18,\n    };\n    let message2 = Object.assign({}, message);\n    console.log(message2); // { name: '海绵宝宝', age: 18 }\n    ```\n\n**注意：**\n\n- 如果复制的属性已经存在，那么该属性将会被覆盖。\n\n## 深拷贝\n\n前面我们复制的都是对象里面全是原始值的情况，那么要是对象里面还存在一个引用值。我们使用之前的方法，会出现什么情况呢。\n\n例子：\n\n    let message = {\n        name: '海绵宝宝',\n        age: 18,\n        address: {\n            city: '北京',\n            street: '朝阳',\n        },\n    };\n    let message2 = {};\n    for (let key in message) {\n        message2[key] = message[key];\n    }\n    message2.address.city = '上海';\n    console.log(message2); // { name: '海绵宝宝', age: 18, address: { city: '上海', street: '朝阳' } }\n\n这里我们看到，对象里面的引用值还是没有被完全复制，这就需要使用深拷贝了。\n\n我们可以使用lodash库的cloneDeep方法，它会深拷贝对象。\n\n## 一个小知识点\n\n使用const声明的对象也是可以被修改的。之前我们了解的const是声明常量的，这也就意味着它的值不能被修改。，但是在对象里面可以实现修改。\n\n    const user = {\n        name = \"user\",\n        weight = 60,\n    }\n    user.weight = 70;\n    alert(user.weight); // 70\n\n也就是说只有我们将const声明作为一个整体进行修改时，才会报错。","source":"_posts/JavaScript/JavaScript的浅拷贝与深拷贝.md","raw":"---\ntitle: JavaScript的深拷贝与浅拷贝\ndate: 2022-8-26\ntags: [前端]\ncategories: [JavaScript]\n---\n# JavaScript的浅拷贝与深拷贝\n\n首先这个浅拷贝与深拷贝是针对引用值复制来谈的。\n\n我们知道在JavaScript中，数据类型分为基本数据类型和引用（对象）数据类型。\n\n1. 基本数据类型的特点就是他们的数据是直接存储在栈（stack）里面的.\n2. 引用数据类型的就不一样了，引用数据类型他们在栈里面存放的是该对象的地址，而不是该对象的值。这个地址指向的是一个堆的内存地址，这个内存地址里面存放的是该对象的值。\n\n## 赋值与浅拷贝的区别\n\n前面我们有讲述过原始值复制，那么这个复制与引用复制，这两种复制的区别是什么呢？\n\n其实我们只要知道，两者复制最后都是复制栈里面的值。在原始值中，复制的是变量的值；但是在引用值复制里面，复制的是栈里面的地址，但是真正的数据没有被复制。\n\n引用值这样复制就会导致一个问题：复制之后的原始值与之前的原始值是相互独立的，这就是说，两者的改变不会影响到另一个；但是引用值则不同，因为他们在栈里面的地址相同，意味着他们指向的对象是同一个对象。这就导致明明修改的是另一个对象数据，但是实际上之前那个对象也被修改了。\n\n例如：\n\n    let message = {\n        name: '海绵宝宝',\n        age: 18,\n    };\n    let message2 = message;\n    message2.name = '小海绵';\n    console.log(message); // { name: '小海绵', age: 18 }\n\n这里我们明明修改的是message2，但是message里面的`name`也被修改了，因为message2和message本质上都是指向内存里面的同一个对象。\n\n## 浅拷贝\n\n为了解决上面出现的这种问题，我们就需要用到浅拷贝。\n\n那么什么是浅拷贝呢？\n\n前面我们看到引用值在使用`=`复制时，并没有达到两个对象互相独立的效果，这是因为我们复制的是栈里面的地址，而不是对象的值。既然如此，那么我们可以直接将对象里面的各个属性单独复制出来吗？\n\n答案是可以的。\n\n- 第一种方法：for···in···\n  \n我们使用for循环，遍历对象的属性，然后再将每个属性复制出来。\n\n    let message = {\n        name: '海绵宝宝',\n        age: 18,\n    };\n    let message2 = {};\n    for (let key in message) {\n        message2[key] = message[key];\n    }\n    console.log(message2); // { name: '海绵宝宝', age: 18 }\n\n- 第二种方法：Object.assign\n\n这里我们可以Object.assign，将对象的属性复制出来。\n\n**语法：**\n\n    Object.assign(dest,[src1,src2,...])\n\n- dest：目标对象(我们要复制到的对象)\n- `scr1,scr2,...`：源对象(我们要复制的对象)\n- 返回值：返回目标对象\n\n例如：\n\n    ```\n    let message = {\n        name: '海绵宝宝',\n        age: 18,\n    };\n    let message2 = Object.assign({}, message);\n    console.log(message2); // { name: '海绵宝宝', age: 18 }\n    ```\n\n**注意：**\n\n- 如果复制的属性已经存在，那么该属性将会被覆盖。\n\n## 深拷贝\n\n前面我们复制的都是对象里面全是原始值的情况，那么要是对象里面还存在一个引用值。我们使用之前的方法，会出现什么情况呢。\n\n例子：\n\n    let message = {\n        name: '海绵宝宝',\n        age: 18,\n        address: {\n            city: '北京',\n            street: '朝阳',\n        },\n    };\n    let message2 = {};\n    for (let key in message) {\n        message2[key] = message[key];\n    }\n    message2.address.city = '上海';\n    console.log(message2); // { name: '海绵宝宝', age: 18, address: { city: '上海', street: '朝阳' } }\n\n这里我们看到，对象里面的引用值还是没有被完全复制，这就需要使用深拷贝了。\n\n我们可以使用lodash库的cloneDeep方法，它会深拷贝对象。\n\n## 一个小知识点\n\n使用const声明的对象也是可以被修改的。之前我们了解的const是声明常量的，这也就意味着它的值不能被修改。，但是在对象里面可以实现修改。\n\n    const user = {\n        name = \"user\",\n        weight = 60,\n    }\n    user.weight = 70;\n    alert(user.weight); // 70\n\n也就是说只有我们将const声明作为一个整体进行修改时，才会报错。","slug":"JavaScript/JavaScript的浅拷贝与深拷贝","published":1,"updated":"2023-01-09T12:15:20.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmib004b9kbmh0arcd84","content":"<h1 id=\"JavaScript的浅拷贝与深拷贝\"><a href=\"#JavaScript的浅拷贝与深拷贝\" class=\"headerlink\" title=\"JavaScript的浅拷贝与深拷贝\"></a>JavaScript的浅拷贝与深拷贝</h1><p>首先这个浅拷贝与深拷贝是针对引用值复制来谈的。</p>\n<p>我们知道在JavaScript中，数据类型分为基本数据类型和引用（对象）数据类型。</p>\n<ol>\n<li>基本数据类型的特点就是他们的数据是直接存储在栈（stack）里面的.</li>\n<li>引用数据类型的就不一样了，引用数据类型他们在栈里面存放的是该对象的地址，而不是该对象的值。这个地址指向的是一个堆的内存地址，这个内存地址里面存放的是该对象的值。</li>\n</ol>\n<h2 id=\"赋值与浅拷贝的区别\"><a href=\"#赋值与浅拷贝的区别\" class=\"headerlink\" title=\"赋值与浅拷贝的区别\"></a>赋值与浅拷贝的区别</h2><p>前面我们有讲述过原始值复制，那么这个复制与引用复制，这两种复制的区别是什么呢？</p>\n<p>其实我们只要知道，两者复制最后都是复制栈里面的值。在原始值中，复制的是变量的值；但是在引用值复制里面，复制的是栈里面的地址，但是真正的数据没有被复制。</p>\n<p>引用值这样复制就会导致一个问题：复制之后的原始值与之前的原始值是相互独立的，这就是说，两者的改变不会影响到另一个；但是引用值则不同，因为他们在栈里面的地址相同，意味着他们指向的对象是同一个对象。这就导致明明修改的是另一个对象数据，但是实际上之前那个对象也被修改了。</p>\n<p>例如：</p>\n<pre><code>let message = &#123;\n    name: &#39;海绵宝宝&#39;,\n    age: 18,\n&#125;;\nlet message2 = message;\nmessage2.name = &#39;小海绵&#39;;\nconsole.log(message); // &#123; name: &#39;小海绵&#39;, age: 18 &#125;\n</code></pre>\n<p>这里我们明明修改的是message2，但是message里面的<code>name</code>也被修改了，因为message2和message本质上都是指向内存里面的同一个对象。</p>\n<h2 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h2><p>为了解决上面出现的这种问题，我们就需要用到浅拷贝。</p>\n<p>那么什么是浅拷贝呢？</p>\n<p>前面我们看到引用值在使用<code>=</code>复制时，并没有达到两个对象互相独立的效果，这是因为我们复制的是栈里面的地址，而不是对象的值。既然如此，那么我们可以直接将对象里面的各个属性单独复制出来吗？</p>\n<p>答案是可以的。</p>\n<ul>\n<li>第一种方法：for···in···</li>\n</ul>\n<p>我们使用for循环，遍历对象的属性，然后再将每个属性复制出来。</p>\n<pre><code>let message = &#123;\n    name: &#39;海绵宝宝&#39;,\n    age: 18,\n&#125;;\nlet message2 = &#123;&#125;;\nfor (let key in message) &#123;\n    message2[key] = message[key];\n&#125;\nconsole.log(message2); // &#123; name: &#39;海绵宝宝&#39;, age: 18 &#125;\n</code></pre>\n<ul>\n<li>第二种方法：Object.assign</li>\n</ul>\n<p>这里我们可以Object.assign，将对象的属性复制出来。</p>\n<p><strong>语法：</strong></p>\n<pre><code>Object.assign(dest,[src1,src2,...])\n</code></pre>\n<ul>\n<li>dest：目标对象(我们要复制到的对象)</li>\n<li><code>scr1,scr2,...</code>：源对象(我们要复制的对象)</li>\n<li>返回值：返回目标对象</li>\n</ul>\n<p>例如：</p>\n<pre><code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let message = &#123;</span><br><span class=\"line\">    name: &#x27;海绵宝宝&#x27;,</span><br><span class=\"line\">    age: 18,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let message2 = Object.assign(&#123;&#125;, message);</span><br><span class=\"line\">console.log(message2); // &#123; name: &#x27;海绵宝宝&#x27;, age: 18 &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>如果复制的属性已经存在，那么该属性将会被覆盖。</li>\n</ul>\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><p>前面我们复制的都是对象里面全是原始值的情况，那么要是对象里面还存在一个引用值。我们使用之前的方法，会出现什么情况呢。</p>\n<p>例子：</p>\n<pre><code>let message = &#123;\n    name: &#39;海绵宝宝&#39;,\n    age: 18,\n    address: &#123;\n        city: &#39;北京&#39;,\n        street: &#39;朝阳&#39;,\n    &#125;,\n&#125;;\nlet message2 = &#123;&#125;;\nfor (let key in message) &#123;\n    message2[key] = message[key];\n&#125;\nmessage2.address.city = &#39;上海&#39;;\nconsole.log(message2); // &#123; name: &#39;海绵宝宝&#39;, age: 18, address: &#123; city: &#39;上海&#39;, street: &#39;朝阳&#39; &#125; &#125;\n</code></pre>\n<p>这里我们看到，对象里面的引用值还是没有被完全复制，这就需要使用深拷贝了。</p>\n<p>我们可以使用lodash库的cloneDeep方法，它会深拷贝对象。</p>\n<h2 id=\"一个小知识点\"><a href=\"#一个小知识点\" class=\"headerlink\" title=\"一个小知识点\"></a>一个小知识点</h2><p>使用const声明的对象也是可以被修改的。之前我们了解的const是声明常量的，这也就意味着它的值不能被修改。，但是在对象里面可以实现修改。</p>\n<pre><code>const user = &#123;\n    name = &quot;user&quot;,\n    weight = 60,\n&#125;\nuser.weight = 70;\nalert(user.weight); // 70\n</code></pre>\n<p>也就是说只有我们将const声明作为一个整体进行修改时，才会报错。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript的浅拷贝与深拷贝\"><a href=\"#JavaScript的浅拷贝与深拷贝\" class=\"headerlink\" title=\"JavaScript的浅拷贝与深拷贝\"></a>JavaScript的浅拷贝与深拷贝</h1><p>首先这个浅拷贝与深拷贝是针对引用值复制来谈的。</p>\n<p>我们知道在JavaScript中，数据类型分为基本数据类型和引用（对象）数据类型。</p>\n<ol>\n<li>基本数据类型的特点就是他们的数据是直接存储在栈（stack）里面的.</li>\n<li>引用数据类型的就不一样了，引用数据类型他们在栈里面存放的是该对象的地址，而不是该对象的值。这个地址指向的是一个堆的内存地址，这个内存地址里面存放的是该对象的值。</li>\n</ol>\n<h2 id=\"赋值与浅拷贝的区别\"><a href=\"#赋值与浅拷贝的区别\" class=\"headerlink\" title=\"赋值与浅拷贝的区别\"></a>赋值与浅拷贝的区别</h2><p>前面我们有讲述过原始值复制，那么这个复制与引用复制，这两种复制的区别是什么呢？</p>\n<p>其实我们只要知道，两者复制最后都是复制栈里面的值。在原始值中，复制的是变量的值；但是在引用值复制里面，复制的是栈里面的地址，但是真正的数据没有被复制。</p>\n<p>引用值这样复制就会导致一个问题：复制之后的原始值与之前的原始值是相互独立的，这就是说，两者的改变不会影响到另一个；但是引用值则不同，因为他们在栈里面的地址相同，意味着他们指向的对象是同一个对象。这就导致明明修改的是另一个对象数据，但是实际上之前那个对象也被修改了。</p>\n<p>例如：</p>\n<pre><code>let message = &#123;\n    name: &#39;海绵宝宝&#39;,\n    age: 18,\n&#125;;\nlet message2 = message;\nmessage2.name = &#39;小海绵&#39;;\nconsole.log(message); // &#123; name: &#39;小海绵&#39;, age: 18 &#125;\n</code></pre>\n<p>这里我们明明修改的是message2，但是message里面的<code>name</code>也被修改了，因为message2和message本质上都是指向内存里面的同一个对象。</p>\n<h2 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h2><p>为了解决上面出现的这种问题，我们就需要用到浅拷贝。</p>\n<p>那么什么是浅拷贝呢？</p>\n<p>前面我们看到引用值在使用<code>=</code>复制时，并没有达到两个对象互相独立的效果，这是因为我们复制的是栈里面的地址，而不是对象的值。既然如此，那么我们可以直接将对象里面的各个属性单独复制出来吗？</p>\n<p>答案是可以的。</p>\n<ul>\n<li>第一种方法：for···in···</li>\n</ul>\n<p>我们使用for循环，遍历对象的属性，然后再将每个属性复制出来。</p>\n<pre><code>let message = &#123;\n    name: &#39;海绵宝宝&#39;,\n    age: 18,\n&#125;;\nlet message2 = &#123;&#125;;\nfor (let key in message) &#123;\n    message2[key] = message[key];\n&#125;\nconsole.log(message2); // &#123; name: &#39;海绵宝宝&#39;, age: 18 &#125;\n</code></pre>\n<ul>\n<li>第二种方法：Object.assign</li>\n</ul>\n<p>这里我们可以Object.assign，将对象的属性复制出来。</p>\n<p><strong>语法：</strong></p>\n<pre><code>Object.assign(dest,[src1,src2,...])\n</code></pre>\n<ul>\n<li>dest：目标对象(我们要复制到的对象)</li>\n<li><code>scr1,scr2,...</code>：源对象(我们要复制的对象)</li>\n<li>返回值：返回目标对象</li>\n</ul>\n<p>例如：</p>\n<pre><code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let message = &#123;</span><br><span class=\"line\">    name: &#x27;海绵宝宝&#x27;,</span><br><span class=\"line\">    age: 18,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let message2 = Object.assign(&#123;&#125;, message);</span><br><span class=\"line\">console.log(message2); // &#123; name: &#x27;海绵宝宝&#x27;, age: 18 &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>如果复制的属性已经存在，那么该属性将会被覆盖。</li>\n</ul>\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><p>前面我们复制的都是对象里面全是原始值的情况，那么要是对象里面还存在一个引用值。我们使用之前的方法，会出现什么情况呢。</p>\n<p>例子：</p>\n<pre><code>let message = &#123;\n    name: &#39;海绵宝宝&#39;,\n    age: 18,\n    address: &#123;\n        city: &#39;北京&#39;,\n        street: &#39;朝阳&#39;,\n    &#125;,\n&#125;;\nlet message2 = &#123;&#125;;\nfor (let key in message) &#123;\n    message2[key] = message[key];\n&#125;\nmessage2.address.city = &#39;上海&#39;;\nconsole.log(message2); // &#123; name: &#39;海绵宝宝&#39;, age: 18, address: &#123; city: &#39;上海&#39;, street: &#39;朝阳&#39; &#125; &#125;\n</code></pre>\n<p>这里我们看到，对象里面的引用值还是没有被完全复制，这就需要使用深拷贝了。</p>\n<p>我们可以使用lodash库的cloneDeep方法，它会深拷贝对象。</p>\n<h2 id=\"一个小知识点\"><a href=\"#一个小知识点\" class=\"headerlink\" title=\"一个小知识点\"></a>一个小知识点</h2><p>使用const声明的对象也是可以被修改的。之前我们了解的const是声明常量的，这也就意味着它的值不能被修改。，但是在对象里面可以实现修改。</p>\n<pre><code>const user = &#123;\n    name = &quot;user&quot;,\n    weight = 60,\n&#125;\nuser.weight = 70;\nalert(user.weight); // 70\n</code></pre>\n<p>也就是说只有我们将const声明作为一个整体进行修改时，才会报错。</p>\n"},{"title":"JavaScript对象的增强知识","date":"2023-05-15T16:00:00.000Z","_content":"# JavaScript对象的增强知识\n\n1. Object.defineProperty\n2. 数据属性描述符\n3. 存取属性描述符\n4. Object.defineProperties\n5. 对象的其他方法补充\n\n# 1. 对象属性的控制\n\n针对对象某一个对象，我们可以对里面的一些属性进行查看修改。\n\n我们可以通过某种方式对这些行为进行限制。\n\n## 1.1 对属性操作的控制\n\n默认情况下，对对象某一个属性操作是没有限制的。\n\n如果我们香香对一个属性进行比较精准的操作控制，我们可以使用属性描述符。\n\n- 通过属性描述符可以精准的添加或者修改对象的属性\n- 属性描述符需要使用Object.defineProperty来对属性进行修改或者添加\n\n# 2 Object.defineProperty\n\n- Object.defineProperty()方法直接在对象上定义一个新属性，或者修改一个对象的现有属性，并且返回该对象。\n\n```jsx\nObject.defineProperty(要操作的对象,要修改的属性(名称或者Symbol),属性描述符)\n```\n\n## 2.1 属性描述符分类\n\n- 数据属性\n- 存取属性\n\n数据属性描述符有以下特征：\n\n1. [Configurable]：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它次该为存取属性描述符。\n\n直接在对象上定义一个属性，[Configurable]默认情况下为`true`\n\n通过属性描述符定一个一个属性时，[Configurable]默认为`false`\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    configurable: false, // 不可以配置该属性\n})\n```\n\n1. [Enumerable]:表示属性是否可以通过for in或者Object.keys()返回该属性\n\n直接在对象上定义一个属性，[Configurable]默认情况下为`true`\n\n通过属性描述符定一个一个属性时，[Configurable]默认为`false`\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    configurable: true,\n    enumerable: true, // 可枚举\n})\n```\n\n1. [writeable]：表示是否可以修改属性的值\n\n直接在对象上定义一个属性，[Configurable]默认情况下为`true`\n\n通过属性描述符定一个一个属性时，[Configurable]默认为`false`\n\n```jsx\n Object.defineProperty(obj, \"name\", {\n    configurable: true,\n    enumerable: true, // 可枚举\n    writable: true, // 可以写入\n})\n```\n\n1. [value]:修改属性的值\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    configurable: true,\n    enumerable: true, // 可枚举\n    writable: true, // 可以写入\n    value: 'qweqwe',\n})\n```\n\n存取属性描述符： \n\n1. [setter]：设置属性时会执行的函数，监听设置属性修改赋值的事件\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    set: function () {\n        console.log(\"name属性被修改了\");\n    }\n})\nobj.name = \"12212\"; // name属性被修改了\n```\n\n1. [getter]：获取属性时会执行的函数，监听获取属性值的事件\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    set: function () {\n        console.log(\"name属性被修改了\");\n    },\n    get: function () {\n        console.log(\"name属性被获取了\");\n    }\n})\nobj.name = \"12212\";\nlet name = obj.name; // name属性被获取了\n```\n\n# 3. 多个属性的描述符\n\n`Object.deineProperties()`\n\n```jsx\nObject.defineProperties(对象名称,{\n\t要设置的属性名\n},\n{\n\t属性描述符\n})\n```\n\n# 4. 对象 方法的补充\n\n- getOwnPropertyDescriptor:获取某个属性的默认属性描述符。\n- getOwnPropertyDescriptors:获取某个对象所有属性的默认属性值\n\n```jsx\nObject.getOwnPropertyDescriptor(对象名，属性名)\nObject.getOwnPropertyDescriptors(对象名)\n```\n\n- 阻止对象的扩展（严格模式下报错）\n\npreventExtensions()","source":"_posts/JavaScript/JavaScript对象的增强知识.md","raw":"---\ntitle: JavaScript对象的增强知识\ndate: 2023-5-16\ntags: [前端]\ncategories: [JavaScript]\n---\n# JavaScript对象的增强知识\n\n1. Object.defineProperty\n2. 数据属性描述符\n3. 存取属性描述符\n4. Object.defineProperties\n5. 对象的其他方法补充\n\n# 1. 对象属性的控制\n\n针对对象某一个对象，我们可以对里面的一些属性进行查看修改。\n\n我们可以通过某种方式对这些行为进行限制。\n\n## 1.1 对属性操作的控制\n\n默认情况下，对对象某一个属性操作是没有限制的。\n\n如果我们香香对一个属性进行比较精准的操作控制，我们可以使用属性描述符。\n\n- 通过属性描述符可以精准的添加或者修改对象的属性\n- 属性描述符需要使用Object.defineProperty来对属性进行修改或者添加\n\n# 2 Object.defineProperty\n\n- Object.defineProperty()方法直接在对象上定义一个新属性，或者修改一个对象的现有属性，并且返回该对象。\n\n```jsx\nObject.defineProperty(要操作的对象,要修改的属性(名称或者Symbol),属性描述符)\n```\n\n## 2.1 属性描述符分类\n\n- 数据属性\n- 存取属性\n\n数据属性描述符有以下特征：\n\n1. [Configurable]：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它次该为存取属性描述符。\n\n直接在对象上定义一个属性，[Configurable]默认情况下为`true`\n\n通过属性描述符定一个一个属性时，[Configurable]默认为`false`\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    configurable: false, // 不可以配置该属性\n})\n```\n\n1. [Enumerable]:表示属性是否可以通过for in或者Object.keys()返回该属性\n\n直接在对象上定义一个属性，[Configurable]默认情况下为`true`\n\n通过属性描述符定一个一个属性时，[Configurable]默认为`false`\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    configurable: true,\n    enumerable: true, // 可枚举\n})\n```\n\n1. [writeable]：表示是否可以修改属性的值\n\n直接在对象上定义一个属性，[Configurable]默认情况下为`true`\n\n通过属性描述符定一个一个属性时，[Configurable]默认为`false`\n\n```jsx\n Object.defineProperty(obj, \"name\", {\n    configurable: true,\n    enumerable: true, // 可枚举\n    writable: true, // 可以写入\n})\n```\n\n1. [value]:修改属性的值\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    configurable: true,\n    enumerable: true, // 可枚举\n    writable: true, // 可以写入\n    value: 'qweqwe',\n})\n```\n\n存取属性描述符： \n\n1. [setter]：设置属性时会执行的函数，监听设置属性修改赋值的事件\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    set: function () {\n        console.log(\"name属性被修改了\");\n    }\n})\nobj.name = \"12212\"; // name属性被修改了\n```\n\n1. [getter]：获取属性时会执行的函数，监听获取属性值的事件\n\n```jsx\nObject.defineProperty(obj, \"name\", {\n    set: function () {\n        console.log(\"name属性被修改了\");\n    },\n    get: function () {\n        console.log(\"name属性被获取了\");\n    }\n})\nobj.name = \"12212\";\nlet name = obj.name; // name属性被获取了\n```\n\n# 3. 多个属性的描述符\n\n`Object.deineProperties()`\n\n```jsx\nObject.defineProperties(对象名称,{\n\t要设置的属性名\n},\n{\n\t属性描述符\n})\n```\n\n# 4. 对象 方法的补充\n\n- getOwnPropertyDescriptor:获取某个属性的默认属性描述符。\n- getOwnPropertyDescriptors:获取某个对象所有属性的默认属性值\n\n```jsx\nObject.getOwnPropertyDescriptor(对象名，属性名)\nObject.getOwnPropertyDescriptors(对象名)\n```\n\n- 阻止对象的扩展（严格模式下报错）\n\npreventExtensions()","slug":"JavaScript/JavaScript对象的增强知识","published":1,"updated":"2023-05-16T02:32:55.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmic004e9kbmee9l23fn","content":"<h1 id=\"JavaScript对象的增强知识\"><a href=\"#JavaScript对象的增强知识\" class=\"headerlink\" title=\"JavaScript对象的增强知识\"></a>JavaScript对象的增强知识</h1><ol>\n<li>Object.defineProperty</li>\n<li>数据属性描述符</li>\n<li>存取属性描述符</li>\n<li>Object.defineProperties</li>\n<li>对象的其他方法补充</li>\n</ol>\n<h1 id=\"1-对象属性的控制\"><a href=\"#1-对象属性的控制\" class=\"headerlink\" title=\"1. 对象属性的控制\"></a>1. 对象属性的控制</h1><p>针对对象某一个对象，我们可以对里面的一些属性进行查看修改。</p>\n<p>我们可以通过某种方式对这些行为进行限制。</p>\n<h2 id=\"1-1-对属性操作的控制\"><a href=\"#1-1-对属性操作的控制\" class=\"headerlink\" title=\"1.1 对属性操作的控制\"></a>1.1 对属性操作的控制</h2><p>默认情况下，对对象某一个属性操作是没有限制的。</p>\n<p>如果我们香香对一个属性进行比较精准的操作控制，我们可以使用属性描述符。</p>\n<ul>\n<li>通过属性描述符可以精准的添加或者修改对象的属性</li>\n<li>属性描述符需要使用Object.defineProperty来对属性进行修改或者添加</li>\n</ul>\n<h1 id=\"2-Object-defineProperty\"><a href=\"#2-Object-defineProperty\" class=\"headerlink\" title=\"2 Object.defineProperty\"></a>2 Object.defineProperty</h1><ul>\n<li>Object.defineProperty()方法直接在对象上定义一个新属性，或者修改一个对象的现有属性，并且返回该对象。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(要操作的对象,要修改的属性(名称或者<span class=\"title class_\">Symbol</span>),属性描述符)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-1-属性描述符分类\"><a href=\"#2-1-属性描述符分类\" class=\"headerlink\" title=\"2.1 属性描述符分类\"></a>2.1 属性描述符分类</h2><ul>\n<li>数据属性</li>\n<li>存取属性</li>\n</ul>\n<p>数据属性描述符有以下特征：</p>\n<ol>\n<li>[Configurable]：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它次该为存取属性描述符。</li>\n</ol>\n<p>直接在对象上定义一个属性，[Configurable]默认情况下为<code>true</code></p>\n<p>通过属性描述符定一个一个属性时，[Configurable]默认为<code>false</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span>, <span class=\"comment\">// 不可以配置该属性</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>[Enumerable]:表示属性是否可以通过for in或者Object.keys()返回该属性</li>\n</ol>\n<p>直接在对象上定义一个属性，[Configurable]默认情况下为<code>true</code></p>\n<p>通过属性描述符定一个一个属性时，[Configurable]默认为<code>false</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可枚举</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>[writeable]：表示是否可以修改属性的值</li>\n</ol>\n<p>直接在对象上定义一个属性，[Configurable]默认情况下为<code>true</code></p>\n<p>通过属性描述符定一个一个属性时，[Configurable]默认为<code>false</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可枚举</span></span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可以写入</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li></li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可枚举</span></span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可以写入</span></span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"string\">&#x27;qweqwe&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>存取属性描述符： </p>\n<ol>\n<li>[setter]：设置属性时会执行的函数，监听设置属性修改赋值的事件</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;name属性被修改了&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&quot;12212&quot;</span>; <span class=\"comment\">// name属性被修改了</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>[getter]：获取属性时会执行的函数，监听获取属性值的事件</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;name属性被修改了&quot;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;name属性被获取了&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&quot;12212&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> name = obj.<span class=\"property\">name</span>; <span class=\"comment\">// name属性被获取了</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-多个属性的描述符\"><a href=\"#3-多个属性的描述符\" class=\"headerlink\" title=\"3. 多个属性的描述符\"></a>3. 多个属性的描述符</h1><p><code>Object.deineProperties()</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperties</span>(对象名称,&#123;</span><br><span class=\"line\">\t要设置的属性名</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t属性描述符</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-对象-方法的补充\"><a href=\"#4-对象-方法的补充\" class=\"headerlink\" title=\"4. 对象 方法的补充\"></a>4. 对象 方法的补充</h1><ul>\n<li>getOwnPropertyDescriptor:获取某个属性的默认属性描述符。</li>\n<li>getOwnPropertyDescriptors:获取某个对象所有属性的默认属性值</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptor</span>(对象名，属性名)</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptors</span>(对象名)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>阻止对象的扩展（严格模式下报错）</li>\n</ul>\n<p>preventExtensions()</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript对象的增强知识\"><a href=\"#JavaScript对象的增强知识\" class=\"headerlink\" title=\"JavaScript对象的增强知识\"></a>JavaScript对象的增强知识</h1><ol>\n<li>Object.defineProperty</li>\n<li>数据属性描述符</li>\n<li>存取属性描述符</li>\n<li>Object.defineProperties</li>\n<li>对象的其他方法补充</li>\n</ol>\n<h1 id=\"1-对象属性的控制\"><a href=\"#1-对象属性的控制\" class=\"headerlink\" title=\"1. 对象属性的控制\"></a>1. 对象属性的控制</h1><p>针对对象某一个对象，我们可以对里面的一些属性进行查看修改。</p>\n<p>我们可以通过某种方式对这些行为进行限制。</p>\n<h2 id=\"1-1-对属性操作的控制\"><a href=\"#1-1-对属性操作的控制\" class=\"headerlink\" title=\"1.1 对属性操作的控制\"></a>1.1 对属性操作的控制</h2><p>默认情况下，对对象某一个属性操作是没有限制的。</p>\n<p>如果我们香香对一个属性进行比较精准的操作控制，我们可以使用属性描述符。</p>\n<ul>\n<li>通过属性描述符可以精准的添加或者修改对象的属性</li>\n<li>属性描述符需要使用Object.defineProperty来对属性进行修改或者添加</li>\n</ul>\n<h1 id=\"2-Object-defineProperty\"><a href=\"#2-Object-defineProperty\" class=\"headerlink\" title=\"2 Object.defineProperty\"></a>2 Object.defineProperty</h1><ul>\n<li>Object.defineProperty()方法直接在对象上定义一个新属性，或者修改一个对象的现有属性，并且返回该对象。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(要操作的对象,要修改的属性(名称或者<span class=\"title class_\">Symbol</span>),属性描述符)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-1-属性描述符分类\"><a href=\"#2-1-属性描述符分类\" class=\"headerlink\" title=\"2.1 属性描述符分类\"></a>2.1 属性描述符分类</h2><ul>\n<li>数据属性</li>\n<li>存取属性</li>\n</ul>\n<p>数据属性描述符有以下特征：</p>\n<ol>\n<li>[Configurable]：表示属性是否可以通过delete删除属性，是否可以修改它的特性，或者是否可以将它次该为存取属性描述符。</li>\n</ol>\n<p>直接在对象上定义一个属性，[Configurable]默认情况下为<code>true</code></p>\n<p>通过属性描述符定一个一个属性时，[Configurable]默认为<code>false</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span>, <span class=\"comment\">// 不可以配置该属性</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>[Enumerable]:表示属性是否可以通过for in或者Object.keys()返回该属性</li>\n</ol>\n<p>直接在对象上定义一个属性，[Configurable]默认情况下为<code>true</code></p>\n<p>通过属性描述符定一个一个属性时，[Configurable]默认为<code>false</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可枚举</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>[writeable]：表示是否可以修改属性的值</li>\n</ol>\n<p>直接在对象上定义一个属性，[Configurable]默认情况下为<code>true</code></p>\n<p>通过属性描述符定一个一个属性时，[Configurable]默认为<code>false</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可枚举</span></span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可以写入</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li></li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可枚举</span></span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 可以写入</span></span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"string\">&#x27;qweqwe&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>存取属性描述符： </p>\n<ol>\n<li>[setter]：设置属性时会执行的函数，监听设置属性修改赋值的事件</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;name属性被修改了&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&quot;12212&quot;</span>; <span class=\"comment\">// name属性被修改了</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>[getter]：获取属性时会执行的函数，监听获取属性值的事件</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&quot;name&quot;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;name属性被修改了&quot;</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;name属性被获取了&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&quot;12212&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> name = obj.<span class=\"property\">name</span>; <span class=\"comment\">// name属性被获取了</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-多个属性的描述符\"><a href=\"#3-多个属性的描述符\" class=\"headerlink\" title=\"3. 多个属性的描述符\"></a>3. 多个属性的描述符</h1><p><code>Object.deineProperties()</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperties</span>(对象名称,&#123;</span><br><span class=\"line\">\t要设置的属性名</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t属性描述符</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-对象-方法的补充\"><a href=\"#4-对象-方法的补充\" class=\"headerlink\" title=\"4. 对象 方法的补充\"></a>4. 对象 方法的补充</h1><ul>\n<li>getOwnPropertyDescriptor:获取某个属性的默认属性描述符。</li>\n<li>getOwnPropertyDescriptors:获取某个对象所有属性的默认属性值</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptor</span>(对象名，属性名)</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptors</span>(对象名)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>阻止对象的扩展（严格模式下报错）</li>\n</ul>\n<p>preventExtensions()</p>\n"},{"title":"JS中的回调函数","date":"2022-10-03T16:00:00.000Z","_content":"# 你真的知道回调函数吗？\n\n在JavaScript中，回调函数是非常重要的概念，但是对于初学者来说，理解回调函数比较困难，本文将会带你了解回调函数。\n\n## 什么是回调函数？\n\n简单来说：一个被当做参数的函数，就叫做回调函数。\n\n在JavaScript中，所有的函数都是对象，所以函数也可以作为参数传递给另一个函数。\n\n在MDN的解释中是这样吗说的：被作为一种实参传入另一个函数中，并且在该外部函数内被调用，来完成某些任务，这样的函数就是回调函数。\n\n在MDN的定义中，有以下几点可能比较难以理解：\n\n1. 什么是实参\n2. 在该外部函数内调用是什么意思\n\n接下来我将解释这两点问题\n\n### 什么是实参\n\n在JavaScript函数中，我们定义函数时括号里面的那几个参数就叫做形参，而我们调用函数时，所传入的参数就叫做实参。\n\n```js\n    function add(a, b) { **\n      return a + b;\n    }\n\n    add(1, 2); // 3\n```\n\n这段代码中的`a`,`b`就是形参，在`**`这一行，此时的`a`,`b`没有实际的值，它存在的意义就是定义变量，将调用函数时传入的参数带入函数内部运算。\n\n当我们调用函数时，传入的参数就是实参，实参的值会被赋值给形参，然后在函数内部运算。\n\n### 在该外部函数内调用是什么意思\n\n我们假设回调函数为`A`,调用回调函数的函数为`B`，此时A作为参数传入B,那么B相对于A就是一个外部函数，然后A函数作为参数传入B之后，完成自己的任务后结束。这就是回调函数的使命。\n\n## 回调函数有什么作用\n\n在js中有很多第三方函数，可以帮助我们快速完成任务，但是很多第三方函数我们却不能随意更改他们的内部实现代码，比如`forEach`,但是有了回调函数，我们就可以将自己写的函数，作为实参传入第三方函数，从而达到改变或者增加第三方函数功能的目的。\n\n## 回调函数的使用\n\n### 举个例子\n\n```js\n    setTimeout(function() {\n      console.log('hello world');\n    }, 1000);\n```\n\n上面代码中，我们直接将回调函数写在了`setTimeout`函数的参数中，这样就可以在`setTimeout`函数内部调用回调函数了。\n\n## 总结\n\n回调函数就是作为实参传入一个函数，并在被传入的这个函数里面实现自己函数的功能。","source":"_posts/JavaScript/Js中的回调函数.md","raw":"---\ntitle: JS中的回调函数\ndate: 2022-10-4\ntags: [前端]\ncategories: [JavaScript]\n---\n# 你真的知道回调函数吗？\n\n在JavaScript中，回调函数是非常重要的概念，但是对于初学者来说，理解回调函数比较困难，本文将会带你了解回调函数。\n\n## 什么是回调函数？\n\n简单来说：一个被当做参数的函数，就叫做回调函数。\n\n在JavaScript中，所有的函数都是对象，所以函数也可以作为参数传递给另一个函数。\n\n在MDN的解释中是这样吗说的：被作为一种实参传入另一个函数中，并且在该外部函数内被调用，来完成某些任务，这样的函数就是回调函数。\n\n在MDN的定义中，有以下几点可能比较难以理解：\n\n1. 什么是实参\n2. 在该外部函数内调用是什么意思\n\n接下来我将解释这两点问题\n\n### 什么是实参\n\n在JavaScript函数中，我们定义函数时括号里面的那几个参数就叫做形参，而我们调用函数时，所传入的参数就叫做实参。\n\n```js\n    function add(a, b) { **\n      return a + b;\n    }\n\n    add(1, 2); // 3\n```\n\n这段代码中的`a`,`b`就是形参，在`**`这一行，此时的`a`,`b`没有实际的值，它存在的意义就是定义变量，将调用函数时传入的参数带入函数内部运算。\n\n当我们调用函数时，传入的参数就是实参，实参的值会被赋值给形参，然后在函数内部运算。\n\n### 在该外部函数内调用是什么意思\n\n我们假设回调函数为`A`,调用回调函数的函数为`B`，此时A作为参数传入B,那么B相对于A就是一个外部函数，然后A函数作为参数传入B之后，完成自己的任务后结束。这就是回调函数的使命。\n\n## 回调函数有什么作用\n\n在js中有很多第三方函数，可以帮助我们快速完成任务，但是很多第三方函数我们却不能随意更改他们的内部实现代码，比如`forEach`,但是有了回调函数，我们就可以将自己写的函数，作为实参传入第三方函数，从而达到改变或者增加第三方函数功能的目的。\n\n## 回调函数的使用\n\n### 举个例子\n\n```js\n    setTimeout(function() {\n      console.log('hello world');\n    }, 1000);\n```\n\n上面代码中，我们直接将回调函数写在了`setTimeout`函数的参数中，这样就可以在`setTimeout`函数内部调用回调函数了。\n\n## 总结\n\n回调函数就是作为实参传入一个函数，并在被传入的这个函数里面实现自己函数的功能。","slug":"JavaScript/Js中的回调函数","published":1,"updated":"2023-01-09T12:18:44.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmid004h9kbm3zcx5zvy","content":"<h1 id=\"你真的知道回调函数吗？\"><a href=\"#你真的知道回调函数吗？\" class=\"headerlink\" title=\"你真的知道回调函数吗？\"></a>你真的知道回调函数吗？</h1><p>在JavaScript中，回调函数是非常重要的概念，但是对于初学者来说，理解回调函数比较困难，本文将会带你了解回调函数。</p>\n<h2 id=\"什么是回调函数？\"><a href=\"#什么是回调函数？\" class=\"headerlink\" title=\"什么是回调函数？\"></a>什么是回调函数？</h2><p>简单来说：一个被当做参数的函数，就叫做回调函数。</p>\n<p>在JavaScript中，所有的函数都是对象，所以函数也可以作为参数传递给另一个函数。</p>\n<p>在MDN的解释中是这样吗说的：被作为一种实参传入另一个函数中，并且在该外部函数内被调用，来完成某些任务，这样的函数就是回调函数。</p>\n<p>在MDN的定义中，有以下几点可能比较难以理解：</p>\n<ol>\n<li>什么是实参</li>\n<li>在该外部函数内调用是什么意思</li>\n</ol>\n<p>接下来我将解释这两点问题</p>\n<h3 id=\"什么是实参\"><a href=\"#什么是实参\" class=\"headerlink\" title=\"什么是实参\"></a>什么是实参</h3><p>在JavaScript函数中，我们定义函数时括号里面的那几个参数就叫做形参，而我们调用函数时，所传入的参数就叫做实参。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>) &#123; **</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码中的<code>a</code>,<code>b</code>就是形参，在<code>**</code>这一行，此时的<code>a</code>,<code>b</code>没有实际的值，它存在的意义就是定义变量，将调用函数时传入的参数带入函数内部运算。</p>\n<p>当我们调用函数时，传入的参数就是实参，实参的值会被赋值给形参，然后在函数内部运算。</p>\n<h3 id=\"在该外部函数内调用是什么意思\"><a href=\"#在该外部函数内调用是什么意思\" class=\"headerlink\" title=\"在该外部函数内调用是什么意思\"></a>在该外部函数内调用是什么意思</h3><p>我们假设回调函数为<code>A</code>,调用回调函数的函数为<code>B</code>，此时A作为参数传入B,那么B相对于A就是一个外部函数，然后A函数作为参数传入B之后，完成自己的任务后结束。这就是回调函数的使命。</p>\n<h2 id=\"回调函数有什么作用\"><a href=\"#回调函数有什么作用\" class=\"headerlink\" title=\"回调函数有什么作用\"></a>回调函数有什么作用</h2><p>在js中有很多第三方函数，可以帮助我们快速完成任务，但是很多第三方函数我们却不能随意更改他们的内部实现代码，比如<code>forEach</code>,但是有了回调函数，我们就可以将自己写的函数，作为实参传入第三方函数，从而达到改变或者增加第三方函数功能的目的。</p>\n<h2 id=\"回调函数的使用\"><a href=\"#回调函数的使用\" class=\"headerlink\" title=\"回调函数的使用\"></a>回调函数的使用</h2><h3 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello world&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，我们直接将回调函数写在了<code>setTimeout</code>函数的参数中，这样就可以在<code>setTimeout</code>函数内部调用回调函数了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>回调函数就是作为实参传入一个函数，并在被传入的这个函数里面实现自己函数的功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"你真的知道回调函数吗？\"><a href=\"#你真的知道回调函数吗？\" class=\"headerlink\" title=\"你真的知道回调函数吗？\"></a>你真的知道回调函数吗？</h1><p>在JavaScript中，回调函数是非常重要的概念，但是对于初学者来说，理解回调函数比较困难，本文将会带你了解回调函数。</p>\n<h2 id=\"什么是回调函数？\"><a href=\"#什么是回调函数？\" class=\"headerlink\" title=\"什么是回调函数？\"></a>什么是回调函数？</h2><p>简单来说：一个被当做参数的函数，就叫做回调函数。</p>\n<p>在JavaScript中，所有的函数都是对象，所以函数也可以作为参数传递给另一个函数。</p>\n<p>在MDN的解释中是这样吗说的：被作为一种实参传入另一个函数中，并且在该外部函数内被调用，来完成某些任务，这样的函数就是回调函数。</p>\n<p>在MDN的定义中，有以下几点可能比较难以理解：</p>\n<ol>\n<li>什么是实参</li>\n<li>在该外部函数内调用是什么意思</li>\n</ol>\n<p>接下来我将解释这两点问题</p>\n<h3 id=\"什么是实参\"><a href=\"#什么是实参\" class=\"headerlink\" title=\"什么是实参\"></a>什么是实参</h3><p>在JavaScript函数中，我们定义函数时括号里面的那几个参数就叫做形参，而我们调用函数时，所传入的参数就叫做实参。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>) &#123; **</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码中的<code>a</code>,<code>b</code>就是形参，在<code>**</code>这一行，此时的<code>a</code>,<code>b</code>没有实际的值，它存在的意义就是定义变量，将调用函数时传入的参数带入函数内部运算。</p>\n<p>当我们调用函数时，传入的参数就是实参，实参的值会被赋值给形参，然后在函数内部运算。</p>\n<h3 id=\"在该外部函数内调用是什么意思\"><a href=\"#在该外部函数内调用是什么意思\" class=\"headerlink\" title=\"在该外部函数内调用是什么意思\"></a>在该外部函数内调用是什么意思</h3><p>我们假设回调函数为<code>A</code>,调用回调函数的函数为<code>B</code>，此时A作为参数传入B,那么B相对于A就是一个外部函数，然后A函数作为参数传入B之后，完成自己的任务后结束。这就是回调函数的使命。</p>\n<h2 id=\"回调函数有什么作用\"><a href=\"#回调函数有什么作用\" class=\"headerlink\" title=\"回调函数有什么作用\"></a>回调函数有什么作用</h2><p>在js中有很多第三方函数，可以帮助我们快速完成任务，但是很多第三方函数我们却不能随意更改他们的内部实现代码，比如<code>forEach</code>,但是有了回调函数，我们就可以将自己写的函数，作为实参传入第三方函数，从而达到改变或者增加第三方函数功能的目的。</p>\n<h2 id=\"回调函数的使用\"><a href=\"#回调函数的使用\" class=\"headerlink\" title=\"回调函数的使用\"></a>回调函数的使用</h2><h3 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello world&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，我们直接将回调函数写在了<code>setTimeout</code>函数的参数中，这样就可以在<code>setTimeout</code>函数内部调用回调函数了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>回调函数就是作为实参传入一个函数，并在被传入的这个函数里面实现自己函数的功能。</p>\n"},{"title":"MAP基础","date":"2022-10-11T16:00:00.000Z","_content":"# MAP基础\n\nmap不同于普通的对象，普通对象的键值对，键只能是数值、字符串或者符号，而map的键可以是任意类型的值，包括对象、函数、数组等。\n\n## 创建map\n\n- 使用Map构造函数\n\n    const map1 = new Map();\n\n我们可以在使用Map构造函数创建的时候，顺带进行初始化：\n\n    const map2 = new Map([\n      ['name', '张三'],\n      ['age', 18]\n    ]);\n\n## Map常见方法\n\n- set(key, value)设置键值对\n\n    map.set(key, value);\n\n在map初始化之后，我们使用`set`方法，可以往map中添加键值对。\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');// 添加了一个键值对\n\n- has(key)判断是否存在某个键\n\n    map.has(key);\n\n在实际开发中，我们有时候需要查询，map里面是否存在这样一个键，此时，我们就需要用到`has`方法：\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');\n    alert(m.has('name'));// true\n\n若是存在，返回`true`，否则返回`false`。\n\n- get(key)获取键值对\n\n在上面我们知道了如何查询一个元素在map中是否存在，那么，如果我们想要获取这个元素的值，我们就需要使用`get`方法：\n\n    map.get(key);\n\n`get`方法：如果存在，返回对应的值，否则返回`undefined`。\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');\n    alert(m.get('name'));// 获取到了键值对的值 海绵宝宝\n\n\n- delete(key)删除某个键值对\n\n    map.delete(key);\n\n前面我们知道了可以增加、查询、判断是否存在某个键，那么如何删除呢？使用`delete`方法。\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');\n    m.delete('name');// 删除name键值对\n    alert(m.has('name'));// false \n\n在删除之后，我们再次查询，发现已经不存在了。\n\n- clear()清空map\n\n    map.clear();\n\n若是我们想直接清空整个map，可以使用`clear`方法。\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');\n    m.clear();// 清空map\n    alert(m.has('name'));// false\n\n使用`clear`之后，这个map里面的所有内容将会被删除，我们再次查询，发现已经不存在了。\n\n## 如何选择\n\n前面我们说道，map和object的区别有在于键：\n\n- map的键可以是任意类型的值，而object的键只能是数值、字符串或者符号。\n\n那么在实际开发中，我们如何来选择呢?\n\n1. 内存\n\n在固定内存大小的情况下，map可以比object更好的存储数据（map可以多储存50%的键值对）。\n\n2. 查找\n\n两者差别不大，在键值对较少的情况下，object的速度也快一点，如果object的键是当做数组的索引一样使用的话，那么object的速度会更快。\n\n3. 插入\n\nmap比object稍微快一点，但是差别不大，如果是插入大量的键值对，那么map的速度会更快。\n\n4. 删除\n\n在大多数浏览器中，map的删除速度更快，如果涉及大量删除键值对的情况，那么毫无疑问map是首选。","source":"_posts/JavaScript/MAP基础.md","raw":"---\ntitle: MAP基础\ndate: 2022-10-12\ntags: [前端]\ncategories: [ES6]\n---\n# MAP基础\n\nmap不同于普通的对象，普通对象的键值对，键只能是数值、字符串或者符号，而map的键可以是任意类型的值，包括对象、函数、数组等。\n\n## 创建map\n\n- 使用Map构造函数\n\n    const map1 = new Map();\n\n我们可以在使用Map构造函数创建的时候，顺带进行初始化：\n\n    const map2 = new Map([\n      ['name', '张三'],\n      ['age', 18]\n    ]);\n\n## Map常见方法\n\n- set(key, value)设置键值对\n\n    map.set(key, value);\n\n在map初始化之后，我们使用`set`方法，可以往map中添加键值对。\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');// 添加了一个键值对\n\n- has(key)判断是否存在某个键\n\n    map.has(key);\n\n在实际开发中，我们有时候需要查询，map里面是否存在这样一个键，此时，我们就需要用到`has`方法：\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');\n    alert(m.has('name'));// true\n\n若是存在，返回`true`，否则返回`false`。\n\n- get(key)获取键值对\n\n在上面我们知道了如何查询一个元素在map中是否存在，那么，如果我们想要获取这个元素的值，我们就需要使用`get`方法：\n\n    map.get(key);\n\n`get`方法：如果存在，返回对应的值，否则返回`undefined`。\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');\n    alert(m.get('name'));// 获取到了键值对的值 海绵宝宝\n\n\n- delete(key)删除某个键值对\n\n    map.delete(key);\n\n前面我们知道了可以增加、查询、判断是否存在某个键，那么如何删除呢？使用`delete`方法。\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');\n    m.delete('name');// 删除name键值对\n    alert(m.has('name'));// false \n\n在删除之后，我们再次查询，发现已经不存在了。\n\n- clear()清空map\n\n    map.clear();\n\n若是我们想直接清空整个map，可以使用`clear`方法。\n\n    const m = new Map();\n    m.set('name', '海绵宝宝');\n    m.clear();// 清空map\n    alert(m.has('name'));// false\n\n使用`clear`之后，这个map里面的所有内容将会被删除，我们再次查询，发现已经不存在了。\n\n## 如何选择\n\n前面我们说道，map和object的区别有在于键：\n\n- map的键可以是任意类型的值，而object的键只能是数值、字符串或者符号。\n\n那么在实际开发中，我们如何来选择呢?\n\n1. 内存\n\n在固定内存大小的情况下，map可以比object更好的存储数据（map可以多储存50%的键值对）。\n\n2. 查找\n\n两者差别不大，在键值对较少的情况下，object的速度也快一点，如果object的键是当做数组的索引一样使用的话，那么object的速度会更快。\n\n3. 插入\n\nmap比object稍微快一点，但是差别不大，如果是插入大量的键值对，那么map的速度会更快。\n\n4. 删除\n\n在大多数浏览器中，map的删除速度更快，如果涉及大量删除键值对的情况，那么毫无疑问map是首选。","slug":"JavaScript/MAP基础","published":1,"updated":"2023-01-10T01:30:37.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmid004k9kbmeqdgd1dn","content":"<h1 id=\"MAP基础\"><a href=\"#MAP基础\" class=\"headerlink\" title=\"MAP基础\"></a>MAP基础</h1><p>map不同于普通的对象，普通对象的键值对，键只能是数值、字符串或者符号，而map的键可以是任意类型的值，包括对象、函数、数组等。</p>\n<h2 id=\"创建map\"><a href=\"#创建map\" class=\"headerlink\" title=\"创建map\"></a>创建map</h2><ul>\n<li><p>使用Map构造函数</p>\n<p>  const map1 &#x3D; new Map();</p>\n</li>\n</ul>\n<p>我们可以在使用Map构造函数创建的时候，顺带进行初始化：</p>\n<pre><code>const map2 = new Map([\n  [&#39;name&#39;, &#39;张三&#39;],\n  [&#39;age&#39;, 18]\n]);\n</code></pre>\n<h2 id=\"Map常见方法\"><a href=\"#Map常见方法\" class=\"headerlink\" title=\"Map常见方法\"></a>Map常见方法</h2><ul>\n<li><p>set(key, value)设置键值对</p>\n<p>  map.set(key, value);</p>\n</li>\n</ul>\n<p>在map初始化之后，我们使用<code>set</code>方法，可以往map中添加键值对。</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);// 添加了一个键值对\n</code></pre>\n<ul>\n<li><p>has(key)判断是否存在某个键</p>\n<p>  map.has(key);</p>\n</li>\n</ul>\n<p>在实际开发中，我们有时候需要查询，map里面是否存在这样一个键，此时，我们就需要用到<code>has</code>方法：</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);\nalert(m.has(&#39;name&#39;));// true\n</code></pre>\n<p>若是存在，返回<code>true</code>，否则返回<code>false</code>。</p>\n<ul>\n<li>get(key)获取键值对</li>\n</ul>\n<p>在上面我们知道了如何查询一个元素在map中是否存在，那么，如果我们想要获取这个元素的值，我们就需要使用<code>get</code>方法：</p>\n<pre><code>map.get(key);\n</code></pre>\n<p><code>get</code>方法：如果存在，返回对应的值，否则返回<code>undefined</code>。</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);\nalert(m.get(&#39;name&#39;));// 获取到了键值对的值 海绵宝宝\n</code></pre>\n<ul>\n<li><p>delete(key)删除某个键值对</p>\n<p>  map.delete(key);</p>\n</li>\n</ul>\n<p>前面我们知道了可以增加、查询、判断是否存在某个键，那么如何删除呢？使用<code>delete</code>方法。</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);\nm.delete(&#39;name&#39;);// 删除name键值对\nalert(m.has(&#39;name&#39;));// false \n</code></pre>\n<p>在删除之后，我们再次查询，发现已经不存在了。</p>\n<ul>\n<li><p>clear()清空map</p>\n<p>  map.clear();</p>\n</li>\n</ul>\n<p>若是我们想直接清空整个map，可以使用<code>clear</code>方法。</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);\nm.clear();// 清空map\nalert(m.has(&#39;name&#39;));// false\n</code></pre>\n<p>使用<code>clear</code>之后，这个map里面的所有内容将会被删除，我们再次查询，发现已经不存在了。</p>\n<h2 id=\"如何选择\"><a href=\"#如何选择\" class=\"headerlink\" title=\"如何选择\"></a>如何选择</h2><p>前面我们说道，map和object的区别有在于键：</p>\n<ul>\n<li>map的键可以是任意类型的值，而object的键只能是数值、字符串或者符号。</li>\n</ul>\n<p>那么在实际开发中，我们如何来选择呢?</p>\n<ol>\n<li>内存</li>\n</ol>\n<p>在固定内存大小的情况下，map可以比object更好的存储数据（map可以多储存50%的键值对）。</p>\n<ol start=\"2\">\n<li>查找</li>\n</ol>\n<p>两者差别不大，在键值对较少的情况下，object的速度也快一点，如果object的键是当做数组的索引一样使用的话，那么object的速度会更快。</p>\n<ol start=\"3\">\n<li>插入</li>\n</ol>\n<p>map比object稍微快一点，但是差别不大，如果是插入大量的键值对，那么map的速度会更快。</p>\n<ol start=\"4\">\n<li>删除</li>\n</ol>\n<p>在大多数浏览器中，map的删除速度更快，如果涉及大量删除键值对的情况，那么毫无疑问map是首选。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MAP基础\"><a href=\"#MAP基础\" class=\"headerlink\" title=\"MAP基础\"></a>MAP基础</h1><p>map不同于普通的对象，普通对象的键值对，键只能是数值、字符串或者符号，而map的键可以是任意类型的值，包括对象、函数、数组等。</p>\n<h2 id=\"创建map\"><a href=\"#创建map\" class=\"headerlink\" title=\"创建map\"></a>创建map</h2><ul>\n<li><p>使用Map构造函数</p>\n<p>  const map1 &#x3D; new Map();</p>\n</li>\n</ul>\n<p>我们可以在使用Map构造函数创建的时候，顺带进行初始化：</p>\n<pre><code>const map2 = new Map([\n  [&#39;name&#39;, &#39;张三&#39;],\n  [&#39;age&#39;, 18]\n]);\n</code></pre>\n<h2 id=\"Map常见方法\"><a href=\"#Map常见方法\" class=\"headerlink\" title=\"Map常见方法\"></a>Map常见方法</h2><ul>\n<li><p>set(key, value)设置键值对</p>\n<p>  map.set(key, value);</p>\n</li>\n</ul>\n<p>在map初始化之后，我们使用<code>set</code>方法，可以往map中添加键值对。</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);// 添加了一个键值对\n</code></pre>\n<ul>\n<li><p>has(key)判断是否存在某个键</p>\n<p>  map.has(key);</p>\n</li>\n</ul>\n<p>在实际开发中，我们有时候需要查询，map里面是否存在这样一个键，此时，我们就需要用到<code>has</code>方法：</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);\nalert(m.has(&#39;name&#39;));// true\n</code></pre>\n<p>若是存在，返回<code>true</code>，否则返回<code>false</code>。</p>\n<ul>\n<li>get(key)获取键值对</li>\n</ul>\n<p>在上面我们知道了如何查询一个元素在map中是否存在，那么，如果我们想要获取这个元素的值，我们就需要使用<code>get</code>方法：</p>\n<pre><code>map.get(key);\n</code></pre>\n<p><code>get</code>方法：如果存在，返回对应的值，否则返回<code>undefined</code>。</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);\nalert(m.get(&#39;name&#39;));// 获取到了键值对的值 海绵宝宝\n</code></pre>\n<ul>\n<li><p>delete(key)删除某个键值对</p>\n<p>  map.delete(key);</p>\n</li>\n</ul>\n<p>前面我们知道了可以增加、查询、判断是否存在某个键，那么如何删除呢？使用<code>delete</code>方法。</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);\nm.delete(&#39;name&#39;);// 删除name键值对\nalert(m.has(&#39;name&#39;));// false \n</code></pre>\n<p>在删除之后，我们再次查询，发现已经不存在了。</p>\n<ul>\n<li><p>clear()清空map</p>\n<p>  map.clear();</p>\n</li>\n</ul>\n<p>若是我们想直接清空整个map，可以使用<code>clear</code>方法。</p>\n<pre><code>const m = new Map();\nm.set(&#39;name&#39;, &#39;海绵宝宝&#39;);\nm.clear();// 清空map\nalert(m.has(&#39;name&#39;));// false\n</code></pre>\n<p>使用<code>clear</code>之后，这个map里面的所有内容将会被删除，我们再次查询，发现已经不存在了。</p>\n<h2 id=\"如何选择\"><a href=\"#如何选择\" class=\"headerlink\" title=\"如何选择\"></a>如何选择</h2><p>前面我们说道，map和object的区别有在于键：</p>\n<ul>\n<li>map的键可以是任意类型的值，而object的键只能是数值、字符串或者符号。</li>\n</ul>\n<p>那么在实际开发中，我们如何来选择呢?</p>\n<ol>\n<li>内存</li>\n</ol>\n<p>在固定内存大小的情况下，map可以比object更好的存储数据（map可以多储存50%的键值对）。</p>\n<ol start=\"2\">\n<li>查找</li>\n</ol>\n<p>两者差别不大，在键值对较少的情况下，object的速度也快一点，如果object的键是当做数组的索引一样使用的话，那么object的速度会更快。</p>\n<ol start=\"3\">\n<li>插入</li>\n</ol>\n<p>map比object稍微快一点，但是差别不大，如果是插入大量的键值对，那么map的速度会更快。</p>\n<ol start=\"4\">\n<li>删除</li>\n</ol>\n<p>在大多数浏览器中，map的删除速度更快，如果涉及大量删除键值对的情况，那么毫无疑问map是首选。</p>\n"},{"title":"MATH常用方法","date":"2022-09-27T16:00:00.000Z","_content":"# MATH常用方法\n\n我们知道在js中有很多的内置对象，使用这些对象可以极大的提高我们的工作效率。\n\n这里我们讲讲在实际开发中用的比较多的Math对象。\n\n## Math对象\n\n`math`对象与其他的对象不同，他不是一个构造函数，不需要创建对象，所以我们就不需要使用`new`关键字来创建对象，我们可以直接使用里面的属性和方法。\n\n下面列出一些常用的属性方法：\n|     方法      |                    描述                    |     备注     |\n| :-----------: | :----------------------------------------: | :----------: |\n|    Math,PI    |                   圆周率                   | Math对象属性 |\n|  Math.abs()   |                 返回绝对值                 |              |\n| Math.random() |          生成0-1之间的随机浮点数           |    [0,1)     |\n| Math.floor()  |                  向下取整                  |              |\n|  Math.ceil()  |                  向上取整                  |              |\n| Math.round()  | 四舍五入（正数：四舍五入；负数：五舍六入） |              |\n|  Math.max()   |             返回多个数中最大值             |              |\n|  Math.min()   |             返回多个数中最小值             |              |\n| Math.pow(x,y) |                返回x的y次幂                |              |\n|  Math.sqrt()  |                  开方运算                  |              |\n\n下面我们进行详细介绍：\n\n## Math.PI\n\n    var pi = Math.PI;\n    console.log(pi);// 3.141592653589793\n\n这个属性直接返回圆周率，我们可以直接使用。\n\n## Math.abs()\n\n    var num = -10;\n    console.log(Math.abs(num));// 10\n\n这个属性传入一个参数，并且返回这个参数的绝对值。\n\n## Math.random()\n\n    var num = Math.random();\n\n这个属性返回一个0-1之间的随机浮点数，不包括1。\n\n*生成[0,x)之间的随机数：*\n\n    Math.round(Math.random()*x);\n\n*生成[x,y)之间的随机数：*\n\n    Math.random()*(y-x)+x;\n\n**重要应用：**\n\n生成指定范围[x,y]内的随机整数：\n\n    function getRandom(min,max){\n        return Math.floor(Math.random()*(max-min+1)+min);\n    }\n\n    console.log(getRandom(1,10));// 1-10之间的随机整数\n\n## Math.floor & Math.ceil()\n\n    let value1 = Math.floor(x);//向下取整\n    let value2 = Math.ceil(x);// 向上取整\n\n当我们需要对某个数值取整的时候，我们可以通过这两个方法来决定是向上还是向下取整。\n\n    let down = Math.floor(3.5);\n    let up = Math.ceil(3.5);\n    console.log(down);// 3\n    console.log(up);// 4\n\n## Math.max() & Math.min()\n\n在实际开发中，我们有时候需要获取多个值之间的最大值或者最小值。\n\n如果没有这个方法，我们需要一个一个去比较，有个这个方法之后，我们直接调用这个方法，传入我们的参数就可以直接返回我们想要的值。\n\n    Math.max(x,y,z...);// 返回最大值\n    Math.min(x,y,z...);// 返回最小值\n\n**注意：**\n\n这里传入的参数只能是数值形式，若是其他形式，比如数组之类的，我们要先将其转换。\n\n## pow()\n\n    Math.pow(a,b);\n\n最后返回的结果是`a的b次方`\n\n*栗子：*\n\n    let a = Math.pow(2,3);\n    console.log(a);// 8\n\n## sqrt()\n\n    Math.sqrt(a);\n\n返回的结果为a的开二次方。\n\n*栗子：*\n\n    var a = Math.sqrt(4);\n    console.log(a);// 2","source":"_posts/JavaScript/MATH常用方法.md","raw":"---\ntitle: MATH常用方法\ndate: 2022-9-28\ntags: [前端]\ncategories: [JavaScript]\n---\n# MATH常用方法\n\n我们知道在js中有很多的内置对象，使用这些对象可以极大的提高我们的工作效率。\n\n这里我们讲讲在实际开发中用的比较多的Math对象。\n\n## Math对象\n\n`math`对象与其他的对象不同，他不是一个构造函数，不需要创建对象，所以我们就不需要使用`new`关键字来创建对象，我们可以直接使用里面的属性和方法。\n\n下面列出一些常用的属性方法：\n|     方法      |                    描述                    |     备注     |\n| :-----------: | :----------------------------------------: | :----------: |\n|    Math,PI    |                   圆周率                   | Math对象属性 |\n|  Math.abs()   |                 返回绝对值                 |              |\n| Math.random() |          生成0-1之间的随机浮点数           |    [0,1)     |\n| Math.floor()  |                  向下取整                  |              |\n|  Math.ceil()  |                  向上取整                  |              |\n| Math.round()  | 四舍五入（正数：四舍五入；负数：五舍六入） |              |\n|  Math.max()   |             返回多个数中最大值             |              |\n|  Math.min()   |             返回多个数中最小值             |              |\n| Math.pow(x,y) |                返回x的y次幂                |              |\n|  Math.sqrt()  |                  开方运算                  |              |\n\n下面我们进行详细介绍：\n\n## Math.PI\n\n    var pi = Math.PI;\n    console.log(pi);// 3.141592653589793\n\n这个属性直接返回圆周率，我们可以直接使用。\n\n## Math.abs()\n\n    var num = -10;\n    console.log(Math.abs(num));// 10\n\n这个属性传入一个参数，并且返回这个参数的绝对值。\n\n## Math.random()\n\n    var num = Math.random();\n\n这个属性返回一个0-1之间的随机浮点数，不包括1。\n\n*生成[0,x)之间的随机数：*\n\n    Math.round(Math.random()*x);\n\n*生成[x,y)之间的随机数：*\n\n    Math.random()*(y-x)+x;\n\n**重要应用：**\n\n生成指定范围[x,y]内的随机整数：\n\n    function getRandom(min,max){\n        return Math.floor(Math.random()*(max-min+1)+min);\n    }\n\n    console.log(getRandom(1,10));// 1-10之间的随机整数\n\n## Math.floor & Math.ceil()\n\n    let value1 = Math.floor(x);//向下取整\n    let value2 = Math.ceil(x);// 向上取整\n\n当我们需要对某个数值取整的时候，我们可以通过这两个方法来决定是向上还是向下取整。\n\n    let down = Math.floor(3.5);\n    let up = Math.ceil(3.5);\n    console.log(down);// 3\n    console.log(up);// 4\n\n## Math.max() & Math.min()\n\n在实际开发中，我们有时候需要获取多个值之间的最大值或者最小值。\n\n如果没有这个方法，我们需要一个一个去比较，有个这个方法之后，我们直接调用这个方法，传入我们的参数就可以直接返回我们想要的值。\n\n    Math.max(x,y,z...);// 返回最大值\n    Math.min(x,y,z...);// 返回最小值\n\n**注意：**\n\n这里传入的参数只能是数值形式，若是其他形式，比如数组之类的，我们要先将其转换。\n\n## pow()\n\n    Math.pow(a,b);\n\n最后返回的结果是`a的b次方`\n\n*栗子：*\n\n    let a = Math.pow(2,3);\n    console.log(a);// 8\n\n## sqrt()\n\n    Math.sqrt(a);\n\n返回的结果为a的开二次方。\n\n*栗子：*\n\n    var a = Math.sqrt(4);\n    console.log(a);// 2","slug":"JavaScript/MATH常用方法","published":1,"updated":"2023-01-10T02:12:34.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmie004n9kbm7fv323qy","content":"<h1 id=\"MATH常用方法\"><a href=\"#MATH常用方法\" class=\"headerlink\" title=\"MATH常用方法\"></a>MATH常用方法</h1><p>我们知道在js中有很多的内置对象，使用这些对象可以极大的提高我们的工作效率。</p>\n<p>这里我们讲讲在实际开发中用的比较多的Math对象。</p>\n<h2 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h2><p><code>math</code>对象与其他的对象不同，他不是一个构造函数，不需要创建对象，所以我们就不需要使用<code>new</code>关键字来创建对象，我们可以直接使用里面的属性和方法。</p>\n<p>下面列出一些常用的属性方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Math,PI</td>\n<td align=\"center\">圆周率</td>\n<td align=\"center\">Math对象属性</td>\n</tr>\n<tr>\n<td align=\"center\">Math.abs()</td>\n<td align=\"center\">返回绝对值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.random()</td>\n<td align=\"center\">生成0-1之间的随机浮点数</td>\n<td align=\"center\">[0,1)</td>\n</tr>\n<tr>\n<td align=\"center\">Math.floor()</td>\n<td align=\"center\">向下取整</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.ceil()</td>\n<td align=\"center\">向上取整</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.round()</td>\n<td align=\"center\">四舍五入（正数：四舍五入；负数：五舍六入）</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.max()</td>\n<td align=\"center\">返回多个数中最大值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.min()</td>\n<td align=\"center\">返回多个数中最小值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.pow(x,y)</td>\n<td align=\"center\">返回x的y次幂</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.sqrt()</td>\n<td align=\"center\">开方运算</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>下面我们进行详细介绍：</p>\n<h2 id=\"Math-PI\"><a href=\"#Math-PI\" class=\"headerlink\" title=\"Math.PI\"></a>Math.PI</h2><pre><code>var pi = Math.PI;\nconsole.log(pi);// 3.141592653589793\n</code></pre>\n<p>这个属性直接返回圆周率，我们可以直接使用。</p>\n<h2 id=\"Math-abs\"><a href=\"#Math-abs\" class=\"headerlink\" title=\"Math.abs()\"></a>Math.abs()</h2><pre><code>var num = -10;\nconsole.log(Math.abs(num));// 10\n</code></pre>\n<p>这个属性传入一个参数，并且返回这个参数的绝对值。</p>\n<h2 id=\"Math-random\"><a href=\"#Math-random\" class=\"headerlink\" title=\"Math.random()\"></a>Math.random()</h2><pre><code>var num = Math.random();\n</code></pre>\n<p>这个属性返回一个0-1之间的随机浮点数，不包括1。</p>\n<p><em>生成[0,x)之间的随机数：</em></p>\n<pre><code>Math.round(Math.random()*x);\n</code></pre>\n<p><em>生成[x,y)之间的随机数：</em></p>\n<pre><code>Math.random()*(y-x)+x;\n</code></pre>\n<p><strong>重要应用：</strong></p>\n<p>生成指定范围[x,y]内的随机整数：</p>\n<pre><code>function getRandom(min,max)&#123;\n    return Math.floor(Math.random()*(max-min+1)+min);\n&#125;\n\nconsole.log(getRandom(1,10));// 1-10之间的随机整数\n</code></pre>\n<h2 id=\"Math-floor-amp-Math-ceil\"><a href=\"#Math-floor-amp-Math-ceil\" class=\"headerlink\" title=\"Math.floor &amp; Math.ceil()\"></a>Math.floor &amp; Math.ceil()</h2><pre><code>let value1 = Math.floor(x);//向下取整\nlet value2 = Math.ceil(x);// 向上取整\n</code></pre>\n<p>当我们需要对某个数值取整的时候，我们可以通过这两个方法来决定是向上还是向下取整。</p>\n<pre><code>let down = Math.floor(3.5);\nlet up = Math.ceil(3.5);\nconsole.log(down);// 3\nconsole.log(up);// 4\n</code></pre>\n<h2 id=\"Math-max-amp-Math-min\"><a href=\"#Math-max-amp-Math-min\" class=\"headerlink\" title=\"Math.max() &amp; Math.min()\"></a>Math.max() &amp; Math.min()</h2><p>在实际开发中，我们有时候需要获取多个值之间的最大值或者最小值。</p>\n<p>如果没有这个方法，我们需要一个一个去比较，有个这个方法之后，我们直接调用这个方法，传入我们的参数就可以直接返回我们想要的值。</p>\n<pre><code>Math.max(x,y,z...);// 返回最大值\nMath.min(x,y,z...);// 返回最小值\n</code></pre>\n<p><strong>注意：</strong></p>\n<p>这里传入的参数只能是数值形式，若是其他形式，比如数组之类的，我们要先将其转换。</p>\n<h2 id=\"pow\"><a href=\"#pow\" class=\"headerlink\" title=\"pow()\"></a>pow()</h2><pre><code>Math.pow(a,b);\n</code></pre>\n<p>最后返回的结果是<code>a的b次方</code></p>\n<p><em>栗子：</em></p>\n<pre><code>let a = Math.pow(2,3);\nconsole.log(a);// 8\n</code></pre>\n<h2 id=\"sqrt\"><a href=\"#sqrt\" class=\"headerlink\" title=\"sqrt()\"></a>sqrt()</h2><pre><code>Math.sqrt(a);\n</code></pre>\n<p>返回的结果为a的开二次方。</p>\n<p><em>栗子：</em></p>\n<pre><code>var a = Math.sqrt(4);\nconsole.log(a);// 2\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MATH常用方法\"><a href=\"#MATH常用方法\" class=\"headerlink\" title=\"MATH常用方法\"></a>MATH常用方法</h1><p>我们知道在js中有很多的内置对象，使用这些对象可以极大的提高我们的工作效率。</p>\n<p>这里我们讲讲在实际开发中用的比较多的Math对象。</p>\n<h2 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h2><p><code>math</code>对象与其他的对象不同，他不是一个构造函数，不需要创建对象，所以我们就不需要使用<code>new</code>关键字来创建对象，我们可以直接使用里面的属性和方法。</p>\n<p>下面列出一些常用的属性方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">描述</th>\n<th align=\"center\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Math,PI</td>\n<td align=\"center\">圆周率</td>\n<td align=\"center\">Math对象属性</td>\n</tr>\n<tr>\n<td align=\"center\">Math.abs()</td>\n<td align=\"center\">返回绝对值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.random()</td>\n<td align=\"center\">生成0-1之间的随机浮点数</td>\n<td align=\"center\">[0,1)</td>\n</tr>\n<tr>\n<td align=\"center\">Math.floor()</td>\n<td align=\"center\">向下取整</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.ceil()</td>\n<td align=\"center\">向上取整</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.round()</td>\n<td align=\"center\">四舍五入（正数：四舍五入；负数：五舍六入）</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.max()</td>\n<td align=\"center\">返回多个数中最大值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.min()</td>\n<td align=\"center\">返回多个数中最小值</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.pow(x,y)</td>\n<td align=\"center\">返回x的y次幂</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">Math.sqrt()</td>\n<td align=\"center\">开方运算</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>下面我们进行详细介绍：</p>\n<h2 id=\"Math-PI\"><a href=\"#Math-PI\" class=\"headerlink\" title=\"Math.PI\"></a>Math.PI</h2><pre><code>var pi = Math.PI;\nconsole.log(pi);// 3.141592653589793\n</code></pre>\n<p>这个属性直接返回圆周率，我们可以直接使用。</p>\n<h2 id=\"Math-abs\"><a href=\"#Math-abs\" class=\"headerlink\" title=\"Math.abs()\"></a>Math.abs()</h2><pre><code>var num = -10;\nconsole.log(Math.abs(num));// 10\n</code></pre>\n<p>这个属性传入一个参数，并且返回这个参数的绝对值。</p>\n<h2 id=\"Math-random\"><a href=\"#Math-random\" class=\"headerlink\" title=\"Math.random()\"></a>Math.random()</h2><pre><code>var num = Math.random();\n</code></pre>\n<p>这个属性返回一个0-1之间的随机浮点数，不包括1。</p>\n<p><em>生成[0,x)之间的随机数：</em></p>\n<pre><code>Math.round(Math.random()*x);\n</code></pre>\n<p><em>生成[x,y)之间的随机数：</em></p>\n<pre><code>Math.random()*(y-x)+x;\n</code></pre>\n<p><strong>重要应用：</strong></p>\n<p>生成指定范围[x,y]内的随机整数：</p>\n<pre><code>function getRandom(min,max)&#123;\n    return Math.floor(Math.random()*(max-min+1)+min);\n&#125;\n\nconsole.log(getRandom(1,10));// 1-10之间的随机整数\n</code></pre>\n<h2 id=\"Math-floor-amp-Math-ceil\"><a href=\"#Math-floor-amp-Math-ceil\" class=\"headerlink\" title=\"Math.floor &amp; Math.ceil()\"></a>Math.floor &amp; Math.ceil()</h2><pre><code>let value1 = Math.floor(x);//向下取整\nlet value2 = Math.ceil(x);// 向上取整\n</code></pre>\n<p>当我们需要对某个数值取整的时候，我们可以通过这两个方法来决定是向上还是向下取整。</p>\n<pre><code>let down = Math.floor(3.5);\nlet up = Math.ceil(3.5);\nconsole.log(down);// 3\nconsole.log(up);// 4\n</code></pre>\n<h2 id=\"Math-max-amp-Math-min\"><a href=\"#Math-max-amp-Math-min\" class=\"headerlink\" title=\"Math.max() &amp; Math.min()\"></a>Math.max() &amp; Math.min()</h2><p>在实际开发中，我们有时候需要获取多个值之间的最大值或者最小值。</p>\n<p>如果没有这个方法，我们需要一个一个去比较，有个这个方法之后，我们直接调用这个方法，传入我们的参数就可以直接返回我们想要的值。</p>\n<pre><code>Math.max(x,y,z...);// 返回最大值\nMath.min(x,y,z...);// 返回最小值\n</code></pre>\n<p><strong>注意：</strong></p>\n<p>这里传入的参数只能是数值形式，若是其他形式，比如数组之类的，我们要先将其转换。</p>\n<h2 id=\"pow\"><a href=\"#pow\" class=\"headerlink\" title=\"pow()\"></a>pow()</h2><pre><code>Math.pow(a,b);\n</code></pre>\n<p>最后返回的结果是<code>a的b次方</code></p>\n<p><em>栗子：</em></p>\n<pre><code>let a = Math.pow(2,3);\nconsole.log(a);// 8\n</code></pre>\n<h2 id=\"sqrt\"><a href=\"#sqrt\" class=\"headerlink\" title=\"sqrt()\"></a>sqrt()</h2><pre><code>Math.sqrt(a);\n</code></pre>\n<p>返回的结果为a的开二次方。</p>\n<p><em>栗子：</em></p>\n<pre><code>var a = Math.sqrt(4);\nconsole.log(a);// 2\n</code></pre>\n"},{"title":"EventEmitter类","date":"2022-12-15T16:00:00.000Z","_content":"# EventEmitter 类\n\n`eventEmitter`是`events`模块里面的一个对象，它的核心功能就是事件触发与事件监听器功能的封装。\n\n## 引入event模块\n\n代码：\n\n```js\n\tvar events = require('events');\n```\n\n我们通过`require`引入这个events模块之后，我们实例化一个`eventEmitter`对象\n\n```js\n\tvar eventEmitter = new events.EventEmitter();\n```\n\n这里注意：\n\n- 实例化对象使用`new`关键字\n- 后面的`EventEmitter`两个单词首字母都需要大写\n\n\n我们有了eventEmitter对象之后，就可以为指定的事件添加监听器了。\n\n在此之前，我们先定义两个监听器：\n\n```js\n\tvar listener1 = function(){\n\t\tconsole.log('我是第一个监听器');\n\t}\n\tvar listener2 = function(){\n\t\tconsole.log('我是第二个监听器');\n\t}\n```\n\n接下来就是为eventEmitter绑定监听器了。\n\n## 绑定监听器\n\n1. 使用`on`方法绑定：\n\t`eventEmitter.on('事件', 监听器);`\n\t使用`on`方法进行绑定的时候，可以多次使用从而绑定多个监听器，执行的时候按照绑定顺序进行执行。\n2. 使用`addListener`方法绑定：\n\t`eventEmitter.addListener('事件',监听器);`\n\t这个方法是将一个监听器添加到监听器数组的尾部。也就是将这个监听器添加到原来事件监听器数组的最后一个。\n3. 使用`once`方法绑定：\n\t`eventEmitter.once('事件',监听器);`\n\t看方法名字，我们就大致可以知道这个监听器只会执行一次，执行完毕之后就会解绑。\n\n### 栗子：\n\n```js\n\t// 默认事件名字为test\n\t\n\t// 方法一绑定监听器\n\teventEmitter.on('test',listener1);\n\teventEmitter.on('test',listener2);\n\t// 方法二绑定监听器\n\teventEmitter.addListener('test',listener1);\n\t// 方法三绑定监听器\n\teventEmitter.once('test',listener1);\n```\n\n上面我们使用了三种方式来绑定监听器，方法一中的监听器会按照绑定顺序执行；方法二中的监听器会最后一个执行，因为它位置事件监听器数组的最后一个，所以此时绑定的监听器会最后一个执行；方法绑定的监听器只会执行一次。\n\n## 解绑监听器\n\n前面我们知道了给事件绑定监听器，那么如何给事件解绑监听器呢？\n\n这里node.js为我们提供了两种方法：\n\n1. \t`removeListener(event, listener)`\n2. \t`removeAllListeners([event])`\n\n从名字我们就可以看出两个方法的不同，第一个只是移除指定事件上的指定监听器；第二则是移除指定事件上的所有监听器。\n\n### 栗子：\n\n```js\n\t// 方法一：\n\teventEmitter.removeListener('test',listener1);\n\t// 方法二：\n\teventEmitter.removeAllListener('test');\n```\n","source":"_posts/JavaScript/eventEmitter.md","raw":"---\ntitle: EventEmitter类\ndate: 2022-12-16\ntags: [前端]\ncategories: [node]\n---\n# EventEmitter 类\n\n`eventEmitter`是`events`模块里面的一个对象，它的核心功能就是事件触发与事件监听器功能的封装。\n\n## 引入event模块\n\n代码：\n\n```js\n\tvar events = require('events');\n```\n\n我们通过`require`引入这个events模块之后，我们实例化一个`eventEmitter`对象\n\n```js\n\tvar eventEmitter = new events.EventEmitter();\n```\n\n这里注意：\n\n- 实例化对象使用`new`关键字\n- 后面的`EventEmitter`两个单词首字母都需要大写\n\n\n我们有了eventEmitter对象之后，就可以为指定的事件添加监听器了。\n\n在此之前，我们先定义两个监听器：\n\n```js\n\tvar listener1 = function(){\n\t\tconsole.log('我是第一个监听器');\n\t}\n\tvar listener2 = function(){\n\t\tconsole.log('我是第二个监听器');\n\t}\n```\n\n接下来就是为eventEmitter绑定监听器了。\n\n## 绑定监听器\n\n1. 使用`on`方法绑定：\n\t`eventEmitter.on('事件', 监听器);`\n\t使用`on`方法进行绑定的时候，可以多次使用从而绑定多个监听器，执行的时候按照绑定顺序进行执行。\n2. 使用`addListener`方法绑定：\n\t`eventEmitter.addListener('事件',监听器);`\n\t这个方法是将一个监听器添加到监听器数组的尾部。也就是将这个监听器添加到原来事件监听器数组的最后一个。\n3. 使用`once`方法绑定：\n\t`eventEmitter.once('事件',监听器);`\n\t看方法名字，我们就大致可以知道这个监听器只会执行一次，执行完毕之后就会解绑。\n\n### 栗子：\n\n```js\n\t// 默认事件名字为test\n\t\n\t// 方法一绑定监听器\n\teventEmitter.on('test',listener1);\n\teventEmitter.on('test',listener2);\n\t// 方法二绑定监听器\n\teventEmitter.addListener('test',listener1);\n\t// 方法三绑定监听器\n\teventEmitter.once('test',listener1);\n```\n\n上面我们使用了三种方式来绑定监听器，方法一中的监听器会按照绑定顺序执行；方法二中的监听器会最后一个执行，因为它位置事件监听器数组的最后一个，所以此时绑定的监听器会最后一个执行；方法绑定的监听器只会执行一次。\n\n## 解绑监听器\n\n前面我们知道了给事件绑定监听器，那么如何给事件解绑监听器呢？\n\n这里node.js为我们提供了两种方法：\n\n1. \t`removeListener(event, listener)`\n2. \t`removeAllListeners([event])`\n\n从名字我们就可以看出两个方法的不同，第一个只是移除指定事件上的指定监听器；第二则是移除指定事件上的所有监听器。\n\n### 栗子：\n\n```js\n\t// 方法一：\n\teventEmitter.removeListener('test',listener1);\n\t// 方法二：\n\teventEmitter.removeAllListener('test');\n```\n","slug":"JavaScript/eventEmitter","published":1,"updated":"2023-01-10T02:21:58.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmif004q9kbmhmcbbbo3","content":"<h1 id=\"EventEmitter-类\"><a href=\"#EventEmitter-类\" class=\"headerlink\" title=\"EventEmitter 类\"></a>EventEmitter 类</h1><p><code>eventEmitter</code>是<code>events</code>模块里面的一个对象，它的核心功能就是事件触发与事件监听器功能的封装。</p>\n<h2 id=\"引入event模块\"><a href=\"#引入event模块\" class=\"headerlink\" title=\"引入event模块\"></a>引入event模块</h2><p>代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们通过<code>require</code>引入这个events模块之后，我们实例化一个<code>eventEmitter</code>对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eventEmitter = <span class=\"keyword\">new</span> events.<span class=\"title class_\">EventEmitter</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这里注意：</p>\n<ul>\n<li>实例化对象使用<code>new</code>关键字</li>\n<li>后面的<code>EventEmitter</code>两个单词首字母都需要大写</li>\n</ul>\n<p>我们有了eventEmitter对象之后，就可以为指定的事件添加监听器了。</p>\n<p>在此之前，我们先定义两个监听器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> listener1 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我是第一个监听器&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> listener2 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我是第二个监听器&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是为eventEmitter绑定监听器了。</p>\n<h2 id=\"绑定监听器\"><a href=\"#绑定监听器\" class=\"headerlink\" title=\"绑定监听器\"></a>绑定监听器</h2><ol>\n<li>使用<code>on</code>方法绑定：<br> <code>eventEmitter.on(&#39;事件&#39;, 监听器);</code><br> 使用<code>on</code>方法进行绑定的时候，可以多次使用从而绑定多个监听器，执行的时候按照绑定顺序进行执行。</li>\n<li>使用<code>addListener</code>方法绑定：<br> <code>eventEmitter.addListener(&#39;事件&#39;,监听器);</code><br> 这个方法是将一个监听器添加到监听器数组的尾部。也就是将这个监听器添加到原来事件监听器数组的最后一个。</li>\n<li>使用<code>once</code>方法绑定：<br> <code>eventEmitter.once(&#39;事件&#39;,监听器);</code><br> 看方法名字，我们就大致可以知道这个监听器只会执行一次，执行完毕之后就会解绑。</li>\n</ol>\n<h3 id=\"栗子：\"><a href=\"#栗子：\" class=\"headerlink\" title=\"栗子：\"></a>栗子：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认事件名字为test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法一绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener2);</span><br><span class=\"line\"><span class=\"comment\">// 方法二绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">addListener</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\"><span class=\"comment\">// 方法三绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">once</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br></pre></td></tr></table></figure>\n\n<p>上面我们使用了三种方式来绑定监听器，方法一中的监听器会按照绑定顺序执行；方法二中的监听器会最后一个执行，因为它位置事件监听器数组的最后一个，所以此时绑定的监听器会最后一个执行；方法绑定的监听器只会执行一次。</p>\n<h2 id=\"解绑监听器\"><a href=\"#解绑监听器\" class=\"headerlink\" title=\"解绑监听器\"></a>解绑监听器</h2><p>前面我们知道了给事件绑定监听器，那么如何给事件解绑监听器呢？</p>\n<p>这里node.js为我们提供了两种方法：</p>\n<ol>\n<li><pre><code>`removeListener(event, listener)`\n</code></pre>\n</li>\n<li><pre><code>`removeAllListeners([event])`\n</code></pre>\n</li>\n</ol>\n<p>从名字我们就可以看出两个方法的不同，第一个只是移除指定事件上的指定监听器；第二则是移除指定事件上的所有监听器。</p>\n<h3 id=\"栗子：-1\"><a href=\"#栗子：-1\" class=\"headerlink\" title=\"栗子：\"></a>栗子：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">removeListener</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\"><span class=\"comment\">// 方法二：</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">removeAllListener</span>(<span class=\"string\">&#x27;test&#x27;</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EventEmitter-类\"><a href=\"#EventEmitter-类\" class=\"headerlink\" title=\"EventEmitter 类\"></a>EventEmitter 类</h1><p><code>eventEmitter</code>是<code>events</code>模块里面的一个对象，它的核心功能就是事件触发与事件监听器功能的封装。</p>\n<h2 id=\"引入event模块\"><a href=\"#引入event模块\" class=\"headerlink\" title=\"引入event模块\"></a>引入event模块</h2><p>代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们通过<code>require</code>引入这个events模块之后，我们实例化一个<code>eventEmitter</code>对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eventEmitter = <span class=\"keyword\">new</span> events.<span class=\"title class_\">EventEmitter</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这里注意：</p>\n<ul>\n<li>实例化对象使用<code>new</code>关键字</li>\n<li>后面的<code>EventEmitter</code>两个单词首字母都需要大写</li>\n</ul>\n<p>我们有了eventEmitter对象之后，就可以为指定的事件添加监听器了。</p>\n<p>在此之前，我们先定义两个监听器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> listener1 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我是第一个监听器&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> listener2 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我是第二个监听器&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是为eventEmitter绑定监听器了。</p>\n<h2 id=\"绑定监听器\"><a href=\"#绑定监听器\" class=\"headerlink\" title=\"绑定监听器\"></a>绑定监听器</h2><ol>\n<li>使用<code>on</code>方法绑定：<br> <code>eventEmitter.on(&#39;事件&#39;, 监听器);</code><br> 使用<code>on</code>方法进行绑定的时候，可以多次使用从而绑定多个监听器，执行的时候按照绑定顺序进行执行。</li>\n<li>使用<code>addListener</code>方法绑定：<br> <code>eventEmitter.addListener(&#39;事件&#39;,监听器);</code><br> 这个方法是将一个监听器添加到监听器数组的尾部。也就是将这个监听器添加到原来事件监听器数组的最后一个。</li>\n<li>使用<code>once</code>方法绑定：<br> <code>eventEmitter.once(&#39;事件&#39;,监听器);</code><br> 看方法名字，我们就大致可以知道这个监听器只会执行一次，执行完毕之后就会解绑。</li>\n</ol>\n<h3 id=\"栗子：\"><a href=\"#栗子：\" class=\"headerlink\" title=\"栗子：\"></a>栗子：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认事件名字为test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法一绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener2);</span><br><span class=\"line\"><span class=\"comment\">// 方法二绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">addListener</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\"><span class=\"comment\">// 方法三绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">once</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br></pre></td></tr></table></figure>\n\n<p>上面我们使用了三种方式来绑定监听器，方法一中的监听器会按照绑定顺序执行；方法二中的监听器会最后一个执行，因为它位置事件监听器数组的最后一个，所以此时绑定的监听器会最后一个执行；方法绑定的监听器只会执行一次。</p>\n<h2 id=\"解绑监听器\"><a href=\"#解绑监听器\" class=\"headerlink\" title=\"解绑监听器\"></a>解绑监听器</h2><p>前面我们知道了给事件绑定监听器，那么如何给事件解绑监听器呢？</p>\n<p>这里node.js为我们提供了两种方法：</p>\n<ol>\n<li><pre><code>`removeListener(event, listener)`\n</code></pre>\n</li>\n<li><pre><code>`removeAllListeners([event])`\n</code></pre>\n</li>\n</ol>\n<p>从名字我们就可以看出两个方法的不同，第一个只是移除指定事件上的指定监听器；第二则是移除指定事件上的所有监听器。</p>\n<h3 id=\"栗子：-1\"><a href=\"#栗子：-1\" class=\"headerlink\" title=\"栗子：\"></a>栗子：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">removeListener</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\"><span class=\"comment\">// 方法二：</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">removeAllListener</span>(<span class=\"string\">&#x27;test&#x27;</span>);</span><br></pre></td></tr></table></figure>\n"},{"title":"new关键字","date":"2022-08-29T16:00:00.000Z","_content":"# new 关键字\n\n在JavaScript中使用构造函数的时候，我们就会用到`new`关键字。\n\n## 定义：\n\n`new`关键字是用来创建一个用户自定义的对象类型实例或者具有构造函数的内置对象的实例\n\n## js中的`new`做了什么？\n\n假设我们要创建一个`user`的新实例，这个时候我们需要使用`new`关键字，那我们以这种方式调用构造函数，会经历一下四个步骤：\n\n1. 创建一个新的对象。\n2. 将构造函数的作用域赋给新对象（所以`this`就指向了这个新的对象）。\n3. 执行构造函数中的代码（为我们这个新对象添加相应的属性）。这些属性就是构造函数里面的属性，我们通过这一步将构造函数的属性添加到新对象里面。\n4. 最后返回这个新对象。\n\n## 我们来看看`new`的例子\n\n    function Test(name) {\n        this.name = name\n    }\n    Test.prototype.sayName = function () {\n        console.log(this.name)\n    }\n    const newTest = new Test('海绵宝宝')\n    console.log(newTest.name) // '海绵宝宝'\n    newTest.sayName() // '海绵宝宝'\n\n在这个例子中，我们可以看到：\n\n- `new`关键字创建了一个新的对象。\n- 并且这个新对象可以访问到构造函数的属性。\n- 这个新对象还可以访问到构造函数的方法。\n- 也就是说，我们通过`new`操作符将构造函数与实例对象通过原型链链接起来了。\n\n但是上面那个例子，构造函数并没有返回任何值（默认返回undefined）,要是我们让他返回值，会发生什么情况呢？\n\n这个分为两种情况：\n\n1. 返回值为原始值。\n2. 返回值为对象。\n\n我们一种一种的来看\n\n首选我们看看返回值为原始值的时候：\n\n    function Test(name) {\n        this.name = name;\n        return '111';\n    }\n    const newTest = new Test('海绵宝宝');\n    console.log(newTest.name); // '海绵宝宝'\n\n上面这个例子，我们可以看到，即使我们最后返回了一个字符串，但是最后实例对象还是输出了构造函数里面的属性值。这说明这个原始值的返回类型没有任何用处。结果还是和没有返回值一样的。\n\n接下来我们看看返回值为对象的时候，会发生什么：\n\n    function Test(name) {\n        this.name = name\n        console.log(this)\n        return {\n            name: '蟹老板'\n        }\n    }\n    const Test1 = new Test('海绵宝宝')\n    console.log(Test1.name)  // '蟹老板'\n    console.log(Test1) // {name: '蟹老板'}\n\n通过这个例子我们知道，当构造函数里面将返回值设置为一个对象的时候，返回的对象会作为实例对象的属性。这个返回值将会被正常的使用。\n\n**总结：**\n\n构造函数尽量不要使用返回值，因为原始值的没有任何作用，返回对象的话会导致`new`操作符失效。","source":"_posts/JavaScript/new 关键字.md","raw":"---\ntitle: new关键字\ndate: 2022-8-30\ntags: [前端]\ncategories: [JavaScript]\n---\n# new 关键字\n\n在JavaScript中使用构造函数的时候，我们就会用到`new`关键字。\n\n## 定义：\n\n`new`关键字是用来创建一个用户自定义的对象类型实例或者具有构造函数的内置对象的实例\n\n## js中的`new`做了什么？\n\n假设我们要创建一个`user`的新实例，这个时候我们需要使用`new`关键字，那我们以这种方式调用构造函数，会经历一下四个步骤：\n\n1. 创建一个新的对象。\n2. 将构造函数的作用域赋给新对象（所以`this`就指向了这个新的对象）。\n3. 执行构造函数中的代码（为我们这个新对象添加相应的属性）。这些属性就是构造函数里面的属性，我们通过这一步将构造函数的属性添加到新对象里面。\n4. 最后返回这个新对象。\n\n## 我们来看看`new`的例子\n\n    function Test(name) {\n        this.name = name\n    }\n    Test.prototype.sayName = function () {\n        console.log(this.name)\n    }\n    const newTest = new Test('海绵宝宝')\n    console.log(newTest.name) // '海绵宝宝'\n    newTest.sayName() // '海绵宝宝'\n\n在这个例子中，我们可以看到：\n\n- `new`关键字创建了一个新的对象。\n- 并且这个新对象可以访问到构造函数的属性。\n- 这个新对象还可以访问到构造函数的方法。\n- 也就是说，我们通过`new`操作符将构造函数与实例对象通过原型链链接起来了。\n\n但是上面那个例子，构造函数并没有返回任何值（默认返回undefined）,要是我们让他返回值，会发生什么情况呢？\n\n这个分为两种情况：\n\n1. 返回值为原始值。\n2. 返回值为对象。\n\n我们一种一种的来看\n\n首选我们看看返回值为原始值的时候：\n\n    function Test(name) {\n        this.name = name;\n        return '111';\n    }\n    const newTest = new Test('海绵宝宝');\n    console.log(newTest.name); // '海绵宝宝'\n\n上面这个例子，我们可以看到，即使我们最后返回了一个字符串，但是最后实例对象还是输出了构造函数里面的属性值。这说明这个原始值的返回类型没有任何用处。结果还是和没有返回值一样的。\n\n接下来我们看看返回值为对象的时候，会发生什么：\n\n    function Test(name) {\n        this.name = name\n        console.log(this)\n        return {\n            name: '蟹老板'\n        }\n    }\n    const Test1 = new Test('海绵宝宝')\n    console.log(Test1.name)  // '蟹老板'\n    console.log(Test1) // {name: '蟹老板'}\n\n通过这个例子我们知道，当构造函数里面将返回值设置为一个对象的时候，返回的对象会作为实例对象的属性。这个返回值将会被正常的使用。\n\n**总结：**\n\n构造函数尽量不要使用返回值，因为原始值的没有任何作用，返回对象的话会导致`new`操作符失效。","slug":"JavaScript/new 关键字","published":1,"updated":"2023-01-10T02:13:17.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmig004t9kbm5hz20ar6","content":"<h1 id=\"new-关键字\"><a href=\"#new-关键字\" class=\"headerlink\" title=\"new 关键字\"></a>new 关键字</h1><p>在JavaScript中使用构造函数的时候，我们就会用到<code>new</code>关键字。</p>\n<h2 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h2><p><code>new</code>关键字是用来创建一个用户自定义的对象类型实例或者具有构造函数的内置对象的实例</p>\n<h2 id=\"js中的new做了什么？\"><a href=\"#js中的new做了什么？\" class=\"headerlink\" title=\"js中的new做了什么？\"></a>js中的<code>new</code>做了什么？</h2><p>假设我们要创建一个<code>user</code>的新实例，这个时候我们需要使用<code>new</code>关键字，那我们以这种方式调用构造函数，会经历一下四个步骤：</p>\n<ol>\n<li>创建一个新的对象。</li>\n<li>将构造函数的作用域赋给新对象（所以<code>this</code>就指向了这个新的对象）。</li>\n<li>执行构造函数中的代码（为我们这个新对象添加相应的属性）。这些属性就是构造函数里面的属性，我们通过这一步将构造函数的属性添加到新对象里面。</li>\n<li>最后返回这个新对象。</li>\n</ol>\n<h2 id=\"我们来看看new的例子\"><a href=\"#我们来看看new的例子\" class=\"headerlink\" title=\"我们来看看new的例子\"></a>我们来看看<code>new</code>的例子</h2><pre><code>function Test(name) &#123;\n    this.name = name\n&#125;\nTest.prototype.sayName = function () &#123;\n    console.log(this.name)\n&#125;\nconst newTest = new Test(&#39;海绵宝宝&#39;)\nconsole.log(newTest.name) // &#39;海绵宝宝&#39;\nnewTest.sayName() // &#39;海绵宝宝&#39;\n</code></pre>\n<p>在这个例子中，我们可以看到：</p>\n<ul>\n<li><code>new</code>关键字创建了一个新的对象。</li>\n<li>并且这个新对象可以访问到构造函数的属性。</li>\n<li>这个新对象还可以访问到构造函数的方法。</li>\n<li>也就是说，我们通过<code>new</code>操作符将构造函数与实例对象通过原型链链接起来了。</li>\n</ul>\n<p>但是上面那个例子，构造函数并没有返回任何值（默认返回undefined）,要是我们让他返回值，会发生什么情况呢？</p>\n<p>这个分为两种情况：</p>\n<ol>\n<li>返回值为原始值。</li>\n<li>返回值为对象。</li>\n</ol>\n<p>我们一种一种的来看</p>\n<p>首选我们看看返回值为原始值的时候：</p>\n<pre><code>function Test(name) &#123;\n    this.name = name;\n    return &#39;111&#39;;\n&#125;\nconst newTest = new Test(&#39;海绵宝宝&#39;);\nconsole.log(newTest.name); // &#39;海绵宝宝&#39;\n</code></pre>\n<p>上面这个例子，我们可以看到，即使我们最后返回了一个字符串，但是最后实例对象还是输出了构造函数里面的属性值。这说明这个原始值的返回类型没有任何用处。结果还是和没有返回值一样的。</p>\n<p>接下来我们看看返回值为对象的时候，会发生什么：</p>\n<pre><code>function Test(name) &#123;\n    this.name = name\n    console.log(this)\n    return &#123;\n        name: &#39;蟹老板&#39;\n    &#125;\n&#125;\nconst Test1 = new Test(&#39;海绵宝宝&#39;)\nconsole.log(Test1.name)  // &#39;蟹老板&#39;\nconsole.log(Test1) // &#123;name: &#39;蟹老板&#39;&#125;\n</code></pre>\n<p>通过这个例子我们知道，当构造函数里面将返回值设置为一个对象的时候，返回的对象会作为实例对象的属性。这个返回值将会被正常的使用。</p>\n<p><strong>总结：</strong></p>\n<p>构造函数尽量不要使用返回值，因为原始值的没有任何作用，返回对象的话会导致<code>new</code>操作符失效。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"new-关键字\"><a href=\"#new-关键字\" class=\"headerlink\" title=\"new 关键字\"></a>new 关键字</h1><p>在JavaScript中使用构造函数的时候，我们就会用到<code>new</code>关键字。</p>\n<h2 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h2><p><code>new</code>关键字是用来创建一个用户自定义的对象类型实例或者具有构造函数的内置对象的实例</p>\n<h2 id=\"js中的new做了什么？\"><a href=\"#js中的new做了什么？\" class=\"headerlink\" title=\"js中的new做了什么？\"></a>js中的<code>new</code>做了什么？</h2><p>假设我们要创建一个<code>user</code>的新实例，这个时候我们需要使用<code>new</code>关键字，那我们以这种方式调用构造函数，会经历一下四个步骤：</p>\n<ol>\n<li>创建一个新的对象。</li>\n<li>将构造函数的作用域赋给新对象（所以<code>this</code>就指向了这个新的对象）。</li>\n<li>执行构造函数中的代码（为我们这个新对象添加相应的属性）。这些属性就是构造函数里面的属性，我们通过这一步将构造函数的属性添加到新对象里面。</li>\n<li>最后返回这个新对象。</li>\n</ol>\n<h2 id=\"我们来看看new的例子\"><a href=\"#我们来看看new的例子\" class=\"headerlink\" title=\"我们来看看new的例子\"></a>我们来看看<code>new</code>的例子</h2><pre><code>function Test(name) &#123;\n    this.name = name\n&#125;\nTest.prototype.sayName = function () &#123;\n    console.log(this.name)\n&#125;\nconst newTest = new Test(&#39;海绵宝宝&#39;)\nconsole.log(newTest.name) // &#39;海绵宝宝&#39;\nnewTest.sayName() // &#39;海绵宝宝&#39;\n</code></pre>\n<p>在这个例子中，我们可以看到：</p>\n<ul>\n<li><code>new</code>关键字创建了一个新的对象。</li>\n<li>并且这个新对象可以访问到构造函数的属性。</li>\n<li>这个新对象还可以访问到构造函数的方法。</li>\n<li>也就是说，我们通过<code>new</code>操作符将构造函数与实例对象通过原型链链接起来了。</li>\n</ul>\n<p>但是上面那个例子，构造函数并没有返回任何值（默认返回undefined）,要是我们让他返回值，会发生什么情况呢？</p>\n<p>这个分为两种情况：</p>\n<ol>\n<li>返回值为原始值。</li>\n<li>返回值为对象。</li>\n</ol>\n<p>我们一种一种的来看</p>\n<p>首选我们看看返回值为原始值的时候：</p>\n<pre><code>function Test(name) &#123;\n    this.name = name;\n    return &#39;111&#39;;\n&#125;\nconst newTest = new Test(&#39;海绵宝宝&#39;);\nconsole.log(newTest.name); // &#39;海绵宝宝&#39;\n</code></pre>\n<p>上面这个例子，我们可以看到，即使我们最后返回了一个字符串，但是最后实例对象还是输出了构造函数里面的属性值。这说明这个原始值的返回类型没有任何用处。结果还是和没有返回值一样的。</p>\n<p>接下来我们看看返回值为对象的时候，会发生什么：</p>\n<pre><code>function Test(name) &#123;\n    this.name = name\n    console.log(this)\n    return &#123;\n        name: &#39;蟹老板&#39;\n    &#125;\n&#125;\nconst Test1 = new Test(&#39;海绵宝宝&#39;)\nconsole.log(Test1.name)  // &#39;蟹老板&#39;\nconsole.log(Test1) // &#123;name: &#39;蟹老板&#39;&#125;\n</code></pre>\n<p>通过这个例子我们知道，当构造函数里面将返回值设置为一个对象的时候，返回的对象会作为实例对象的属性。这个返回值将会被正常的使用。</p>\n<p><strong>总结：</strong></p>\n<p>构造函数尽量不要使用返回值，因为原始值的没有任何作用，返回对象的话会导致<code>new</code>操作符失效。</p>\n"},{"title":"三种动态创建元素的区别","date":"2022-09-18T16:00:00.000Z","_content":"# 三种动态创建元素的区别\n\n1. document.createElement() \n2. document.write() \n3. innerHTML\n\n## 首先 write\n\n    document.write('写入的内容');\n\n调用这个方法之后，整个页面的内容将会被替换为写入的内容，所以这个方法只能在页面加载完成之前调用，否则会导致页面内容丢失。\n\n也就是说，如果此方法在页面加载完成之后调用，会导致整个页面只剩下`write`方法里面的内容。\n\n## 其次 createElement\n\n    var div = document.createElement('div');\n    div.innerHTML = '写入的内容';\n    document.body.appendChild(div);\n\n这个方法是动态创建一个元素，然后将这个元素添加到页面中。\n\n相当于在页面中床架一个文本节点，然后通过`appendChild`方法将这个文本节点添加到页面中。这个方法不会导致页面的重绘，也就不会出现`write`的问题。\n\n## 最后 innerHTML\n\n    element.innerHTML = '写入的内容';\n\n这个方法是直接将所选元素的内容替换为写入的内容，所以这个方法也不会导致页面的重绘。但是如果所选节点为`body`，那么也会导致页面的重绘。","source":"_posts/JavaScript/三种动态创建元素的区别.md","raw":"---\ntitle: 三种动态创建元素的区别\ndate: 2022-9-19\ntags: [前端]\ncategories: [JavaScript]\n---\n# 三种动态创建元素的区别\n\n1. document.createElement() \n2. document.write() \n3. innerHTML\n\n## 首先 write\n\n    document.write('写入的内容');\n\n调用这个方法之后，整个页面的内容将会被替换为写入的内容，所以这个方法只能在页面加载完成之前调用，否则会导致页面内容丢失。\n\n也就是说，如果此方法在页面加载完成之后调用，会导致整个页面只剩下`write`方法里面的内容。\n\n## 其次 createElement\n\n    var div = document.createElement('div');\n    div.innerHTML = '写入的内容';\n    document.body.appendChild(div);\n\n这个方法是动态创建一个元素，然后将这个元素添加到页面中。\n\n相当于在页面中床架一个文本节点，然后通过`appendChild`方法将这个文本节点添加到页面中。这个方法不会导致页面的重绘，也就不会出现`write`的问题。\n\n## 最后 innerHTML\n\n    element.innerHTML = '写入的内容';\n\n这个方法是直接将所选元素的内容替换为写入的内容，所以这个方法也不会导致页面的重绘。但是如果所选节点为`body`，那么也会导致页面的重绘。","slug":"JavaScript/三种动态创建元素的区别","published":1,"updated":"2023-01-08T11:55:48.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmii004x9kbm64d6gruk","content":"<h1 id=\"三种动态创建元素的区别\"><a href=\"#三种动态创建元素的区别\" class=\"headerlink\" title=\"三种动态创建元素的区别\"></a>三种动态创建元素的区别</h1><ol>\n<li>document.createElement() </li>\n<li>document.write() </li>\n<li>innerHTML</li>\n</ol>\n<h2 id=\"首先-write\"><a href=\"#首先-write\" class=\"headerlink\" title=\"首先 write\"></a>首先 write</h2><pre><code>document.write(&#39;写入的内容&#39;);\n</code></pre>\n<p>调用这个方法之后，整个页面的内容将会被替换为写入的内容，所以这个方法只能在页面加载完成之前调用，否则会导致页面内容丢失。</p>\n<p>也就是说，如果此方法在页面加载完成之后调用，会导致整个页面只剩下<code>write</code>方法里面的内容。</p>\n<h2 id=\"其次-createElement\"><a href=\"#其次-createElement\" class=\"headerlink\" title=\"其次 createElement\"></a>其次 createElement</h2><pre><code>var div = document.createElement(&#39;div&#39;);\ndiv.innerHTML = &#39;写入的内容&#39;;\ndocument.body.appendChild(div);\n</code></pre>\n<p>这个方法是动态创建一个元素，然后将这个元素添加到页面中。</p>\n<p>相当于在页面中床架一个文本节点，然后通过<code>appendChild</code>方法将这个文本节点添加到页面中。这个方法不会导致页面的重绘，也就不会出现<code>write</code>的问题。</p>\n<h2 id=\"最后-innerHTML\"><a href=\"#最后-innerHTML\" class=\"headerlink\" title=\"最后 innerHTML\"></a>最后 innerHTML</h2><pre><code>element.innerHTML = &#39;写入的内容&#39;;\n</code></pre>\n<p>这个方法是直接将所选元素的内容替换为写入的内容，所以这个方法也不会导致页面的重绘。但是如果所选节点为<code>body</code>，那么也会导致页面的重绘。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"三种动态创建元素的区别\"><a href=\"#三种动态创建元素的区别\" class=\"headerlink\" title=\"三种动态创建元素的区别\"></a>三种动态创建元素的区别</h1><ol>\n<li>document.createElement() </li>\n<li>document.write() </li>\n<li>innerHTML</li>\n</ol>\n<h2 id=\"首先-write\"><a href=\"#首先-write\" class=\"headerlink\" title=\"首先 write\"></a>首先 write</h2><pre><code>document.write(&#39;写入的内容&#39;);\n</code></pre>\n<p>调用这个方法之后，整个页面的内容将会被替换为写入的内容，所以这个方法只能在页面加载完成之前调用，否则会导致页面内容丢失。</p>\n<p>也就是说，如果此方法在页面加载完成之后调用，会导致整个页面只剩下<code>write</code>方法里面的内容。</p>\n<h2 id=\"其次-createElement\"><a href=\"#其次-createElement\" class=\"headerlink\" title=\"其次 createElement\"></a>其次 createElement</h2><pre><code>var div = document.createElement(&#39;div&#39;);\ndiv.innerHTML = &#39;写入的内容&#39;;\ndocument.body.appendChild(div);\n</code></pre>\n<p>这个方法是动态创建一个元素，然后将这个元素添加到页面中。</p>\n<p>相当于在页面中床架一个文本节点，然后通过<code>appendChild</code>方法将这个文本节点添加到页面中。这个方法不会导致页面的重绘，也就不会出现<code>write</code>的问题。</p>\n<h2 id=\"最后-innerHTML\"><a href=\"#最后-innerHTML\" class=\"headerlink\" title=\"最后 innerHTML\"></a>最后 innerHTML</h2><pre><code>element.innerHTML = &#39;写入的内容&#39;;\n</code></pre>\n<p>这个方法是直接将所选元素的内容替换为写入的内容，所以这个方法也不会导致页面的重绘。但是如果所选节点为<code>body</code>，那么也会导致页面的重绘。</p>\n"},{"title":"事件对象","date":"2022-09-19T16:00:00.000Z","_content":"# 事件对象\n\n我们先来写一个例子\n\n    <button>点击</button>\n    <script>\n        let btn = document.querySelector('button');\n        btn.onclick = function (event) {\n            alert(event.target);\n        }\n\n- `event`就是一个事件对象，写到我们侦听函数的小括号里面，我们可以把它看做是形参。\n- 事件对象只有有了事件才会存在，它是系统自动创建的，不需要我们传递参数\n- 事件对象 是我们事件的一系列相关数据的结合体，我们可以通过事件对象来获取事件的相关数据  比如鼠标点击就包含了鼠标的相关信息：鼠标坐标等等；键盘事件就包含了键盘的相关信息：按下的键盘码等等。\n- 这个事件对象我们可以自己命名，比如 event\n- 好东西总是会有兼容性的问题，也就是在ie6~8中，浏览器不会传递参数，则需要window.event中获取查找。\n\n## 事件对象常见的属性和方法\n\n|  事件对象属性方法   |                 说明                  |\n| :-----------------: | :-----------------------------------: |\n|      e.target       |      返回触发事件的对象（标准）       |\n|      e.ELement      |  返回触发事件的对象（非标准 ie6~8）   |\n|       e.type        |  返回事件的类型 比如click mouseover   |\n|   e.cancelBubble    |    该属性阻止冒泡  非标准（ie6~8）    |\n|    e.returnValue    | 该属性阻止默认事件 非标准（链接跳转） |\n| e.preventDefault()  |        该方法阻止默认事件 标准        |\n| e.stopPropagation() |         该方法阻止冒泡拍排序          |","source":"_posts/JavaScript/事件对象.md","raw":"---\ntitle: 事件对象\ndate: 2022-9-20\ntags: [前端]\ncategories: [JavaScript]\n---\n# 事件对象\n\n我们先来写一个例子\n\n    <button>点击</button>\n    <script>\n        let btn = document.querySelector('button');\n        btn.onclick = function (event) {\n            alert(event.target);\n        }\n\n- `event`就是一个事件对象，写到我们侦听函数的小括号里面，我们可以把它看做是形参。\n- 事件对象只有有了事件才会存在，它是系统自动创建的，不需要我们传递参数\n- 事件对象 是我们事件的一系列相关数据的结合体，我们可以通过事件对象来获取事件的相关数据  比如鼠标点击就包含了鼠标的相关信息：鼠标坐标等等；键盘事件就包含了键盘的相关信息：按下的键盘码等等。\n- 这个事件对象我们可以自己命名，比如 event\n- 好东西总是会有兼容性的问题，也就是在ie6~8中，浏览器不会传递参数，则需要window.event中获取查找。\n\n## 事件对象常见的属性和方法\n\n|  事件对象属性方法   |                 说明                  |\n| :-----------------: | :-----------------------------------: |\n|      e.target       |      返回触发事件的对象（标准）       |\n|      e.ELement      |  返回触发事件的对象（非标准 ie6~8）   |\n|       e.type        |  返回事件的类型 比如click mouseover   |\n|   e.cancelBubble    |    该属性阻止冒泡  非标准（ie6~8）    |\n|    e.returnValue    | 该属性阻止默认事件 非标准（链接跳转） |\n| e.preventDefault()  |        该方法阻止默认事件 标准        |\n| e.stopPropagation() |         该方法阻止冒泡拍排序          |","slug":"JavaScript/事件对象","published":1,"updated":"2023-01-08T12:03:07.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmij00509kbmhugy9634","content":"<h1 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h1><p>我们先来写一个例子</p>\n<pre><code>&lt;button&gt;点击&lt;/button&gt;\n&lt;script&gt;\n    let btn = document.querySelector(&#39;button&#39;);\n    btn.onclick = function (event) &#123;\n        alert(event.target);\n    &#125;\n</code></pre>\n<ul>\n<li><code>event</code>就是一个事件对象，写到我们侦听函数的小括号里面，我们可以把它看做是形参。</li>\n<li>事件对象只有有了事件才会存在，它是系统自动创建的，不需要我们传递参数</li>\n<li>事件对象 是我们事件的一系列相关数据的结合体，我们可以通过事件对象来获取事件的相关数据  比如鼠标点击就包含了鼠标的相关信息：鼠标坐标等等；键盘事件就包含了键盘的相关信息：按下的键盘码等等。</li>\n<li>这个事件对象我们可以自己命名，比如 event</li>\n<li>好东西总是会有兼容性的问题，也就是在ie6~8中，浏览器不会传递参数，则需要window.event中获取查找。</li>\n</ul>\n<h2 id=\"事件对象常见的属性和方法\"><a href=\"#事件对象常见的属性和方法\" class=\"headerlink\" title=\"事件对象常见的属性和方法\"></a>事件对象常见的属性和方法</h2><table>\n<thead>\n<tr>\n<th align=\"center\">事件对象属性方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">e.target</td>\n<td align=\"center\">返回触发事件的对象（标准）</td>\n</tr>\n<tr>\n<td align=\"center\">e.ELement</td>\n<td align=\"center\">返回触发事件的对象（非标准 ie6~8）</td>\n</tr>\n<tr>\n<td align=\"center\">e.type</td>\n<td align=\"center\">返回事件的类型 比如click mouseover</td>\n</tr>\n<tr>\n<td align=\"center\">e.cancelBubble</td>\n<td align=\"center\">该属性阻止冒泡  非标准（ie6~8）</td>\n</tr>\n<tr>\n<td align=\"center\">e.returnValue</td>\n<td align=\"center\">该属性阻止默认事件 非标准（链接跳转）</td>\n</tr>\n<tr>\n<td align=\"center\">e.preventDefault()</td>\n<td align=\"center\">该方法阻止默认事件 标准</td>\n</tr>\n<tr>\n<td align=\"center\">e.stopPropagation()</td>\n<td align=\"center\">该方法阻止冒泡拍排序</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h1><p>我们先来写一个例子</p>\n<pre><code>&lt;button&gt;点击&lt;/button&gt;\n&lt;script&gt;\n    let btn = document.querySelector(&#39;button&#39;);\n    btn.onclick = function (event) &#123;\n        alert(event.target);\n    &#125;\n</code></pre>\n<ul>\n<li><code>event</code>就是一个事件对象，写到我们侦听函数的小括号里面，我们可以把它看做是形参。</li>\n<li>事件对象只有有了事件才会存在，它是系统自动创建的，不需要我们传递参数</li>\n<li>事件对象 是我们事件的一系列相关数据的结合体，我们可以通过事件对象来获取事件的相关数据  比如鼠标点击就包含了鼠标的相关信息：鼠标坐标等等；键盘事件就包含了键盘的相关信息：按下的键盘码等等。</li>\n<li>这个事件对象我们可以自己命名，比如 event</li>\n<li>好东西总是会有兼容性的问题，也就是在ie6~8中，浏览器不会传递参数，则需要window.event中获取查找。</li>\n</ul>\n<h2 id=\"事件对象常见的属性和方法\"><a href=\"#事件对象常见的属性和方法\" class=\"headerlink\" title=\"事件对象常见的属性和方法\"></a>事件对象常见的属性和方法</h2><table>\n<thead>\n<tr>\n<th align=\"center\">事件对象属性方法</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">e.target</td>\n<td align=\"center\">返回触发事件的对象（标准）</td>\n</tr>\n<tr>\n<td align=\"center\">e.ELement</td>\n<td align=\"center\">返回触发事件的对象（非标准 ie6~8）</td>\n</tr>\n<tr>\n<td align=\"center\">e.type</td>\n<td align=\"center\">返回事件的类型 比如click mouseover</td>\n</tr>\n<tr>\n<td align=\"center\">e.cancelBubble</td>\n<td align=\"center\">该属性阻止冒泡  非标准（ie6~8）</td>\n</tr>\n<tr>\n<td align=\"center\">e.returnValue</td>\n<td align=\"center\">该属性阻止默认事件 非标准（链接跳转）</td>\n</tr>\n<tr>\n<td align=\"center\">e.preventDefault()</td>\n<td align=\"center\">该方法阻止默认事件 标准</td>\n</tr>\n<tr>\n<td align=\"center\">e.stopPropagation()</td>\n<td align=\"center\">该方法阻止冒泡拍排序</td>\n</tr>\n</tbody></table>\n"},{"title":"事件对象详细解析","data":["2023-5-8"],"_content":"# 事件对象详细解析\n\n[TOC]\n\n## 事件对象的概念\n在JavaScript中，事件对象是一个与当前事件相关的对象，它包含着当前事件的所有信息。事件对象的属性和方法可以让我们对事件的状态进行检测，或者对事件做出响应。\n\n- 如何获取这个对象：\n\nevent对象会在传入事件处理的函数回调中，被系统传入，我们可以在回调函数中拿到这个对象。\n    \n```js\nelement.onclick = function(event) {\n    console.log(event);\n}\n```\n\n## Event常见的属性和方法\n\n- type：事件的类型\n- target：事件的目标对象\n- currentTarget：事件的当前目标对象\n- eventPhase: 事件所处的阶段,1:捕获阶段,2:目标阶段,3:冒泡阶段\n- offsetX,offsetY:事件发生时在元素内的位置\n- pageX,pageY:事件发生时在客户端相对于document的位置\n- clientX,clientY:事件发生时在客户端相对于浏览器的位置\n- screenX,screenY:事件发生时在屏幕上的位置\n\n## 事件对象的一些方法\n\n- preventDefault()：阻止默认事件\n- stopPropagation()：阻止事件传递\n\n## 事件处理中的this\n\n在事件处理函数中，this指向的是当前事件的目标对象。","source":"_posts/JavaScript/事件对象详细解析.md","raw":"---\ntitle: 事件对象详细解析\ndata: [2023-5-8]\ntags: [前端]\ncategories: [JavaScript]\n---\n# 事件对象详细解析\n\n[TOC]\n\n## 事件对象的概念\n在JavaScript中，事件对象是一个与当前事件相关的对象，它包含着当前事件的所有信息。事件对象的属性和方法可以让我们对事件的状态进行检测，或者对事件做出响应。\n\n- 如何获取这个对象：\n\nevent对象会在传入事件处理的函数回调中，被系统传入，我们可以在回调函数中拿到这个对象。\n    \n```js\nelement.onclick = function(event) {\n    console.log(event);\n}\n```\n\n## Event常见的属性和方法\n\n- type：事件的类型\n- target：事件的目标对象\n- currentTarget：事件的当前目标对象\n- eventPhase: 事件所处的阶段,1:捕获阶段,2:目标阶段,3:冒泡阶段\n- offsetX,offsetY:事件发生时在元素内的位置\n- pageX,pageY:事件发生时在客户端相对于document的位置\n- clientX,clientY:事件发生时在客户端相对于浏览器的位置\n- screenX,screenY:事件发生时在屏幕上的位置\n\n## 事件对象的一些方法\n\n- preventDefault()：阻止默认事件\n- stopPropagation()：阻止事件传递\n\n## 事件处理中的this\n\n在事件处理函数中，this指向的是当前事件的目标对象。","slug":"JavaScript/事件对象详细解析","published":1,"date":"2023-05-08T13:22:15.953Z","updated":"2023-05-10T03:09:17.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmik00539kbmd4bu7nyy","content":"<h1 id=\"事件对象详细解析\"><a href=\"#事件对象详细解析\" class=\"headerlink\" title=\"事件对象详细解析\"></a>事件对象详细解析</h1><p>[TOC]</p>\n<h2 id=\"事件对象的概念\"><a href=\"#事件对象的概念\" class=\"headerlink\" title=\"事件对象的概念\"></a>事件对象的概念</h2><p>在JavaScript中，事件对象是一个与当前事件相关的对象，它包含着当前事件的所有信息。事件对象的属性和方法可以让我们对事件的状态进行检测，或者对事件做出响应。</p>\n<ul>\n<li>如何获取这个对象：</li>\n</ul>\n<p>event对象会在传入事件处理的函数回调中，被系统传入，我们可以在回调函数中拿到这个对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Event常见的属性和方法\"><a href=\"#Event常见的属性和方法\" class=\"headerlink\" title=\"Event常见的属性和方法\"></a>Event常见的属性和方法</h2><ul>\n<li>type：事件的类型</li>\n<li>target：事件的目标对象</li>\n<li>currentTarget：事件的当前目标对象</li>\n<li>eventPhase: 事件所处的阶段,1:捕获阶段,2:目标阶段,3:冒泡阶段</li>\n<li>offsetX,offsetY:事件发生时在元素内的位置</li>\n<li>pageX,pageY:事件发生时在客户端相对于document的位置</li>\n<li>clientX,clientY:事件发生时在客户端相对于浏览器的位置</li>\n<li>screenX,screenY:事件发生时在屏幕上的位置</li>\n</ul>\n<h2 id=\"事件对象的一些方法\"><a href=\"#事件对象的一些方法\" class=\"headerlink\" title=\"事件对象的一些方法\"></a>事件对象的一些方法</h2><ul>\n<li>preventDefault()：阻止默认事件</li>\n<li>stopPropagation()：阻止事件传递</li>\n</ul>\n<h2 id=\"事件处理中的this\"><a href=\"#事件处理中的this\" class=\"headerlink\" title=\"事件处理中的this\"></a>事件处理中的this</h2><p>在事件处理函数中，this指向的是当前事件的目标对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"事件对象详细解析\"><a href=\"#事件对象详细解析\" class=\"headerlink\" title=\"事件对象详细解析\"></a>事件对象详细解析</h1><p>[TOC]</p>\n<h2 id=\"事件对象的概念\"><a href=\"#事件对象的概念\" class=\"headerlink\" title=\"事件对象的概念\"></a>事件对象的概念</h2><p>在JavaScript中，事件对象是一个与当前事件相关的对象，它包含着当前事件的所有信息。事件对象的属性和方法可以让我们对事件的状态进行检测，或者对事件做出响应。</p>\n<ul>\n<li>如何获取这个对象：</li>\n</ul>\n<p>event对象会在传入事件处理的函数回调中，被系统传入，我们可以在回调函数中拿到这个对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Event常见的属性和方法\"><a href=\"#Event常见的属性和方法\" class=\"headerlink\" title=\"Event常见的属性和方法\"></a>Event常见的属性和方法</h2><ul>\n<li>type：事件的类型</li>\n<li>target：事件的目标对象</li>\n<li>currentTarget：事件的当前目标对象</li>\n<li>eventPhase: 事件所处的阶段,1:捕获阶段,2:目标阶段,3:冒泡阶段</li>\n<li>offsetX,offsetY:事件发生时在元素内的位置</li>\n<li>pageX,pageY:事件发生时在客户端相对于document的位置</li>\n<li>clientX,clientY:事件发生时在客户端相对于浏览器的位置</li>\n<li>screenX,screenY:事件发生时在屏幕上的位置</li>\n</ul>\n<h2 id=\"事件对象的一些方法\"><a href=\"#事件对象的一些方法\" class=\"headerlink\" title=\"事件对象的一些方法\"></a>事件对象的一些方法</h2><ul>\n<li>preventDefault()：阻止默认事件</li>\n<li>stopPropagation()：阻止事件传递</li>\n</ul>\n<h2 id=\"事件处理中的this\"><a href=\"#事件处理中的this\" class=\"headerlink\" title=\"事件处理中的this\"></a>事件处理中的this</h2><p>在事件处理函数中，this指向的是当前事件的目标对象。</p>\n"},{"title":"函数中的this","data":["2023-2-28"],"_content":"\n# 函数中的this\n\n- 函数调用时，JavaScript或默认给this绑定一个值\n- this的绑定与定义的位置没有关系\n- this的绑定与调用方式以及调用的位置有关系\n- this是在运行时被绑定的\n\n# 1.this的绑定规则\n\n1. 默认绑定\n2. 隐式绑定\n3. 显示绑定\n4. new绑定\n\n## 1.1默认绑定\n\n1. 普通函数被独立调用\n\n```jsx\nfunction foo() {\n    console.log(this);\n}\n\nfoo(); // windows\n```\n\n1. 函数定义在对象中，但是被独立调用\n\n```jsx\nvar obj = {\n\tbar: function(){\n\t\tconsole.log(this);\n\t}\n}\n\nlet baz = obj.bar;\nbaz(); // window\n```\n\n1. 严格模式下，独立调用的函数this指向undefined\n\n## 1.2 隐式绑定\n\n通过某个对象进行调用\n\n也就是函数调用位置是某个对象发起的函数调用。\n\n```jsx\nfunction foo() {\n    console.log(this);\n};\n\nlet obj = {\n    baz: foo,\n};\n\nobj.baz(); // obj\n```\n\n**隐式绑定有一个前提条件**\n\n- 必须在调用对象内部有一个对函数的引用（比如一个属性）\n- 如果没有这样的引用，在调用的时候，就会报找不到该函数的错误\n- 通过这个引用，间接将this绑定到了这个对象上\n\n## 1.3 通过new绑定\n\nnew会经过以下几个阶段:\n\n1. 创建新的空对象\n2. 将this指向这个空对象\n3. 执行函数体重的代码\n4. 没有显示返回非空对象时，默认返回这个对象\n\n## 1.4 显示绑定\n\n如果我们不希望在对象内部包含这个函数的引用，同时又希望在该函数上进行强制调用该函数。\n\n我们可以使用apply与call方法 \n\n- 这两个方法第一个参数都是为一个对象\n    - 这个对象就是给this准备IDE\n    - 在调用你这个函数时，会将this绑定到传入的这个对象身上\n- 后面的参数：apply为数组，call为参数列表\n\n比如：\n\n```jsx\nfoo.aply(obj,[\"as\",12,4]);\nfoo.call(obj,\"as\",12,4);\n```\n\n如果想要将一个函数总是显示绑定到一个对象上，我们可以使用bind方法。\n\n- bind方法，bind()方法创建一个新的绑定函数\n\n```jsx\nfoo.bind(obj);\n```\n\nbind函数传入参数的方式与call是一样的。\n\n## 1.5 内置函数的this绑定\n\n1. 定时器\n    \n    定时器的this绑定为window。\n    \n2. 事件监听\n3. forEach\n    \n    forEach默认绑定为window，你也可以在forEach第二个参数中传入要绑定的this对象。\n    \n\n```jsx\nvar names = [\"avx\",\"asd\",\"fgd\"];\nnames.forEach(function(){\n\tconsole.log(this);\n},obj)\n```\n\n## 1.6 几种绑定规则的优先级\n\n- 默认规则的优先级最低\n- 显示绑定的优先级高于隐式绑定\n- new绑定高于隐式绑定\n- new不可以appLy/call一起使用\n- new的优先级高于bind\n- bind的优先级高于apply/call\n\nnew > bind > apply/call > 隐式绑定 > 默认绑定\n\n# 2.this规则之外-忽略显示绑定\n\n- 如果在显示绑定中，传入一个null或者undefined,那么该这个显示绑定失效，使用默认规则\n- 创建一个函数的间接引用，这种情况使用默认绑定规则。\n\n# 3.箭头函数\n\n箭头函数是ES6之后新增的一种编写函数的方法。\n\n- 箭头函数不会绑定this。arguments属性\n- 箭头函数不能作为构造函数䣂使用（不能和new一起使用，报错）\n\n## 3.1 箭头函数的写法\n\n```jsx\n(参数列表) => {\n\t函数体\n}\n```\n\n## 3.2 箭头函数的编写优化（简写）\n\n- 如果箭头函数只有一个参数，那么小括号可以省略\n\n```jsx\nitem => {\n\tconsole.log(item);\n}\n```\n\n- 如果函数体只有一行代码，可以省略大括号\n    \n    并且这行代码的返回值会作为整个函数的返回值\n    \n    ```jsx\n    item => consloe.log(item);\n    ```\n    \n\n**注意**\n\n这一行代码中不能包含return关键字\n\n如果要返回值，那么这行代码的运算结果就会作为整个函数的返回值返回。\n\n```jsx\nitem => item*2;\n```\n\n- 如果默认返回值是一个对象，那么这个对象必须加()\n\n```jsx\nfoo = () => ({name:\"hi\"});\n```\n\n# 3.3箭头函数里面的this\n\n在普通函数里面是有this标识符的，但是在箭头函数里面没有this。\n\n通过apply来调用还是没有this指向。\n\n查找this的规则与查找变量一样：该作用域没有this，就往上一层作用域查找，直到查找到this。\n\n# 4.面试题\n\n## 4.1 面试题1\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31e5753ac9ea42aabcc556d153159d6f~tplv-k3u1fbpfcp-watermark.image?)\n\n\n第一个`sss()`调用时默认调用，所以this为默认绑定，this指向window，所以最后的值为window。\n\n第二个函数调用为隐式绑定，所以this指向person,所以最后结果为person。\n\n第三个同样也是隐式绑定，所以结果一样。\n\n第四个是间接函数引用，返回结果为一个独立的函数，this指向window，结果为window。\n\n## 4.2 面试题2\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d54305f0ee74ea09f8d4f7bfce063f4~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de309ac813814f4f874fbe6ec45cbd7c~tplv-k3u1fbpfcp-watermark.image?)\n\n- 22行： 隐式绑定，this指向person1,结果person1\n- 23行：显式绑定，this指向person2，结果为person2\n- 25行：箭头函数没有this，去上层作用域查找，所以this绑定为window，最后结果为window\n- 26行：箭头函数没有this，去上层作用域查找，所以this绑定为window，最后结果为window\n- 28行：首先执行person1.foo3()，这个函数结果为一个函数，后面接着执行返回的这个函数，所以为函数单独调用，为默认绑定，this指向window，所以最后结果为window。\n- 29行：虽然foo3()的this绑定为person2，但是后面返回的一个函数，还是相当于是函数独立调用，所以最后this还是指向window，结果为window。\n- 30行：最后调用的函数为显式绑定，this指向person2，所以最后结果为person2。\n- 32行：因为foo4()函数返回的结果函数没有this指向，所以会往上层作用域查找，最后this指向person1，结果为person1\n- 33行：foo4()的this被显式绑定为person2，所以返回结果箭头函数this也指向person2，结果为person2.\n- 34行：因为箭头函数没有this，所以显式绑定不起作用，所以最后结果为person1。\n\n## 4.3 面试题3\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4640f4437b848c2a21724c96b0d821c~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcb6b6392ca4271a3d35e246ddd6342~tplv-k3u1fbpfcp-watermark.image?)\n\nnew执行步骤：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d28c5e3c5534e7fbdfb72cc1147fcc7~tplv-k3u1fbpfcp-watermark.image?)\n\nnew操作符运行示意图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee986bc7381140c7ab9549d8219154bb~tplv-k3u1fbpfcp-watermark.image?)\n\n- 22行： 隐式绑定，结果为person1。\n- 23行：显式绑定到person2，结果为person2。\n- 25行：上层作用域查找，查找到person1\n- 26行：箭头函数没有this，显式绑定失效，所以还是person1\n- 28行：独立函数调用，默认绑定，window\n- 29行：还是独立函数调用，默认绑定，结果为window\n- 30行：显式绑定为person2，结果为person2\n- 32行：箭头函数没有this，往上层查找，所以为foo4()的this，foo4()this指向person1，所以结果为person1\n- 33行：foo4()this显式绑定为person2，所以最后结果为person2\n- 34行：箭头函数没有this，显式绑定失效，所以结果还是为person1","source":"_posts/JavaScript/函数中的this.md","raw":"---\ntitle: 函数中的this\ndata: [2023-2-28]\ntags: [前端]\ncategories: [JavaScript]\n---\n\n# 函数中的this\n\n- 函数调用时，JavaScript或默认给this绑定一个值\n- this的绑定与定义的位置没有关系\n- this的绑定与调用方式以及调用的位置有关系\n- this是在运行时被绑定的\n\n# 1.this的绑定规则\n\n1. 默认绑定\n2. 隐式绑定\n3. 显示绑定\n4. new绑定\n\n## 1.1默认绑定\n\n1. 普通函数被独立调用\n\n```jsx\nfunction foo() {\n    console.log(this);\n}\n\nfoo(); // windows\n```\n\n1. 函数定义在对象中，但是被独立调用\n\n```jsx\nvar obj = {\n\tbar: function(){\n\t\tconsole.log(this);\n\t}\n}\n\nlet baz = obj.bar;\nbaz(); // window\n```\n\n1. 严格模式下，独立调用的函数this指向undefined\n\n## 1.2 隐式绑定\n\n通过某个对象进行调用\n\n也就是函数调用位置是某个对象发起的函数调用。\n\n```jsx\nfunction foo() {\n    console.log(this);\n};\n\nlet obj = {\n    baz: foo,\n};\n\nobj.baz(); // obj\n```\n\n**隐式绑定有一个前提条件**\n\n- 必须在调用对象内部有一个对函数的引用（比如一个属性）\n- 如果没有这样的引用，在调用的时候，就会报找不到该函数的错误\n- 通过这个引用，间接将this绑定到了这个对象上\n\n## 1.3 通过new绑定\n\nnew会经过以下几个阶段:\n\n1. 创建新的空对象\n2. 将this指向这个空对象\n3. 执行函数体重的代码\n4. 没有显示返回非空对象时，默认返回这个对象\n\n## 1.4 显示绑定\n\n如果我们不希望在对象内部包含这个函数的引用，同时又希望在该函数上进行强制调用该函数。\n\n我们可以使用apply与call方法 \n\n- 这两个方法第一个参数都是为一个对象\n    - 这个对象就是给this准备IDE\n    - 在调用你这个函数时，会将this绑定到传入的这个对象身上\n- 后面的参数：apply为数组，call为参数列表\n\n比如：\n\n```jsx\nfoo.aply(obj,[\"as\",12,4]);\nfoo.call(obj,\"as\",12,4);\n```\n\n如果想要将一个函数总是显示绑定到一个对象上，我们可以使用bind方法。\n\n- bind方法，bind()方法创建一个新的绑定函数\n\n```jsx\nfoo.bind(obj);\n```\n\nbind函数传入参数的方式与call是一样的。\n\n## 1.5 内置函数的this绑定\n\n1. 定时器\n    \n    定时器的this绑定为window。\n    \n2. 事件监听\n3. forEach\n    \n    forEach默认绑定为window，你也可以在forEach第二个参数中传入要绑定的this对象。\n    \n\n```jsx\nvar names = [\"avx\",\"asd\",\"fgd\"];\nnames.forEach(function(){\n\tconsole.log(this);\n},obj)\n```\n\n## 1.6 几种绑定规则的优先级\n\n- 默认规则的优先级最低\n- 显示绑定的优先级高于隐式绑定\n- new绑定高于隐式绑定\n- new不可以appLy/call一起使用\n- new的优先级高于bind\n- bind的优先级高于apply/call\n\nnew > bind > apply/call > 隐式绑定 > 默认绑定\n\n# 2.this规则之外-忽略显示绑定\n\n- 如果在显示绑定中，传入一个null或者undefined,那么该这个显示绑定失效，使用默认规则\n- 创建一个函数的间接引用，这种情况使用默认绑定规则。\n\n# 3.箭头函数\n\n箭头函数是ES6之后新增的一种编写函数的方法。\n\n- 箭头函数不会绑定this。arguments属性\n- 箭头函数不能作为构造函数䣂使用（不能和new一起使用，报错）\n\n## 3.1 箭头函数的写法\n\n```jsx\n(参数列表) => {\n\t函数体\n}\n```\n\n## 3.2 箭头函数的编写优化（简写）\n\n- 如果箭头函数只有一个参数，那么小括号可以省略\n\n```jsx\nitem => {\n\tconsole.log(item);\n}\n```\n\n- 如果函数体只有一行代码，可以省略大括号\n    \n    并且这行代码的返回值会作为整个函数的返回值\n    \n    ```jsx\n    item => consloe.log(item);\n    ```\n    \n\n**注意**\n\n这一行代码中不能包含return关键字\n\n如果要返回值，那么这行代码的运算结果就会作为整个函数的返回值返回。\n\n```jsx\nitem => item*2;\n```\n\n- 如果默认返回值是一个对象，那么这个对象必须加()\n\n```jsx\nfoo = () => ({name:\"hi\"});\n```\n\n# 3.3箭头函数里面的this\n\n在普通函数里面是有this标识符的，但是在箭头函数里面没有this。\n\n通过apply来调用还是没有this指向。\n\n查找this的规则与查找变量一样：该作用域没有this，就往上一层作用域查找，直到查找到this。\n\n# 4.面试题\n\n## 4.1 面试题1\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31e5753ac9ea42aabcc556d153159d6f~tplv-k3u1fbpfcp-watermark.image?)\n\n\n第一个`sss()`调用时默认调用，所以this为默认绑定，this指向window，所以最后的值为window。\n\n第二个函数调用为隐式绑定，所以this指向person,所以最后结果为person。\n\n第三个同样也是隐式绑定，所以结果一样。\n\n第四个是间接函数引用，返回结果为一个独立的函数，this指向window，结果为window。\n\n## 4.2 面试题2\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d54305f0ee74ea09f8d4f7bfce063f4~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de309ac813814f4f874fbe6ec45cbd7c~tplv-k3u1fbpfcp-watermark.image?)\n\n- 22行： 隐式绑定，this指向person1,结果person1\n- 23行：显式绑定，this指向person2，结果为person2\n- 25行：箭头函数没有this，去上层作用域查找，所以this绑定为window，最后结果为window\n- 26行：箭头函数没有this，去上层作用域查找，所以this绑定为window，最后结果为window\n- 28行：首先执行person1.foo3()，这个函数结果为一个函数，后面接着执行返回的这个函数，所以为函数单独调用，为默认绑定，this指向window，所以最后结果为window。\n- 29行：虽然foo3()的this绑定为person2，但是后面返回的一个函数，还是相当于是函数独立调用，所以最后this还是指向window，结果为window。\n- 30行：最后调用的函数为显式绑定，this指向person2，所以最后结果为person2。\n- 32行：因为foo4()函数返回的结果函数没有this指向，所以会往上层作用域查找，最后this指向person1，结果为person1\n- 33行：foo4()的this被显式绑定为person2，所以返回结果箭头函数this也指向person2，结果为person2.\n- 34行：因为箭头函数没有this，所以显式绑定不起作用，所以最后结果为person1。\n\n## 4.3 面试题3\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4640f4437b848c2a21724c96b0d821c~tplv-k3u1fbpfcp-watermark.image?)\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcb6b6392ca4271a3d35e246ddd6342~tplv-k3u1fbpfcp-watermark.image?)\n\nnew执行步骤：\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d28c5e3c5534e7fbdfb72cc1147fcc7~tplv-k3u1fbpfcp-watermark.image?)\n\nnew操作符运行示意图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee986bc7381140c7ab9549d8219154bb~tplv-k3u1fbpfcp-watermark.image?)\n\n- 22行： 隐式绑定，结果为person1。\n- 23行：显式绑定到person2，结果为person2。\n- 25行：上层作用域查找，查找到person1\n- 26行：箭头函数没有this，显式绑定失效，所以还是person1\n- 28行：独立函数调用，默认绑定，window\n- 29行：还是独立函数调用，默认绑定，结果为window\n- 30行：显式绑定为person2，结果为person2\n- 32行：箭头函数没有this，往上层查找，所以为foo4()的this，foo4()this指向person1，所以结果为person1\n- 33行：foo4()this显式绑定为person2，所以最后结果为person2\n- 34行：箭头函数没有this，显式绑定失效，所以结果还是为person1","slug":"JavaScript/函数中的this","published":1,"date":"2023-05-09T02:32:13.339Z","updated":"2023-05-10T03:08:59.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmil00569kbmhxoz2v1i","content":"<h1 id=\"函数中的this\"><a href=\"#函数中的this\" class=\"headerlink\" title=\"函数中的this\"></a>函数中的this</h1><ul>\n<li>函数调用时，JavaScript或默认给this绑定一个值</li>\n<li>this的绑定与定义的位置没有关系</li>\n<li>this的绑定与调用方式以及调用的位置有关系</li>\n<li>this是在运行时被绑定的</li>\n</ul>\n<h1 id=\"1-this的绑定规则\"><a href=\"#1-this的绑定规则\" class=\"headerlink\" title=\"1.this的绑定规则\"></a>1.this的绑定规则</h1><ol>\n<li>默认绑定</li>\n<li>隐式绑定</li>\n<li>显示绑定</li>\n<li>new绑定</li>\n</ol>\n<h2 id=\"1-1默认绑定\"><a href=\"#1-1默认绑定\" class=\"headerlink\" title=\"1.1默认绑定\"></a>1.1默认绑定</h2><ol>\n<li>普通函数被独立调用</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// windows</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>函数定义在对象中，但是被独立调用</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">bar</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> baz = obj.<span class=\"property\">bar</span>;</span><br><span class=\"line\"><span class=\"title function_\">baz</span>(); <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>严格模式下，独立调用的函数this指向undefined</li>\n</ol>\n<h2 id=\"1-2-隐式绑定\"><a href=\"#1-2-隐式绑定\" class=\"headerlink\" title=\"1.2 隐式绑定\"></a>1.2 隐式绑定</h2><p>通过某个对象进行调用</p>\n<p>也就是函数调用位置是某个对象发起的函数调用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">baz</span>: foo,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"title function_\">baz</span>(); <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>隐式绑定有一个前提条件</strong></p>\n<ul>\n<li>必须在调用对象内部有一个对函数的引用（比如一个属性）</li>\n<li>如果没有这样的引用，在调用的时候，就会报找不到该函数的错误</li>\n<li>通过这个引用，间接将this绑定到了这个对象上</li>\n</ul>\n<h2 id=\"1-3-通过new绑定\"><a href=\"#1-3-通过new绑定\" class=\"headerlink\" title=\"1.3 通过new绑定\"></a>1.3 通过new绑定</h2><p>new会经过以下几个阶段:</p>\n<ol>\n<li>创建新的空对象</li>\n<li>将this指向这个空对象</li>\n<li>执行函数体重的代码</li>\n<li>没有显示返回非空对象时，默认返回这个对象</li>\n</ol>\n<h2 id=\"1-4-显示绑定\"><a href=\"#1-4-显示绑定\" class=\"headerlink\" title=\"1.4 显示绑定\"></a>1.4 显示绑定</h2><p>如果我们不希望在对象内部包含这个函数的引用，同时又希望在该函数上进行强制调用该函数。</p>\n<p>我们可以使用apply与call方法 </p>\n<ul>\n<li>这两个方法第一个参数都是为一个对象<ul>\n<li>这个对象就是给this准备IDE</li>\n<li>在调用你这个函数时，会将this绑定到传入的这个对象身上</li>\n</ul>\n</li>\n<li>后面的参数：apply为数组，call为参数列表</li>\n</ul>\n<p>比如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.<span class=\"title function_\">aply</span>(obj,[<span class=\"string\">&quot;as&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">4</span>]);</span><br><span class=\"line\">foo.<span class=\"title function_\">call</span>(obj,<span class=\"string\">&quot;as&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果想要将一个函数总是显示绑定到一个对象上，我们可以使用bind方法。</p>\n<ul>\n<li>bind方法，bind()方法创建一个新的绑定函数</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.<span class=\"title function_\">bind</span>(obj);</span><br></pre></td></tr></table></figure>\n\n<p>bind函数传入参数的方式与call是一样的。</p>\n<h2 id=\"1-5-内置函数的this绑定\"><a href=\"#1-5-内置函数的this绑定\" class=\"headerlink\" title=\"1.5 内置函数的this绑定\"></a>1.5 内置函数的this绑定</h2><ol>\n<li><p>定时器</p>\n<p> 定时器的this绑定为window。</p>\n</li>\n<li><p>事件监听</p>\n</li>\n<li><p>forEach</p>\n<p> forEach默认绑定为window，你也可以在forEach第二个参数中传入要绑定的this对象。</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = [<span class=\"string\">&quot;avx&quot;</span>,<span class=\"string\">&quot;asd&quot;</span>,<span class=\"string\">&quot;fgd&quot;</span>];</span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;,obj)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-几种绑定规则的优先级\"><a href=\"#1-6-几种绑定规则的优先级\" class=\"headerlink\" title=\"1.6 几种绑定规则的优先级\"></a>1.6 几种绑定规则的优先级</h2><ul>\n<li>默认规则的优先级最低</li>\n<li>显示绑定的优先级高于隐式绑定</li>\n<li>new绑定高于隐式绑定</li>\n<li>new不可以appLy&#x2F;call一起使用</li>\n<li>new的优先级高于bind</li>\n<li>bind的优先级高于apply&#x2F;call</li>\n</ul>\n<p>new &gt; bind &gt; apply&#x2F;call &gt; 隐式绑定 &gt; 默认绑定</p>\n<h1 id=\"2-this规则之外-忽略显示绑定\"><a href=\"#2-this规则之外-忽略显示绑定\" class=\"headerlink\" title=\"2.this规则之外-忽略显示绑定\"></a>2.this规则之外-忽略显示绑定</h1><ul>\n<li>如果在显示绑定中，传入一个null或者undefined,那么该这个显示绑定失效，使用默认规则</li>\n<li>创建一个函数的间接引用，这种情况使用默认绑定规则。</li>\n</ul>\n<h1 id=\"3-箭头函数\"><a href=\"#3-箭头函数\" class=\"headerlink\" title=\"3.箭头函数\"></a>3.箭头函数</h1><p>箭头函数是ES6之后新增的一种编写函数的方法。</p>\n<ul>\n<li>箭头函数不会绑定this。arguments属性</li>\n<li>箭头函数不能作为构造函数䣂使用（不能和new一起使用，报错）</li>\n</ul>\n<h2 id=\"3-1-箭头函数的写法\"><a href=\"#3-1-箭头函数的写法\" class=\"headerlink\" title=\"3.1 箭头函数的写法\"></a>3.1 箭头函数的写法</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(参数列表) =&gt; &#123;</span><br><span class=\"line\">\t函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-箭头函数的编写优化（简写）\"><a href=\"#3-2-箭头函数的编写优化（简写）\" class=\"headerlink\" title=\"3.2 箭头函数的编写优化（简写）\"></a>3.2 箭头函数的编写优化（简写）</h2><ul>\n<li>如果箭头函数只有一个参数，那么小括号可以省略</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果函数体只有一行代码，可以省略大括号</p>\n<p>  并且这行代码的返回值会作为整个函数的返回值</p>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item =&gt; consloe.<span class=\"title function_\">log</span>(item);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>注意</strong></p>\n<p>这一行代码中不能包含return关键字</p>\n<p>如果要返回值，那么这行代码的运算结果就会作为整个函数的返回值返回。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item =&gt; item*<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果默认返回值是一个对象，那么这个对象必须加()</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo = <span class=\"function\">() =&gt;</span> (&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;hi&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-3箭头函数里面的this\"><a href=\"#3-3箭头函数里面的this\" class=\"headerlink\" title=\"3.3箭头函数里面的this\"></a>3.3箭头函数里面的this</h1><p>在普通函数里面是有this标识符的，但是在箭头函数里面没有this。</p>\n<p>通过apply来调用还是没有this指向。</p>\n<p>查找this的规则与查找变量一样：该作用域没有this，就往上一层作用域查找，直到查找到this。</p>\n<h1 id=\"4-面试题\"><a href=\"#4-面试题\" class=\"headerlink\" title=\"4.面试题\"></a>4.面试题</h1><h2 id=\"4-1-面试题1\"><a href=\"#4-1-面试题1\" class=\"headerlink\" title=\"4.1 面试题1\"></a>4.1 面试题1</h2><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31e5753ac9ea42aabcc556d153159d6f~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>第一个<code>sss()</code>调用时默认调用，所以this为默认绑定，this指向window，所以最后的值为window。</p>\n<p>第二个函数调用为隐式绑定，所以this指向person,所以最后结果为person。</p>\n<p>第三个同样也是隐式绑定，所以结果一样。</p>\n<p>第四个是间接函数引用，返回结果为一个独立的函数，this指向window，结果为window。</p>\n<h2 id=\"4-2-面试题2\"><a href=\"#4-2-面试题2\" class=\"headerlink\" title=\"4.2 面试题2\"></a>4.2 面试题2</h2><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d54305f0ee74ea09f8d4f7bfce063f4~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de309ac813814f4f874fbe6ec45cbd7c~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>22行： 隐式绑定，this指向person1,结果person1</li>\n<li>23行：显式绑定，this指向person2，结果为person2</li>\n<li>25行：箭头函数没有this，去上层作用域查找，所以this绑定为window，最后结果为window</li>\n<li>26行：箭头函数没有this，去上层作用域查找，所以this绑定为window，最后结果为window</li>\n<li>28行：首先执行person1.foo3()，这个函数结果为一个函数，后面接着执行返回的这个函数，所以为函数单独调用，为默认绑定，this指向window，所以最后结果为window。</li>\n<li>29行：虽然foo3()的this绑定为person2，但是后面返回的一个函数，还是相当于是函数独立调用，所以最后this还是指向window，结果为window。</li>\n<li>30行：最后调用的函数为显式绑定，this指向person2，所以最后结果为person2。</li>\n<li>32行：因为foo4()函数返回的结果函数没有this指向，所以会往上层作用域查找，最后this指向person1，结果为person1</li>\n<li>33行：foo4()的this被显式绑定为person2，所以返回结果箭头函数this也指向person2，结果为person2.</li>\n<li>34行：因为箭头函数没有this，所以显式绑定不起作用，所以最后结果为person1。</li>\n</ul>\n<h2 id=\"4-3-面试题3\"><a href=\"#4-3-面试题3\" class=\"headerlink\" title=\"4.3 面试题3\"></a>4.3 面试题3</h2><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4640f4437b848c2a21724c96b0d821c~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcb6b6392ca4271a3d35e246ddd6342~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>new执行步骤：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d28c5e3c5534e7fbdfb72cc1147fcc7~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>new操作符运行示意图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee986bc7381140c7ab9549d8219154bb~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>22行： 隐式绑定，结果为person1。</li>\n<li>23行：显式绑定到person2，结果为person2。</li>\n<li>25行：上层作用域查找，查找到person1</li>\n<li>26行：箭头函数没有this，显式绑定失效，所以还是person1</li>\n<li>28行：独立函数调用，默认绑定，window</li>\n<li>29行：还是独立函数调用，默认绑定，结果为window</li>\n<li>30行：显式绑定为person2，结果为person2</li>\n<li>32行：箭头函数没有this，往上层查找，所以为foo4()的this，foo4()this指向person1，所以结果为person1</li>\n<li>33行：foo4()this显式绑定为person2，所以最后结果为person2</li>\n<li>34行：箭头函数没有this，显式绑定失效，所以结果还是为person1</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"函数中的this\"><a href=\"#函数中的this\" class=\"headerlink\" title=\"函数中的this\"></a>函数中的this</h1><ul>\n<li>函数调用时，JavaScript或默认给this绑定一个值</li>\n<li>this的绑定与定义的位置没有关系</li>\n<li>this的绑定与调用方式以及调用的位置有关系</li>\n<li>this是在运行时被绑定的</li>\n</ul>\n<h1 id=\"1-this的绑定规则\"><a href=\"#1-this的绑定规则\" class=\"headerlink\" title=\"1.this的绑定规则\"></a>1.this的绑定规则</h1><ol>\n<li>默认绑定</li>\n<li>隐式绑定</li>\n<li>显示绑定</li>\n<li>new绑定</li>\n</ol>\n<h2 id=\"1-1默认绑定\"><a href=\"#1-1默认绑定\" class=\"headerlink\" title=\"1.1默认绑定\"></a>1.1默认绑定</h2><ol>\n<li>普通函数被独立调用</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>(); <span class=\"comment\">// windows</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>函数定义在对象中，但是被独立调用</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">bar</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> baz = obj.<span class=\"property\">bar</span>;</span><br><span class=\"line\"><span class=\"title function_\">baz</span>(); <span class=\"comment\">// window</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>严格模式下，独立调用的函数this指向undefined</li>\n</ol>\n<h2 id=\"1-2-隐式绑定\"><a href=\"#1-2-隐式绑定\" class=\"headerlink\" title=\"1.2 隐式绑定\"></a>1.2 隐式绑定</h2><p>通过某个对象进行调用</p>\n<p>也就是函数调用位置是某个对象发起的函数调用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">baz</span>: foo,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"title function_\">baz</span>(); <span class=\"comment\">// obj</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>隐式绑定有一个前提条件</strong></p>\n<ul>\n<li>必须在调用对象内部有一个对函数的引用（比如一个属性）</li>\n<li>如果没有这样的引用，在调用的时候，就会报找不到该函数的错误</li>\n<li>通过这个引用，间接将this绑定到了这个对象上</li>\n</ul>\n<h2 id=\"1-3-通过new绑定\"><a href=\"#1-3-通过new绑定\" class=\"headerlink\" title=\"1.3 通过new绑定\"></a>1.3 通过new绑定</h2><p>new会经过以下几个阶段:</p>\n<ol>\n<li>创建新的空对象</li>\n<li>将this指向这个空对象</li>\n<li>执行函数体重的代码</li>\n<li>没有显示返回非空对象时，默认返回这个对象</li>\n</ol>\n<h2 id=\"1-4-显示绑定\"><a href=\"#1-4-显示绑定\" class=\"headerlink\" title=\"1.4 显示绑定\"></a>1.4 显示绑定</h2><p>如果我们不希望在对象内部包含这个函数的引用，同时又希望在该函数上进行强制调用该函数。</p>\n<p>我们可以使用apply与call方法 </p>\n<ul>\n<li>这两个方法第一个参数都是为一个对象<ul>\n<li>这个对象就是给this准备IDE</li>\n<li>在调用你这个函数时，会将this绑定到传入的这个对象身上</li>\n</ul>\n</li>\n<li>后面的参数：apply为数组，call为参数列表</li>\n</ul>\n<p>比如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.<span class=\"title function_\">aply</span>(obj,[<span class=\"string\">&quot;as&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">4</span>]);</span><br><span class=\"line\">foo.<span class=\"title function_\">call</span>(obj,<span class=\"string\">&quot;as&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果想要将一个函数总是显示绑定到一个对象上，我们可以使用bind方法。</p>\n<ul>\n<li>bind方法，bind()方法创建一个新的绑定函数</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.<span class=\"title function_\">bind</span>(obj);</span><br></pre></td></tr></table></figure>\n\n<p>bind函数传入参数的方式与call是一样的。</p>\n<h2 id=\"1-5-内置函数的this绑定\"><a href=\"#1-5-内置函数的this绑定\" class=\"headerlink\" title=\"1.5 内置函数的this绑定\"></a>1.5 内置函数的this绑定</h2><ol>\n<li><p>定时器</p>\n<p> 定时器的this绑定为window。</p>\n</li>\n<li><p>事件监听</p>\n</li>\n<li><p>forEach</p>\n<p> forEach默认绑定为window，你也可以在forEach第二个参数中传入要绑定的this对象。</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = [<span class=\"string\">&quot;avx&quot;</span>,<span class=\"string\">&quot;asd&quot;</span>,<span class=\"string\">&quot;fgd&quot;</span>];</span><br><span class=\"line\">names.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">&#125;,obj)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-6-几种绑定规则的优先级\"><a href=\"#1-6-几种绑定规则的优先级\" class=\"headerlink\" title=\"1.6 几种绑定规则的优先级\"></a>1.6 几种绑定规则的优先级</h2><ul>\n<li>默认规则的优先级最低</li>\n<li>显示绑定的优先级高于隐式绑定</li>\n<li>new绑定高于隐式绑定</li>\n<li>new不可以appLy&#x2F;call一起使用</li>\n<li>new的优先级高于bind</li>\n<li>bind的优先级高于apply&#x2F;call</li>\n</ul>\n<p>new &gt; bind &gt; apply&#x2F;call &gt; 隐式绑定 &gt; 默认绑定</p>\n<h1 id=\"2-this规则之外-忽略显示绑定\"><a href=\"#2-this规则之外-忽略显示绑定\" class=\"headerlink\" title=\"2.this规则之外-忽略显示绑定\"></a>2.this规则之外-忽略显示绑定</h1><ul>\n<li>如果在显示绑定中，传入一个null或者undefined,那么该这个显示绑定失效，使用默认规则</li>\n<li>创建一个函数的间接引用，这种情况使用默认绑定规则。</li>\n</ul>\n<h1 id=\"3-箭头函数\"><a href=\"#3-箭头函数\" class=\"headerlink\" title=\"3.箭头函数\"></a>3.箭头函数</h1><p>箭头函数是ES6之后新增的一种编写函数的方法。</p>\n<ul>\n<li>箭头函数不会绑定this。arguments属性</li>\n<li>箭头函数不能作为构造函数䣂使用（不能和new一起使用，报错）</li>\n</ul>\n<h2 id=\"3-1-箭头函数的写法\"><a href=\"#3-1-箭头函数的写法\" class=\"headerlink\" title=\"3.1 箭头函数的写法\"></a>3.1 箭头函数的写法</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(参数列表) =&gt; &#123;</span><br><span class=\"line\">\t函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-箭头函数的编写优化（简写）\"><a href=\"#3-2-箭头函数的编写优化（简写）\" class=\"headerlink\" title=\"3.2 箭头函数的编写优化（简写）\"></a>3.2 箭头函数的编写优化（简写）</h2><ul>\n<li>如果箭头函数只有一个参数，那么小括号可以省略</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果函数体只有一行代码，可以省略大括号</p>\n<p>  并且这行代码的返回值会作为整个函数的返回值</p>\n  <figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item =&gt; consloe.<span class=\"title function_\">log</span>(item);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>注意</strong></p>\n<p>这一行代码中不能包含return关键字</p>\n<p>如果要返回值，那么这行代码的运算结果就会作为整个函数的返回值返回。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item =&gt; item*<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果默认返回值是一个对象，那么这个对象必须加()</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo = <span class=\"function\">() =&gt;</span> (&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;hi&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-3箭头函数里面的this\"><a href=\"#3-3箭头函数里面的this\" class=\"headerlink\" title=\"3.3箭头函数里面的this\"></a>3.3箭头函数里面的this</h1><p>在普通函数里面是有this标识符的，但是在箭头函数里面没有this。</p>\n<p>通过apply来调用还是没有this指向。</p>\n<p>查找this的规则与查找变量一样：该作用域没有this，就往上一层作用域查找，直到查找到this。</p>\n<h1 id=\"4-面试题\"><a href=\"#4-面试题\" class=\"headerlink\" title=\"4.面试题\"></a>4.面试题</h1><h2 id=\"4-1-面试题1\"><a href=\"#4-1-面试题1\" class=\"headerlink\" title=\"4.1 面试题1\"></a>4.1 面试题1</h2><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31e5753ac9ea42aabcc556d153159d6f~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>第一个<code>sss()</code>调用时默认调用，所以this为默认绑定，this指向window，所以最后的值为window。</p>\n<p>第二个函数调用为隐式绑定，所以this指向person,所以最后结果为person。</p>\n<p>第三个同样也是隐式绑定，所以结果一样。</p>\n<p>第四个是间接函数引用，返回结果为一个独立的函数，this指向window，结果为window。</p>\n<h2 id=\"4-2-面试题2\"><a href=\"#4-2-面试题2\" class=\"headerlink\" title=\"4.2 面试题2\"></a>4.2 面试题2</h2><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d54305f0ee74ea09f8d4f7bfce063f4~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de309ac813814f4f874fbe6ec45cbd7c~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>22行： 隐式绑定，this指向person1,结果person1</li>\n<li>23行：显式绑定，this指向person2，结果为person2</li>\n<li>25行：箭头函数没有this，去上层作用域查找，所以this绑定为window，最后结果为window</li>\n<li>26行：箭头函数没有this，去上层作用域查找，所以this绑定为window，最后结果为window</li>\n<li>28行：首先执行person1.foo3()，这个函数结果为一个函数，后面接着执行返回的这个函数，所以为函数单独调用，为默认绑定，this指向window，所以最后结果为window。</li>\n<li>29行：虽然foo3()的this绑定为person2，但是后面返回的一个函数，还是相当于是函数独立调用，所以最后this还是指向window，结果为window。</li>\n<li>30行：最后调用的函数为显式绑定，this指向person2，所以最后结果为person2。</li>\n<li>32行：因为foo4()函数返回的结果函数没有this指向，所以会往上层作用域查找，最后this指向person1，结果为person1</li>\n<li>33行：foo4()的this被显式绑定为person2，所以返回结果箭头函数this也指向person2，结果为person2.</li>\n<li>34行：因为箭头函数没有this，所以显式绑定不起作用，所以最后结果为person1。</li>\n</ul>\n<h2 id=\"4-3-面试题3\"><a href=\"#4-3-面试题3\" class=\"headerlink\" title=\"4.3 面试题3\"></a>4.3 面试题3</h2><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4640f4437b848c2a21724c96b0d821c~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcb6b6392ca4271a3d35e246ddd6342~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>new执行步骤：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d28c5e3c5534e7fbdfb72cc1147fcc7~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>new操作符运行示意图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee986bc7381140c7ab9549d8219154bb~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>22行： 隐式绑定，结果为person1。</li>\n<li>23行：显式绑定到person2，结果为person2。</li>\n<li>25行：上层作用域查找，查找到person1</li>\n<li>26行：箭头函数没有this，显式绑定失效，所以还是person1</li>\n<li>28行：独立函数调用，默认绑定，window</li>\n<li>29行：还是独立函数调用，默认绑定，结果为window</li>\n<li>30行：显式绑定为person2，结果为person2</li>\n<li>32行：箭头函数没有this，往上层查找，所以为foo4()的this，foo4()this指向person1，所以结果为person1</li>\n<li>33行：foo4()this显式绑定为person2，所以最后结果为person2</li>\n<li>34行：箭头函数没有this，显式绑定失效，所以结果还是为person1</li>\n</ul>\n"},{"title":"JS中函数","date":"2022-08-19T16:00:00.000Z","_content":"# JavaScript中的函数\n\n## 函数的定义\n\n我们经常在脚本的很多地方需要使用到同样的代码，这时候就需要使用函数来实现。  \n比如在访客登陆，退出等情况下，我们需要弹出提示框，这时候就需要使用函数来实现。  \n函数本质就是将一段代码给封装起来，作为一个功能，这样就可以重复使用。  \n\n函数是程序的主要“构件模块”，函数可以调用很多次，这就大大减少了代码量。\n\n## 函数的声明\n\n先举一个例子：\n\n    function showMessage() {\n        alert(\"Hello World!\");\n    }\n\n我们来解释一下，首先定义函数的时候，出现function关键字，接着是函数名，然后是一对括号（括号里面可以写上需要传进函数的参数，没有则可以不写），括号里面的参数使用逗号隔开，然后花括号里面的部分就是函数体。 \n\n**调用函数：**\n在调用函数的时候，函数名后面跟着一对括号，括号里面可以写上需要传进函数的参数，没有则可以不写。  \n比如：\n\n    showMessage();\n\n## 局部变量\n\n函数内部的变量，只在函数内部有效，函数执行完毕后，变量就会被销毁。  \n例如：  \n\n    function showMessage() {\n        var msg = \"Hello World!\";\n        alert(msg);\n    }\n\n    showMessage();\n\n    console.log(msg); // 报错，msg is not defined\n\n在上面的代码中，我们在函数内部定一个msg变量，函数执行完毕后，msg变量就会被销毁。可以看到在函数内部，该变量可以正常使用，但是在函数外部，却报错了。因为我们没有定义该变量，所以报错。\n\n## 全局变量\n\n全局变量又称外部变量，是在函数外部定义的变量，可以在函数内部使用。  \n函数对全局变量拥有全部的访问权限。这就意味着函数可以修改外部变量\n\n**注意：**\n1.只有在没有局部变量的情况下，函数才会使用外部变量；如果函数内部定义了局部变量，那么函数内部的局部变量会覆盖外部变量（外部变量被忽略）。  \n2.在任何函数之外声明的变量，都被成为全局变量。  \n3.全局变量在任意函数中都是课件的（除非被局部变量屏蔽，也就是局部变量的名字和全局变量的一样）。  \n4.全局变量的作用域是整个程序。\n\n## 默认值\n\n前面我们提到，有些函数是需要传值进去的，这个传进去的值，我们把它叫做参数；如果一个函数需要传参，但是我们没有提供值的话，那么在函数对应的变量那里，它的值会变成undefined。  \n例如：\n\n    function showMessage(msg) {\n        alert(msg);\n    }\n\n    showMessage(); // undefined  \n\n在JavaScript中，每次函数在没有带个别参数的情况下，默认参数会被计算出来。\n\n## 返回值\n\n函数可以将一个值返回到调用代码中作为结果，这个被返回的值就被称作返回值。  \n例如：\n\n    function sum(a,b){\n        result = a+b;\n        return result;\n    }\n    let result1 = sum(1,2);\n    alert(result1)//3\n\n这段代码就是两数相加，最后将结果返回。\n\n**注意：**\n\n- return这个指令可以在函数的任意位置（不一定要在函数末尾）；但是当函数执行到这里的时候，函数将会停止，并且将结果返回给调用代码（例如上面例子里的result1）。\n\n- 函数中可以不止出现一个return，比如在条件分支语句中，可以根据分支情况书写多个return语句。\n\n- return语句不一定不许有返回值，也就是说，return语句可以是空的，但是这会导致执行到return语句时函数立即退出。\n\n- 空值的return或者没有return语句的函数，他们最后返回回去的都是undefined。\n\n- 不要在return与返回值之间添加新行，因为在JavaScript中默认会在return后面加上分号，如果你添加了新行，那么就意味着你在return语句结束之后书写的代码（这是会被浏览器忽略的）。","source":"_posts/JavaScript/函数.md","raw":"---\ntitle: JS中函数\ndate: 2022-8-20 \ntags: 前端\ncategories: JavaScript\n---\n# JavaScript中的函数\n\n## 函数的定义\n\n我们经常在脚本的很多地方需要使用到同样的代码，这时候就需要使用函数来实现。  \n比如在访客登陆，退出等情况下，我们需要弹出提示框，这时候就需要使用函数来实现。  \n函数本质就是将一段代码给封装起来，作为一个功能，这样就可以重复使用。  \n\n函数是程序的主要“构件模块”，函数可以调用很多次，这就大大减少了代码量。\n\n## 函数的声明\n\n先举一个例子：\n\n    function showMessage() {\n        alert(\"Hello World!\");\n    }\n\n我们来解释一下，首先定义函数的时候，出现function关键字，接着是函数名，然后是一对括号（括号里面可以写上需要传进函数的参数，没有则可以不写），括号里面的参数使用逗号隔开，然后花括号里面的部分就是函数体。 \n\n**调用函数：**\n在调用函数的时候，函数名后面跟着一对括号，括号里面可以写上需要传进函数的参数，没有则可以不写。  \n比如：\n\n    showMessage();\n\n## 局部变量\n\n函数内部的变量，只在函数内部有效，函数执行完毕后，变量就会被销毁。  \n例如：  \n\n    function showMessage() {\n        var msg = \"Hello World!\";\n        alert(msg);\n    }\n\n    showMessage();\n\n    console.log(msg); // 报错，msg is not defined\n\n在上面的代码中，我们在函数内部定一个msg变量，函数执行完毕后，msg变量就会被销毁。可以看到在函数内部，该变量可以正常使用，但是在函数外部，却报错了。因为我们没有定义该变量，所以报错。\n\n## 全局变量\n\n全局变量又称外部变量，是在函数外部定义的变量，可以在函数内部使用。  \n函数对全局变量拥有全部的访问权限。这就意味着函数可以修改外部变量\n\n**注意：**\n1.只有在没有局部变量的情况下，函数才会使用外部变量；如果函数内部定义了局部变量，那么函数内部的局部变量会覆盖外部变量（外部变量被忽略）。  \n2.在任何函数之外声明的变量，都被成为全局变量。  \n3.全局变量在任意函数中都是课件的（除非被局部变量屏蔽，也就是局部变量的名字和全局变量的一样）。  \n4.全局变量的作用域是整个程序。\n\n## 默认值\n\n前面我们提到，有些函数是需要传值进去的，这个传进去的值，我们把它叫做参数；如果一个函数需要传参，但是我们没有提供值的话，那么在函数对应的变量那里，它的值会变成undefined。  \n例如：\n\n    function showMessage(msg) {\n        alert(msg);\n    }\n\n    showMessage(); // undefined  \n\n在JavaScript中，每次函数在没有带个别参数的情况下，默认参数会被计算出来。\n\n## 返回值\n\n函数可以将一个值返回到调用代码中作为结果，这个被返回的值就被称作返回值。  \n例如：\n\n    function sum(a,b){\n        result = a+b;\n        return result;\n    }\n    let result1 = sum(1,2);\n    alert(result1)//3\n\n这段代码就是两数相加，最后将结果返回。\n\n**注意：**\n\n- return这个指令可以在函数的任意位置（不一定要在函数末尾）；但是当函数执行到这里的时候，函数将会停止，并且将结果返回给调用代码（例如上面例子里的result1）。\n\n- 函数中可以不止出现一个return，比如在条件分支语句中，可以根据分支情况书写多个return语句。\n\n- return语句不一定不许有返回值，也就是说，return语句可以是空的，但是这会导致执行到return语句时函数立即退出。\n\n- 空值的return或者没有return语句的函数，他们最后返回回去的都是undefined。\n\n- 不要在return与返回值之间添加新行，因为在JavaScript中默认会在return后面加上分号，如果你添加了新行，那么就意味着你在return语句结束之后书写的代码（这是会被浏览器忽略的）。","slug":"JavaScript/函数","published":1,"updated":"2023-01-08T11:34:30.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmim00599kbm5we7eycm","content":"<h1 id=\"JavaScript中的函数\"><a href=\"#JavaScript中的函数\" class=\"headerlink\" title=\"JavaScript中的函数\"></a>JavaScript中的函数</h1><h2 id=\"函数的定义\"><a href=\"#函数的定义\" class=\"headerlink\" title=\"函数的定义\"></a>函数的定义</h2><p>我们经常在脚本的很多地方需要使用到同样的代码，这时候就需要使用函数来实现。<br>比如在访客登陆，退出等情况下，我们需要弹出提示框，这时候就需要使用函数来实现。<br>函数本质就是将一段代码给封装起来，作为一个功能，这样就可以重复使用。  </p>\n<p>函数是程序的主要“构件模块”，函数可以调用很多次，这就大大减少了代码量。</p>\n<h2 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h2><p>先举一个例子：</p>\n<pre><code>function showMessage() &#123;\n    alert(&quot;Hello World!&quot;);\n&#125;\n</code></pre>\n<p>我们来解释一下，首先定义函数的时候，出现function关键字，接着是函数名，然后是一对括号（括号里面可以写上需要传进函数的参数，没有则可以不写），括号里面的参数使用逗号隔开，然后花括号里面的部分就是函数体。 </p>\n<p><strong>调用函数：</strong><br>在调用函数的时候，函数名后面跟着一对括号，括号里面可以写上需要传进函数的参数，没有则可以不写。<br>比如：</p>\n<pre><code>showMessage();\n</code></pre>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>函数内部的变量，只在函数内部有效，函数执行完毕后，变量就会被销毁。<br>例如：  </p>\n<pre><code>function showMessage() &#123;\n    var msg = &quot;Hello World!&quot;;\n    alert(msg);\n&#125;\n\nshowMessage();\n\nconsole.log(msg); // 报错，msg is not defined\n</code></pre>\n<p>在上面的代码中，我们在函数内部定一个msg变量，函数执行完毕后，msg变量就会被销毁。可以看到在函数内部，该变量可以正常使用，但是在函数外部，却报错了。因为我们没有定义该变量，所以报错。</p>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><p>全局变量又称外部变量，是在函数外部定义的变量，可以在函数内部使用。<br>函数对全局变量拥有全部的访问权限。这就意味着函数可以修改外部变量</p>\n<p><strong>注意：</strong><br>1.只有在没有局部变量的情况下，函数才会使用外部变量；如果函数内部定义了局部变量，那么函数内部的局部变量会覆盖外部变量（外部变量被忽略）。<br>2.在任何函数之外声明的变量，都被成为全局变量。<br>3.全局变量在任意函数中都是课件的（除非被局部变量屏蔽，也就是局部变量的名字和全局变量的一样）。<br>4.全局变量的作用域是整个程序。</p>\n<h2 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h2><p>前面我们提到，有些函数是需要传值进去的，这个传进去的值，我们把它叫做参数；如果一个函数需要传参，但是我们没有提供值的话，那么在函数对应的变量那里，它的值会变成undefined。<br>例如：</p>\n<pre><code>function showMessage(msg) &#123;\n    alert(msg);\n&#125;\n\nshowMessage(); // undefined  \n</code></pre>\n<p>在JavaScript中，每次函数在没有带个别参数的情况下，默认参数会被计算出来。</p>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>函数可以将一个值返回到调用代码中作为结果，这个被返回的值就被称作返回值。<br>例如：</p>\n<pre><code>function sum(a,b)&#123;\n    result = a+b;\n    return result;\n&#125;\nlet result1 = sum(1,2);\nalert(result1)//3\n</code></pre>\n<p>这段代码就是两数相加，最后将结果返回。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>return这个指令可以在函数的任意位置（不一定要在函数末尾）；但是当函数执行到这里的时候，函数将会停止，并且将结果返回给调用代码（例如上面例子里的result1）。</p>\n</li>\n<li><p>函数中可以不止出现一个return，比如在条件分支语句中，可以根据分支情况书写多个return语句。</p>\n</li>\n<li><p>return语句不一定不许有返回值，也就是说，return语句可以是空的，但是这会导致执行到return语句时函数立即退出。</p>\n</li>\n<li><p>空值的return或者没有return语句的函数，他们最后返回回去的都是undefined。</p>\n</li>\n<li><p>不要在return与返回值之间添加新行，因为在JavaScript中默认会在return后面加上分号，如果你添加了新行，那么就意味着你在return语句结束之后书写的代码（这是会被浏览器忽略的）。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript中的函数\"><a href=\"#JavaScript中的函数\" class=\"headerlink\" title=\"JavaScript中的函数\"></a>JavaScript中的函数</h1><h2 id=\"函数的定义\"><a href=\"#函数的定义\" class=\"headerlink\" title=\"函数的定义\"></a>函数的定义</h2><p>我们经常在脚本的很多地方需要使用到同样的代码，这时候就需要使用函数来实现。<br>比如在访客登陆，退出等情况下，我们需要弹出提示框，这时候就需要使用函数来实现。<br>函数本质就是将一段代码给封装起来，作为一个功能，这样就可以重复使用。  </p>\n<p>函数是程序的主要“构件模块”，函数可以调用很多次，这就大大减少了代码量。</p>\n<h2 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h2><p>先举一个例子：</p>\n<pre><code>function showMessage() &#123;\n    alert(&quot;Hello World!&quot;);\n&#125;\n</code></pre>\n<p>我们来解释一下，首先定义函数的时候，出现function关键字，接着是函数名，然后是一对括号（括号里面可以写上需要传进函数的参数，没有则可以不写），括号里面的参数使用逗号隔开，然后花括号里面的部分就是函数体。 </p>\n<p><strong>调用函数：</strong><br>在调用函数的时候，函数名后面跟着一对括号，括号里面可以写上需要传进函数的参数，没有则可以不写。<br>比如：</p>\n<pre><code>showMessage();\n</code></pre>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>函数内部的变量，只在函数内部有效，函数执行完毕后，变量就会被销毁。<br>例如：  </p>\n<pre><code>function showMessage() &#123;\n    var msg = &quot;Hello World!&quot;;\n    alert(msg);\n&#125;\n\nshowMessage();\n\nconsole.log(msg); // 报错，msg is not defined\n</code></pre>\n<p>在上面的代码中，我们在函数内部定一个msg变量，函数执行完毕后，msg变量就会被销毁。可以看到在函数内部，该变量可以正常使用，但是在函数外部，却报错了。因为我们没有定义该变量，所以报错。</p>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><p>全局变量又称外部变量，是在函数外部定义的变量，可以在函数内部使用。<br>函数对全局变量拥有全部的访问权限。这就意味着函数可以修改外部变量</p>\n<p><strong>注意：</strong><br>1.只有在没有局部变量的情况下，函数才会使用外部变量；如果函数内部定义了局部变量，那么函数内部的局部变量会覆盖外部变量（外部变量被忽略）。<br>2.在任何函数之外声明的变量，都被成为全局变量。<br>3.全局变量在任意函数中都是课件的（除非被局部变量屏蔽，也就是局部变量的名字和全局变量的一样）。<br>4.全局变量的作用域是整个程序。</p>\n<h2 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h2><p>前面我们提到，有些函数是需要传值进去的，这个传进去的值，我们把它叫做参数；如果一个函数需要传参，但是我们没有提供值的话，那么在函数对应的变量那里，它的值会变成undefined。<br>例如：</p>\n<pre><code>function showMessage(msg) &#123;\n    alert(msg);\n&#125;\n\nshowMessage(); // undefined  \n</code></pre>\n<p>在JavaScript中，每次函数在没有带个别参数的情况下，默认参数会被计算出来。</p>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>函数可以将一个值返回到调用代码中作为结果，这个被返回的值就被称作返回值。<br>例如：</p>\n<pre><code>function sum(a,b)&#123;\n    result = a+b;\n    return result;\n&#125;\nlet result1 = sum(1,2);\nalert(result1)//3\n</code></pre>\n<p>这段代码就是两数相加，最后将结果返回。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>return这个指令可以在函数的任意位置（不一定要在函数末尾）；但是当函数执行到这里的时候，函数将会停止，并且将结果返回给调用代码（例如上面例子里的result1）。</p>\n</li>\n<li><p>函数中可以不止出现一个return，比如在条件分支语句中，可以根据分支情况书写多个return语句。</p>\n</li>\n<li><p>return语句不一定不许有返回值，也就是说，return语句可以是空的，但是这会导致执行到return语句时函数立即退出。</p>\n</li>\n<li><p>空值的return或者没有return语句的函数，他们最后返回回去的都是undefined。</p>\n</li>\n<li><p>不要在return与返回值之间添加新行，因为在JavaScript中默认会在return后面加上分号，如果你添加了新行，那么就意味着你在return语句结束之后书写的代码（这是会被浏览器忽略的）。</p>\n</li>\n</ul>\n"},{"title":"函数表达式和函数声明的区别","date":"2022-08-21T01:58:00.000Z","_content":"# 函数表达式和函数声明的区别\n\n## 语法上\n\n- 函数声明：函数声明是在代码里面作为单独的一段代码，并且在函数末尾是没有分号的。  \n\n例如：  \n\n    function sum(a,b){\n        return a+b;\n    }\n\n- 函数表达式：函数表达四是在一个表达式中或者另一个语法结构中创建的函数，此时函数是作为语句的一部分，并且此时函数表达式最后是有分号的。\n\n例如：\n\n    let sum = funcition(a,b){\n        return a+b;\n    };\n\n这就是函数表达式与函数声明在语法上的区别。\n\n## 作用时间\n\n要想知道他们俩在作用时间上的区别，我们就需要知道这个函数什么时候开始创建。  \n\n首先，函数表达式，函数表达式这个函数，是**需要代码执行到这一行代码的时候，函数才开始被创建**，从现在开始，这个函数才可以使用（分配、调用等等）。\n\n其次函数声明，**在函数声明被定义之前，他就可以被调用**，也就是说函数声明，我们可以在代码的任何地方调用这个函数。","source":"_posts/JavaScript/函数表达式和函数声明的区别.md","raw":"---\ntitle: 函数表达式和函数声明的区别\ndate: 2022-8-21 9:58\ntags: [前端]\ncategories: [JavaScript]\n---\n# 函数表达式和函数声明的区别\n\n## 语法上\n\n- 函数声明：函数声明是在代码里面作为单独的一段代码，并且在函数末尾是没有分号的。  \n\n例如：  \n\n    function sum(a,b){\n        return a+b;\n    }\n\n- 函数表达式：函数表达四是在一个表达式中或者另一个语法结构中创建的函数，此时函数是作为语句的一部分，并且此时函数表达式最后是有分号的。\n\n例如：\n\n    let sum = funcition(a,b){\n        return a+b;\n    };\n\n这就是函数表达式与函数声明在语法上的区别。\n\n## 作用时间\n\n要想知道他们俩在作用时间上的区别，我们就需要知道这个函数什么时候开始创建。  \n\n首先，函数表达式，函数表达式这个函数，是**需要代码执行到这一行代码的时候，函数才开始被创建**，从现在开始，这个函数才可以使用（分配、调用等等）。\n\n其次函数声明，**在函数声明被定义之前，他就可以被调用**，也就是说函数声明，我们可以在代码的任何地方调用这个函数。","slug":"JavaScript/函数表达式和函数声明的区别","published":1,"updated":"2023-01-08T11:39:28.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmio005c9kbm28349iv3","content":"<h1 id=\"函数表达式和函数声明的区别\"><a href=\"#函数表达式和函数声明的区别\" class=\"headerlink\" title=\"函数表达式和函数声明的区别\"></a>函数表达式和函数声明的区别</h1><h2 id=\"语法上\"><a href=\"#语法上\" class=\"headerlink\" title=\"语法上\"></a>语法上</h2><ul>\n<li>函数声明：函数声明是在代码里面作为单独的一段代码，并且在函数末尾是没有分号的。</li>\n</ul>\n<p>例如：  </p>\n<pre><code>function sum(a,b)&#123;\n    return a+b;\n&#125;\n</code></pre>\n<ul>\n<li>函数表达式：函数表达四是在一个表达式中或者另一个语法结构中创建的函数，此时函数是作为语句的一部分，并且此时函数表达式最后是有分号的。</li>\n</ul>\n<p>例如：</p>\n<pre><code>let sum = funcition(a,b)&#123;\n    return a+b;\n&#125;;\n</code></pre>\n<p>这就是函数表达式与函数声明在语法上的区别。</p>\n<h2 id=\"作用时间\"><a href=\"#作用时间\" class=\"headerlink\" title=\"作用时间\"></a>作用时间</h2><p>要想知道他们俩在作用时间上的区别，我们就需要知道这个函数什么时候开始创建。  </p>\n<p>首先，函数表达式，函数表达式这个函数，是<strong>需要代码执行到这一行代码的时候，函数才开始被创建</strong>，从现在开始，这个函数才可以使用（分配、调用等等）。</p>\n<p>其次函数声明，<strong>在函数声明被定义之前，他就可以被调用</strong>，也就是说函数声明，我们可以在代码的任何地方调用这个函数。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"函数表达式和函数声明的区别\"><a href=\"#函数表达式和函数声明的区别\" class=\"headerlink\" title=\"函数表达式和函数声明的区别\"></a>函数表达式和函数声明的区别</h1><h2 id=\"语法上\"><a href=\"#语法上\" class=\"headerlink\" title=\"语法上\"></a>语法上</h2><ul>\n<li>函数声明：函数声明是在代码里面作为单独的一段代码，并且在函数末尾是没有分号的。</li>\n</ul>\n<p>例如：  </p>\n<pre><code>function sum(a,b)&#123;\n    return a+b;\n&#125;\n</code></pre>\n<ul>\n<li>函数表达式：函数表达四是在一个表达式中或者另一个语法结构中创建的函数，此时函数是作为语句的一部分，并且此时函数表达式最后是有分号的。</li>\n</ul>\n<p>例如：</p>\n<pre><code>let sum = funcition(a,b)&#123;\n    return a+b;\n&#125;;\n</code></pre>\n<p>这就是函数表达式与函数声明在语法上的区别。</p>\n<h2 id=\"作用时间\"><a href=\"#作用时间\" class=\"headerlink\" title=\"作用时间\"></a>作用时间</h2><p>要想知道他们俩在作用时间上的区别，我们就需要知道这个函数什么时候开始创建。  </p>\n<p>首先，函数表达式，函数表达式这个函数，是<strong>需要代码执行到这一行代码的时候，函数才开始被创建</strong>，从现在开始，这个函数才可以使用（分配、调用等等）。</p>\n<p>其次函数声明，<strong>在函数声明被定义之前，他就可以被调用</strong>，也就是说函数声明，我们可以在代码的任何地方调用这个函数。</p>\n"},{"title":"删除事件（解绑事件）","date":"2022-09-21T16:00:00.000Z","_content":"\n# 删除事件（解绑事件）\n\n在实际开发中，我们可能会遇到这样一个问题，在用户点击某一个按钮之后，我们希望那个按钮所绑定的事件是一次性的，这个时候就需要在事件处理函数执行完毕之后将这个事件给删除掉。\n\n这个时候就需要用到删除事件的方法了。\n\n## 方法监听注册方式\n\n### 1. removeEventListener\n\n    eventTarget.removeEventListener(type, listener, [useCapture]);\n\n*参数*\n\n- type：事件类型，比如click，mouseover等等\n- listener：事件处理函数\n- userCapture：是否捕获阶段执行 true：捕获阶段执行 false：冒泡阶段执行\n\n### 2. detachEvent\n\n    eventTarget.detachEvent(type, listener);\n\n*参数*\n\n* type：事件类型，比如click，mouseover等等\n* listener：事件处理函数\n\n## 传统注册方式\n\n### eventTarget.onxxx = null\n\n    eventTarget.onxxx = null;\n\n*参数*\n\n- eventTarget：事件目标\n- onxxx：事件类型，比如onclick，onmouseover等等\n","source":"_posts/JavaScript/删除事件（解绑事件）.md","raw":"---\ntitle: 删除事件（解绑事件）\ndate: 2022-9-22\ntags: [前端]\ncategories: [JavaScript]\n---\n\n# 删除事件（解绑事件）\n\n在实际开发中，我们可能会遇到这样一个问题，在用户点击某一个按钮之后，我们希望那个按钮所绑定的事件是一次性的，这个时候就需要在事件处理函数执行完毕之后将这个事件给删除掉。\n\n这个时候就需要用到删除事件的方法了。\n\n## 方法监听注册方式\n\n### 1. removeEventListener\n\n    eventTarget.removeEventListener(type, listener, [useCapture]);\n\n*参数*\n\n- type：事件类型，比如click，mouseover等等\n- listener：事件处理函数\n- userCapture：是否捕获阶段执行 true：捕获阶段执行 false：冒泡阶段执行\n\n### 2. detachEvent\n\n    eventTarget.detachEvent(type, listener);\n\n*参数*\n\n* type：事件类型，比如click，mouseover等等\n* listener：事件处理函数\n\n## 传统注册方式\n\n### eventTarget.onxxx = null\n\n    eventTarget.onxxx = null;\n\n*参数*\n\n- eventTarget：事件目标\n- onxxx：事件类型，比如onclick，onmouseover等等\n","slug":"JavaScript/删除事件（解绑事件）","published":1,"updated":"2023-01-08T11:57:57.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmip005f9kbm8gqm8e9y","content":"<h1 id=\"删除事件（解绑事件）\"><a href=\"#删除事件（解绑事件）\" class=\"headerlink\" title=\"删除事件（解绑事件）\"></a>删除事件（解绑事件）</h1><p>在实际开发中，我们可能会遇到这样一个问题，在用户点击某一个按钮之后，我们希望那个按钮所绑定的事件是一次性的，这个时候就需要在事件处理函数执行完毕之后将这个事件给删除掉。</p>\n<p>这个时候就需要用到删除事件的方法了。</p>\n<h2 id=\"方法监听注册方式\"><a href=\"#方法监听注册方式\" class=\"headerlink\" title=\"方法监听注册方式\"></a>方法监听注册方式</h2><h3 id=\"1-removeEventListener\"><a href=\"#1-removeEventListener\" class=\"headerlink\" title=\"1. removeEventListener\"></a>1. removeEventListener</h3><pre><code>eventTarget.removeEventListener(type, listener, [useCapture]);\n</code></pre>\n<p><em>参数</em></p>\n<ul>\n<li>type：事件类型，比如click，mouseover等等</li>\n<li>listener：事件处理函数</li>\n<li>userCapture：是否捕获阶段执行 true：捕获阶段执行 false：冒泡阶段执行</li>\n</ul>\n<h3 id=\"2-detachEvent\"><a href=\"#2-detachEvent\" class=\"headerlink\" title=\"2. detachEvent\"></a>2. detachEvent</h3><pre><code>eventTarget.detachEvent(type, listener);\n</code></pre>\n<p><em>参数</em></p>\n<ul>\n<li>type：事件类型，比如click，mouseover等等</li>\n<li>listener：事件处理函数</li>\n</ul>\n<h2 id=\"传统注册方式\"><a href=\"#传统注册方式\" class=\"headerlink\" title=\"传统注册方式\"></a>传统注册方式</h2><h3 id=\"eventTarget-onxxx-x3D-null\"><a href=\"#eventTarget-onxxx-x3D-null\" class=\"headerlink\" title=\"eventTarget.onxxx &#x3D; null\"></a>eventTarget.onxxx &#x3D; null</h3><pre><code>eventTarget.onxxx = null;\n</code></pre>\n<p><em>参数</em></p>\n<ul>\n<li>eventTarget：事件目标</li>\n<li>onxxx：事件类型，比如onclick，onmouseover等等</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"删除事件（解绑事件）\"><a href=\"#删除事件（解绑事件）\" class=\"headerlink\" title=\"删除事件（解绑事件）\"></a>删除事件（解绑事件）</h1><p>在实际开发中，我们可能会遇到这样一个问题，在用户点击某一个按钮之后，我们希望那个按钮所绑定的事件是一次性的，这个时候就需要在事件处理函数执行完毕之后将这个事件给删除掉。</p>\n<p>这个时候就需要用到删除事件的方法了。</p>\n<h2 id=\"方法监听注册方式\"><a href=\"#方法监听注册方式\" class=\"headerlink\" title=\"方法监听注册方式\"></a>方法监听注册方式</h2><h3 id=\"1-removeEventListener\"><a href=\"#1-removeEventListener\" class=\"headerlink\" title=\"1. removeEventListener\"></a>1. removeEventListener</h3><pre><code>eventTarget.removeEventListener(type, listener, [useCapture]);\n</code></pre>\n<p><em>参数</em></p>\n<ul>\n<li>type：事件类型，比如click，mouseover等等</li>\n<li>listener：事件处理函数</li>\n<li>userCapture：是否捕获阶段执行 true：捕获阶段执行 false：冒泡阶段执行</li>\n</ul>\n<h3 id=\"2-detachEvent\"><a href=\"#2-detachEvent\" class=\"headerlink\" title=\"2. detachEvent\"></a>2. detachEvent</h3><pre><code>eventTarget.detachEvent(type, listener);\n</code></pre>\n<p><em>参数</em></p>\n<ul>\n<li>type：事件类型，比如click，mouseover等等</li>\n<li>listener：事件处理函数</li>\n</ul>\n<h2 id=\"传统注册方式\"><a href=\"#传统注册方式\" class=\"headerlink\" title=\"传统注册方式\"></a>传统注册方式</h2><h3 id=\"eventTarget-onxxx-x3D-null\"><a href=\"#eventTarget-onxxx-x3D-null\" class=\"headerlink\" title=\"eventTarget.onxxx &#x3D; null\"></a>eventTarget.onxxx &#x3D; null</h3><pre><code>eventTarget.onxxx = null;\n</code></pre>\n<p><em>参数</em></p>\n<ul>\n<li>eventTarget：事件目标</li>\n<li>onxxx：事件类型，比如onclick，onmouseover等等</li>\n</ul>\n"},{"title":"如何提高写作水平","date":"2022-09-25T16:00:00.000Z","_content":"# 如何提高写作水平\n\n## 前言\n\n当今越来越多的人开始通过写技术文章来提高自己的水平。写技术文章有很多好处，对于有着许多经验的大佬来说写文章可以进一步提高自己的技术；对于一些初学者来说，歇一歇技术文章可以进一步巩固自己的知识。\n\n当今这些技术文章，有很多问题：标题党，泛泛而谈。标题党是我最讨厌的一类，我觉得写技术文章为了博取眼球，我可以理解，但是里面的内容至少要让读者觉得不会那么无趣。对于文章的内容应该精准定位，而不是让读者在那里听你吹牛，要让读者有真正的收获。\n\n在听了王老师的讲课之后，我的写作思路感觉明朗了许多。\n\n## 如何引入读者\n\n我们高中语文课的时候，老师就教过我们如何吸引读者的眼球，让读者有往下阅读的欲望。我们可以通过叙事的方法，像讲故事一样把读者引入我们的文章，毕竟有谁不想听到故事的结尾呢。\n\n通过一种讲故事的方法勾起读者往下阅读的欲望，此时我们还可以通过一种幽默的语气来讲述，这样一下就拉近了我们与读者的距离。\n\n但是要记住，我们写的是技术类的文章，而不是讲故事，所以把读者引入的这一部分不可以太长，否则读者会觉得你在讲故事，而不是讲技术。要知道我们的读者主要目的是想要看我们的技术文章。\n\n## 正文部分\n\n正文部分我们不可以太突兀，每一个部分尽量要有良好的过渡。我们可以通过一些小的例子来引入我们的正文，这样可以让读者更好的理解我们的文章。\n\n比如讲述一个你在实际操作中遇到的困难，最后通过我们下面要讲的这个技术将这个困难完美解决，这样读者就会觉得你的文章很有用，而不是一些泛泛而谈的文章。\n\n还有在写文章的时候，我们还要站在读者的角度，想一想当读者在阅读这篇文章的时候，会产生怎么样的疑问，我们就可以在文章里面解答这些疑问。这不仅仅体现了你对技术的了解，还可以引起读者的共鸣。\n\n讲解内容的时候，尽量使用直白的话语，不要弯弯绕绕或者使用生僻词汇。要让读者易于理解，要让读者看完我们的文章之后有所收获。\n\n## 结尾部分\n\n在文章结尾的时候，我们可以对前面我们所讲述的内容做一个总结，这样可以让读者对我们的文章有一个整体的了解。我们还可以在文章结尾处给出一些参考资料，这样读者如果想要深入了解的话，就可以通过这些参考资料来进行学习。\n\n在结尾的时候，我们还可以通过一些幽默的语气来结束我们的文章，这样可以让读者对我们的文章有一个美好的印象。或者结尾的时候我们使用一些网络热梗之类的词语，加深我们这篇文章在读者脑海中的印象。","source":"_posts/JavaScript/如何提高写作水平.md","raw":"---\ntitle: 如何提高写作水平\ndate: 2022-9-26\ntags: [随笔]\ncategories: [随笔]\n---\n# 如何提高写作水平\n\n## 前言\n\n当今越来越多的人开始通过写技术文章来提高自己的水平。写技术文章有很多好处，对于有着许多经验的大佬来说写文章可以进一步提高自己的技术；对于一些初学者来说，歇一歇技术文章可以进一步巩固自己的知识。\n\n当今这些技术文章，有很多问题：标题党，泛泛而谈。标题党是我最讨厌的一类，我觉得写技术文章为了博取眼球，我可以理解，但是里面的内容至少要让读者觉得不会那么无趣。对于文章的内容应该精准定位，而不是让读者在那里听你吹牛，要让读者有真正的收获。\n\n在听了王老师的讲课之后，我的写作思路感觉明朗了许多。\n\n## 如何引入读者\n\n我们高中语文课的时候，老师就教过我们如何吸引读者的眼球，让读者有往下阅读的欲望。我们可以通过叙事的方法，像讲故事一样把读者引入我们的文章，毕竟有谁不想听到故事的结尾呢。\n\n通过一种讲故事的方法勾起读者往下阅读的欲望，此时我们还可以通过一种幽默的语气来讲述，这样一下就拉近了我们与读者的距离。\n\n但是要记住，我们写的是技术类的文章，而不是讲故事，所以把读者引入的这一部分不可以太长，否则读者会觉得你在讲故事，而不是讲技术。要知道我们的读者主要目的是想要看我们的技术文章。\n\n## 正文部分\n\n正文部分我们不可以太突兀，每一个部分尽量要有良好的过渡。我们可以通过一些小的例子来引入我们的正文，这样可以让读者更好的理解我们的文章。\n\n比如讲述一个你在实际操作中遇到的困难，最后通过我们下面要讲的这个技术将这个困难完美解决，这样读者就会觉得你的文章很有用，而不是一些泛泛而谈的文章。\n\n还有在写文章的时候，我们还要站在读者的角度，想一想当读者在阅读这篇文章的时候，会产生怎么样的疑问，我们就可以在文章里面解答这些疑问。这不仅仅体现了你对技术的了解，还可以引起读者的共鸣。\n\n讲解内容的时候，尽量使用直白的话语，不要弯弯绕绕或者使用生僻词汇。要让读者易于理解，要让读者看完我们的文章之后有所收获。\n\n## 结尾部分\n\n在文章结尾的时候，我们可以对前面我们所讲述的内容做一个总结，这样可以让读者对我们的文章有一个整体的了解。我们还可以在文章结尾处给出一些参考资料，这样读者如果想要深入了解的话，就可以通过这些参考资料来进行学习。\n\n在结尾的时候，我们还可以通过一些幽默的语气来结束我们的文章，这样可以让读者对我们的文章有一个美好的印象。或者结尾的时候我们使用一些网络热梗之类的词语，加深我们这篇文章在读者脑海中的印象。","slug":"JavaScript/如何提高写作水平","published":1,"updated":"2023-01-08T11:53:36.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmiq005i9kbm2pkb0u50","content":"<h1 id=\"如何提高写作水平\"><a href=\"#如何提高写作水平\" class=\"headerlink\" title=\"如何提高写作水平\"></a>如何提高写作水平</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当今越来越多的人开始通过写技术文章来提高自己的水平。写技术文章有很多好处，对于有着许多经验的大佬来说写文章可以进一步提高自己的技术；对于一些初学者来说，歇一歇技术文章可以进一步巩固自己的知识。</p>\n<p>当今这些技术文章，有很多问题：标题党，泛泛而谈。标题党是我最讨厌的一类，我觉得写技术文章为了博取眼球，我可以理解，但是里面的内容至少要让读者觉得不会那么无趣。对于文章的内容应该精准定位，而不是让读者在那里听你吹牛，要让读者有真正的收获。</p>\n<p>在听了王老师的讲课之后，我的写作思路感觉明朗了许多。</p>\n<h2 id=\"如何引入读者\"><a href=\"#如何引入读者\" class=\"headerlink\" title=\"如何引入读者\"></a>如何引入读者</h2><p>我们高中语文课的时候，老师就教过我们如何吸引读者的眼球，让读者有往下阅读的欲望。我们可以通过叙事的方法，像讲故事一样把读者引入我们的文章，毕竟有谁不想听到故事的结尾呢。</p>\n<p>通过一种讲故事的方法勾起读者往下阅读的欲望，此时我们还可以通过一种幽默的语气来讲述，这样一下就拉近了我们与读者的距离。</p>\n<p>但是要记住，我们写的是技术类的文章，而不是讲故事，所以把读者引入的这一部分不可以太长，否则读者会觉得你在讲故事，而不是讲技术。要知道我们的读者主要目的是想要看我们的技术文章。</p>\n<h2 id=\"正文部分\"><a href=\"#正文部分\" class=\"headerlink\" title=\"正文部分\"></a>正文部分</h2><p>正文部分我们不可以太突兀，每一个部分尽量要有良好的过渡。我们可以通过一些小的例子来引入我们的正文，这样可以让读者更好的理解我们的文章。</p>\n<p>比如讲述一个你在实际操作中遇到的困难，最后通过我们下面要讲的这个技术将这个困难完美解决，这样读者就会觉得你的文章很有用，而不是一些泛泛而谈的文章。</p>\n<p>还有在写文章的时候，我们还要站在读者的角度，想一想当读者在阅读这篇文章的时候，会产生怎么样的疑问，我们就可以在文章里面解答这些疑问。这不仅仅体现了你对技术的了解，还可以引起读者的共鸣。</p>\n<p>讲解内容的时候，尽量使用直白的话语，不要弯弯绕绕或者使用生僻词汇。要让读者易于理解，要让读者看完我们的文章之后有所收获。</p>\n<h2 id=\"结尾部分\"><a href=\"#结尾部分\" class=\"headerlink\" title=\"结尾部分\"></a>结尾部分</h2><p>在文章结尾的时候，我们可以对前面我们所讲述的内容做一个总结，这样可以让读者对我们的文章有一个整体的了解。我们还可以在文章结尾处给出一些参考资料，这样读者如果想要深入了解的话，就可以通过这些参考资料来进行学习。</p>\n<p>在结尾的时候，我们还可以通过一些幽默的语气来结束我们的文章，这样可以让读者对我们的文章有一个美好的印象。或者结尾的时候我们使用一些网络热梗之类的词语，加深我们这篇文章在读者脑海中的印象。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"如何提高写作水平\"><a href=\"#如何提高写作水平\" class=\"headerlink\" title=\"如何提高写作水平\"></a>如何提高写作水平</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当今越来越多的人开始通过写技术文章来提高自己的水平。写技术文章有很多好处，对于有着许多经验的大佬来说写文章可以进一步提高自己的技术；对于一些初学者来说，歇一歇技术文章可以进一步巩固自己的知识。</p>\n<p>当今这些技术文章，有很多问题：标题党，泛泛而谈。标题党是我最讨厌的一类，我觉得写技术文章为了博取眼球，我可以理解，但是里面的内容至少要让读者觉得不会那么无趣。对于文章的内容应该精准定位，而不是让读者在那里听你吹牛，要让读者有真正的收获。</p>\n<p>在听了王老师的讲课之后，我的写作思路感觉明朗了许多。</p>\n<h2 id=\"如何引入读者\"><a href=\"#如何引入读者\" class=\"headerlink\" title=\"如何引入读者\"></a>如何引入读者</h2><p>我们高中语文课的时候，老师就教过我们如何吸引读者的眼球，让读者有往下阅读的欲望。我们可以通过叙事的方法，像讲故事一样把读者引入我们的文章，毕竟有谁不想听到故事的结尾呢。</p>\n<p>通过一种讲故事的方法勾起读者往下阅读的欲望，此时我们还可以通过一种幽默的语气来讲述，这样一下就拉近了我们与读者的距离。</p>\n<p>但是要记住，我们写的是技术类的文章，而不是讲故事，所以把读者引入的这一部分不可以太长，否则读者会觉得你在讲故事，而不是讲技术。要知道我们的读者主要目的是想要看我们的技术文章。</p>\n<h2 id=\"正文部分\"><a href=\"#正文部分\" class=\"headerlink\" title=\"正文部分\"></a>正文部分</h2><p>正文部分我们不可以太突兀，每一个部分尽量要有良好的过渡。我们可以通过一些小的例子来引入我们的正文，这样可以让读者更好的理解我们的文章。</p>\n<p>比如讲述一个你在实际操作中遇到的困难，最后通过我们下面要讲的这个技术将这个困难完美解决，这样读者就会觉得你的文章很有用，而不是一些泛泛而谈的文章。</p>\n<p>还有在写文章的时候，我们还要站在读者的角度，想一想当读者在阅读这篇文章的时候，会产生怎么样的疑问，我们就可以在文章里面解答这些疑问。这不仅仅体现了你对技术的了解，还可以引起读者的共鸣。</p>\n<p>讲解内容的时候，尽量使用直白的话语，不要弯弯绕绕或者使用生僻词汇。要让读者易于理解，要让读者看完我们的文章之后有所收获。</p>\n<h2 id=\"结尾部分\"><a href=\"#结尾部分\" class=\"headerlink\" title=\"结尾部分\"></a>结尾部分</h2><p>在文章结尾的时候，我们可以对前面我们所讲述的内容做一个总结，这样可以让读者对我们的文章有一个整体的了解。我们还可以在文章结尾处给出一些参考资料，这样读者如果想要深入了解的话，就可以通过这些参考资料来进行学习。</p>\n<p>在结尾的时候，我们还可以通过一些幽默的语气来结束我们的文章，这样可以让读者对我们的文章有一个美好的印象。或者结尾的时候我们使用一些网络热梗之类的词语，加深我们这篇文章在读者脑海中的印象。</p>\n"},{"title":"原始值与引用值","date":"2022-08-19T16:00:00.000Z","_content":"# 原始值与引用值  \n\n在JavaScript中包含两种不同类型的数据：原始值和引用值\n**原始值** ：是指不包含任何引用的值（简单值），比如数字、字符串、布尔值、null和undefined。\n**引用值** ：是指包含了一个引用的值，比如对象、数组、函数和方法。\n\n## 1.动态属性\n\n原始值和引用值，都是定义一个变量之后然后我们给它赋值，在赋值这一部分基本差不多，但是在赋值之后，我们可以对这个变量（值）做什么，就会有很大的不同。  \n\n首先，对于引用值而言，我们可以对它的属性做什么，比如添加、删除、修改、查看等等。\n\n    let person = new Object();\n    person.name = \"海绵宝宝\";\n    console.log(person.name); // 海绵宝宝\n\n在这里我们先创建了一个对象（引用值），然后我们将其保存在person这个变量中，随后给该对象添加了一个name属性，并给它赋值`海绵宝宝`。最后我们输出这个对象的属性。\n\n但是在原始值中，不能存在属性，我们添加属性之后，会报错。\n\n    let name = \"海绵宝宝\"；\n    name.weighta = 120;\n    console.log(name.weight);//报错（undefined）\n\n这里我们本想给name定义一个weight属性，并赋值为120，但是最后我们输出的时候，发现该属性不生效。\n\n*注意：* 原始值类型的初始化可以只使用原始字面量形式，但是如果使用的new关键字，那么JavaScript就会创建一个object类型的实例。\n\n## 2.存储方式\n\n引用值和原始值的存储方式也有不同，在我们内存中，有堆和栈两种模式，堆就类似于把一堆数据放在一起，每个数据都有他们的编号；而栈呢，就类似于是排队一般，每一个数据同样也有他们的编号。  \n\n在原始值中是，他们的数据都存储在栈中，通过变量名索引找到对应的值。\n\n在引用值中，就会有不同，引用值首先会在栈中存储相应数据的地址，根据地址从而找到在堆中的数据。\n\n这就是原始值和引用值在存储方式上的区别。\n\n## 3.复制值\n\n原始值与引用值除了在存储方式上不一样，在原始值和引用值通过变量赋值的时候，也会有不同。\n\n**原始值：**\n\n在原始值通过变量赋值到另一个变量的时候，原始值的数据会被赋值到另一个位置。也就是说，两个变量他们所存储的数据，在栈里面是两个完全不同的位置，他们通过各自的索引找到自己对应的数据。\n\n例如：\n\n    let num1 = 10;\n    let num2 = num1;\n\n*复制之前*\n|      |     |\n| ---- | --- |\n|      |     |\n| num1 | 10  |\n*复制之后*\n|      |     |\n| ---- | --- |\n| num2 |     |\n| num1 | 5   |\n\n我们把上面的表格想象成一个栈就很好理解了。赋值之后的变量指向的并不是之前变量的地址，这也就意味着这两个变量可以独立使用，互不干扰。\n\n**引用值：**\n\n在引用值的赋值中，例如我们将boj1的值复制给obj2,那么首先，浏览器会将obj1对象数据在堆里面的地址（存储在栈中），复制给obj2,这一点和前面原始值的复制机制是一样的，都是在栈中另外找一个内存空间上来存放obj2用数据位于堆的地址；第二步，通过这个堆的地址，obj1和obj2访问堆里面的数据，但是这里不一样，堆里面的数据没有被之前那样重新找一个地址存放，也就是说，两个变量最后访问到堆里面的数据是同一个地址。\n\n也就是说，其实这两个变量，指向的是同一个对象，只是他们在栈里面存储地址的位置不同而已，但是他们在栈里面存储的数据（也就是对象在堆里面的地址）是一样的。\n","source":"_posts/JavaScript/原始值与引用值.md","raw":"---\ntitle: 原始值与引用值\ntags: [前端]\ndate: 2022-8-20\ncategories: [JavaScript]\n---\n# 原始值与引用值  \n\n在JavaScript中包含两种不同类型的数据：原始值和引用值\n**原始值** ：是指不包含任何引用的值（简单值），比如数字、字符串、布尔值、null和undefined。\n**引用值** ：是指包含了一个引用的值，比如对象、数组、函数和方法。\n\n## 1.动态属性\n\n原始值和引用值，都是定义一个变量之后然后我们给它赋值，在赋值这一部分基本差不多，但是在赋值之后，我们可以对这个变量（值）做什么，就会有很大的不同。  \n\n首先，对于引用值而言，我们可以对它的属性做什么，比如添加、删除、修改、查看等等。\n\n    let person = new Object();\n    person.name = \"海绵宝宝\";\n    console.log(person.name); // 海绵宝宝\n\n在这里我们先创建了一个对象（引用值），然后我们将其保存在person这个变量中，随后给该对象添加了一个name属性，并给它赋值`海绵宝宝`。最后我们输出这个对象的属性。\n\n但是在原始值中，不能存在属性，我们添加属性之后，会报错。\n\n    let name = \"海绵宝宝\"；\n    name.weighta = 120;\n    console.log(name.weight);//报错（undefined）\n\n这里我们本想给name定义一个weight属性，并赋值为120，但是最后我们输出的时候，发现该属性不生效。\n\n*注意：* 原始值类型的初始化可以只使用原始字面量形式，但是如果使用的new关键字，那么JavaScript就会创建一个object类型的实例。\n\n## 2.存储方式\n\n引用值和原始值的存储方式也有不同，在我们内存中，有堆和栈两种模式，堆就类似于把一堆数据放在一起，每个数据都有他们的编号；而栈呢，就类似于是排队一般，每一个数据同样也有他们的编号。  \n\n在原始值中是，他们的数据都存储在栈中，通过变量名索引找到对应的值。\n\n在引用值中，就会有不同，引用值首先会在栈中存储相应数据的地址，根据地址从而找到在堆中的数据。\n\n这就是原始值和引用值在存储方式上的区别。\n\n## 3.复制值\n\n原始值与引用值除了在存储方式上不一样，在原始值和引用值通过变量赋值的时候，也会有不同。\n\n**原始值：**\n\n在原始值通过变量赋值到另一个变量的时候，原始值的数据会被赋值到另一个位置。也就是说，两个变量他们所存储的数据，在栈里面是两个完全不同的位置，他们通过各自的索引找到自己对应的数据。\n\n例如：\n\n    let num1 = 10;\n    let num2 = num1;\n\n*复制之前*\n|      |     |\n| ---- | --- |\n|      |     |\n| num1 | 10  |\n*复制之后*\n|      |     |\n| ---- | --- |\n| num2 |     |\n| num1 | 5   |\n\n我们把上面的表格想象成一个栈就很好理解了。赋值之后的变量指向的并不是之前变量的地址，这也就意味着这两个变量可以独立使用，互不干扰。\n\n**引用值：**\n\n在引用值的赋值中，例如我们将boj1的值复制给obj2,那么首先，浏览器会将obj1对象数据在堆里面的地址（存储在栈中），复制给obj2,这一点和前面原始值的复制机制是一样的，都是在栈中另外找一个内存空间上来存放obj2用数据位于堆的地址；第二步，通过这个堆的地址，obj1和obj2访问堆里面的数据，但是这里不一样，堆里面的数据没有被之前那样重新找一个地址存放，也就是说，两个变量最后访问到堆里面的数据是同一个地址。\n\n也就是说，其实这两个变量，指向的是同一个对象，只是他们在栈里面存储地址的位置不同而已，但是他们在栈里面存储的数据（也就是对象在堆里面的地址）是一样的。\n","slug":"JavaScript/原始值与引用值","published":1,"updated":"2023-01-09T11:45:10.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmir005l9kbm3g2lhj63","content":"<h1 id=\"原始值与引用值\"><a href=\"#原始值与引用值\" class=\"headerlink\" title=\"原始值与引用值\"></a>原始值与引用值</h1><p>在JavaScript中包含两种不同类型的数据：原始值和引用值<br><strong>原始值</strong> ：是指不包含任何引用的值（简单值），比如数字、字符串、布尔值、null和undefined。<br><strong>引用值</strong> ：是指包含了一个引用的值，比如对象、数组、函数和方法。</p>\n<h2 id=\"1-动态属性\"><a href=\"#1-动态属性\" class=\"headerlink\" title=\"1.动态属性\"></a>1.动态属性</h2><p>原始值和引用值，都是定义一个变量之后然后我们给它赋值，在赋值这一部分基本差不多，但是在赋值之后，我们可以对这个变量（值）做什么，就会有很大的不同。  </p>\n<p>首先，对于引用值而言，我们可以对它的属性做什么，比如添加、删除、修改、查看等等。</p>\n<pre><code>let person = new Object();\nperson.name = &quot;海绵宝宝&quot;;\nconsole.log(person.name); // 海绵宝宝\n</code></pre>\n<p>在这里我们先创建了一个对象（引用值），然后我们将其保存在person这个变量中，随后给该对象添加了一个name属性，并给它赋值<code>海绵宝宝</code>。最后我们输出这个对象的属性。</p>\n<p>但是在原始值中，不能存在属性，我们添加属性之后，会报错。</p>\n<pre><code>let name = &quot;海绵宝宝&quot;；\nname.weighta = 120;\nconsole.log(name.weight);//报错（undefined）\n</code></pre>\n<p>这里我们本想给name定义一个weight属性，并赋值为120，但是最后我们输出的时候，发现该属性不生效。</p>\n<p><em>注意：</em> 原始值类型的初始化可以只使用原始字面量形式，但是如果使用的new关键字，那么JavaScript就会创建一个object类型的实例。</p>\n<h2 id=\"2-存储方式\"><a href=\"#2-存储方式\" class=\"headerlink\" title=\"2.存储方式\"></a>2.存储方式</h2><p>引用值和原始值的存储方式也有不同，在我们内存中，有堆和栈两种模式，堆就类似于把一堆数据放在一起，每个数据都有他们的编号；而栈呢，就类似于是排队一般，每一个数据同样也有他们的编号。  </p>\n<p>在原始值中是，他们的数据都存储在栈中，通过变量名索引找到对应的值。</p>\n<p>在引用值中，就会有不同，引用值首先会在栈中存储相应数据的地址，根据地址从而找到在堆中的数据。</p>\n<p>这就是原始值和引用值在存储方式上的区别。</p>\n<h2 id=\"3-复制值\"><a href=\"#3-复制值\" class=\"headerlink\" title=\"3.复制值\"></a>3.复制值</h2><p>原始值与引用值除了在存储方式上不一样，在原始值和引用值通过变量赋值的时候，也会有不同。</p>\n<p><strong>原始值：</strong></p>\n<p>在原始值通过变量赋值到另一个变量的时候，原始值的数据会被赋值到另一个位置。也就是说，两个变量他们所存储的数据，在栈里面是两个完全不同的位置，他们通过各自的索引找到自己对应的数据。</p>\n<p>例如：</p>\n<pre><code>let num1 = 10;\nlet num2 = num1;\n</code></pre>\n<p><em>复制之前</em></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>num1</td>\n<td>10</td>\n</tr>\n<tr>\n<td><em>复制之后</em></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>—-</td>\n<td>—</td>\n</tr>\n<tr>\n<td>num2</td>\n<td></td>\n</tr>\n<tr>\n<td>num1</td>\n<td>5</td>\n</tr>\n</tbody></table>\n<p>我们把上面的表格想象成一个栈就很好理解了。赋值之后的变量指向的并不是之前变量的地址，这也就意味着这两个变量可以独立使用，互不干扰。</p>\n<p><strong>引用值：</strong></p>\n<p>在引用值的赋值中，例如我们将boj1的值复制给obj2,那么首先，浏览器会将obj1对象数据在堆里面的地址（存储在栈中），复制给obj2,这一点和前面原始值的复制机制是一样的，都是在栈中另外找一个内存空间上来存放obj2用数据位于堆的地址；第二步，通过这个堆的地址，obj1和obj2访问堆里面的数据，但是这里不一样，堆里面的数据没有被之前那样重新找一个地址存放，也就是说，两个变量最后访问到堆里面的数据是同一个地址。</p>\n<p>也就是说，其实这两个变量，指向的是同一个对象，只是他们在栈里面存储地址的位置不同而已，但是他们在栈里面存储的数据（也就是对象在堆里面的地址）是一样的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"原始值与引用值\"><a href=\"#原始值与引用值\" class=\"headerlink\" title=\"原始值与引用值\"></a>原始值与引用值</h1><p>在JavaScript中包含两种不同类型的数据：原始值和引用值<br><strong>原始值</strong> ：是指不包含任何引用的值（简单值），比如数字、字符串、布尔值、null和undefined。<br><strong>引用值</strong> ：是指包含了一个引用的值，比如对象、数组、函数和方法。</p>\n<h2 id=\"1-动态属性\"><a href=\"#1-动态属性\" class=\"headerlink\" title=\"1.动态属性\"></a>1.动态属性</h2><p>原始值和引用值，都是定义一个变量之后然后我们给它赋值，在赋值这一部分基本差不多，但是在赋值之后，我们可以对这个变量（值）做什么，就会有很大的不同。  </p>\n<p>首先，对于引用值而言，我们可以对它的属性做什么，比如添加、删除、修改、查看等等。</p>\n<pre><code>let person = new Object();\nperson.name = &quot;海绵宝宝&quot;;\nconsole.log(person.name); // 海绵宝宝\n</code></pre>\n<p>在这里我们先创建了一个对象（引用值），然后我们将其保存在person这个变量中，随后给该对象添加了一个name属性，并给它赋值<code>海绵宝宝</code>。最后我们输出这个对象的属性。</p>\n<p>但是在原始值中，不能存在属性，我们添加属性之后，会报错。</p>\n<pre><code>let name = &quot;海绵宝宝&quot;；\nname.weighta = 120;\nconsole.log(name.weight);//报错（undefined）\n</code></pre>\n<p>这里我们本想给name定义一个weight属性，并赋值为120，但是最后我们输出的时候，发现该属性不生效。</p>\n<p><em>注意：</em> 原始值类型的初始化可以只使用原始字面量形式，但是如果使用的new关键字，那么JavaScript就会创建一个object类型的实例。</p>\n<h2 id=\"2-存储方式\"><a href=\"#2-存储方式\" class=\"headerlink\" title=\"2.存储方式\"></a>2.存储方式</h2><p>引用值和原始值的存储方式也有不同，在我们内存中，有堆和栈两种模式，堆就类似于把一堆数据放在一起，每个数据都有他们的编号；而栈呢，就类似于是排队一般，每一个数据同样也有他们的编号。  </p>\n<p>在原始值中是，他们的数据都存储在栈中，通过变量名索引找到对应的值。</p>\n<p>在引用值中，就会有不同，引用值首先会在栈中存储相应数据的地址，根据地址从而找到在堆中的数据。</p>\n<p>这就是原始值和引用值在存储方式上的区别。</p>\n<h2 id=\"3-复制值\"><a href=\"#3-复制值\" class=\"headerlink\" title=\"3.复制值\"></a>3.复制值</h2><p>原始值与引用值除了在存储方式上不一样，在原始值和引用值通过变量赋值的时候，也会有不同。</p>\n<p><strong>原始值：</strong></p>\n<p>在原始值通过变量赋值到另一个变量的时候，原始值的数据会被赋值到另一个位置。也就是说，两个变量他们所存储的数据，在栈里面是两个完全不同的位置，他们通过各自的索引找到自己对应的数据。</p>\n<p>例如：</p>\n<pre><code>let num1 = 10;\nlet num2 = num1;\n</code></pre>\n<p><em>复制之前</em></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>num1</td>\n<td>10</td>\n</tr>\n<tr>\n<td><em>复制之后</em></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>—-</td>\n<td>—</td>\n</tr>\n<tr>\n<td>num2</td>\n<td></td>\n</tr>\n<tr>\n<td>num1</td>\n<td>5</td>\n</tr>\n</tbody></table>\n<p>我们把上面的表格想象成一个栈就很好理解了。赋值之后的变量指向的并不是之前变量的地址，这也就意味着这两个变量可以独立使用，互不干扰。</p>\n<p><strong>引用值：</strong></p>\n<p>在引用值的赋值中，例如我们将boj1的值复制给obj2,那么首先，浏览器会将obj1对象数据在堆里面的地址（存储在栈中），复制给obj2,这一点和前面原始值的复制机制是一样的，都是在栈中另外找一个内存空间上来存放obj2用数据位于堆的地址；第二步，通过这个堆的地址，obj1和obj2访问堆里面的数据，但是这里不一样，堆里面的数据没有被之前那样重新找一个地址存放，也就是说，两个变量最后访问到堆里面的数据是同一个地址。</p>\n<p>也就是说，其实这两个变量，指向的是同一个对象，只是他们在栈里面存储地址的位置不同而已，但是他们在栈里面存储的数据（也就是对象在堆里面的地址）是一样的。</p>\n"},{"title":"字符串常用方法","date":"2022-09-27T16:00:00.000Z","_content":"# 字符串常用方法\n\n在这里，我们讲述一下`string`的常见方法，在我们时机开发中，字符串的使用评率是很高的，所以这些常见的方法我们需要记住并且熟练运用。下面我们就来了解字符串有哪些常用的方法吧！\n\n**注意：**\n\n由于字符串的不可变性，所以字符串的所有方法都是返回一个新的字符串，而不是修改原来的字符串。（原来的字符串不变）\n\n## 查找字符串\n\n### `indexOf()`\n\n    value = str.indexOf('要查找的字符串',[查找开始的位置（索引）]);\n\n这个方式是从字符串索引号[0]开始向后面查找，如果找到了，就返回第一个字符的索引号（不会继续向后查找），如果没有找到，就返回-1。\n\n这个方法后面那个查找开始位置为可选参数，如果我们不填写，默认是从索引号[0]开始查找。\n\n那么：\n\n- 如果查找结果返回的是0，说明我们要查找的参数位于字符串的开头。\n- 如果查找结果返回的是-1，说明我们要查找的参数在字符串里面不存在。\n\n*栗子时间：*\n\n    var str = 'hello world';\n    console.log(str.indexOf('hello')); // 0\n    console.log(str.indexOf('world')); // 6\n    console.log(str.indexOf('o',5)); // 7\n    console.log(str.indexOf('world',7)); // -1\n\n### `lastIndexOf()`\n\n    value = str.lastIndexOf('要查找的字符串',[查找开始的位置（索引）]);\n\n这个方法是从字符串的最后一个字符开始向前面查找，如果找到了，就返回第一个字符的索引号（不会继续向前查找），如果没有找到，就返回-1。\n\n这个方法后面那个查找开始位置为可选参数，如果我们不填写，默认是从索引号[0]开始查找。\n\n那么：  \n\n- 如果查找结果返回的是0，说明我们要查找的参数位于字符串的开头。\n- 如果查找结果返回的是-1，说明我们要查找的参数在字符串里面不存在。\n\n*栗子时间：*\n\n    var str = 'hello world';\n    console.log(str.lastIndexOf('hello')); // 0\n    console.log(str.lastIndexOf('world')); // 6\n    console.log(str.lastIndexOf('o',6)); // 4\n    console.log(str.lastIndexOf('world', 7)); // 6\n\n**进阶**\n\n- 通过前面的学习，我们知道了`indexOf()`和`lastIndexOf()`这两个方法，那么我们就可以通过这两个方法来判断一个字符串是否包含另一个字符串了。\n\n    var str = 'hello world';\n    if(str.indexOf('hello') != -1){\n        console.log('包含');\n    }else{\n        console.log('不包含');\n    }\n\n- `indexOf()`和`lastIndexOf()`有一个缺点：它只能返回查找到的第一个字符的索引号，如果我们要查找的字符串在字符串里面出现了多次，那么我们就无法得到它的索引号了。那么我们就可以通过循环的方法来解决这个问题。\n\n    var str = 'hello world oo';\n    var q = str.indexOf('o');\n    while (q <= str.length) {\n        if (str.indexOf('o', q) != -1) {\n            q = str.indexOf('o', q);\n            console.log('o' + q); // 4\n        } else {\n            break;\n        }\n        q++;\n    }\n\n### `search()`\n\n    value = str.search('要查找的字符串');\n\n这个方法是用来查找字符串里面是否包含另一个字符串的，如果找到了，就返回第一个字符的索引号（不会继续向后查找），如果没有找到，就返回-1。\n\n### `include()`\n\n    value = str.include('要查找的字符串',[position]);\n\n这个方法是用来查找字符串里面是否包含另一个字符串的，如果找到了，就返回true，如果没有找到，就返回false。\n\n参数中的`position`，代表我们检索开始的位置，如果不填写，默认是从索引号[0]开始检索；如果指定就从指定位置开始检索。\n\n    let str = 'hello world';\n    console.log(str.include('hello')); // true\n    console.log(str.include('world')); // true\n\n    console.log(str.include('hello',1)); // false\n    console.log(str.include('world',7)); // false\n\n### `startsWith()`&`endsWith()`\n\n    value = str.startsWith('要查找的字符串',[position]);\n\n    value = str.endsWith('要查找的字符串',[position]);\n\n这两个方法是用来判断字符串是否以指定的字符串开头或结尾的，如果是，就返回true，如果不是，就返回false。\n\n**注意：**\n\n这个两个方法中的`position`参数意义是不同的：\n\n- `startsWith()`中的`position`代表我们检索开始的位置，如果不填写，默认是从索引号[0]开始检索，直到字符串末尾；如果指定就从指定位置开始检索，直到字符串末尾。[position,字符串末尾]\n\n- `endsWith()`中的`position`代表我们检索结束的位置，如果不填写，默认是从字符串末尾开始检索，直到索引号[0]；如果指定就从指定位置开始检索，直到索引号[0]。[0,position)\n\n    let str = 'hello world';\n    console.log(str.startsWith('hello')); // true\n    console.log(str.startsWith('world')); // false\n\n    console.log(str.endsWith('hello')); // false\n    console.log(str.endsWith('world')); // true\n\n    console.log(str.startsWith('hello',1)); // false\n    console.log(str.startsWith('world',7)); // false\n\n    console.log(str.endsWith('hello',1)); // false\n    console.log(str.endsWith('world',7)); // false","source":"_posts/JavaScript/字符串常用方法.md","raw":"---\ntitle: 字符串常用方法\ndate: 2022-9-28\ntags: [前端]\ncategories: [JavaScript]\n---\n# 字符串常用方法\n\n在这里，我们讲述一下`string`的常见方法，在我们时机开发中，字符串的使用评率是很高的，所以这些常见的方法我们需要记住并且熟练运用。下面我们就来了解字符串有哪些常用的方法吧！\n\n**注意：**\n\n由于字符串的不可变性，所以字符串的所有方法都是返回一个新的字符串，而不是修改原来的字符串。（原来的字符串不变）\n\n## 查找字符串\n\n### `indexOf()`\n\n    value = str.indexOf('要查找的字符串',[查找开始的位置（索引）]);\n\n这个方式是从字符串索引号[0]开始向后面查找，如果找到了，就返回第一个字符的索引号（不会继续向后查找），如果没有找到，就返回-1。\n\n这个方法后面那个查找开始位置为可选参数，如果我们不填写，默认是从索引号[0]开始查找。\n\n那么：\n\n- 如果查找结果返回的是0，说明我们要查找的参数位于字符串的开头。\n- 如果查找结果返回的是-1，说明我们要查找的参数在字符串里面不存在。\n\n*栗子时间：*\n\n    var str = 'hello world';\n    console.log(str.indexOf('hello')); // 0\n    console.log(str.indexOf('world')); // 6\n    console.log(str.indexOf('o',5)); // 7\n    console.log(str.indexOf('world',7)); // -1\n\n### `lastIndexOf()`\n\n    value = str.lastIndexOf('要查找的字符串',[查找开始的位置（索引）]);\n\n这个方法是从字符串的最后一个字符开始向前面查找，如果找到了，就返回第一个字符的索引号（不会继续向前查找），如果没有找到，就返回-1。\n\n这个方法后面那个查找开始位置为可选参数，如果我们不填写，默认是从索引号[0]开始查找。\n\n那么：  \n\n- 如果查找结果返回的是0，说明我们要查找的参数位于字符串的开头。\n- 如果查找结果返回的是-1，说明我们要查找的参数在字符串里面不存在。\n\n*栗子时间：*\n\n    var str = 'hello world';\n    console.log(str.lastIndexOf('hello')); // 0\n    console.log(str.lastIndexOf('world')); // 6\n    console.log(str.lastIndexOf('o',6)); // 4\n    console.log(str.lastIndexOf('world', 7)); // 6\n\n**进阶**\n\n- 通过前面的学习，我们知道了`indexOf()`和`lastIndexOf()`这两个方法，那么我们就可以通过这两个方法来判断一个字符串是否包含另一个字符串了。\n\n    var str = 'hello world';\n    if(str.indexOf('hello') != -1){\n        console.log('包含');\n    }else{\n        console.log('不包含');\n    }\n\n- `indexOf()`和`lastIndexOf()`有一个缺点：它只能返回查找到的第一个字符的索引号，如果我们要查找的字符串在字符串里面出现了多次，那么我们就无法得到它的索引号了。那么我们就可以通过循环的方法来解决这个问题。\n\n    var str = 'hello world oo';\n    var q = str.indexOf('o');\n    while (q <= str.length) {\n        if (str.indexOf('o', q) != -1) {\n            q = str.indexOf('o', q);\n            console.log('o' + q); // 4\n        } else {\n            break;\n        }\n        q++;\n    }\n\n### `search()`\n\n    value = str.search('要查找的字符串');\n\n这个方法是用来查找字符串里面是否包含另一个字符串的，如果找到了，就返回第一个字符的索引号（不会继续向后查找），如果没有找到，就返回-1。\n\n### `include()`\n\n    value = str.include('要查找的字符串',[position]);\n\n这个方法是用来查找字符串里面是否包含另一个字符串的，如果找到了，就返回true，如果没有找到，就返回false。\n\n参数中的`position`，代表我们检索开始的位置，如果不填写，默认是从索引号[0]开始检索；如果指定就从指定位置开始检索。\n\n    let str = 'hello world';\n    console.log(str.include('hello')); // true\n    console.log(str.include('world')); // true\n\n    console.log(str.include('hello',1)); // false\n    console.log(str.include('world',7)); // false\n\n### `startsWith()`&`endsWith()`\n\n    value = str.startsWith('要查找的字符串',[position]);\n\n    value = str.endsWith('要查找的字符串',[position]);\n\n这两个方法是用来判断字符串是否以指定的字符串开头或结尾的，如果是，就返回true，如果不是，就返回false。\n\n**注意：**\n\n这个两个方法中的`position`参数意义是不同的：\n\n- `startsWith()`中的`position`代表我们检索开始的位置，如果不填写，默认是从索引号[0]开始检索，直到字符串末尾；如果指定就从指定位置开始检索，直到字符串末尾。[position,字符串末尾]\n\n- `endsWith()`中的`position`代表我们检索结束的位置，如果不填写，默认是从字符串末尾开始检索，直到索引号[0]；如果指定就从指定位置开始检索，直到索引号[0]。[0,position)\n\n    let str = 'hello world';\n    console.log(str.startsWith('hello')); // true\n    console.log(str.startsWith('world')); // false\n\n    console.log(str.endsWith('hello')); // false\n    console.log(str.endsWith('world')); // true\n\n    console.log(str.startsWith('hello',1)); // false\n    console.log(str.startsWith('world',7)); // false\n\n    console.log(str.endsWith('hello',1)); // false\n    console.log(str.endsWith('world',7)); // false","slug":"JavaScript/字符串常用方法","published":1,"updated":"2023-01-09T11:47:46.433Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmis005o9kbm5w2hb2mn","content":"<h1 id=\"字符串常用方法\"><a href=\"#字符串常用方法\" class=\"headerlink\" title=\"字符串常用方法\"></a>字符串常用方法</h1><p>在这里，我们讲述一下<code>string</code>的常见方法，在我们时机开发中，字符串的使用评率是很高的，所以这些常见的方法我们需要记住并且熟练运用。下面我们就来了解字符串有哪些常用的方法吧！</p>\n<p><strong>注意：</strong></p>\n<p>由于字符串的不可变性，所以字符串的所有方法都是返回一个新的字符串，而不是修改原来的字符串。（原来的字符串不变）</p>\n<h2 id=\"查找字符串\"><a href=\"#查找字符串\" class=\"headerlink\" title=\"查找字符串\"></a>查找字符串</h2><h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf()\"></a><code>indexOf()</code></h3><pre><code>value = str.indexOf(&#39;要查找的字符串&#39;,[查找开始的位置（索引）]);\n</code></pre>\n<p>这个方式是从字符串索引号[0]开始向后面查找，如果找到了，就返回第一个字符的索引号（不会继续向后查找），如果没有找到，就返回-1。</p>\n<p>这个方法后面那个查找开始位置为可选参数，如果我们不填写，默认是从索引号[0]开始查找。</p>\n<p>那么：</p>\n<ul>\n<li>如果查找结果返回的是0，说明我们要查找的参数位于字符串的开头。</li>\n<li>如果查找结果返回的是-1，说明我们要查找的参数在字符串里面不存在。</li>\n</ul>\n<p><em>栗子时间：</em></p>\n<pre><code>var str = &#39;hello world&#39;;\nconsole.log(str.indexOf(&#39;hello&#39;)); // 0\nconsole.log(str.indexOf(&#39;world&#39;)); // 6\nconsole.log(str.indexOf(&#39;o&#39;,5)); // 7\nconsole.log(str.indexOf(&#39;world&#39;,7)); // -1\n</code></pre>\n<h3 id=\"lastIndexOf\"><a href=\"#lastIndexOf\" class=\"headerlink\" title=\"lastIndexOf()\"></a><code>lastIndexOf()</code></h3><pre><code>value = str.lastIndexOf(&#39;要查找的字符串&#39;,[查找开始的位置（索引）]);\n</code></pre>\n<p>这个方法是从字符串的最后一个字符开始向前面查找，如果找到了，就返回第一个字符的索引号（不会继续向前查找），如果没有找到，就返回-1。</p>\n<p>这个方法后面那个查找开始位置为可选参数，如果我们不填写，默认是从索引号[0]开始查找。</p>\n<p>那么：  </p>\n<ul>\n<li>如果查找结果返回的是0，说明我们要查找的参数位于字符串的开头。</li>\n<li>如果查找结果返回的是-1，说明我们要查找的参数在字符串里面不存在。</li>\n</ul>\n<p><em>栗子时间：</em></p>\n<pre><code>var str = &#39;hello world&#39;;\nconsole.log(str.lastIndexOf(&#39;hello&#39;)); // 0\nconsole.log(str.lastIndexOf(&#39;world&#39;)); // 6\nconsole.log(str.lastIndexOf(&#39;o&#39;,6)); // 4\nconsole.log(str.lastIndexOf(&#39;world&#39;, 7)); // 6\n</code></pre>\n<p><strong>进阶</strong></p>\n<ul>\n<li><p>通过前面的学习，我们知道了<code>indexOf()</code>和<code>lastIndexOf()</code>这两个方法，那么我们就可以通过这两个方法来判断一个字符串是否包含另一个字符串了。</p>\n<p>  var str &#x3D; ‘hello world’;<br>  if(str.indexOf(‘hello’) !&#x3D; -1){<br>  console.log(‘包含’);<br>  }else{<br>  console.log(‘不包含’);<br>  }</p>\n</li>\n<li><p><code>indexOf()</code>和<code>lastIndexOf()</code>有一个缺点：它只能返回查找到的第一个字符的索引号，如果我们要查找的字符串在字符串里面出现了多次，那么我们就无法得到它的索引号了。那么我们就可以通过循环的方法来解决这个问题。</p>\n<p>  var str &#x3D; ‘hello world oo’;<br>  var q &#x3D; str.indexOf(‘o’);<br>  while (q &lt;&#x3D; str.length) {<br>  if (str.indexOf(‘o’, q) !&#x3D; -1) {<br>      q &#x3D; str.indexOf(‘o’, q);<br>      console.log(‘o’ + q); &#x2F;&#x2F; 4<br>  } else {<br>      break;<br>  }<br>  q++;<br>  }</p>\n</li>\n</ul>\n<h3 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a><code>search()</code></h3><pre><code>value = str.search(&#39;要查找的字符串&#39;);\n</code></pre>\n<p>这个方法是用来查找字符串里面是否包含另一个字符串的，如果找到了，就返回第一个字符的索引号（不会继续向后查找），如果没有找到，就返回-1。</p>\n<h3 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include()\"></a><code>include()</code></h3><pre><code>value = str.include(&#39;要查找的字符串&#39;,[position]);\n</code></pre>\n<p>这个方法是用来查找字符串里面是否包含另一个字符串的，如果找到了，就返回true，如果没有找到，就返回false。</p>\n<p>参数中的<code>position</code>，代表我们检索开始的位置，如果不填写，默认是从索引号[0]开始检索；如果指定就从指定位置开始检索。</p>\n<pre><code>let str = &#39;hello world&#39;;\nconsole.log(str.include(&#39;hello&#39;)); // true\nconsole.log(str.include(&#39;world&#39;)); // true\n\nconsole.log(str.include(&#39;hello&#39;,1)); // false\nconsole.log(str.include(&#39;world&#39;,7)); // false\n</code></pre>\n<h3 id=\"startsWith-amp-endsWith\"><a href=\"#startsWith-amp-endsWith\" class=\"headerlink\" title=\"startsWith()&amp;endsWith()\"></a><code>startsWith()</code>&amp;<code>endsWith()</code></h3><pre><code>value = str.startsWith(&#39;要查找的字符串&#39;,[position]);\n\nvalue = str.endsWith(&#39;要查找的字符串&#39;,[position]);\n</code></pre>\n<p>这两个方法是用来判断字符串是否以指定的字符串开头或结尾的，如果是，就返回true，如果不是，就返回false。</p>\n<p><strong>注意：</strong></p>\n<p>这个两个方法中的<code>position</code>参数意义是不同的：</p>\n<ul>\n<li><p><code>startsWith()</code>中的<code>position</code>代表我们检索开始的位置，如果不填写，默认是从索引号[0]开始检索，直到字符串末尾；如果指定就从指定位置开始检索，直到字符串末尾。[position,字符串末尾]</p>\n</li>\n<li><p><code>endsWith()</code>中的<code>position</code>代表我们检索结束的位置，如果不填写，默认是从字符串末尾开始检索，直到索引号[0]；如果指定就从指定位置开始检索，直到索引号[0]。[0,position)</p>\n<p>  let str &#x3D; ‘hello world’;<br>  console.log(str.startsWith(‘hello’)); &#x2F;&#x2F; true<br>  console.log(str.startsWith(‘world’)); &#x2F;&#x2F; false</p>\n<p>  console.log(str.endsWith(‘hello’)); &#x2F;&#x2F; false<br>  console.log(str.endsWith(‘world’)); &#x2F;&#x2F; true</p>\n<p>  console.log(str.startsWith(‘hello’,1)); &#x2F;&#x2F; false<br>  console.log(str.startsWith(‘world’,7)); &#x2F;&#x2F; false</p>\n<p>  console.log(str.endsWith(‘hello’,1)); &#x2F;&#x2F; false<br>  console.log(str.endsWith(‘world’,7)); &#x2F;&#x2F; false</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"字符串常用方法\"><a href=\"#字符串常用方法\" class=\"headerlink\" title=\"字符串常用方法\"></a>字符串常用方法</h1><p>在这里，我们讲述一下<code>string</code>的常见方法，在我们时机开发中，字符串的使用评率是很高的，所以这些常见的方法我们需要记住并且熟练运用。下面我们就来了解字符串有哪些常用的方法吧！</p>\n<p><strong>注意：</strong></p>\n<p>由于字符串的不可变性，所以字符串的所有方法都是返回一个新的字符串，而不是修改原来的字符串。（原来的字符串不变）</p>\n<h2 id=\"查找字符串\"><a href=\"#查找字符串\" class=\"headerlink\" title=\"查找字符串\"></a>查找字符串</h2><h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf()\"></a><code>indexOf()</code></h3><pre><code>value = str.indexOf(&#39;要查找的字符串&#39;,[查找开始的位置（索引）]);\n</code></pre>\n<p>这个方式是从字符串索引号[0]开始向后面查找，如果找到了，就返回第一个字符的索引号（不会继续向后查找），如果没有找到，就返回-1。</p>\n<p>这个方法后面那个查找开始位置为可选参数，如果我们不填写，默认是从索引号[0]开始查找。</p>\n<p>那么：</p>\n<ul>\n<li>如果查找结果返回的是0，说明我们要查找的参数位于字符串的开头。</li>\n<li>如果查找结果返回的是-1，说明我们要查找的参数在字符串里面不存在。</li>\n</ul>\n<p><em>栗子时间：</em></p>\n<pre><code>var str = &#39;hello world&#39;;\nconsole.log(str.indexOf(&#39;hello&#39;)); // 0\nconsole.log(str.indexOf(&#39;world&#39;)); // 6\nconsole.log(str.indexOf(&#39;o&#39;,5)); // 7\nconsole.log(str.indexOf(&#39;world&#39;,7)); // -1\n</code></pre>\n<h3 id=\"lastIndexOf\"><a href=\"#lastIndexOf\" class=\"headerlink\" title=\"lastIndexOf()\"></a><code>lastIndexOf()</code></h3><pre><code>value = str.lastIndexOf(&#39;要查找的字符串&#39;,[查找开始的位置（索引）]);\n</code></pre>\n<p>这个方法是从字符串的最后一个字符开始向前面查找，如果找到了，就返回第一个字符的索引号（不会继续向前查找），如果没有找到，就返回-1。</p>\n<p>这个方法后面那个查找开始位置为可选参数，如果我们不填写，默认是从索引号[0]开始查找。</p>\n<p>那么：  </p>\n<ul>\n<li>如果查找结果返回的是0，说明我们要查找的参数位于字符串的开头。</li>\n<li>如果查找结果返回的是-1，说明我们要查找的参数在字符串里面不存在。</li>\n</ul>\n<p><em>栗子时间：</em></p>\n<pre><code>var str = &#39;hello world&#39;;\nconsole.log(str.lastIndexOf(&#39;hello&#39;)); // 0\nconsole.log(str.lastIndexOf(&#39;world&#39;)); // 6\nconsole.log(str.lastIndexOf(&#39;o&#39;,6)); // 4\nconsole.log(str.lastIndexOf(&#39;world&#39;, 7)); // 6\n</code></pre>\n<p><strong>进阶</strong></p>\n<ul>\n<li><p>通过前面的学习，我们知道了<code>indexOf()</code>和<code>lastIndexOf()</code>这两个方法，那么我们就可以通过这两个方法来判断一个字符串是否包含另一个字符串了。</p>\n<p>  var str &#x3D; ‘hello world’;<br>  if(str.indexOf(‘hello’) !&#x3D; -1){<br>  console.log(‘包含’);<br>  }else{<br>  console.log(‘不包含’);<br>  }</p>\n</li>\n<li><p><code>indexOf()</code>和<code>lastIndexOf()</code>有一个缺点：它只能返回查找到的第一个字符的索引号，如果我们要查找的字符串在字符串里面出现了多次，那么我们就无法得到它的索引号了。那么我们就可以通过循环的方法来解决这个问题。</p>\n<p>  var str &#x3D; ‘hello world oo’;<br>  var q &#x3D; str.indexOf(‘o’);<br>  while (q &lt;&#x3D; str.length) {<br>  if (str.indexOf(‘o’, q) !&#x3D; -1) {<br>      q &#x3D; str.indexOf(‘o’, q);<br>      console.log(‘o’ + q); &#x2F;&#x2F; 4<br>  } else {<br>      break;<br>  }<br>  q++;<br>  }</p>\n</li>\n</ul>\n<h3 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a><code>search()</code></h3><pre><code>value = str.search(&#39;要查找的字符串&#39;);\n</code></pre>\n<p>这个方法是用来查找字符串里面是否包含另一个字符串的，如果找到了，就返回第一个字符的索引号（不会继续向后查找），如果没有找到，就返回-1。</p>\n<h3 id=\"include\"><a href=\"#include\" class=\"headerlink\" title=\"include()\"></a><code>include()</code></h3><pre><code>value = str.include(&#39;要查找的字符串&#39;,[position]);\n</code></pre>\n<p>这个方法是用来查找字符串里面是否包含另一个字符串的，如果找到了，就返回true，如果没有找到，就返回false。</p>\n<p>参数中的<code>position</code>，代表我们检索开始的位置，如果不填写，默认是从索引号[0]开始检索；如果指定就从指定位置开始检索。</p>\n<pre><code>let str = &#39;hello world&#39;;\nconsole.log(str.include(&#39;hello&#39;)); // true\nconsole.log(str.include(&#39;world&#39;)); // true\n\nconsole.log(str.include(&#39;hello&#39;,1)); // false\nconsole.log(str.include(&#39;world&#39;,7)); // false\n</code></pre>\n<h3 id=\"startsWith-amp-endsWith\"><a href=\"#startsWith-amp-endsWith\" class=\"headerlink\" title=\"startsWith()&amp;endsWith()\"></a><code>startsWith()</code>&amp;<code>endsWith()</code></h3><pre><code>value = str.startsWith(&#39;要查找的字符串&#39;,[position]);\n\nvalue = str.endsWith(&#39;要查找的字符串&#39;,[position]);\n</code></pre>\n<p>这两个方法是用来判断字符串是否以指定的字符串开头或结尾的，如果是，就返回true，如果不是，就返回false。</p>\n<p><strong>注意：</strong></p>\n<p>这个两个方法中的<code>position</code>参数意义是不同的：</p>\n<ul>\n<li><p><code>startsWith()</code>中的<code>position</code>代表我们检索开始的位置，如果不填写，默认是从索引号[0]开始检索，直到字符串末尾；如果指定就从指定位置开始检索，直到字符串末尾。[position,字符串末尾]</p>\n</li>\n<li><p><code>endsWith()</code>中的<code>position</code>代表我们检索结束的位置，如果不填写，默认是从字符串末尾开始检索，直到索引号[0]；如果指定就从指定位置开始检索，直到索引号[0]。[0,position)</p>\n<p>  let str &#x3D; ‘hello world’;<br>  console.log(str.startsWith(‘hello’)); &#x2F;&#x2F; true<br>  console.log(str.startsWith(‘world’)); &#x2F;&#x2F; false</p>\n<p>  console.log(str.endsWith(‘hello’)); &#x2F;&#x2F; false<br>  console.log(str.endsWith(‘world’)); &#x2F;&#x2F; true</p>\n<p>  console.log(str.startsWith(‘hello’,1)); &#x2F;&#x2F; false<br>  console.log(str.startsWith(‘world’,7)); &#x2F;&#x2F; false</p>\n<p>  console.log(str.endsWith(‘hello’,1)); &#x2F;&#x2F; false<br>  console.log(str.endsWith(‘world’,7)); &#x2F;&#x2F; false</p>\n</li>\n</ul>\n"},{"title":"可选链","date":"2023-01-09T14:00:27.949Z","_content":"# 可选链\"?.\"\n\n首先，可选链是一种访问嵌套对象属性的安全方式，即使中间的属性不存在也不会出现错误。\n\n那么什么是**属性不存在**呢？\n\n举个例子吧：例如此时我们代码里面有一个`user`对象，里面存储了我们用户的地址，以及街道地址。\n\n    let user = {\n        address:{\n            city:'重庆';\n            street:'渝北';\n        }\n    }\n\n这个时候，我们去获取`user.address`不会报错，获取`user.address.street`也不会报错。\n\n但是如果，对象里面没有address这个属性的时候，那么当我们调用`user.address.street`的时候，就会报错。\n\n    let user = {};\n    alert(user.address.street);//报错\n\n在很多的实际开发当中，我们并不希望得到的一个报错，我们更希望是一个`undefined`（表示没有该属性）。这个时候我们就需要用到可选链这个小家伙。\n\n##  可选链\n\n`?.`:当可选链前面的值为`undefined`或者`null`时，它就会停止运算，并且返回`undefined`。\n\n举个例子：\n\n    let user = {};\n    alert(user.address.street);//报错（1）\n    alert(user.address?.street);//undefined（2）\n\n在这段代码中，（1）输出一个报错，但是（2）输出一个`undefined`。这是因为在执行（2）的时候，遇到`？.`的时候，判断`address`是否存在，很明显`user`是一个空对象，所以属性`address`并不存在，最后输出`undefined`。\n\n**注意：**\n\n- `?.`：只会对它前面的值成为可选值，也就是只会判断前面的值是否存在；它不会对后面的值产生影响。\n- 不要过渡的使用可选链，因为使用可选链会将可能出错的地方给掩盖掉（只输出一个`undefined`）,这将会导致后面我们调试更加困难。\n- 可选链前面的变量必须要先声明，不然将会报错。\n\n## 短路效应\n\n前面我们说过，可选链只会对其前面的值起作用，对后面的值没有影响。\n\n如果可选链前面的值为`undefined`或者`null`的时候，会直接跳过后面的值，直接输出`undefined`，这就是短路效应。\n\n## 扩展\n\n可选链不是一个运算符，它是一个特殊的语法结构，它还可以有其他的变体：\n\n- `?.()`:\n---\n    let userSayHi = {\n        sayHi:function(){\n            alert('hi');\n        }\n    };\n    let userTest = {};\n\n    userSayHi.sayHi?.();//hi\n    userTest.sayHi?.();//undefined\n\n这里首先会检查对象里面有没有`sayHi`这个属性。在`userTest`这里没有该属性，所以直接输出`undefined`.\n\n- `?.[]`:\n---\n    let userSayHi = {\n        sayHi:function(){\n            alert('hi');\n        }\n    };\n    let userTest = {};\n\n    userSayHi.sayHi?.['sayHi']();//hi\n    userTest.sayHi?.['sayHi']();//undefined\n\n这里的原理同上。\n\n**最后：**\n\n一个小知识点：我们可以使用可选链来安全的读取或者删除，但是却不能写入，也就是可选链不能在赋值语句的左侧。这将会报错。","source":"_posts/JavaScript/可选链.md","raw":"---\ntitle: 可选链\ndate: 2022-9-8-26\ntags: [前端]\ncategories: [JavaScript]\n---\n# 可选链\"?.\"\n\n首先，可选链是一种访问嵌套对象属性的安全方式，即使中间的属性不存在也不会出现错误。\n\n那么什么是**属性不存在**呢？\n\n举个例子吧：例如此时我们代码里面有一个`user`对象，里面存储了我们用户的地址，以及街道地址。\n\n    let user = {\n        address:{\n            city:'重庆';\n            street:'渝北';\n        }\n    }\n\n这个时候，我们去获取`user.address`不会报错，获取`user.address.street`也不会报错。\n\n但是如果，对象里面没有address这个属性的时候，那么当我们调用`user.address.street`的时候，就会报错。\n\n    let user = {};\n    alert(user.address.street);//报错\n\n在很多的实际开发当中，我们并不希望得到的一个报错，我们更希望是一个`undefined`（表示没有该属性）。这个时候我们就需要用到可选链这个小家伙。\n\n##  可选链\n\n`?.`:当可选链前面的值为`undefined`或者`null`时，它就会停止运算，并且返回`undefined`。\n\n举个例子：\n\n    let user = {};\n    alert(user.address.street);//报错（1）\n    alert(user.address?.street);//undefined（2）\n\n在这段代码中，（1）输出一个报错，但是（2）输出一个`undefined`。这是因为在执行（2）的时候，遇到`？.`的时候，判断`address`是否存在，很明显`user`是一个空对象，所以属性`address`并不存在，最后输出`undefined`。\n\n**注意：**\n\n- `?.`：只会对它前面的值成为可选值，也就是只会判断前面的值是否存在；它不会对后面的值产生影响。\n- 不要过渡的使用可选链，因为使用可选链会将可能出错的地方给掩盖掉（只输出一个`undefined`）,这将会导致后面我们调试更加困难。\n- 可选链前面的变量必须要先声明，不然将会报错。\n\n## 短路效应\n\n前面我们说过，可选链只会对其前面的值起作用，对后面的值没有影响。\n\n如果可选链前面的值为`undefined`或者`null`的时候，会直接跳过后面的值，直接输出`undefined`，这就是短路效应。\n\n## 扩展\n\n可选链不是一个运算符，它是一个特殊的语法结构，它还可以有其他的变体：\n\n- `?.()`:\n---\n    let userSayHi = {\n        sayHi:function(){\n            alert('hi');\n        }\n    };\n    let userTest = {};\n\n    userSayHi.sayHi?.();//hi\n    userTest.sayHi?.();//undefined\n\n这里首先会检查对象里面有没有`sayHi`这个属性。在`userTest`这里没有该属性，所以直接输出`undefined`.\n\n- `?.[]`:\n---\n    let userSayHi = {\n        sayHi:function(){\n            alert('hi');\n        }\n    };\n    let userTest = {};\n\n    userSayHi.sayHi?.['sayHi']();//hi\n    userTest.sayHi?.['sayHi']();//undefined\n\n这里的原理同上。\n\n**最后：**\n\n一个小知识点：我们可以使用可选链来安全的读取或者删除，但是却不能写入，也就是可选链不能在赋值语句的左侧。这将会报错。","slug":"JavaScript/可选链","published":1,"updated":"2023-01-08T11:39:53.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmit005r9kbm9rra7iae","content":"<h1 id=\"可选链”-”\"><a href=\"#可选链”-”\" class=\"headerlink\" title=\"可选链”?.”\"></a>可选链”?.”</h1><p>首先，可选链是一种访问嵌套对象属性的安全方式，即使中间的属性不存在也不会出现错误。</p>\n<p>那么什么是<strong>属性不存在</strong>呢？</p>\n<p>举个例子吧：例如此时我们代码里面有一个<code>user</code>对象，里面存储了我们用户的地址，以及街道地址。</p>\n<pre><code>let user = &#123;\n    address:&#123;\n        city:&#39;重庆&#39;;\n        street:&#39;渝北&#39;;\n    &#125;\n&#125;\n</code></pre>\n<p>这个时候，我们去获取<code>user.address</code>不会报错，获取<code>user.address.street</code>也不会报错。</p>\n<p>但是如果，对象里面没有address这个属性的时候，那么当我们调用<code>user.address.street</code>的时候，就会报错。</p>\n<pre><code>let user = &#123;&#125;;\nalert(user.address.street);//报错\n</code></pre>\n<p>在很多的实际开发当中，我们并不希望得到的一个报错，我们更希望是一个<code>undefined</code>（表示没有该属性）。这个时候我们就需要用到可选链这个小家伙。</p>\n<h2 id=\"可选链\"><a href=\"#可选链\" class=\"headerlink\" title=\"可选链\"></a>可选链</h2><p><code>?.</code>:当可选链前面的值为<code>undefined</code>或者<code>null</code>时，它就会停止运算，并且返回<code>undefined</code>。</p>\n<p>举个例子：</p>\n<pre><code>let user = &#123;&#125;;\nalert(user.address.street);//报错（1）\nalert(user.address?.street);//undefined（2）\n</code></pre>\n<p>在这段代码中，（1）输出一个报错，但是（2）输出一个<code>undefined</code>。这是因为在执行（2）的时候，遇到<code>？.</code>的时候，判断<code>address</code>是否存在，很明显<code>user</code>是一个空对象，所以属性<code>address</code>并不存在，最后输出<code>undefined</code>。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><code>?.</code>：只会对它前面的值成为可选值，也就是只会判断前面的值是否存在；它不会对后面的值产生影响。</li>\n<li>不要过渡的使用可选链，因为使用可选链会将可能出错的地方给掩盖掉（只输出一个<code>undefined</code>）,这将会导致后面我们调试更加困难。</li>\n<li>可选链前面的变量必须要先声明，不然将会报错。</li>\n</ul>\n<h2 id=\"短路效应\"><a href=\"#短路效应\" class=\"headerlink\" title=\"短路效应\"></a>短路效应</h2><p>前面我们说过，可选链只会对其前面的值起作用，对后面的值没有影响。</p>\n<p>如果可选链前面的值为<code>undefined</code>或者<code>null</code>的时候，会直接跳过后面的值，直接输出<code>undefined</code>，这就是短路效应。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>可选链不是一个运算符，它是一个特殊的语法结构，它还可以有其他的变体：</p>\n<ul>\n<li><code>?.()</code>:</li>\n</ul>\n<hr>\n<pre><code>let userSayHi = &#123;\n    sayHi:function()&#123;\n        alert(&#39;hi&#39;);\n    &#125;\n&#125;;\nlet userTest = &#123;&#125;;\n\nuserSayHi.sayHi?.();//hi\nuserTest.sayHi?.();//undefined\n</code></pre>\n<p>这里首先会检查对象里面有没有<code>sayHi</code>这个属性。在<code>userTest</code>这里没有该属性，所以直接输出<code>undefined</code>.</p>\n<ul>\n<li><code>?.[]</code>:</li>\n</ul>\n<hr>\n<pre><code>let userSayHi = &#123;\n    sayHi:function()&#123;\n        alert(&#39;hi&#39;);\n    &#125;\n&#125;;\nlet userTest = &#123;&#125;;\n\nuserSayHi.sayHi?.[&#39;sayHi&#39;]();//hi\nuserTest.sayHi?.[&#39;sayHi&#39;]();//undefined\n</code></pre>\n<p>这里的原理同上。</p>\n<p><strong>最后：</strong></p>\n<p>一个小知识点：我们可以使用可选链来安全的读取或者删除，但是却不能写入，也就是可选链不能在赋值语句的左侧。这将会报错。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"可选链”-”\"><a href=\"#可选链”-”\" class=\"headerlink\" title=\"可选链”?.”\"></a>可选链”?.”</h1><p>首先，可选链是一种访问嵌套对象属性的安全方式，即使中间的属性不存在也不会出现错误。</p>\n<p>那么什么是<strong>属性不存在</strong>呢？</p>\n<p>举个例子吧：例如此时我们代码里面有一个<code>user</code>对象，里面存储了我们用户的地址，以及街道地址。</p>\n<pre><code>let user = &#123;\n    address:&#123;\n        city:&#39;重庆&#39;;\n        street:&#39;渝北&#39;;\n    &#125;\n&#125;\n</code></pre>\n<p>这个时候，我们去获取<code>user.address</code>不会报错，获取<code>user.address.street</code>也不会报错。</p>\n<p>但是如果，对象里面没有address这个属性的时候，那么当我们调用<code>user.address.street</code>的时候，就会报错。</p>\n<pre><code>let user = &#123;&#125;;\nalert(user.address.street);//报错\n</code></pre>\n<p>在很多的实际开发当中，我们并不希望得到的一个报错，我们更希望是一个<code>undefined</code>（表示没有该属性）。这个时候我们就需要用到可选链这个小家伙。</p>\n<h2 id=\"可选链\"><a href=\"#可选链\" class=\"headerlink\" title=\"可选链\"></a>可选链</h2><p><code>?.</code>:当可选链前面的值为<code>undefined</code>或者<code>null</code>时，它就会停止运算，并且返回<code>undefined</code>。</p>\n<p>举个例子：</p>\n<pre><code>let user = &#123;&#125;;\nalert(user.address.street);//报错（1）\nalert(user.address?.street);//undefined（2）\n</code></pre>\n<p>在这段代码中，（1）输出一个报错，但是（2）输出一个<code>undefined</code>。这是因为在执行（2）的时候，遇到<code>？.</code>的时候，判断<code>address</code>是否存在，很明显<code>user</code>是一个空对象，所以属性<code>address</code>并不存在，最后输出<code>undefined</code>。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><code>?.</code>：只会对它前面的值成为可选值，也就是只会判断前面的值是否存在；它不会对后面的值产生影响。</li>\n<li>不要过渡的使用可选链，因为使用可选链会将可能出错的地方给掩盖掉（只输出一个<code>undefined</code>）,这将会导致后面我们调试更加困难。</li>\n<li>可选链前面的变量必须要先声明，不然将会报错。</li>\n</ul>\n<h2 id=\"短路效应\"><a href=\"#短路效应\" class=\"headerlink\" title=\"短路效应\"></a>短路效应</h2><p>前面我们说过，可选链只会对其前面的值起作用，对后面的值没有影响。</p>\n<p>如果可选链前面的值为<code>undefined</code>或者<code>null</code>的时候，会直接跳过后面的值，直接输出<code>undefined</code>，这就是短路效应。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>可选链不是一个运算符，它是一个特殊的语法结构，它还可以有其他的变体：</p>\n<ul>\n<li><code>?.()</code>:</li>\n</ul>\n<hr>\n<pre><code>let userSayHi = &#123;\n    sayHi:function()&#123;\n        alert(&#39;hi&#39;);\n    &#125;\n&#125;;\nlet userTest = &#123;&#125;;\n\nuserSayHi.sayHi?.();//hi\nuserTest.sayHi?.();//undefined\n</code></pre>\n<p>这里首先会检查对象里面有没有<code>sayHi</code>这个属性。在<code>userTest</code>这里没有该属性，所以直接输出<code>undefined</code>.</p>\n<ul>\n<li><code>?.[]</code>:</li>\n</ul>\n<hr>\n<pre><code>let userSayHi = &#123;\n    sayHi:function()&#123;\n        alert(&#39;hi&#39;);\n    &#125;\n&#125;;\nlet userTest = &#123;&#125;;\n\nuserSayHi.sayHi?.[&#39;sayHi&#39;]();//hi\nuserTest.sayHi?.[&#39;sayHi&#39;]();//undefined\n</code></pre>\n<p>这里的原理同上。</p>\n<p><strong>最后：</strong></p>\n<p>一个小知识点：我们可以使用可选链来安全的读取或者删除，但是却不能写入，也就是可选链不能在赋值语句的左侧。这将会报错。</p>\n"},{"title":"字符串常用方法第二弹","date":"2022-09-27T16:00:00.000Z","_content":"# 字符串常用方法第二弹\n\n在上一篇文章我们讲到了字符串的常用方法，这篇文章我们继续讲解字符串的常用方法。\n\n这里我们将会讲解字符串获取指定位置以及字符串截取的方法。\n\n同样由于字符串的不可改变性，所以这些方法都是返回一个新的字符串，并不会改变原来的字符串。\n\n## 字符串获取指定位置的方法\n\n### `charAt(index)`\n\n`charAt` 方法用于返回指定位置的字符，如果位置超出字符串长度则返回空字符串。\n\n    value= str.charAt(index);\n\n方法里面的那个参数就是我们获取的位置，比如我们想获取字符串的第一个字符，那么我们就可以这样写\n\n    var str = \"hello world\";\n    var value = str.charAt(0);\n    console.log(value); // h\n\n其实这个方法和`str[index]`最终实现的效果是一样的。  \n如果我们传入的参数不在字符串的范围内[0,str.length)，那么就会返回空字符串。\n\n    var str = \"hello world\";\n    var value = str.charAt(100);\n    console.log(value); // \"\"\n\n### `str.[index]`\n\n    value = str[index];\n\n这个方法的使用和`str.charAt(index)`是一样的，在这里我们就不过多讲述。\n\n### `charCodeAt(index)`\n\n`charCodeAt` 方法用于返回指定位置的字符的 Unicode 编码，如果位置超出字符串长度则返回 NaN。\n\n    value = str.charCodeAt(index);\n\n通过这个方法，我们可以获取到字符串中某个位置的字符的 Unicode 编码。\n\n    var str = \"hello world\";\n    var value = str.charCodeAt(0);\n    console.log(value); // 104\n\n## 字符串截取\n\n### `slice(start, end)`\n\n在有关字符串截取的方法中，`slice` 方法是最常用的方法，它的作用是返回一个新的字符串，包含从 start 到 end（不包括该元素）的字符串。`[start, end)`\n\n    value = str.slice(start, end);\n\n此方法从字符串中截取指定位置的内容。传入参数分为一下几种情况：\n\n- 传入一个参数`正数`，那么就是从这个位置`正数`开始截取到字符串的末尾。\n- 传入一个参数`负数`，那么就是从字符串的末尾开始截取到这个位置`负数`。\n- 传入两个参数`正数1，正数2`，那么就是从开始位置`正数1`开始截取到结束位置`正数2`。\n- 传入两个参数`负数1，负数2`，那么就是从开始位置`负数1`开始截取到结束位置`负数2`。\n- 传入两个参数`正数1，负数2`，那么就是从开始位置`正数1`开始截取到结束位置`负数2`。\n- 传入两个参数`位置1，位置2`（位置1大于位置2），那么最后返回的结果为空。\n\n### `substring(start, end)`\n\n`substring` 方法的作用和`slice`方法是一样的,不同之处有：\n\n- `substring()`的参数不能为负数，如果为负数，那么就会自动转换为 0。\n- `substring()`的参数如果位置1大于位置2，那么就会自动调换位置。返回值不会像`slice`方法那样返回空字符串。\n\n    value = str.substring(start, end);\n\n### `substr(start, length)`\n\n这个方法现在还没有标准化，所以不建议使用它。\n\n`substr` 方法的作用是返回一个新的字符串，包含从 start 到 start + length 的字符串。`[start, start + length)`\n\n    value = str.substr(start, length);\n\n里面的参数有以下几种情况：\n\n- 传入两个参数`正数1，正数2`，那么就是从开始位置`正数1`开始截取到结束位置`正数1 + 正数2`。\n- 传入一个参数`正数`，从指定位置`正数`开始，截取到最后。\n- 传入一个参数`负数`,从倒数第`|负数|`个位置开始截取到最后。\n\n## 其他一些常见方法\n\n### `String.formCharCode()`通过Unicode编码获取字符\n\n此方法是根据字符的Unicode编码获取字符。\n\n    value = String.formCharCode(unicode);\n\n方法里面的参数就是Unicode编码。\n\n*栗子:*\n\n    var str = String.fromCharCode(72);\n    console.log(str); // H\n\n### `concat()`连接字符串\n\n此方法用于连接一个或者多个字符串。\n\n    value = str.concat(str1, str2, str3...);\n\n方法里面的参数可以是一个或者多个字符串。但是我们可以有更简单的办法，就是使用`+`来实现。\n\n所以这个方法我们基本不使用。\n\n### `split()` 字符串转换为数组【重要】\n\n这个方法十分重要，在我们日常的开发中，经常会将字符串转换为数组。这个方法就变得尤为重要。\n\n    value = str.split('分隔符');\n\n此方法中的参数，就是我们分隔字符串的依据，例如：一个字符串里面有多个逗号，我们恰好需要将这个字符串转换为数组，那么我们就可以使用逗号来分隔字符串。\n\n    var longStr = '1,2,3,4,5,6';// 字符串\n    var arr = str.split(',');\n    console.log(arr); // [1, 2, 3, 4, 5, 6]\n\n### `replace()`替换字符串\n\n此方法用于替换字符串中的内容。\n\n    value = str.replace('要替换的内容', '替换后的内容');\n\n此方法中的参数，第一个参数是要替换的内容，第二个参数是替换后的内容。\n\n    var str1 = 'today is fine day!fine day!';\n    var str2 = str1.replace('fine', 'good');\n    console.log(str1); // today is fine day!fine day!\n    console.log(str2); // today is good day!fine day!\n\n通过这段代码，我们知道替换效果不会改变原有的字符串，其次只会替换第一个匹配的内容。如要替换全部内容，就需要使用到正则表达式。\n\n### `repeat()`重复字符串\n\n此方法用于重复字符串。\n\n    value = str.repeat(count);\n\n此方法中的参数，就是重复的次数。\n\n    var str = 'hello';\n    var str1 = str.repeat(3);\n    console.log(str1); // hellohellohello\n\n### `trim()`去除字符串两端的空格\n\n此方法用于去除字符串两端的空格。\n\n    value = str.trim();\n\n*栗子：*\n\n    var str = '  hello world  ';\n    var str1 = str.trim();\n    console.log(str1); // hello world\n\n### `toLocaleLowerCase()`&`toLocalUpperCase()`转换大小写\n\n此方法用于转换字符串的大小写。\n\n    value = str.toLocaleLowerCase();\n    value = str.toLocaleUpperCase();\n\n此方法是将字符串全部改为大写或者小写。\n\n*栗子：*\n\n    var str = 'Hello World';\n    var str1 = str.toLocaleLowerCase();\n    var str2 = str.toLocaleUpperCase();\n    console.log(str1); // hello world\n    console.log(str2); // HELLO WORLD","source":"_posts/JavaScript/字符串常用方法第二弹.md","raw":"---\ntitle: 字符串常用方法第二弹\ndate: 2022-9-28\ntags: [前端]\ncategories: [JavaScript]\n---\n# 字符串常用方法第二弹\n\n在上一篇文章我们讲到了字符串的常用方法，这篇文章我们继续讲解字符串的常用方法。\n\n这里我们将会讲解字符串获取指定位置以及字符串截取的方法。\n\n同样由于字符串的不可改变性，所以这些方法都是返回一个新的字符串，并不会改变原来的字符串。\n\n## 字符串获取指定位置的方法\n\n### `charAt(index)`\n\n`charAt` 方法用于返回指定位置的字符，如果位置超出字符串长度则返回空字符串。\n\n    value= str.charAt(index);\n\n方法里面的那个参数就是我们获取的位置，比如我们想获取字符串的第一个字符，那么我们就可以这样写\n\n    var str = \"hello world\";\n    var value = str.charAt(0);\n    console.log(value); // h\n\n其实这个方法和`str[index]`最终实现的效果是一样的。  \n如果我们传入的参数不在字符串的范围内[0,str.length)，那么就会返回空字符串。\n\n    var str = \"hello world\";\n    var value = str.charAt(100);\n    console.log(value); // \"\"\n\n### `str.[index]`\n\n    value = str[index];\n\n这个方法的使用和`str.charAt(index)`是一样的，在这里我们就不过多讲述。\n\n### `charCodeAt(index)`\n\n`charCodeAt` 方法用于返回指定位置的字符的 Unicode 编码，如果位置超出字符串长度则返回 NaN。\n\n    value = str.charCodeAt(index);\n\n通过这个方法，我们可以获取到字符串中某个位置的字符的 Unicode 编码。\n\n    var str = \"hello world\";\n    var value = str.charCodeAt(0);\n    console.log(value); // 104\n\n## 字符串截取\n\n### `slice(start, end)`\n\n在有关字符串截取的方法中，`slice` 方法是最常用的方法，它的作用是返回一个新的字符串，包含从 start 到 end（不包括该元素）的字符串。`[start, end)`\n\n    value = str.slice(start, end);\n\n此方法从字符串中截取指定位置的内容。传入参数分为一下几种情况：\n\n- 传入一个参数`正数`，那么就是从这个位置`正数`开始截取到字符串的末尾。\n- 传入一个参数`负数`，那么就是从字符串的末尾开始截取到这个位置`负数`。\n- 传入两个参数`正数1，正数2`，那么就是从开始位置`正数1`开始截取到结束位置`正数2`。\n- 传入两个参数`负数1，负数2`，那么就是从开始位置`负数1`开始截取到结束位置`负数2`。\n- 传入两个参数`正数1，负数2`，那么就是从开始位置`正数1`开始截取到结束位置`负数2`。\n- 传入两个参数`位置1，位置2`（位置1大于位置2），那么最后返回的结果为空。\n\n### `substring(start, end)`\n\n`substring` 方法的作用和`slice`方法是一样的,不同之处有：\n\n- `substring()`的参数不能为负数，如果为负数，那么就会自动转换为 0。\n- `substring()`的参数如果位置1大于位置2，那么就会自动调换位置。返回值不会像`slice`方法那样返回空字符串。\n\n    value = str.substring(start, end);\n\n### `substr(start, length)`\n\n这个方法现在还没有标准化，所以不建议使用它。\n\n`substr` 方法的作用是返回一个新的字符串，包含从 start 到 start + length 的字符串。`[start, start + length)`\n\n    value = str.substr(start, length);\n\n里面的参数有以下几种情况：\n\n- 传入两个参数`正数1，正数2`，那么就是从开始位置`正数1`开始截取到结束位置`正数1 + 正数2`。\n- 传入一个参数`正数`，从指定位置`正数`开始，截取到最后。\n- 传入一个参数`负数`,从倒数第`|负数|`个位置开始截取到最后。\n\n## 其他一些常见方法\n\n### `String.formCharCode()`通过Unicode编码获取字符\n\n此方法是根据字符的Unicode编码获取字符。\n\n    value = String.formCharCode(unicode);\n\n方法里面的参数就是Unicode编码。\n\n*栗子:*\n\n    var str = String.fromCharCode(72);\n    console.log(str); // H\n\n### `concat()`连接字符串\n\n此方法用于连接一个或者多个字符串。\n\n    value = str.concat(str1, str2, str3...);\n\n方法里面的参数可以是一个或者多个字符串。但是我们可以有更简单的办法，就是使用`+`来实现。\n\n所以这个方法我们基本不使用。\n\n### `split()` 字符串转换为数组【重要】\n\n这个方法十分重要，在我们日常的开发中，经常会将字符串转换为数组。这个方法就变得尤为重要。\n\n    value = str.split('分隔符');\n\n此方法中的参数，就是我们分隔字符串的依据，例如：一个字符串里面有多个逗号，我们恰好需要将这个字符串转换为数组，那么我们就可以使用逗号来分隔字符串。\n\n    var longStr = '1,2,3,4,5,6';// 字符串\n    var arr = str.split(',');\n    console.log(arr); // [1, 2, 3, 4, 5, 6]\n\n### `replace()`替换字符串\n\n此方法用于替换字符串中的内容。\n\n    value = str.replace('要替换的内容', '替换后的内容');\n\n此方法中的参数，第一个参数是要替换的内容，第二个参数是替换后的内容。\n\n    var str1 = 'today is fine day!fine day!';\n    var str2 = str1.replace('fine', 'good');\n    console.log(str1); // today is fine day!fine day!\n    console.log(str2); // today is good day!fine day!\n\n通过这段代码，我们知道替换效果不会改变原有的字符串，其次只会替换第一个匹配的内容。如要替换全部内容，就需要使用到正则表达式。\n\n### `repeat()`重复字符串\n\n此方法用于重复字符串。\n\n    value = str.repeat(count);\n\n此方法中的参数，就是重复的次数。\n\n    var str = 'hello';\n    var str1 = str.repeat(3);\n    console.log(str1); // hellohellohello\n\n### `trim()`去除字符串两端的空格\n\n此方法用于去除字符串两端的空格。\n\n    value = str.trim();\n\n*栗子：*\n\n    var str = '  hello world  ';\n    var str1 = str.trim();\n    console.log(str1); // hello world\n\n### `toLocaleLowerCase()`&`toLocalUpperCase()`转换大小写\n\n此方法用于转换字符串的大小写。\n\n    value = str.toLocaleLowerCase();\n    value = str.toLocaleUpperCase();\n\n此方法是将字符串全部改为大写或者小写。\n\n*栗子：*\n\n    var str = 'Hello World';\n    var str1 = str.toLocaleLowerCase();\n    var str2 = str.toLocaleUpperCase();\n    console.log(str1); // hello world\n    console.log(str2); // HELLO WORLD","slug":"JavaScript/字符串常用方法第二弹","published":1,"updated":"2023-01-09T11:49:56.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmiu005u9kbmbvj5fbw0","content":"<h1 id=\"字符串常用方法第二弹\"><a href=\"#字符串常用方法第二弹\" class=\"headerlink\" title=\"字符串常用方法第二弹\"></a>字符串常用方法第二弹</h1><p>在上一篇文章我们讲到了字符串的常用方法，这篇文章我们继续讲解字符串的常用方法。</p>\n<p>这里我们将会讲解字符串获取指定位置以及字符串截取的方法。</p>\n<p>同样由于字符串的不可改变性，所以这些方法都是返回一个新的字符串，并不会改变原来的字符串。</p>\n<h2 id=\"字符串获取指定位置的方法\"><a href=\"#字符串获取指定位置的方法\" class=\"headerlink\" title=\"字符串获取指定位置的方法\"></a>字符串获取指定位置的方法</h2><h3 id=\"charAt-index\"><a href=\"#charAt-index\" class=\"headerlink\" title=\"charAt(index)\"></a><code>charAt(index)</code></h3><p><code>charAt</code> 方法用于返回指定位置的字符，如果位置超出字符串长度则返回空字符串。</p>\n<pre><code>value= str.charAt(index);\n</code></pre>\n<p>方法里面的那个参数就是我们获取的位置，比如我们想获取字符串的第一个字符，那么我们就可以这样写</p>\n<pre><code>var str = &quot;hello world&quot;;\nvar value = str.charAt(0);\nconsole.log(value); // h\n</code></pre>\n<p>其实这个方法和<code>str[index]</code>最终实现的效果是一样的。<br>如果我们传入的参数不在字符串的范围内[0,str.length)，那么就会返回空字符串。</p>\n<pre><code>var str = &quot;hello world&quot;;\nvar value = str.charAt(100);\nconsole.log(value); // &quot;&quot;\n</code></pre>\n<h3 id=\"str-index\"><a href=\"#str-index\" class=\"headerlink\" title=\"str.[index]\"></a><code>str.[index]</code></h3><pre><code>value = str[index];\n</code></pre>\n<p>这个方法的使用和<code>str.charAt(index)</code>是一样的，在这里我们就不过多讲述。</p>\n<h3 id=\"charCodeAt-index\"><a href=\"#charCodeAt-index\" class=\"headerlink\" title=\"charCodeAt(index)\"></a><code>charCodeAt(index)</code></h3><p><code>charCodeAt</code> 方法用于返回指定位置的字符的 Unicode 编码，如果位置超出字符串长度则返回 NaN。</p>\n<pre><code>value = str.charCodeAt(index);\n</code></pre>\n<p>通过这个方法，我们可以获取到字符串中某个位置的字符的 Unicode 编码。</p>\n<pre><code>var str = &quot;hello world&quot;;\nvar value = str.charCodeAt(0);\nconsole.log(value); // 104\n</code></pre>\n<h2 id=\"字符串截取\"><a href=\"#字符串截取\" class=\"headerlink\" title=\"字符串截取\"></a>字符串截取</h2><h3 id=\"slice-start-end\"><a href=\"#slice-start-end\" class=\"headerlink\" title=\"slice(start, end)\"></a><code>slice(start, end)</code></h3><p>在有关字符串截取的方法中，<code>slice</code> 方法是最常用的方法，它的作用是返回一个新的字符串，包含从 start 到 end（不包括该元素）的字符串。<code>[start, end)</code></p>\n<pre><code>value = str.slice(start, end);\n</code></pre>\n<p>此方法从字符串中截取指定位置的内容。传入参数分为一下几种情况：</p>\n<ul>\n<li>传入一个参数<code>正数</code>，那么就是从这个位置<code>正数</code>开始截取到字符串的末尾。</li>\n<li>传入一个参数<code>负数</code>，那么就是从字符串的末尾开始截取到这个位置<code>负数</code>。</li>\n<li>传入两个参数<code>正数1，正数2</code>，那么就是从开始位置<code>正数1</code>开始截取到结束位置<code>正数2</code>。</li>\n<li>传入两个参数<code>负数1，负数2</code>，那么就是从开始位置<code>负数1</code>开始截取到结束位置<code>负数2</code>。</li>\n<li>传入两个参数<code>正数1，负数2</code>，那么就是从开始位置<code>正数1</code>开始截取到结束位置<code>负数2</code>。</li>\n<li>传入两个参数<code>位置1，位置2</code>（位置1大于位置2），那么最后返回的结果为空。</li>\n</ul>\n<h3 id=\"substring-start-end\"><a href=\"#substring-start-end\" class=\"headerlink\" title=\"substring(start, end)\"></a><code>substring(start, end)</code></h3><p><code>substring</code> 方法的作用和<code>slice</code>方法是一样的,不同之处有：</p>\n<ul>\n<li><p><code>substring()</code>的参数不能为负数，如果为负数，那么就会自动转换为 0。</p>\n</li>\n<li><p><code>substring()</code>的参数如果位置1大于位置2，那么就会自动调换位置。返回值不会像<code>slice</code>方法那样返回空字符串。</p>\n<p>  value &#x3D; str.substring(start, end);</p>\n</li>\n</ul>\n<h3 id=\"substr-start-length\"><a href=\"#substr-start-length\" class=\"headerlink\" title=\"substr(start, length)\"></a><code>substr(start, length)</code></h3><p>这个方法现在还没有标准化，所以不建议使用它。</p>\n<p><code>substr</code> 方法的作用是返回一个新的字符串，包含从 start 到 start + length 的字符串。<code>[start, start + length)</code></p>\n<pre><code>value = str.substr(start, length);\n</code></pre>\n<p>里面的参数有以下几种情况：</p>\n<ul>\n<li>传入两个参数<code>正数1，正数2</code>，那么就是从开始位置<code>正数1</code>开始截取到结束位置<code>正数1 + 正数2</code>。</li>\n<li>传入一个参数<code>正数</code>，从指定位置<code>正数</code>开始，截取到最后。</li>\n<li>传入一个参数<code>负数</code>,从倒数第<code>|负数|</code>个位置开始截取到最后。</li>\n</ul>\n<h2 id=\"其他一些常见方法\"><a href=\"#其他一些常见方法\" class=\"headerlink\" title=\"其他一些常见方法\"></a>其他一些常见方法</h2><h3 id=\"String-formCharCode-通过Unicode编码获取字符\"><a href=\"#String-formCharCode-通过Unicode编码获取字符\" class=\"headerlink\" title=\"String.formCharCode()通过Unicode编码获取字符\"></a><code>String.formCharCode()</code>通过Unicode编码获取字符</h3><p>此方法是根据字符的Unicode编码获取字符。</p>\n<pre><code>value = String.formCharCode(unicode);\n</code></pre>\n<p>方法里面的参数就是Unicode编码。</p>\n<p><em>栗子:</em></p>\n<pre><code>var str = String.fromCharCode(72);\nconsole.log(str); // H\n</code></pre>\n<h3 id=\"concat-连接字符串\"><a href=\"#concat-连接字符串\" class=\"headerlink\" title=\"concat()连接字符串\"></a><code>concat()</code>连接字符串</h3><p>此方法用于连接一个或者多个字符串。</p>\n<pre><code>value = str.concat(str1, str2, str3...);\n</code></pre>\n<p>方法里面的参数可以是一个或者多个字符串。但是我们可以有更简单的办法，就是使用<code>+</code>来实现。</p>\n<p>所以这个方法我们基本不使用。</p>\n<h3 id=\"split-字符串转换为数组【重要】\"><a href=\"#split-字符串转换为数组【重要】\" class=\"headerlink\" title=\"split() 字符串转换为数组【重要】\"></a><code>split()</code> 字符串转换为数组【重要】</h3><p>这个方法十分重要，在我们日常的开发中，经常会将字符串转换为数组。这个方法就变得尤为重要。</p>\n<pre><code>value = str.split(&#39;分隔符&#39;);\n</code></pre>\n<p>此方法中的参数，就是我们分隔字符串的依据，例如：一个字符串里面有多个逗号，我们恰好需要将这个字符串转换为数组，那么我们就可以使用逗号来分隔字符串。</p>\n<pre><code>var longStr = &#39;1,2,3,4,5,6&#39;;// 字符串\nvar arr = str.split(&#39;,&#39;);\nconsole.log(arr); // [1, 2, 3, 4, 5, 6]\n</code></pre>\n<h3 id=\"replace-替换字符串\"><a href=\"#replace-替换字符串\" class=\"headerlink\" title=\"replace()替换字符串\"></a><code>replace()</code>替换字符串</h3><p>此方法用于替换字符串中的内容。</p>\n<pre><code>value = str.replace(&#39;要替换的内容&#39;, &#39;替换后的内容&#39;);\n</code></pre>\n<p>此方法中的参数，第一个参数是要替换的内容，第二个参数是替换后的内容。</p>\n<pre><code>var str1 = &#39;today is fine day!fine day!&#39;;\nvar str2 = str1.replace(&#39;fine&#39;, &#39;good&#39;);\nconsole.log(str1); // today is fine day!fine day!\nconsole.log(str2); // today is good day!fine day!\n</code></pre>\n<p>通过这段代码，我们知道替换效果不会改变原有的字符串，其次只会替换第一个匹配的内容。如要替换全部内容，就需要使用到正则表达式。</p>\n<h3 id=\"repeat-重复字符串\"><a href=\"#repeat-重复字符串\" class=\"headerlink\" title=\"repeat()重复字符串\"></a><code>repeat()</code>重复字符串</h3><p>此方法用于重复字符串。</p>\n<pre><code>value = str.repeat(count);\n</code></pre>\n<p>此方法中的参数，就是重复的次数。</p>\n<pre><code>var str = &#39;hello&#39;;\nvar str1 = str.repeat(3);\nconsole.log(str1); // hellohellohello\n</code></pre>\n<h3 id=\"trim-去除字符串两端的空格\"><a href=\"#trim-去除字符串两端的空格\" class=\"headerlink\" title=\"trim()去除字符串两端的空格\"></a><code>trim()</code>去除字符串两端的空格</h3><p>此方法用于去除字符串两端的空格。</p>\n<pre><code>value = str.trim();\n</code></pre>\n<p><em>栗子：</em></p>\n<pre><code>var str = &#39;  hello world  &#39;;\nvar str1 = str.trim();\nconsole.log(str1); // hello world\n</code></pre>\n<h3 id=\"toLocaleLowerCase-amp-toLocalUpperCase-转换大小写\"><a href=\"#toLocaleLowerCase-amp-toLocalUpperCase-转换大小写\" class=\"headerlink\" title=\"toLocaleLowerCase()&amp;toLocalUpperCase()转换大小写\"></a><code>toLocaleLowerCase()</code>&amp;<code>toLocalUpperCase()</code>转换大小写</h3><p>此方法用于转换字符串的大小写。</p>\n<pre><code>value = str.toLocaleLowerCase();\nvalue = str.toLocaleUpperCase();\n</code></pre>\n<p>此方法是将字符串全部改为大写或者小写。</p>\n<p><em>栗子：</em></p>\n<pre><code>var str = &#39;Hello World&#39;;\nvar str1 = str.toLocaleLowerCase();\nvar str2 = str.toLocaleUpperCase();\nconsole.log(str1); // hello world\nconsole.log(str2); // HELLO WORLD\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"字符串常用方法第二弹\"><a href=\"#字符串常用方法第二弹\" class=\"headerlink\" title=\"字符串常用方法第二弹\"></a>字符串常用方法第二弹</h1><p>在上一篇文章我们讲到了字符串的常用方法，这篇文章我们继续讲解字符串的常用方法。</p>\n<p>这里我们将会讲解字符串获取指定位置以及字符串截取的方法。</p>\n<p>同样由于字符串的不可改变性，所以这些方法都是返回一个新的字符串，并不会改变原来的字符串。</p>\n<h2 id=\"字符串获取指定位置的方法\"><a href=\"#字符串获取指定位置的方法\" class=\"headerlink\" title=\"字符串获取指定位置的方法\"></a>字符串获取指定位置的方法</h2><h3 id=\"charAt-index\"><a href=\"#charAt-index\" class=\"headerlink\" title=\"charAt(index)\"></a><code>charAt(index)</code></h3><p><code>charAt</code> 方法用于返回指定位置的字符，如果位置超出字符串长度则返回空字符串。</p>\n<pre><code>value= str.charAt(index);\n</code></pre>\n<p>方法里面的那个参数就是我们获取的位置，比如我们想获取字符串的第一个字符，那么我们就可以这样写</p>\n<pre><code>var str = &quot;hello world&quot;;\nvar value = str.charAt(0);\nconsole.log(value); // h\n</code></pre>\n<p>其实这个方法和<code>str[index]</code>最终实现的效果是一样的。<br>如果我们传入的参数不在字符串的范围内[0,str.length)，那么就会返回空字符串。</p>\n<pre><code>var str = &quot;hello world&quot;;\nvar value = str.charAt(100);\nconsole.log(value); // &quot;&quot;\n</code></pre>\n<h3 id=\"str-index\"><a href=\"#str-index\" class=\"headerlink\" title=\"str.[index]\"></a><code>str.[index]</code></h3><pre><code>value = str[index];\n</code></pre>\n<p>这个方法的使用和<code>str.charAt(index)</code>是一样的，在这里我们就不过多讲述。</p>\n<h3 id=\"charCodeAt-index\"><a href=\"#charCodeAt-index\" class=\"headerlink\" title=\"charCodeAt(index)\"></a><code>charCodeAt(index)</code></h3><p><code>charCodeAt</code> 方法用于返回指定位置的字符的 Unicode 编码，如果位置超出字符串长度则返回 NaN。</p>\n<pre><code>value = str.charCodeAt(index);\n</code></pre>\n<p>通过这个方法，我们可以获取到字符串中某个位置的字符的 Unicode 编码。</p>\n<pre><code>var str = &quot;hello world&quot;;\nvar value = str.charCodeAt(0);\nconsole.log(value); // 104\n</code></pre>\n<h2 id=\"字符串截取\"><a href=\"#字符串截取\" class=\"headerlink\" title=\"字符串截取\"></a>字符串截取</h2><h3 id=\"slice-start-end\"><a href=\"#slice-start-end\" class=\"headerlink\" title=\"slice(start, end)\"></a><code>slice(start, end)</code></h3><p>在有关字符串截取的方法中，<code>slice</code> 方法是最常用的方法，它的作用是返回一个新的字符串，包含从 start 到 end（不包括该元素）的字符串。<code>[start, end)</code></p>\n<pre><code>value = str.slice(start, end);\n</code></pre>\n<p>此方法从字符串中截取指定位置的内容。传入参数分为一下几种情况：</p>\n<ul>\n<li>传入一个参数<code>正数</code>，那么就是从这个位置<code>正数</code>开始截取到字符串的末尾。</li>\n<li>传入一个参数<code>负数</code>，那么就是从字符串的末尾开始截取到这个位置<code>负数</code>。</li>\n<li>传入两个参数<code>正数1，正数2</code>，那么就是从开始位置<code>正数1</code>开始截取到结束位置<code>正数2</code>。</li>\n<li>传入两个参数<code>负数1，负数2</code>，那么就是从开始位置<code>负数1</code>开始截取到结束位置<code>负数2</code>。</li>\n<li>传入两个参数<code>正数1，负数2</code>，那么就是从开始位置<code>正数1</code>开始截取到结束位置<code>负数2</code>。</li>\n<li>传入两个参数<code>位置1，位置2</code>（位置1大于位置2），那么最后返回的结果为空。</li>\n</ul>\n<h3 id=\"substring-start-end\"><a href=\"#substring-start-end\" class=\"headerlink\" title=\"substring(start, end)\"></a><code>substring(start, end)</code></h3><p><code>substring</code> 方法的作用和<code>slice</code>方法是一样的,不同之处有：</p>\n<ul>\n<li><p><code>substring()</code>的参数不能为负数，如果为负数，那么就会自动转换为 0。</p>\n</li>\n<li><p><code>substring()</code>的参数如果位置1大于位置2，那么就会自动调换位置。返回值不会像<code>slice</code>方法那样返回空字符串。</p>\n<p>  value &#x3D; str.substring(start, end);</p>\n</li>\n</ul>\n<h3 id=\"substr-start-length\"><a href=\"#substr-start-length\" class=\"headerlink\" title=\"substr(start, length)\"></a><code>substr(start, length)</code></h3><p>这个方法现在还没有标准化，所以不建议使用它。</p>\n<p><code>substr</code> 方法的作用是返回一个新的字符串，包含从 start 到 start + length 的字符串。<code>[start, start + length)</code></p>\n<pre><code>value = str.substr(start, length);\n</code></pre>\n<p>里面的参数有以下几种情况：</p>\n<ul>\n<li>传入两个参数<code>正数1，正数2</code>，那么就是从开始位置<code>正数1</code>开始截取到结束位置<code>正数1 + 正数2</code>。</li>\n<li>传入一个参数<code>正数</code>，从指定位置<code>正数</code>开始，截取到最后。</li>\n<li>传入一个参数<code>负数</code>,从倒数第<code>|负数|</code>个位置开始截取到最后。</li>\n</ul>\n<h2 id=\"其他一些常见方法\"><a href=\"#其他一些常见方法\" class=\"headerlink\" title=\"其他一些常见方法\"></a>其他一些常见方法</h2><h3 id=\"String-formCharCode-通过Unicode编码获取字符\"><a href=\"#String-formCharCode-通过Unicode编码获取字符\" class=\"headerlink\" title=\"String.formCharCode()通过Unicode编码获取字符\"></a><code>String.formCharCode()</code>通过Unicode编码获取字符</h3><p>此方法是根据字符的Unicode编码获取字符。</p>\n<pre><code>value = String.formCharCode(unicode);\n</code></pre>\n<p>方法里面的参数就是Unicode编码。</p>\n<p><em>栗子:</em></p>\n<pre><code>var str = String.fromCharCode(72);\nconsole.log(str); // H\n</code></pre>\n<h3 id=\"concat-连接字符串\"><a href=\"#concat-连接字符串\" class=\"headerlink\" title=\"concat()连接字符串\"></a><code>concat()</code>连接字符串</h3><p>此方法用于连接一个或者多个字符串。</p>\n<pre><code>value = str.concat(str1, str2, str3...);\n</code></pre>\n<p>方法里面的参数可以是一个或者多个字符串。但是我们可以有更简单的办法，就是使用<code>+</code>来实现。</p>\n<p>所以这个方法我们基本不使用。</p>\n<h3 id=\"split-字符串转换为数组【重要】\"><a href=\"#split-字符串转换为数组【重要】\" class=\"headerlink\" title=\"split() 字符串转换为数组【重要】\"></a><code>split()</code> 字符串转换为数组【重要】</h3><p>这个方法十分重要，在我们日常的开发中，经常会将字符串转换为数组。这个方法就变得尤为重要。</p>\n<pre><code>value = str.split(&#39;分隔符&#39;);\n</code></pre>\n<p>此方法中的参数，就是我们分隔字符串的依据，例如：一个字符串里面有多个逗号，我们恰好需要将这个字符串转换为数组，那么我们就可以使用逗号来分隔字符串。</p>\n<pre><code>var longStr = &#39;1,2,3,4,5,6&#39;;// 字符串\nvar arr = str.split(&#39;,&#39;);\nconsole.log(arr); // [1, 2, 3, 4, 5, 6]\n</code></pre>\n<h3 id=\"replace-替换字符串\"><a href=\"#replace-替换字符串\" class=\"headerlink\" title=\"replace()替换字符串\"></a><code>replace()</code>替换字符串</h3><p>此方法用于替换字符串中的内容。</p>\n<pre><code>value = str.replace(&#39;要替换的内容&#39;, &#39;替换后的内容&#39;);\n</code></pre>\n<p>此方法中的参数，第一个参数是要替换的内容，第二个参数是替换后的内容。</p>\n<pre><code>var str1 = &#39;today is fine day!fine day!&#39;;\nvar str2 = str1.replace(&#39;fine&#39;, &#39;good&#39;);\nconsole.log(str1); // today is fine day!fine day!\nconsole.log(str2); // today is good day!fine day!\n</code></pre>\n<p>通过这段代码，我们知道替换效果不会改变原有的字符串，其次只会替换第一个匹配的内容。如要替换全部内容，就需要使用到正则表达式。</p>\n<h3 id=\"repeat-重复字符串\"><a href=\"#repeat-重复字符串\" class=\"headerlink\" title=\"repeat()重复字符串\"></a><code>repeat()</code>重复字符串</h3><p>此方法用于重复字符串。</p>\n<pre><code>value = str.repeat(count);\n</code></pre>\n<p>此方法中的参数，就是重复的次数。</p>\n<pre><code>var str = &#39;hello&#39;;\nvar str1 = str.repeat(3);\nconsole.log(str1); // hellohellohello\n</code></pre>\n<h3 id=\"trim-去除字符串两端的空格\"><a href=\"#trim-去除字符串两端的空格\" class=\"headerlink\" title=\"trim()去除字符串两端的空格\"></a><code>trim()</code>去除字符串两端的空格</h3><p>此方法用于去除字符串两端的空格。</p>\n<pre><code>value = str.trim();\n</code></pre>\n<p><em>栗子：</em></p>\n<pre><code>var str = &#39;  hello world  &#39;;\nvar str1 = str.trim();\nconsole.log(str1); // hello world\n</code></pre>\n<h3 id=\"toLocaleLowerCase-amp-toLocalUpperCase-转换大小写\"><a href=\"#toLocaleLowerCase-amp-toLocalUpperCase-转换大小写\" class=\"headerlink\" title=\"toLocaleLowerCase()&amp;toLocalUpperCase()转换大小写\"></a><code>toLocaleLowerCase()</code>&amp;<code>toLocalUpperCase()</code>转换大小写</h3><p>此方法用于转换字符串的大小写。</p>\n<pre><code>value = str.toLocaleLowerCase();\nvalue = str.toLocaleUpperCase();\n</code></pre>\n<p>此方法是将字符串全部改为大写或者小写。</p>\n<p><em>栗子：</em></p>\n<pre><code>var str = &#39;Hello World&#39;;\nvar str1 = str.toLocaleLowerCase();\nvar str2 = str.toLocaleUpperCase();\nconsole.log(str1); // hello world\nconsole.log(str2); // HELLO WORLD\n</code></pre>\n"},{"title":"JS中的对象","date":"2022-08-20T16:00:00.000Z","_content":"# 对象\n\n对象属于JavaScript数据类型中的引用型。对象不同于之前的几种原始类型，原始类型只能同时包含一种数据类型，但是对象可以使用多个键值对的形式来保存多种数据额类型。  \n\n对象里面的键值对我们使用花括号把他们包含起来。\n\n对象我们 可以理解为一个大的文件夹，文件夹里面存放的数据额就是文件夹里面的文件。文件可以是多种多样的。\n\n## 声明对象\n\n1.“构造函数”法：\n\n    let user = new Object();\n\n使用new关键字我们创建了一个名字纹user的对象。\n\n2.“字面量”法：\n\n    let user = {};\n\n这里我们使用一对花括号，来创建一个对象。\n\n## 文本和属性\n\n前面我们说道，在对象里面可以存储多种数据，这些数据我们以键值对的方式来存放。\n\n    key: value\n\n这就是一个键值对。key是键(名字、标识符)，位于`:`前面，value是值，位于`:`后面。\n\n    let user = {\n        name = \"海绵宝宝\",\n        address = \"蟹堡王\",\n    };\n\n上面这段代码，我们给user这个对象添加了两个属性（键值对）。这样我们就可以理解为，一个名为user的文件夹，里面存放了一个名字和一个地址的文件，在对应的文件里面，保存了相应的数据。\n\n我们可以随时读取对象里面的数据。\n\n    alert(user.name);//海绵宝宝\n    alert(user.address);//蟹堡王\n\n这里我们输出对象里面的数据。\n\n当然我们还可以随时修改对象里面的数据。\n\n    user.name = \"蟹老板\";//修改名字\n\n然后我们输出结果：\n\n    alert(user.name);//蟹老板\n\n当对象里面某一个属性我们不需要的时候，我们可以删除它。\n\n    删除操作：\n    delete user.address;\n\n这样我们就成功删除了address这个属性。\n\n**注意：**\n\n- 在对象中不同属性之间，我们使用逗号隔开。为了保证良好的代码规范，尽量在每一个属性末尾添加一个分号。\n- 属性命名的时候，我们可能会遇到多个词语或者属性名之间有空格的情况，这种情况下我们就需要使用双引号来包裹属性名。否则会报错。\n\n\n    \"my name\" = \"海绵宝宝\"；\n    \n\n## 点“.”符号\n\n前面我们在调用对象里面的属性的时候，我们使用`对象名.属性名`的方式来调用。但是如果遇到了属性名之间有空格的情况，使用点符号就行不通了，会报错，因为点符号要求属性名必须是有效的变量标识符，也就是说不能包含空格、不能以数字开头，也不能包含特殊符号（$和_除外）。\n\n这时我们就需要使用到方括号`[]`。，方括号可以适用于任何字符串。\n\n    alert(user[\"my name\"]);//海绵宝宝\n\n**注意：**\n方括号里面的字符串需要放在引号里面，单引号、双引号均可。\n\n","source":"_posts/JavaScript/对象.md","raw":"---\ntitle: JS中的对象\ndate: 2022-8-21\ntags: 前端\ncategories: JavaScript\n---\n# 对象\n\n对象属于JavaScript数据类型中的引用型。对象不同于之前的几种原始类型，原始类型只能同时包含一种数据类型，但是对象可以使用多个键值对的形式来保存多种数据额类型。  \n\n对象里面的键值对我们使用花括号把他们包含起来。\n\n对象我们 可以理解为一个大的文件夹，文件夹里面存放的数据额就是文件夹里面的文件。文件可以是多种多样的。\n\n## 声明对象\n\n1.“构造函数”法：\n\n    let user = new Object();\n\n使用new关键字我们创建了一个名字纹user的对象。\n\n2.“字面量”法：\n\n    let user = {};\n\n这里我们使用一对花括号，来创建一个对象。\n\n## 文本和属性\n\n前面我们说道，在对象里面可以存储多种数据，这些数据我们以键值对的方式来存放。\n\n    key: value\n\n这就是一个键值对。key是键(名字、标识符)，位于`:`前面，value是值，位于`:`后面。\n\n    let user = {\n        name = \"海绵宝宝\",\n        address = \"蟹堡王\",\n    };\n\n上面这段代码，我们给user这个对象添加了两个属性（键值对）。这样我们就可以理解为，一个名为user的文件夹，里面存放了一个名字和一个地址的文件，在对应的文件里面，保存了相应的数据。\n\n我们可以随时读取对象里面的数据。\n\n    alert(user.name);//海绵宝宝\n    alert(user.address);//蟹堡王\n\n这里我们输出对象里面的数据。\n\n当然我们还可以随时修改对象里面的数据。\n\n    user.name = \"蟹老板\";//修改名字\n\n然后我们输出结果：\n\n    alert(user.name);//蟹老板\n\n当对象里面某一个属性我们不需要的时候，我们可以删除它。\n\n    删除操作：\n    delete user.address;\n\n这样我们就成功删除了address这个属性。\n\n**注意：**\n\n- 在对象中不同属性之间，我们使用逗号隔开。为了保证良好的代码规范，尽量在每一个属性末尾添加一个分号。\n- 属性命名的时候，我们可能会遇到多个词语或者属性名之间有空格的情况，这种情况下我们就需要使用双引号来包裹属性名。否则会报错。\n\n\n    \"my name\" = \"海绵宝宝\"；\n    \n\n## 点“.”符号\n\n前面我们在调用对象里面的属性的时候，我们使用`对象名.属性名`的方式来调用。但是如果遇到了属性名之间有空格的情况，使用点符号就行不通了，会报错，因为点符号要求属性名必须是有效的变量标识符，也就是说不能包含空格、不能以数字开头，也不能包含特殊符号（$和_除外）。\n\n这时我们就需要使用到方括号`[]`。，方括号可以适用于任何字符串。\n\n    alert(user[\"my name\"]);//海绵宝宝\n\n**注意：**\n方括号里面的字符串需要放在引号里面，单引号、双引号均可。\n\n","slug":"JavaScript/对象","published":1,"updated":"2023-01-08T11:06:07.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmiv005x9kbme87wa87e","content":"<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><p>对象属于JavaScript数据类型中的引用型。对象不同于之前的几种原始类型，原始类型只能同时包含一种数据类型，但是对象可以使用多个键值对的形式来保存多种数据额类型。  </p>\n<p>对象里面的键值对我们使用花括号把他们包含起来。</p>\n<p>对象我们 可以理解为一个大的文件夹，文件夹里面存放的数据额就是文件夹里面的文件。文件可以是多种多样的。</p>\n<h2 id=\"声明对象\"><a href=\"#声明对象\" class=\"headerlink\" title=\"声明对象\"></a>声明对象</h2><p>1.“构造函数”法：</p>\n<pre><code>let user = new Object();\n</code></pre>\n<p>使用new关键字我们创建了一个名字纹user的对象。</p>\n<p>2.“字面量”法：</p>\n<pre><code>let user = &#123;&#125;;\n</code></pre>\n<p>这里我们使用一对花括号，来创建一个对象。</p>\n<h2 id=\"文本和属性\"><a href=\"#文本和属性\" class=\"headerlink\" title=\"文本和属性\"></a>文本和属性</h2><p>前面我们说道，在对象里面可以存储多种数据，这些数据我们以键值对的方式来存放。</p>\n<pre><code>key: value\n</code></pre>\n<p>这就是一个键值对。key是键(名字、标识符)，位于<code>:</code>前面，value是值，位于<code>:</code>后面。</p>\n<pre><code>let user = &#123;\n    name = &quot;海绵宝宝&quot;,\n    address = &quot;蟹堡王&quot;,\n&#125;;\n</code></pre>\n<p>上面这段代码，我们给user这个对象添加了两个属性（键值对）。这样我们就可以理解为，一个名为user的文件夹，里面存放了一个名字和一个地址的文件，在对应的文件里面，保存了相应的数据。</p>\n<p>我们可以随时读取对象里面的数据。</p>\n<pre><code>alert(user.name);//海绵宝宝\nalert(user.address);//蟹堡王\n</code></pre>\n<p>这里我们输出对象里面的数据。</p>\n<p>当然我们还可以随时修改对象里面的数据。</p>\n<pre><code>user.name = &quot;蟹老板&quot;;//修改名字\n</code></pre>\n<p>然后我们输出结果：</p>\n<pre><code>alert(user.name);//蟹老板\n</code></pre>\n<p>当对象里面某一个属性我们不需要的时候，我们可以删除它。</p>\n<pre><code>删除操作：\ndelete user.address;\n</code></pre>\n<p>这样我们就成功删除了address这个属性。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>在对象中不同属性之间，我们使用逗号隔开。为了保证良好的代码规范，尽量在每一个属性末尾添加一个分号。</p>\n</li>\n<li><p>属性命名的时候，我们可能会遇到多个词语或者属性名之间有空格的情况，这种情况下我们就需要使用双引号来包裹属性名。否则会报错。</p>\n<p>  “my name” &#x3D; “海绵宝宝”；</p>\n</li>\n</ul>\n<h2 id=\"点“-”符号\"><a href=\"#点“-”符号\" class=\"headerlink\" title=\"点“.”符号\"></a>点“.”符号</h2><p>前面我们在调用对象里面的属性的时候，我们使用<code>对象名.属性名</code>的方式来调用。但是如果遇到了属性名之间有空格的情况，使用点符号就行不通了，会报错，因为点符号要求属性名必须是有效的变量标识符，也就是说不能包含空格、不能以数字开头，也不能包含特殊符号（$和_除外）。</p>\n<p>这时我们就需要使用到方括号<code>[]</code>。，方括号可以适用于任何字符串。</p>\n<pre><code>alert(user[&quot;my name&quot;]);//海绵宝宝\n</code></pre>\n<p><strong>注意：</strong><br>方括号里面的字符串需要放在引号里面，单引号、双引号均可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><p>对象属于JavaScript数据类型中的引用型。对象不同于之前的几种原始类型，原始类型只能同时包含一种数据类型，但是对象可以使用多个键值对的形式来保存多种数据额类型。  </p>\n<p>对象里面的键值对我们使用花括号把他们包含起来。</p>\n<p>对象我们 可以理解为一个大的文件夹，文件夹里面存放的数据额就是文件夹里面的文件。文件可以是多种多样的。</p>\n<h2 id=\"声明对象\"><a href=\"#声明对象\" class=\"headerlink\" title=\"声明对象\"></a>声明对象</h2><p>1.“构造函数”法：</p>\n<pre><code>let user = new Object();\n</code></pre>\n<p>使用new关键字我们创建了一个名字纹user的对象。</p>\n<p>2.“字面量”法：</p>\n<pre><code>let user = &#123;&#125;;\n</code></pre>\n<p>这里我们使用一对花括号，来创建一个对象。</p>\n<h2 id=\"文本和属性\"><a href=\"#文本和属性\" class=\"headerlink\" title=\"文本和属性\"></a>文本和属性</h2><p>前面我们说道，在对象里面可以存储多种数据，这些数据我们以键值对的方式来存放。</p>\n<pre><code>key: value\n</code></pre>\n<p>这就是一个键值对。key是键(名字、标识符)，位于<code>:</code>前面，value是值，位于<code>:</code>后面。</p>\n<pre><code>let user = &#123;\n    name = &quot;海绵宝宝&quot;,\n    address = &quot;蟹堡王&quot;,\n&#125;;\n</code></pre>\n<p>上面这段代码，我们给user这个对象添加了两个属性（键值对）。这样我们就可以理解为，一个名为user的文件夹，里面存放了一个名字和一个地址的文件，在对应的文件里面，保存了相应的数据。</p>\n<p>我们可以随时读取对象里面的数据。</p>\n<pre><code>alert(user.name);//海绵宝宝\nalert(user.address);//蟹堡王\n</code></pre>\n<p>这里我们输出对象里面的数据。</p>\n<p>当然我们还可以随时修改对象里面的数据。</p>\n<pre><code>user.name = &quot;蟹老板&quot;;//修改名字\n</code></pre>\n<p>然后我们输出结果：</p>\n<pre><code>alert(user.name);//蟹老板\n</code></pre>\n<p>当对象里面某一个属性我们不需要的时候，我们可以删除它。</p>\n<pre><code>删除操作：\ndelete user.address;\n</code></pre>\n<p>这样我们就成功删除了address这个属性。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>在对象中不同属性之间，我们使用逗号隔开。为了保证良好的代码规范，尽量在每一个属性末尾添加一个分号。</p>\n</li>\n<li><p>属性命名的时候，我们可能会遇到多个词语或者属性名之间有空格的情况，这种情况下我们就需要使用双引号来包裹属性名。否则会报错。</p>\n<p>  “my name” &#x3D; “海绵宝宝”；</p>\n</li>\n</ul>\n<h2 id=\"点“-”符号\"><a href=\"#点“-”符号\" class=\"headerlink\" title=\"点“.”符号\"></a>点“.”符号</h2><p>前面我们在调用对象里面的属性的时候，我们使用<code>对象名.属性名</code>的方式来调用。但是如果遇到了属性名之间有空格的情况，使用点符号就行不通了，会报错，因为点符号要求属性名必须是有效的变量标识符，也就是说不能包含空格、不能以数字开头，也不能包含特殊符号（$和_除外）。</p>\n<p>这时我们就需要使用到方括号<code>[]</code>。，方括号可以适用于任何字符串。</p>\n<pre><code>alert(user[&quot;my name&quot;]);//海绵宝宝\n</code></pre>\n<p><strong>注意：</strong><br>方括号里面的字符串需要放在引号里面，单引号、双引号均可。</p>\n"},{"title":"数字、字符串、数组的相互转换","date":"2022-09-30T16:00:00.000Z","_content":"# 数字、字符串、数组的相互转换\n\n今天是我第一天刷力扣，我就想着通过刷题来巩固一下之间学习过的知识。\n\n然后有一道题就需要将数字转换为字符串，然后倒转，比较是否相等。\n\n这里我就想把之前学习到数字、字符串、数组的相互转换，以及倒转的方法总结一下。\n\n## 数字转换为字符串\n\n### 1. `+`运算符\n\n```js\n    var num = 123;\n    var str = num + '';\n    console.log(str); // \"123\"\n```\n\n在JavaScript中，当我们的数值与字符串相加时，JavaScript会自动将数值转换为字符串。  \n这就是JavaScript中隐性转换的一种。\n\n### 1. toString()\n\n```js\n    var num = 123;\n    var str = num.toString();\n    console.log(str);// \"123\"\n    var str1 = num.toString(2);\n    console.log(str1);// \"1111011\"\n```\n\n`toString(参数)` 方法返回一个表示指定 Number 对象的字符串。该字符串使用指定的基数进行表示。如果省略基数参数，则使用基数 10。  \n也就是说，我们使用该方法时，如果不传参数，我们默认使用的是十进制。我们可以传入参数（2、8、10、16），来指定我们要转换的进制。\n\n### 2. String()\n\n```js\n    var num = 123;\n    var str = String(num);\n    console.log(str);// \"123\"\n```\n\n`String()` 方法将一个指定的值转换为字符串。他可以将非字符串的参数转换为字符串。不止是数字，还可以是对象、数组、布尔值、unll、undefined等。\n\n## 字符串转换为数组\n\n### 1. split()\n\n```js\n    var str = '123';\n    var arr = str.split('');\n    console.log(arr);// [\"1\", \"2\", \"3\"]\n```\n`spilt()` 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分割为子字符串，以确定每个拆分的位置。\n\n    str.split([separator[, limit]])\n\n- separator：指定表示每个拆分应发生的点的字符串。separator 可以是一个字符串或正则表达式。如果 separator 是一个空字符串，则 str 中的每个字符之间都会被分割。\n- limit：一个整数，限定返回的分割片段数量，返回数组里面的元素数量不会超过这个数。如果不设置此参数，那么整个字符串都将会被分隔，不会考虑返回数组的长度。\n\n### 2. Array.from()\n\n```js\n    var str = '123';\n    var arr = Array.from(str);\n    console.log(arr);// [\"1\", \"2\", \"3\"]\n```\n\n`Array.from()` 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\n\n这个方法是JavaScript中内置的一个方法，它是从给定的数组创建一个新的数组实例。\n\n这个方法不仅可以将字符串转换为数组，还可以将数字转换为数组。\n\n## 数组转换为字符串\n\n### 1. join()\n\n```js\n    var arr = [1, 2, 3];\n    var str = arr.join('');\n    console.log(str);// \"123\"\n```\n\n`join()` 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。\n\n    arr.join([separator])\n\n在这个方法里面可以填一个参数，这个参数就是我们要用来连接数组的分隔符。如果不填，那么默认使用的是逗号。参数需要使用引号括起来。\n\n### 2. toString()\n\n```js\n    var arr = [1, 2, 3];\n    var str = arr.toString();\n    console.log(str);// \"1,2,3\"\n```\n\n这个方法是不是很眼熟，没错我们前面数值转换为字符串也使用这个方法。\n\n使用这个方法将数组转换为字符串，那么数组中的每一项都会被转换为字符串，然后使用逗号连接起来。","source":"_posts/JavaScript/数字、字符串、数组的相互转换.md","raw":"---\ntitle: 数字、字符串、数组的相互转换\ndate: 2022-10-1\ntags: [前端]\ncategories: [JavaScript,刷题]\n---\n# 数字、字符串、数组的相互转换\n\n今天是我第一天刷力扣，我就想着通过刷题来巩固一下之间学习过的知识。\n\n然后有一道题就需要将数字转换为字符串，然后倒转，比较是否相等。\n\n这里我就想把之前学习到数字、字符串、数组的相互转换，以及倒转的方法总结一下。\n\n## 数字转换为字符串\n\n### 1. `+`运算符\n\n```js\n    var num = 123;\n    var str = num + '';\n    console.log(str); // \"123\"\n```\n\n在JavaScript中，当我们的数值与字符串相加时，JavaScript会自动将数值转换为字符串。  \n这就是JavaScript中隐性转换的一种。\n\n### 1. toString()\n\n```js\n    var num = 123;\n    var str = num.toString();\n    console.log(str);// \"123\"\n    var str1 = num.toString(2);\n    console.log(str1);// \"1111011\"\n```\n\n`toString(参数)` 方法返回一个表示指定 Number 对象的字符串。该字符串使用指定的基数进行表示。如果省略基数参数，则使用基数 10。  \n也就是说，我们使用该方法时，如果不传参数，我们默认使用的是十进制。我们可以传入参数（2、8、10、16），来指定我们要转换的进制。\n\n### 2. String()\n\n```js\n    var num = 123;\n    var str = String(num);\n    console.log(str);// \"123\"\n```\n\n`String()` 方法将一个指定的值转换为字符串。他可以将非字符串的参数转换为字符串。不止是数字，还可以是对象、数组、布尔值、unll、undefined等。\n\n## 字符串转换为数组\n\n### 1. split()\n\n```js\n    var str = '123';\n    var arr = str.split('');\n    console.log(arr);// [\"1\", \"2\", \"3\"]\n```\n`spilt()` 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分割为子字符串，以确定每个拆分的位置。\n\n    str.split([separator[, limit]])\n\n- separator：指定表示每个拆分应发生的点的字符串。separator 可以是一个字符串或正则表达式。如果 separator 是一个空字符串，则 str 中的每个字符之间都会被分割。\n- limit：一个整数，限定返回的分割片段数量，返回数组里面的元素数量不会超过这个数。如果不设置此参数，那么整个字符串都将会被分隔，不会考虑返回数组的长度。\n\n### 2. Array.from()\n\n```js\n    var str = '123';\n    var arr = Array.from(str);\n    console.log(arr);// [\"1\", \"2\", \"3\"]\n```\n\n`Array.from()` 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\n\n这个方法是JavaScript中内置的一个方法，它是从给定的数组创建一个新的数组实例。\n\n这个方法不仅可以将字符串转换为数组，还可以将数字转换为数组。\n\n## 数组转换为字符串\n\n### 1. join()\n\n```js\n    var arr = [1, 2, 3];\n    var str = arr.join('');\n    console.log(str);// \"123\"\n```\n\n`join()` 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。\n\n    arr.join([separator])\n\n在这个方法里面可以填一个参数，这个参数就是我们要用来连接数组的分隔符。如果不填，那么默认使用的是逗号。参数需要使用引号括起来。\n\n### 2. toString()\n\n```js\n    var arr = [1, 2, 3];\n    var str = arr.toString();\n    console.log(str);// \"1,2,3\"\n```\n\n这个方法是不是很眼熟，没错我们前面数值转换为字符串也使用这个方法。\n\n使用这个方法将数组转换为字符串，那么数组中的每一项都会被转换为字符串，然后使用逗号连接起来。","slug":"JavaScript/数字、字符串、数组的相互转换","published":1,"updated":"2023-01-08T12:04:04.259Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmix00609kbmbhw2ggco","content":"<h1 id=\"数字、字符串、数组的相互转换\"><a href=\"#数字、字符串、数组的相互转换\" class=\"headerlink\" title=\"数字、字符串、数组的相互转换\"></a>数字、字符串、数组的相互转换</h1><p>今天是我第一天刷力扣，我就想着通过刷题来巩固一下之间学习过的知识。</p>\n<p>然后有一道题就需要将数字转换为字符串，然后倒转，比较是否相等。</p>\n<p>这里我就想把之前学习到数字、字符串、数组的相互转换，以及倒转的方法总结一下。</p>\n<h2 id=\"数字转换为字符串\"><a href=\"#数字转换为字符串\" class=\"headerlink\" title=\"数字转换为字符串\"></a>数字转换为字符串</h2><h3 id=\"1-运算符\"><a href=\"#1-运算符\" class=\"headerlink\" title=\"1. +运算符\"></a>1. <code>+</code>运算符</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = num + <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str); <span class=\"comment\">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>在JavaScript中，当我们的数值与字符串相加时，JavaScript会自动将数值转换为字符串。<br>这就是JavaScript中隐性转换的一种。</p>\n<h3 id=\"1-toString\"><a href=\"#1-toString\" class=\"headerlink\" title=\"1. toString()\"></a>1. toString()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = num.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// &quot;123&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str1 = num.<span class=\"title function_\">toString</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str1);<span class=\"comment\">// &quot;1111011&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toString(参数)</code> 方法返回一个表示指定 Number 对象的字符串。该字符串使用指定的基数进行表示。如果省略基数参数，则使用基数 10。<br>也就是说，我们使用该方法时，如果不传参数，我们默认使用的是十进制。我们可以传入参数（2、8、10、16），来指定我们要转换的进制。</p>\n<h3 id=\"2-String\"><a href=\"#2-String\" class=\"headerlink\" title=\"2. String()\"></a>2. String()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"title class_\">String</span>(num);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>String()</code> 方法将一个指定的值转换为字符串。他可以将非字符串的参数转换为字符串。不止是数字，还可以是对象、数组、布尔值、unll、undefined等。</p>\n<h2 id=\"字符串转换为数组\"><a href=\"#字符串转换为数组\" class=\"headerlink\" title=\"字符串转换为数组\"></a>字符串转换为数组</h2><h3 id=\"1-split\"><a href=\"#1-split\" class=\"headerlink\" title=\"1. split()\"></a>1. split()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;123&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = str.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);<span class=\"comment\">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure>\n<p><code>spilt()</code> 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分割为子字符串，以确定每个拆分的位置。</p>\n<pre><code>str.split([separator[, limit]])\n</code></pre>\n<ul>\n<li>separator：指定表示每个拆分应发生的点的字符串。separator 可以是一个字符串或正则表达式。如果 separator 是一个空字符串，则 str 中的每个字符之间都会被分割。</li>\n<li>limit：一个整数，限定返回的分割片段数量，返回数组里面的元素数量不会超过这个数。如果不设置此参数，那么整个字符串都将会被分隔，不会考虑返回数组的长度。</li>\n</ul>\n<h3 id=\"2-Array-from\"><a href=\"#2-Array-from\" class=\"headerlink\" title=\"2. Array.from()\"></a>2. Array.from()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;123&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(str);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);<span class=\"comment\">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Array.from()</code> 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>\n<p>这个方法是JavaScript中内置的一个方法，它是从给定的数组创建一个新的数组实例。</p>\n<p>这个方法不仅可以将字符串转换为数组，还可以将数字转换为数组。</p>\n<h2 id=\"数组转换为字符串\"><a href=\"#数组转换为字符串\" class=\"headerlink\" title=\"数组转换为字符串\"></a>数组转换为字符串</h2><h3 id=\"1-join\"><a href=\"#1-join\" class=\"headerlink\" title=\"1. join()\"></a>1. join()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = arr.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>join()</code> 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p>\n<pre><code>arr.join([separator])\n</code></pre>\n<p>在这个方法里面可以填一个参数，这个参数就是我们要用来连接数组的分隔符。如果不填，那么默认使用的是逗号。参数需要使用引号括起来。</p>\n<h3 id=\"2-toString\"><a href=\"#2-toString\" class=\"headerlink\" title=\"2. toString()\"></a>2. toString()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = arr.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个方法是不是很眼熟，没错我们前面数值转换为字符串也使用这个方法。</p>\n<p>使用这个方法将数组转换为字符串，那么数组中的每一项都会被转换为字符串，然后使用逗号连接起来。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数字、字符串、数组的相互转换\"><a href=\"#数字、字符串、数组的相互转换\" class=\"headerlink\" title=\"数字、字符串、数组的相互转换\"></a>数字、字符串、数组的相互转换</h1><p>今天是我第一天刷力扣，我就想着通过刷题来巩固一下之间学习过的知识。</p>\n<p>然后有一道题就需要将数字转换为字符串，然后倒转，比较是否相等。</p>\n<p>这里我就想把之前学习到数字、字符串、数组的相互转换，以及倒转的方法总结一下。</p>\n<h2 id=\"数字转换为字符串\"><a href=\"#数字转换为字符串\" class=\"headerlink\" title=\"数字转换为字符串\"></a>数字转换为字符串</h2><h3 id=\"1-运算符\"><a href=\"#1-运算符\" class=\"headerlink\" title=\"1. +运算符\"></a>1. <code>+</code>运算符</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = num + <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str); <span class=\"comment\">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>在JavaScript中，当我们的数值与字符串相加时，JavaScript会自动将数值转换为字符串。<br>这就是JavaScript中隐性转换的一种。</p>\n<h3 id=\"1-toString\"><a href=\"#1-toString\" class=\"headerlink\" title=\"1. toString()\"></a>1. toString()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = num.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// &quot;123&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str1 = num.<span class=\"title function_\">toString</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str1);<span class=\"comment\">// &quot;1111011&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toString(参数)</code> 方法返回一个表示指定 Number 对象的字符串。该字符串使用指定的基数进行表示。如果省略基数参数，则使用基数 10。<br>也就是说，我们使用该方法时，如果不传参数，我们默认使用的是十进制。我们可以传入参数（2、8、10、16），来指定我们要转换的进制。</p>\n<h3 id=\"2-String\"><a href=\"#2-String\" class=\"headerlink\" title=\"2. String()\"></a>2. String()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"title class_\">String</span>(num);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>String()</code> 方法将一个指定的值转换为字符串。他可以将非字符串的参数转换为字符串。不止是数字，还可以是对象、数组、布尔值、unll、undefined等。</p>\n<h2 id=\"字符串转换为数组\"><a href=\"#字符串转换为数组\" class=\"headerlink\" title=\"字符串转换为数组\"></a>字符串转换为数组</h2><h3 id=\"1-split\"><a href=\"#1-split\" class=\"headerlink\" title=\"1. split()\"></a>1. split()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;123&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = str.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);<span class=\"comment\">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure>\n<p><code>spilt()</code> 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分割为子字符串，以确定每个拆分的位置。</p>\n<pre><code>str.split([separator[, limit]])\n</code></pre>\n<ul>\n<li>separator：指定表示每个拆分应发生的点的字符串。separator 可以是一个字符串或正则表达式。如果 separator 是一个空字符串，则 str 中的每个字符之间都会被分割。</li>\n<li>limit：一个整数，限定返回的分割片段数量，返回数组里面的元素数量不会超过这个数。如果不设置此参数，那么整个字符串都将会被分隔，不会考虑返回数组的长度。</li>\n</ul>\n<h3 id=\"2-Array-from\"><a href=\"#2-Array-from\" class=\"headerlink\" title=\"2. Array.from()\"></a>2. Array.from()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;123&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(str);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);<span class=\"comment\">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Array.from()</code> 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>\n<p>这个方法是JavaScript中内置的一个方法，它是从给定的数组创建一个新的数组实例。</p>\n<p>这个方法不仅可以将字符串转换为数组，还可以将数字转换为数组。</p>\n<h2 id=\"数组转换为字符串\"><a href=\"#数组转换为字符串\" class=\"headerlink\" title=\"数组转换为字符串\"></a>数组转换为字符串</h2><h3 id=\"1-join\"><a href=\"#1-join\" class=\"headerlink\" title=\"1. join()\"></a>1. join()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = arr.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>join()</code> 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p>\n<pre><code>arr.join([separator])\n</code></pre>\n<p>在这个方法里面可以填一个参数，这个参数就是我们要用来连接数组的分隔符。如果不填，那么默认使用的是逗号。参数需要使用引号括起来。</p>\n<h3 id=\"2-toString\"><a href=\"#2-toString\" class=\"headerlink\" title=\"2. toString()\"></a>2. toString()</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = arr.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(str);<span class=\"comment\">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个方法是不是很眼熟，没错我们前面数值转换为字符串也使用这个方法。</p>\n<p>使用这个方法将数组转换为字符串，那么数组中的每一项都会被转换为字符串，然后使用逗号连接起来。</p>\n"},{"title":"js操作元素","date":"2022-09-08T16:00:00.000Z","_content":"# 操作元素\n\n## 前言\n\n前面说过，网页三件套中，HTML负责网页的框架，CSS负责网页的样式，而JavaScript负责网页的行为。\n\n在JavaScript中，我们可以通过DOM来操作网页中的元素，比如获取元素，修改元素，添加元素，删除元素等。这就是JavaScript操作网页行为的一种体现。\n\n## 流程\n\n与前面事件执行流程类似，操作元素也是通过事件触发，然后执行对应的操作。\n\n首先获取事件源，然后将事件源与世界类型进行绑定，最后通过函数的方式执行。\n\n那我们可以通过操作元素，达到一些什么样的效果呢?\n\n接着往下面看吧。\n\n## 改变元素文本内容\n\n**方式一：**\n\n    element.innerHTML = \"新的内容\";\n    替换起始位置和终止位置的内容，包括html标签；同时空格和换行会被保留。\n\n**方式二：**\n\n    element.innerText = \"新的内容\";\n    替换起始位置和终止位置的内容，但是它会自动删除html标签，同时空格和换行也会被删除。\n\n**两者的区别：**\n\n    1. innerHTML可以获取元素中的html标签，而innerText不可以。\n    2. innerHTML可以获取元素中的空格和换行，而innerText不可以。\n    3. innerHTML可以设置元素中的html标签，而innerText不可以。innerText不能识别html标签，所以设置的时候，会将html标签当做普通文本显示。\n\n## 改变元素样式\n\n通过js我们可以改编元素的大小，位置，颜色等等。\n\n1. 如果修改的元素样式比较少，我们可以通过element.style.属性名 = \"属性值\"的方式来修改。\n    element.style.属性 = \"样式属性值\";\n    例如：div.style.color = \"red\";\n\n此时修改的样式产生的是行内样式，css权重比较高。\n\n2. 如果修改元素的样式位于css文件中同时又比较多，我们可以通过element.className = \"类名\"的方式来修改。\n    element.className = \"新的类名\";\n    例如：element.className = \"red\";\n\n使用方法：\n\n1. 在css文件中定义一个类，例如：.red{color:red;}\n2. 在js中，我们通过element.className = \"red\"的方式来修改元素的样式。\n3. 最后实现效果\n\n*例子：*\n\n```css\n    <style>\n        .red{\n            color: red;\n        }\n    </style>\n```\n\n```html\n    <div>123123<div>\n```\n\n我们通过js将`red`类在div被点击之后添加上去。\n\n```javascript\n    let redClass = document.querySelector('div');\n    redClass.onclick = function(){\n        this.className = 'red';\n    }\n```\n\n这种方法适用于需要修改样式过多或者过于复杂的情况。\n\n**注意：**\nclassName会直接覆盖掉原来的元素类名，也就是原来的样式将会丢失。\n\n如果想要保留原来的样式，可以这样做：`element.className = '原来的样式类名 后面我们添加的样式类名'`，也就是多类名选择器。\n\n## 改变元素属性\n\n在html中，我们可以通过属性来设置元素的一些属性，比如id，class，src，href，alt，title等。\n\n    element.属性 = \"新的属性\";\n    例如：img.src = \"新的图片路径\";\n\n这些都是普通标签的元素操作，在html中有一类特殊的标签：`表单标签`。\n\n    表单元素：type,value,checked,selected,disable\n\n这些元素要如何进行操作呢?\n\n    <input type = \"text\" value = \"123123\">\n\n这里有一个输入框，我们来改变里面元素的内容：\n\n    let input = document.querySelector(\"input\");\n    input.onclick = function(){\n        input.value = \"新的内容\";\n    }\n\n这里我们就不能使用innerHTML或者innerText了。\n","source":"_posts/JavaScript/操作元素.md","raw":"---\ntitle: js操作元素\ndate: 2022-9-9\ntags: 前端\ncategories: JavaScript\n---\n# 操作元素\n\n## 前言\n\n前面说过，网页三件套中，HTML负责网页的框架，CSS负责网页的样式，而JavaScript负责网页的行为。\n\n在JavaScript中，我们可以通过DOM来操作网页中的元素，比如获取元素，修改元素，添加元素，删除元素等。这就是JavaScript操作网页行为的一种体现。\n\n## 流程\n\n与前面事件执行流程类似，操作元素也是通过事件触发，然后执行对应的操作。\n\n首先获取事件源，然后将事件源与世界类型进行绑定，最后通过函数的方式执行。\n\n那我们可以通过操作元素，达到一些什么样的效果呢?\n\n接着往下面看吧。\n\n## 改变元素文本内容\n\n**方式一：**\n\n    element.innerHTML = \"新的内容\";\n    替换起始位置和终止位置的内容，包括html标签；同时空格和换行会被保留。\n\n**方式二：**\n\n    element.innerText = \"新的内容\";\n    替换起始位置和终止位置的内容，但是它会自动删除html标签，同时空格和换行也会被删除。\n\n**两者的区别：**\n\n    1. innerHTML可以获取元素中的html标签，而innerText不可以。\n    2. innerHTML可以获取元素中的空格和换行，而innerText不可以。\n    3. innerHTML可以设置元素中的html标签，而innerText不可以。innerText不能识别html标签，所以设置的时候，会将html标签当做普通文本显示。\n\n## 改变元素样式\n\n通过js我们可以改编元素的大小，位置，颜色等等。\n\n1. 如果修改的元素样式比较少，我们可以通过element.style.属性名 = \"属性值\"的方式来修改。\n    element.style.属性 = \"样式属性值\";\n    例如：div.style.color = \"red\";\n\n此时修改的样式产生的是行内样式，css权重比较高。\n\n2. 如果修改元素的样式位于css文件中同时又比较多，我们可以通过element.className = \"类名\"的方式来修改。\n    element.className = \"新的类名\";\n    例如：element.className = \"red\";\n\n使用方法：\n\n1. 在css文件中定义一个类，例如：.red{color:red;}\n2. 在js中，我们通过element.className = \"red\"的方式来修改元素的样式。\n3. 最后实现效果\n\n*例子：*\n\n```css\n    <style>\n        .red{\n            color: red;\n        }\n    </style>\n```\n\n```html\n    <div>123123<div>\n```\n\n我们通过js将`red`类在div被点击之后添加上去。\n\n```javascript\n    let redClass = document.querySelector('div');\n    redClass.onclick = function(){\n        this.className = 'red';\n    }\n```\n\n这种方法适用于需要修改样式过多或者过于复杂的情况。\n\n**注意：**\nclassName会直接覆盖掉原来的元素类名，也就是原来的样式将会丢失。\n\n如果想要保留原来的样式，可以这样做：`element.className = '原来的样式类名 后面我们添加的样式类名'`，也就是多类名选择器。\n\n## 改变元素属性\n\n在html中，我们可以通过属性来设置元素的一些属性，比如id，class，src，href，alt，title等。\n\n    element.属性 = \"新的属性\";\n    例如：img.src = \"新的图片路径\";\n\n这些都是普通标签的元素操作，在html中有一类特殊的标签：`表单标签`。\n\n    表单元素：type,value,checked,selected,disable\n\n这些元素要如何进行操作呢?\n\n    <input type = \"text\" value = \"123123\">\n\n这里有一个输入框，我们来改变里面元素的内容：\n\n    let input = document.querySelector(\"input\");\n    input.onclick = function(){\n        input.value = \"新的内容\";\n    }\n\n这里我们就不能使用innerHTML或者innerText了。\n","slug":"JavaScript/操作元素","published":1,"updated":"2023-01-08T11:11:24.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmiz00639kbm8fks0f5x","content":"<h1 id=\"操作元素\"><a href=\"#操作元素\" class=\"headerlink\" title=\"操作元素\"></a>操作元素</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面说过，网页三件套中，HTML负责网页的框架，CSS负责网页的样式，而JavaScript负责网页的行为。</p>\n<p>在JavaScript中，我们可以通过DOM来操作网页中的元素，比如获取元素，修改元素，添加元素，删除元素等。这就是JavaScript操作网页行为的一种体现。</p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p>与前面事件执行流程类似，操作元素也是通过事件触发，然后执行对应的操作。</p>\n<p>首先获取事件源，然后将事件源与世界类型进行绑定，最后通过函数的方式执行。</p>\n<p>那我们可以通过操作元素，达到一些什么样的效果呢?</p>\n<p>接着往下面看吧。</p>\n<h2 id=\"改变元素文本内容\"><a href=\"#改变元素文本内容\" class=\"headerlink\" title=\"改变元素文本内容\"></a>改变元素文本内容</h2><p><strong>方式一：</strong></p>\n<pre><code>element.innerHTML = &quot;新的内容&quot;;\n替换起始位置和终止位置的内容，包括html标签；同时空格和换行会被保留。\n</code></pre>\n<p><strong>方式二：</strong></p>\n<pre><code>element.innerText = &quot;新的内容&quot;;\n替换起始位置和终止位置的内容，但是它会自动删除html标签，同时空格和换行也会被删除。\n</code></pre>\n<p><strong>两者的区别：</strong></p>\n<pre><code>1. innerHTML可以获取元素中的html标签，而innerText不可以。\n2. innerHTML可以获取元素中的空格和换行，而innerText不可以。\n3. innerHTML可以设置元素中的html标签，而innerText不可以。innerText不能识别html标签，所以设置的时候，会将html标签当做普通文本显示。\n</code></pre>\n<h2 id=\"改变元素样式\"><a href=\"#改变元素样式\" class=\"headerlink\" title=\"改变元素样式\"></a>改变元素样式</h2><p>通过js我们可以改编元素的大小，位置，颜色等等。</p>\n<ol>\n<li>如果修改的元素样式比较少，我们可以通过element.style.属性名 &#x3D; “属性值”的方式来修改。<br> element.style.属性 &#x3D; “样式属性值”;<br> 例如：div.style.color &#x3D; “red”;</li>\n</ol>\n<p>此时修改的样式产生的是行内样式，css权重比较高。</p>\n<ol start=\"2\">\n<li>如果修改元素的样式位于css文件中同时又比较多，我们可以通过element.className &#x3D; “类名”的方式来修改。<br> element.className &#x3D; “新的类名”;<br> 例如：element.className &#x3D; “red”;</li>\n</ol>\n<p>使用方法：</p>\n<ol>\n<li>在css文件中定义一个类，例如：.red{color:red;}</li>\n<li>在js中，我们通过element.className &#x3D; “red”的方式来修改元素的样式。</li>\n<li>最后实现效果</li>\n</ol>\n<p><em>例子：</em></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    <span class=\"selector-class\">.red</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>123123<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们通过js将<code>red</code>类在div被点击之后添加上去。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> redClass = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;div&#x27;</span>);</span><br><span class=\"line\">redClass.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">className</span> = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法适用于需要修改样式过多或者过于复杂的情况。</p>\n<p><strong>注意：</strong><br>className会直接覆盖掉原来的元素类名，也就是原来的样式将会丢失。</p>\n<p>如果想要保留原来的样式，可以这样做：<code>element.className = &#39;原来的样式类名 后面我们添加的样式类名&#39;</code>，也就是多类名选择器。</p>\n<h2 id=\"改变元素属性\"><a href=\"#改变元素属性\" class=\"headerlink\" title=\"改变元素属性\"></a>改变元素属性</h2><p>在html中，我们可以通过属性来设置元素的一些属性，比如id，class，src，href，alt，title等。</p>\n<pre><code>element.属性 = &quot;新的属性&quot;;\n例如：img.src = &quot;新的图片路径&quot;;\n</code></pre>\n<p>这些都是普通标签的元素操作，在html中有一类特殊的标签：<code>表单标签</code>。</p>\n<pre><code>表单元素：type,value,checked,selected,disable\n</code></pre>\n<p>这些元素要如何进行操作呢?</p>\n<pre><code>&lt;input type = &quot;text&quot; value = &quot;123123&quot;&gt;\n</code></pre>\n<p>这里有一个输入框，我们来改变里面元素的内容：</p>\n<pre><code>let input = document.querySelector(&quot;input&quot;);\ninput.onclick = function()&#123;\n    input.value = &quot;新的内容&quot;;\n&#125;\n</code></pre>\n<p>这里我们就不能使用innerHTML或者innerText了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"操作元素\"><a href=\"#操作元素\" class=\"headerlink\" title=\"操作元素\"></a>操作元素</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前面说过，网页三件套中，HTML负责网页的框架，CSS负责网页的样式，而JavaScript负责网页的行为。</p>\n<p>在JavaScript中，我们可以通过DOM来操作网页中的元素，比如获取元素，修改元素，添加元素，删除元素等。这就是JavaScript操作网页行为的一种体现。</p>\n<h2 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h2><p>与前面事件执行流程类似，操作元素也是通过事件触发，然后执行对应的操作。</p>\n<p>首先获取事件源，然后将事件源与世界类型进行绑定，最后通过函数的方式执行。</p>\n<p>那我们可以通过操作元素，达到一些什么样的效果呢?</p>\n<p>接着往下面看吧。</p>\n<h2 id=\"改变元素文本内容\"><a href=\"#改变元素文本内容\" class=\"headerlink\" title=\"改变元素文本内容\"></a>改变元素文本内容</h2><p><strong>方式一：</strong></p>\n<pre><code>element.innerHTML = &quot;新的内容&quot;;\n替换起始位置和终止位置的内容，包括html标签；同时空格和换行会被保留。\n</code></pre>\n<p><strong>方式二：</strong></p>\n<pre><code>element.innerText = &quot;新的内容&quot;;\n替换起始位置和终止位置的内容，但是它会自动删除html标签，同时空格和换行也会被删除。\n</code></pre>\n<p><strong>两者的区别：</strong></p>\n<pre><code>1. innerHTML可以获取元素中的html标签，而innerText不可以。\n2. innerHTML可以获取元素中的空格和换行，而innerText不可以。\n3. innerHTML可以设置元素中的html标签，而innerText不可以。innerText不能识别html标签，所以设置的时候，会将html标签当做普通文本显示。\n</code></pre>\n<h2 id=\"改变元素样式\"><a href=\"#改变元素样式\" class=\"headerlink\" title=\"改变元素样式\"></a>改变元素样式</h2><p>通过js我们可以改编元素的大小，位置，颜色等等。</p>\n<ol>\n<li>如果修改的元素样式比较少，我们可以通过element.style.属性名 &#x3D; “属性值”的方式来修改。<br> element.style.属性 &#x3D; “样式属性值”;<br> 例如：div.style.color &#x3D; “red”;</li>\n</ol>\n<p>此时修改的样式产生的是行内样式，css权重比较高。</p>\n<ol start=\"2\">\n<li>如果修改元素的样式位于css文件中同时又比较多，我们可以通过element.className &#x3D; “类名”的方式来修改。<br> element.className &#x3D; “新的类名”;<br> 例如：element.className &#x3D; “red”;</li>\n</ol>\n<p>使用方法：</p>\n<ol>\n<li>在css文件中定义一个类，例如：.red{color:red;}</li>\n<li>在js中，我们通过element.className &#x3D; “red”的方式来修改元素的样式。</li>\n<li>最后实现效果</li>\n</ol>\n<p><em>例子：</em></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    <span class=\"selector-class\">.red</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>123123<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们通过js将<code>red</code>类在div被点击之后添加上去。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> redClass = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;div&#x27;</span>);</span><br><span class=\"line\">redClass.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">className</span> = <span class=\"string\">&#x27;red&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法适用于需要修改样式过多或者过于复杂的情况。</p>\n<p><strong>注意：</strong><br>className会直接覆盖掉原来的元素类名，也就是原来的样式将会丢失。</p>\n<p>如果想要保留原来的样式，可以这样做：<code>element.className = &#39;原来的样式类名 后面我们添加的样式类名&#39;</code>，也就是多类名选择器。</p>\n<h2 id=\"改变元素属性\"><a href=\"#改变元素属性\" class=\"headerlink\" title=\"改变元素属性\"></a>改变元素属性</h2><p>在html中，我们可以通过属性来设置元素的一些属性，比如id，class，src，href，alt，title等。</p>\n<pre><code>element.属性 = &quot;新的属性&quot;;\n例如：img.src = &quot;新的图片路径&quot;;\n</code></pre>\n<p>这些都是普通标签的元素操作，在html中有一类特殊的标签：<code>表单标签</code>。</p>\n<pre><code>表单元素：type,value,checked,selected,disable\n</code></pre>\n<p>这些元素要如何进行操作呢?</p>\n<pre><code>&lt;input type = &quot;text&quot; value = &quot;123123&quot;&gt;\n</code></pre>\n<p>这里有一个输入框，我们来改变里面元素的内容：</p>\n<pre><code>let input = document.querySelector(&quot;input&quot;);\ninput.onclick = function()&#123;\n    input.value = &quot;新的内容&quot;;\n&#125;\n</code></pre>\n<p>这里我们就不能使用innerHTML或者innerText了。</p>\n"},{"title":"数组常用方法","date":"2022-08-28T16:00:00.000Z","_content":"# 数组常用方法\n\n## 添加/删除元素\n\n### push\n\npush() 方法可以将一个或多个元素添加到数组的末尾，并返回新的长度。\n\n    push(元素1,元素2……)\n\n可以一次性添加多个元素，也可以一个一个添加。\n\n```javascript\nvar arr = [1, 2, 3];\narr.push(4);\nconsole.log(arr); // [1, 2, 3, 4]\n```\n\n### pop\n\npop() 方法可以删除数组的最后一个元素，并返回该元素。\n\n    result = pop();\n\n最后将被删除的元素返回给 result。\n\n```javascript\nvar arr = [1, 2, 3];\nvar last = arr.pop();\nconsole.log(arr); // [1, 2]\nconsole.log(last); // 3\n```\n\n### unshift\n\nunshift() 方法可以将一个或多个元素添加到数组的开头，并返回新的长度。\n\n    arr.unshift(元素1,元素2……);\n\n可以一次性添加一个或者多个元素。\n\n```javascript\nvar arr = [1, 2, 3];\narr.unshift(0);\nconsole.log(arr); // [0, 1, 2, 3]\n```\n\n### shift\n\nshift() 方法可以删除数组的第一个元素，并返回该元素。\n\n    result = shift();\n\n最后将被删除的元素返回给 result。\n\n```javascript\nvar arr = [1, 2, 3];\nvar first = arr.shift();\nconsole.log(arr); // [2, 3]\nconsole.log(first); // 1\n```\n\n### splice\n\nsplice() 方法可以删除任意位置的元素，并且可以添加新的元素。返回被删除的元素。\n\n    arr.splice(index,howmany,element1,.....)\n\n- index: 要删除的元素的起始位置。\n- howmany: 要删除的元素个数。\n- element1,.....: 要添加的元素。(可以添加一个或者多个元素，元素之间使用逗号分隔)\n\n```javascript\nvar arr = [1, 2, 3];\nvar arr1 = arr.splice(1, 2,-1,-2); // 从下标为1的元素开始删除，删除两个元素,并插入-1,-2\nconsole.log(arr); // [1, -1, -2]\nconsole.log(arr1); // [2，3]\n```\n\n### slice\n\nslice() 方法可以提取数组的一部分，并返回一个新的数组。\n\n    arr.slice(start,end);\n\n- start: 要提取的元素的起始位置。\n- end: 要提取的元素的结束位置。(最后提取出来的元素并不包括结束位置的元素)\n\n```javascript\nvar arr = [1, 2, 3, 4, 5, 6];\nvar arr1 = arr.slice(1, 3); // 提取下标为[1,3)的元素（不包括下标为3的元素）\nconsole.log(arr); // [1, 2, 3, 4, 5, 6]\nconsole.log(arr1); // [2, 3]\n```\n\n### concat\n\nconcat() 方法可以将一个或多个数组连接起来，并返回一个新的数组。\n\n    arr.concat(arr1,arr2,....);\n\n- arr1,arr2,....: 要连接的数组。\n\n可以一次性连接多个数组。\n\n```javascript\nvar arr = [1, 2, 3];\nvar arr1 = arr.concat([4, 5]); // 将[4, 5]连接到arr后面\nconsole.log(arr); // [1, 2, 3]\nconsole.log(arr1); // [1, 2, 3, 4, 5]\n```\n\n\n### 一个小知识点：\n\npop()和push()方法在执行速度上比shift()和unshift()方法要快。\n\n因为pop()方法需要从数组的末尾删除元素，它不需要去移动数组的下标；而shift()方法从数组的开头删除元素，最后返回这个数组的时候，我们需要去比较数组里面每一个元素的下标，并移动。","source":"_posts/JavaScript/数组常用方法.md","raw":"---\ntitle: 数组常用方法\ndate: 2022-8-29\ntags: [前端]\ncategories: [JavaScript]\n---\n# 数组常用方法\n\n## 添加/删除元素\n\n### push\n\npush() 方法可以将一个或多个元素添加到数组的末尾，并返回新的长度。\n\n    push(元素1,元素2……)\n\n可以一次性添加多个元素，也可以一个一个添加。\n\n```javascript\nvar arr = [1, 2, 3];\narr.push(4);\nconsole.log(arr); // [1, 2, 3, 4]\n```\n\n### pop\n\npop() 方法可以删除数组的最后一个元素，并返回该元素。\n\n    result = pop();\n\n最后将被删除的元素返回给 result。\n\n```javascript\nvar arr = [1, 2, 3];\nvar last = arr.pop();\nconsole.log(arr); // [1, 2]\nconsole.log(last); // 3\n```\n\n### unshift\n\nunshift() 方法可以将一个或多个元素添加到数组的开头，并返回新的长度。\n\n    arr.unshift(元素1,元素2……);\n\n可以一次性添加一个或者多个元素。\n\n```javascript\nvar arr = [1, 2, 3];\narr.unshift(0);\nconsole.log(arr); // [0, 1, 2, 3]\n```\n\n### shift\n\nshift() 方法可以删除数组的第一个元素，并返回该元素。\n\n    result = shift();\n\n最后将被删除的元素返回给 result。\n\n```javascript\nvar arr = [1, 2, 3];\nvar first = arr.shift();\nconsole.log(arr); // [2, 3]\nconsole.log(first); // 1\n```\n\n### splice\n\nsplice() 方法可以删除任意位置的元素，并且可以添加新的元素。返回被删除的元素。\n\n    arr.splice(index,howmany,element1,.....)\n\n- index: 要删除的元素的起始位置。\n- howmany: 要删除的元素个数。\n- element1,.....: 要添加的元素。(可以添加一个或者多个元素，元素之间使用逗号分隔)\n\n```javascript\nvar arr = [1, 2, 3];\nvar arr1 = arr.splice(1, 2,-1,-2); // 从下标为1的元素开始删除，删除两个元素,并插入-1,-2\nconsole.log(arr); // [1, -1, -2]\nconsole.log(arr1); // [2，3]\n```\n\n### slice\n\nslice() 方法可以提取数组的一部分，并返回一个新的数组。\n\n    arr.slice(start,end);\n\n- start: 要提取的元素的起始位置。\n- end: 要提取的元素的结束位置。(最后提取出来的元素并不包括结束位置的元素)\n\n```javascript\nvar arr = [1, 2, 3, 4, 5, 6];\nvar arr1 = arr.slice(1, 3); // 提取下标为[1,3)的元素（不包括下标为3的元素）\nconsole.log(arr); // [1, 2, 3, 4, 5, 6]\nconsole.log(arr1); // [2, 3]\n```\n\n### concat\n\nconcat() 方法可以将一个或多个数组连接起来，并返回一个新的数组。\n\n    arr.concat(arr1,arr2,....);\n\n- arr1,arr2,....: 要连接的数组。\n\n可以一次性连接多个数组。\n\n```javascript\nvar arr = [1, 2, 3];\nvar arr1 = arr.concat([4, 5]); // 将[4, 5]连接到arr后面\nconsole.log(arr); // [1, 2, 3]\nconsole.log(arr1); // [1, 2, 3, 4, 5]\n```\n\n\n### 一个小知识点：\n\npop()和push()方法在执行速度上比shift()和unshift()方法要快。\n\n因为pop()方法需要从数组的末尾删除元素，它不需要去移动数组的下标；而shift()方法从数组的开头删除元素，最后返回这个数组的时候，我们需要去比较数组里面每一个元素的下标，并移动。","slug":"JavaScript/数组常用方法","published":1,"updated":"2023-01-08T12:05:14.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj000669kbm4umc7lsd","content":"<h1 id=\"数组常用方法\"><a href=\"#数组常用方法\" class=\"headerlink\" title=\"数组常用方法\"></a>数组常用方法</h1><h2 id=\"添加-x2F-删除元素\"><a href=\"#添加-x2F-删除元素\" class=\"headerlink\" title=\"添加&#x2F;删除元素\"></a>添加&#x2F;删除元素</h2><h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><p>push() 方法可以将一个或多个元素添加到数组的末尾，并返回新的长度。</p>\n<pre><code>push(元素1,元素2……)\n</code></pre>\n<p>可以一次性添加多个元素，也可以一个一个添加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">push</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h3><p>pop() 方法可以删除数组的最后一个元素，并返回该元素。</p>\n<pre><code>result = pop();\n</code></pre>\n<p>最后将被删除的元素返回给 result。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> last = arr.<span class=\"title function_\">pop</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(last); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift\"></a>unshift</h3><p>unshift() 方法可以将一个或多个元素添加到数组的开头，并返回新的长度。</p>\n<pre><code>arr.unshift(元素1,元素2……);\n</code></pre>\n<p>可以一次性添加一个或者多个元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">unshift</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h3><p>shift() 方法可以删除数组的第一个元素，并返回该元素。</p>\n<pre><code>result = shift();\n</code></pre>\n<p>最后将被删除的元素返回给 result。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> first = arr.<span class=\"title function_\">shift</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [2, 3]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h3><p>splice() 方法可以删除任意位置的元素，并且可以添加新的元素。返回被删除的元素。</p>\n<pre><code>arr.splice(index,howmany,element1,.....)\n</code></pre>\n<ul>\n<li>index: 要删除的元素的起始位置。</li>\n<li>howmany: 要删除的元素个数。</li>\n<li>element1,…..: 要添加的元素。(可以添加一个或者多个元素，元素之间使用逗号分隔)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = arr.<span class=\"title function_\">splice</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>,-<span class=\"number\">1</span>,-<span class=\"number\">2</span>); <span class=\"comment\">// 从下标为1的元素开始删除，删除两个元素,并插入-1,-2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, -1, -2]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr1); <span class=\"comment\">// [2，3]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><p>slice() 方法可以提取数组的一部分，并返回一个新的数组。</p>\n<pre><code>arr.slice(start,end);\n</code></pre>\n<ul>\n<li>start: 要提取的元素的起始位置。</li>\n<li>end: 要提取的元素的结束位置。(最后提取出来的元素并不包括结束位置的元素)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = arr.<span class=\"title function_\">slice</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 提取下标为[1,3)的元素（不包括下标为3的元素）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr1); <span class=\"comment\">// [2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h3><p>concat() 方法可以将一个或多个数组连接起来，并返回一个新的数组。</p>\n<pre><code>arr.concat(arr1,arr2,....);\n</code></pre>\n<ul>\n<li>arr1,arr2,….: 要连接的数组。</li>\n</ul>\n<p>可以一次性连接多个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = arr.<span class=\"title function_\">concat</span>([<span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// 将[4, 5]连接到arr后面</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr1); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"一个小知识点：\"><a href=\"#一个小知识点：\" class=\"headerlink\" title=\"一个小知识点：\"></a>一个小知识点：</h3><p>pop()和push()方法在执行速度上比shift()和unshift()方法要快。</p>\n<p>因为pop()方法需要从数组的末尾删除元素，它不需要去移动数组的下标；而shift()方法从数组的开头删除元素，最后返回这个数组的时候，我们需要去比较数组里面每一个元素的下标，并移动。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组常用方法\"><a href=\"#数组常用方法\" class=\"headerlink\" title=\"数组常用方法\"></a>数组常用方法</h1><h2 id=\"添加-x2F-删除元素\"><a href=\"#添加-x2F-删除元素\" class=\"headerlink\" title=\"添加&#x2F;删除元素\"></a>添加&#x2F;删除元素</h2><h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><p>push() 方法可以将一个或多个元素添加到数组的末尾，并返回新的长度。</p>\n<pre><code>push(元素1,元素2……)\n</code></pre>\n<p>可以一次性添加多个元素，也可以一个一个添加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">push</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h3><p>pop() 方法可以删除数组的最后一个元素，并返回该元素。</p>\n<pre><code>result = pop();\n</code></pre>\n<p>最后将被删除的元素返回给 result。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> last = arr.<span class=\"title function_\">pop</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(last); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unshift\"><a href=\"#unshift\" class=\"headerlink\" title=\"unshift\"></a>unshift</h3><p>unshift() 方法可以将一个或多个元素添加到数组的开头，并返回新的长度。</p>\n<pre><code>arr.unshift(元素1,元素2……);\n</code></pre>\n<p>可以一次性添加一个或者多个元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">unshift</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"shift\"><a href=\"#shift\" class=\"headerlink\" title=\"shift\"></a>shift</h3><p>shift() 方法可以删除数组的第一个元素，并返回该元素。</p>\n<pre><code>result = shift();\n</code></pre>\n<p>最后将被删除的元素返回给 result。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> first = arr.<span class=\"title function_\">shift</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [2, 3]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(first); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice\"></a>splice</h3><p>splice() 方法可以删除任意位置的元素，并且可以添加新的元素。返回被删除的元素。</p>\n<pre><code>arr.splice(index,howmany,element1,.....)\n</code></pre>\n<ul>\n<li>index: 要删除的元素的起始位置。</li>\n<li>howmany: 要删除的元素个数。</li>\n<li>element1,…..: 要添加的元素。(可以添加一个或者多个元素，元素之间使用逗号分隔)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = arr.<span class=\"title function_\">splice</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>,-<span class=\"number\">1</span>,-<span class=\"number\">2</span>); <span class=\"comment\">// 从下标为1的元素开始删除，删除两个元素,并插入-1,-2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, -1, -2]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr1); <span class=\"comment\">// [2，3]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h3><p>slice() 方法可以提取数组的一部分，并返回一个新的数组。</p>\n<pre><code>arr.slice(start,end);\n</code></pre>\n<ul>\n<li>start: 要提取的元素的起始位置。</li>\n<li>end: 要提取的元素的结束位置。(最后提取出来的元素并不包括结束位置的元素)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = arr.<span class=\"title function_\">slice</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>); <span class=\"comment\">// 提取下标为[1,3)的元素（不包括下标为3的元素）</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr1); <span class=\"comment\">// [2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h3><p>concat() 方法可以将一个或多个数组连接起来，并返回一个新的数组。</p>\n<pre><code>arr.concat(arr1,arr2,....);\n</code></pre>\n<ul>\n<li>arr1,arr2,….: 要连接的数组。</li>\n</ul>\n<p>可以一次性连接多个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = arr.<span class=\"title function_\">concat</span>([<span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// 将[4, 5]连接到arr后面</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr1); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"一个小知识点：\"><a href=\"#一个小知识点：\" class=\"headerlink\" title=\"一个小知识点：\"></a>一个小知识点：</h3><p>pop()和push()方法在执行速度上比shift()和unshift()方法要快。</p>\n<p>因为pop()方法需要从数组的末尾删除元素，它不需要去移动数组的下标；而shift()方法从数组的开头删除元素，最后返回这个数组的时候，我们需要去比较数组里面每一个元素的下标，并移动。</p>\n"},{"title":"数组常用方法3.0","date":"2022-08-30T16:00:00.000Z","_content":"# 数组常用方法3.0\n\n前面我们了解了数组的添加删除元素以及数组的查找。\n\n接下来，我们了解数组的转换。\n\n数组转换也有很多种方法：\n\n## map\n\n`arr.map`方法是最有用和经常使用的方法之一。\n\n    arr.map(function(item, index, array) {\n        return item;//返回的是新的值，而不是当前元素\n    });\n\n`map`方法对数组的每个元素都调用函数，并且返回一个新的数组，新数组的元素是函数返回的值。\n\n    let lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item => item.length);\n    alert(lengths); // 5,7,6\n\n这里通过`map`方法，我们可以得到每个元素的长度。\n\n## sort\n\n`arr.sort()`方法是对数组进行原位排序的方法（原位：就是指在原数组内，不会生成新数组）\n\nsort方法如果不提供compareFunction比较函数，那么就把数组中的元素转成字符串后按字符的Unicode码点进行比较。元素按不同的类型转成字符串的结果是不同的，对于JSON格式对象来说，其转换的结果就是[object Object]。\n\n最好的方法就是我们自己写一个比较函数，按照自己的想法去进行排序，比较函数要求返回`-1,0,1`。\n\n    function compare(a, b) {\n        if (a > b) return 1; // 如果第一个值比第二个值大\n        if (a == b) return 0; // 如果两个值相等\n        if (a < b) return -1; // 如果第一个值比第二个值小\n    }\n    let arr = [1, 2, 3, 4, 5];\n    arr.sort(compare);\n    alert(arr); // 1,2,3,4,5\n\n\n## reverse\n\n`arr.reverse()`这个方法通常用来颠倒`arr`里面元素的顺序。\n\n    let arr = [1,2,3,4,5];\n    arr.reverse();\n    console.log(arr);//5,4,3,2,1\n\n\n## join\n\n`join`方法是将数组中的元素用指定的字符串连接起来，返回一个字符串。\n\n里面可以放一个参数，这个参数是用来连接数组元素的字符串。\n\n    let str = ['海绵宝宝','痞老板','蟹老板','派大星']；\n    let newStr = str.join(';');//不同元素之间用分号连接\n    console.log(newStr);//海绵宝宝;痞老板;蟹老板;派大星\n\n这个方法就是用来连接数组中的元素的。\n\n## split\n\n`split()`方法是用来分开字符串的，并将结果返回到一个数组里面\n\n里面可以加一个参数，代表分隔符，默认是空格。\n\n    let str = '海绵宝宝;痞老板;蟹老板;派大星';\n    let newStr = str.split(';');//用分号分隔字符串\n    console.log(newStr);//[海绵宝宝,痞老板,蟹老板,派大星]","source":"_posts/JavaScript/数组常用方法3.0.md","raw":"---\ntitle: 数组常用方法3.0\ndate: 2022-8-31\ntags: [前端]\ncategories: [JavaScript]\n---\n# 数组常用方法3.0\n\n前面我们了解了数组的添加删除元素以及数组的查找。\n\n接下来，我们了解数组的转换。\n\n数组转换也有很多种方法：\n\n## map\n\n`arr.map`方法是最有用和经常使用的方法之一。\n\n    arr.map(function(item, index, array) {\n        return item;//返回的是新的值，而不是当前元素\n    });\n\n`map`方法对数组的每个元素都调用函数，并且返回一个新的数组，新数组的元素是函数返回的值。\n\n    let lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item => item.length);\n    alert(lengths); // 5,7,6\n\n这里通过`map`方法，我们可以得到每个元素的长度。\n\n## sort\n\n`arr.sort()`方法是对数组进行原位排序的方法（原位：就是指在原数组内，不会生成新数组）\n\nsort方法如果不提供compareFunction比较函数，那么就把数组中的元素转成字符串后按字符的Unicode码点进行比较。元素按不同的类型转成字符串的结果是不同的，对于JSON格式对象来说，其转换的结果就是[object Object]。\n\n最好的方法就是我们自己写一个比较函数，按照自己的想法去进行排序，比较函数要求返回`-1,0,1`。\n\n    function compare(a, b) {\n        if (a > b) return 1; // 如果第一个值比第二个值大\n        if (a == b) return 0; // 如果两个值相等\n        if (a < b) return -1; // 如果第一个值比第二个值小\n    }\n    let arr = [1, 2, 3, 4, 5];\n    arr.sort(compare);\n    alert(arr); // 1,2,3,4,5\n\n\n## reverse\n\n`arr.reverse()`这个方法通常用来颠倒`arr`里面元素的顺序。\n\n    let arr = [1,2,3,4,5];\n    arr.reverse();\n    console.log(arr);//5,4,3,2,1\n\n\n## join\n\n`join`方法是将数组中的元素用指定的字符串连接起来，返回一个字符串。\n\n里面可以放一个参数，这个参数是用来连接数组元素的字符串。\n\n    let str = ['海绵宝宝','痞老板','蟹老板','派大星']；\n    let newStr = str.join(';');//不同元素之间用分号连接\n    console.log(newStr);//海绵宝宝;痞老板;蟹老板;派大星\n\n这个方法就是用来连接数组中的元素的。\n\n## split\n\n`split()`方法是用来分开字符串的，并将结果返回到一个数组里面\n\n里面可以加一个参数，代表分隔符，默认是空格。\n\n    let str = '海绵宝宝;痞老板;蟹老板;派大星';\n    let newStr = str.split(';');//用分号分隔字符串\n    console.log(newStr);//[海绵宝宝,痞老板,蟹老板,派大星]","slug":"JavaScript/数组常用方法3.0","published":1,"updated":"2023-01-08T12:05:47.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj1006a9kbm6t5dfbzv","content":"<h1 id=\"数组常用方法3-0\"><a href=\"#数组常用方法3-0\" class=\"headerlink\" title=\"数组常用方法3.0\"></a>数组常用方法3.0</h1><p>前面我们了解了数组的添加删除元素以及数组的查找。</p>\n<p>接下来，我们了解数组的转换。</p>\n<p>数组转换也有很多种方法：</p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p><code>arr.map</code>方法是最有用和经常使用的方法之一。</p>\n<pre><code>arr.map(function(item, index, array) &#123;\n    return item;//返回的是新的值，而不是当前元素\n&#125;);\n</code></pre>\n<p><code>map</code>方法对数组的每个元素都调用函数，并且返回一个新的数组，新数组的元素是函数返回的值。</p>\n<pre><code>let lengths = [&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].map(item =&gt; item.length);\nalert(lengths); // 5,7,6\n</code></pre>\n<p>这里通过<code>map</code>方法，我们可以得到每个元素的长度。</p>\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><p><code>arr.sort()</code>方法是对数组进行原位排序的方法（原位：就是指在原数组内，不会生成新数组）</p>\n<p>sort方法如果不提供compareFunction比较函数，那么就把数组中的元素转成字符串后按字符的Unicode码点进行比较。元素按不同的类型转成字符串的结果是不同的，对于JSON格式对象来说，其转换的结果就是[object Object]。</p>\n<p>最好的方法就是我们自己写一个比较函数，按照自己的想法去进行排序，比较函数要求返回<code>-1,0,1</code>。</p>\n<pre><code>function compare(a, b) &#123;\n    if (a &gt; b) return 1; // 如果第一个值比第二个值大\n    if (a == b) return 0; // 如果两个值相等\n    if (a &lt; b) return -1; // 如果第一个值比第二个值小\n&#125;\nlet arr = [1, 2, 3, 4, 5];\narr.sort(compare);\nalert(arr); // 1,2,3,4,5\n</code></pre>\n<h2 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h2><p><code>arr.reverse()</code>这个方法通常用来颠倒<code>arr</code>里面元素的顺序。</p>\n<pre><code>let arr = [1,2,3,4,5];\narr.reverse();\nconsole.log(arr);//5,4,3,2,1\n</code></pre>\n<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h2><p><code>join</code>方法是将数组中的元素用指定的字符串连接起来，返回一个字符串。</p>\n<p>里面可以放一个参数，这个参数是用来连接数组元素的字符串。</p>\n<pre><code>let str = [&#39;海绵宝宝&#39;,&#39;痞老板&#39;,&#39;蟹老板&#39;,&#39;派大星&#39;]；\nlet newStr = str.join(&#39;;&#39;);//不同元素之间用分号连接\nconsole.log(newStr);//海绵宝宝;痞老板;蟹老板;派大星\n</code></pre>\n<p>这个方法就是用来连接数组中的元素的。</p>\n<h2 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split\"></a>split</h2><p><code>split()</code>方法是用来分开字符串的，并将结果返回到一个数组里面</p>\n<p>里面可以加一个参数，代表分隔符，默认是空格。</p>\n<pre><code>let str = &#39;海绵宝宝;痞老板;蟹老板;派大星&#39;;\nlet newStr = str.split(&#39;;&#39;);//用分号分隔字符串\nconsole.log(newStr);//[海绵宝宝,痞老板,蟹老板,派大星]\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组常用方法3-0\"><a href=\"#数组常用方法3-0\" class=\"headerlink\" title=\"数组常用方法3.0\"></a>数组常用方法3.0</h1><p>前面我们了解了数组的添加删除元素以及数组的查找。</p>\n<p>接下来，我们了解数组的转换。</p>\n<p>数组转换也有很多种方法：</p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p><code>arr.map</code>方法是最有用和经常使用的方法之一。</p>\n<pre><code>arr.map(function(item, index, array) &#123;\n    return item;//返回的是新的值，而不是当前元素\n&#125;);\n</code></pre>\n<p><code>map</code>方法对数组的每个元素都调用函数，并且返回一个新的数组，新数组的元素是函数返回的值。</p>\n<pre><code>let lengths = [&quot;Bilbo&quot;, &quot;Gandalf&quot;, &quot;Nazgul&quot;].map(item =&gt; item.length);\nalert(lengths); // 5,7,6\n</code></pre>\n<p>这里通过<code>map</code>方法，我们可以得到每个元素的长度。</p>\n<h2 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h2><p><code>arr.sort()</code>方法是对数组进行原位排序的方法（原位：就是指在原数组内，不会生成新数组）</p>\n<p>sort方法如果不提供compareFunction比较函数，那么就把数组中的元素转成字符串后按字符的Unicode码点进行比较。元素按不同的类型转成字符串的结果是不同的，对于JSON格式对象来说，其转换的结果就是[object Object]。</p>\n<p>最好的方法就是我们自己写一个比较函数，按照自己的想法去进行排序，比较函数要求返回<code>-1,0,1</code>。</p>\n<pre><code>function compare(a, b) &#123;\n    if (a &gt; b) return 1; // 如果第一个值比第二个值大\n    if (a == b) return 0; // 如果两个值相等\n    if (a &lt; b) return -1; // 如果第一个值比第二个值小\n&#125;\nlet arr = [1, 2, 3, 4, 5];\narr.sort(compare);\nalert(arr); // 1,2,3,4,5\n</code></pre>\n<h2 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h2><p><code>arr.reverse()</code>这个方法通常用来颠倒<code>arr</code>里面元素的顺序。</p>\n<pre><code>let arr = [1,2,3,4,5];\narr.reverse();\nconsole.log(arr);//5,4,3,2,1\n</code></pre>\n<h2 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join\"></a>join</h2><p><code>join</code>方法是将数组中的元素用指定的字符串连接起来，返回一个字符串。</p>\n<p>里面可以放一个参数，这个参数是用来连接数组元素的字符串。</p>\n<pre><code>let str = [&#39;海绵宝宝&#39;,&#39;痞老板&#39;,&#39;蟹老板&#39;,&#39;派大星&#39;]；\nlet newStr = str.join(&#39;;&#39;);//不同元素之间用分号连接\nconsole.log(newStr);//海绵宝宝;痞老板;蟹老板;派大星\n</code></pre>\n<p>这个方法就是用来连接数组中的元素的。</p>\n<h2 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split\"></a>split</h2><p><code>split()</code>方法是用来分开字符串的，并将结果返回到一个数组里面</p>\n<p>里面可以加一个参数，代表分隔符，默认是空格。</p>\n<pre><code>let str = &#39;海绵宝宝;痞老板;蟹老板;派大星&#39;;\nlet newStr = str.split(&#39;;&#39;);//用分号分隔字符串\nconsole.log(newStr);//[海绵宝宝,痞老板,蟹老板,派大星]\n</code></pre>\n"},{"title":"数组常用方法2.0","date":"2022-08-19T16:00:00.000Z","_content":"\n# 数组常用方法2.0\n\n在上一篇文章中，我们讲到数组的添加/删除元素的方法，这里我们接着讲述数组的查找元素的方法。\n\n## 数组中搜索元素\n\n### indexOf/lastIndexOf与includes\n\nindexOf() 方法可以返回某个指定的元素在数组中首次出现的位置，如果不存在，则返回 -1。\n\n    indexOf(元素, [fromIndex = 0])\n\n- 元素：指定的元素。（也就是我们需要查找的元素）\n- formIndex：指定的起始位置。（默认为 0）,位置为数组的下标。\n\nlastIndexOf() 方法可以返回某个指定的元素在数组中最后出现的位置，如果不存在，则返回 -1。\n\n    lastIndexOf(元素, [fromIndex = array.length - 1])\n\n- 元素：指定的元素。（也就是我们需要查找的元素）\n- formIndex：指定的起始位置。（默认为数组的长度 - 1）,位置为数组的下标。(此时查找方向为从后往前)\n\nincludes() 方法可以判断某个指定的元素是否存在于数组中，如果存在，则返回 true，否则返回 false。\n\n    includes(元素, [fromIndex = 0])\n\n- 元素：指定的元素。（也就是我们需要查找的元素）\n- formIndex：指定的起始位置。（默认为 0）,位置为数组的下标。\n\n### find/findIndex/findLastIndex\n\n当我们需要查找一个对象数组中的元素，我们应该如何找到特定对象的元素呢？\n\n这时候就可以使用`arr.find`语法，它可以返回第一个符合条件的元素。\n\nfind() 方法可以在数组中找到第一个符合条件的元素，如果没有找到，则返回 undefined。\n\n    let result = arr.find(function(item,index,array)){\n        //如果返回true，则返回该元素，并停止迭代。\n        //对于假值的情况（false）,否则返回undefined\n    }\n\n- item：当前遍历的元素。\n- index：当前遍历的元素的索引。\n- array：当前遍历的数组。(也就是数组本省)\n\n`arr.findIndex()`方法与`find()`方法类似，只不过它返回符合条件的元素的索引，而不是返回元素本身。\n\n`arr.findLastIndex()`方法与`findIndex()`方法类似，只不过它是从右向左搜索，有点类似于`lastIndexOf`。\n\n### filter\n\n`filter()` 方法返回一个由所有符合条件的元素组成的新数组。\n\n`find`方法和`filter`方法的区别在于，`find`方法只返回第一个符合条件的元素，而`filter`方法返回所有符合条件的元素（数组形式）。\n\n    let results = arr.filter(function(item, index, array) {\n        // 如果 true,那么 item 被 push 到 results，迭代继续\n        // 如果什么都没找到，则返回空数组\n    });","source":"_posts/JavaScript/数组常用方法2.0.md","raw":"---\ntitle: 数组常用方法2.0\ndate: 2022-8-20\ntags: [前端]\ncategories: [JavaScript]\n---\n\n# 数组常用方法2.0\n\n在上一篇文章中，我们讲到数组的添加/删除元素的方法，这里我们接着讲述数组的查找元素的方法。\n\n## 数组中搜索元素\n\n### indexOf/lastIndexOf与includes\n\nindexOf() 方法可以返回某个指定的元素在数组中首次出现的位置，如果不存在，则返回 -1。\n\n    indexOf(元素, [fromIndex = 0])\n\n- 元素：指定的元素。（也就是我们需要查找的元素）\n- formIndex：指定的起始位置。（默认为 0）,位置为数组的下标。\n\nlastIndexOf() 方法可以返回某个指定的元素在数组中最后出现的位置，如果不存在，则返回 -1。\n\n    lastIndexOf(元素, [fromIndex = array.length - 1])\n\n- 元素：指定的元素。（也就是我们需要查找的元素）\n- formIndex：指定的起始位置。（默认为数组的长度 - 1）,位置为数组的下标。(此时查找方向为从后往前)\n\nincludes() 方法可以判断某个指定的元素是否存在于数组中，如果存在，则返回 true，否则返回 false。\n\n    includes(元素, [fromIndex = 0])\n\n- 元素：指定的元素。（也就是我们需要查找的元素）\n- formIndex：指定的起始位置。（默认为 0）,位置为数组的下标。\n\n### find/findIndex/findLastIndex\n\n当我们需要查找一个对象数组中的元素，我们应该如何找到特定对象的元素呢？\n\n这时候就可以使用`arr.find`语法，它可以返回第一个符合条件的元素。\n\nfind() 方法可以在数组中找到第一个符合条件的元素，如果没有找到，则返回 undefined。\n\n    let result = arr.find(function(item,index,array)){\n        //如果返回true，则返回该元素，并停止迭代。\n        //对于假值的情况（false）,否则返回undefined\n    }\n\n- item：当前遍历的元素。\n- index：当前遍历的元素的索引。\n- array：当前遍历的数组。(也就是数组本省)\n\n`arr.findIndex()`方法与`find()`方法类似，只不过它返回符合条件的元素的索引，而不是返回元素本身。\n\n`arr.findLastIndex()`方法与`findIndex()`方法类似，只不过它是从右向左搜索，有点类似于`lastIndexOf`。\n\n### filter\n\n`filter()` 方法返回一个由所有符合条件的元素组成的新数组。\n\n`find`方法和`filter`方法的区别在于，`find`方法只返回第一个符合条件的元素，而`filter`方法返回所有符合条件的元素（数组形式）。\n\n    let results = arr.filter(function(item, index, array) {\n        // 如果 true,那么 item 被 push 到 results，迭代继续\n        // 如果什么都没找到，则返回空数组\n    });","slug":"JavaScript/数组常用方法2.0","published":1,"updated":"2023-01-08T12:09:04.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj1006d9kbm9284h7x8","content":"<h1 id=\"数组常用方法2-0\"><a href=\"#数组常用方法2-0\" class=\"headerlink\" title=\"数组常用方法2.0\"></a>数组常用方法2.0</h1><p>在上一篇文章中，我们讲到数组的添加&#x2F;删除元素的方法，这里我们接着讲述数组的查找元素的方法。</p>\n<h2 id=\"数组中搜索元素\"><a href=\"#数组中搜索元素\" class=\"headerlink\" title=\"数组中搜索元素\"></a>数组中搜索元素</h2><h3 id=\"indexOf-x2F-lastIndexOf与includes\"><a href=\"#indexOf-x2F-lastIndexOf与includes\" class=\"headerlink\" title=\"indexOf&#x2F;lastIndexOf与includes\"></a>indexOf&#x2F;lastIndexOf与includes</h3><p>indexOf() 方法可以返回某个指定的元素在数组中首次出现的位置，如果不存在，则返回 -1。</p>\n<pre><code>indexOf(元素, [fromIndex = 0])\n</code></pre>\n<ul>\n<li>元素：指定的元素。（也就是我们需要查找的元素）</li>\n<li>formIndex：指定的起始位置。（默认为 0）,位置为数组的下标。</li>\n</ul>\n<p>lastIndexOf() 方法可以返回某个指定的元素在数组中最后出现的位置，如果不存在，则返回 -1。</p>\n<pre><code>lastIndexOf(元素, [fromIndex = array.length - 1])\n</code></pre>\n<ul>\n<li>元素：指定的元素。（也就是我们需要查找的元素）</li>\n<li>formIndex：指定的起始位置。（默认为数组的长度 - 1）,位置为数组的下标。(此时查找方向为从后往前)</li>\n</ul>\n<p>includes() 方法可以判断某个指定的元素是否存在于数组中，如果存在，则返回 true，否则返回 false。</p>\n<pre><code>includes(元素, [fromIndex = 0])\n</code></pre>\n<ul>\n<li>元素：指定的元素。（也就是我们需要查找的元素）</li>\n<li>formIndex：指定的起始位置。（默认为 0）,位置为数组的下标。</li>\n</ul>\n<h3 id=\"find-x2F-findIndex-x2F-findLastIndex\"><a href=\"#find-x2F-findIndex-x2F-findLastIndex\" class=\"headerlink\" title=\"find&#x2F;findIndex&#x2F;findLastIndex\"></a>find&#x2F;findIndex&#x2F;findLastIndex</h3><p>当我们需要查找一个对象数组中的元素，我们应该如何找到特定对象的元素呢？</p>\n<p>这时候就可以使用<code>arr.find</code>语法，它可以返回第一个符合条件的元素。</p>\n<p>find() 方法可以在数组中找到第一个符合条件的元素，如果没有找到，则返回 undefined。</p>\n<pre><code>let result = arr.find(function(item,index,array))&#123;\n    //如果返回true，则返回该元素，并停止迭代。\n    //对于假值的情况（false）,否则返回undefined\n&#125;\n</code></pre>\n<ul>\n<li>item：当前遍历的元素。</li>\n<li>index：当前遍历的元素的索引。</li>\n<li>array：当前遍历的数组。(也就是数组本省)</li>\n</ul>\n<p><code>arr.findIndex()</code>方法与<code>find()</code>方法类似，只不过它返回符合条件的元素的索引，而不是返回元素本身。</p>\n<p><code>arr.findLastIndex()</code>方法与<code>findIndex()</code>方法类似，只不过它是从右向左搜索，有点类似于<code>lastIndexOf</code>。</p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p><code>filter()</code> 方法返回一个由所有符合条件的元素组成的新数组。</p>\n<p><code>find</code>方法和<code>filter</code>方法的区别在于，<code>find</code>方法只返回第一个符合条件的元素，而<code>filter</code>方法返回所有符合条件的元素（数组形式）。</p>\n<pre><code>let results = arr.filter(function(item, index, array) &#123;\n    // 如果 true,那么 item 被 push 到 results，迭代继续\n    // 如果什么都没找到，则返回空数组\n&#125;);\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组常用方法2-0\"><a href=\"#数组常用方法2-0\" class=\"headerlink\" title=\"数组常用方法2.0\"></a>数组常用方法2.0</h1><p>在上一篇文章中，我们讲到数组的添加&#x2F;删除元素的方法，这里我们接着讲述数组的查找元素的方法。</p>\n<h2 id=\"数组中搜索元素\"><a href=\"#数组中搜索元素\" class=\"headerlink\" title=\"数组中搜索元素\"></a>数组中搜索元素</h2><h3 id=\"indexOf-x2F-lastIndexOf与includes\"><a href=\"#indexOf-x2F-lastIndexOf与includes\" class=\"headerlink\" title=\"indexOf&#x2F;lastIndexOf与includes\"></a>indexOf&#x2F;lastIndexOf与includes</h3><p>indexOf() 方法可以返回某个指定的元素在数组中首次出现的位置，如果不存在，则返回 -1。</p>\n<pre><code>indexOf(元素, [fromIndex = 0])\n</code></pre>\n<ul>\n<li>元素：指定的元素。（也就是我们需要查找的元素）</li>\n<li>formIndex：指定的起始位置。（默认为 0）,位置为数组的下标。</li>\n</ul>\n<p>lastIndexOf() 方法可以返回某个指定的元素在数组中最后出现的位置，如果不存在，则返回 -1。</p>\n<pre><code>lastIndexOf(元素, [fromIndex = array.length - 1])\n</code></pre>\n<ul>\n<li>元素：指定的元素。（也就是我们需要查找的元素）</li>\n<li>formIndex：指定的起始位置。（默认为数组的长度 - 1）,位置为数组的下标。(此时查找方向为从后往前)</li>\n</ul>\n<p>includes() 方法可以判断某个指定的元素是否存在于数组中，如果存在，则返回 true，否则返回 false。</p>\n<pre><code>includes(元素, [fromIndex = 0])\n</code></pre>\n<ul>\n<li>元素：指定的元素。（也就是我们需要查找的元素）</li>\n<li>formIndex：指定的起始位置。（默认为 0）,位置为数组的下标。</li>\n</ul>\n<h3 id=\"find-x2F-findIndex-x2F-findLastIndex\"><a href=\"#find-x2F-findIndex-x2F-findLastIndex\" class=\"headerlink\" title=\"find&#x2F;findIndex&#x2F;findLastIndex\"></a>find&#x2F;findIndex&#x2F;findLastIndex</h3><p>当我们需要查找一个对象数组中的元素，我们应该如何找到特定对象的元素呢？</p>\n<p>这时候就可以使用<code>arr.find</code>语法，它可以返回第一个符合条件的元素。</p>\n<p>find() 方法可以在数组中找到第一个符合条件的元素，如果没有找到，则返回 undefined。</p>\n<pre><code>let result = arr.find(function(item,index,array))&#123;\n    //如果返回true，则返回该元素，并停止迭代。\n    //对于假值的情况（false）,否则返回undefined\n&#125;\n</code></pre>\n<ul>\n<li>item：当前遍历的元素。</li>\n<li>index：当前遍历的元素的索引。</li>\n<li>array：当前遍历的数组。(也就是数组本省)</li>\n</ul>\n<p><code>arr.findIndex()</code>方法与<code>find()</code>方法类似，只不过它返回符合条件的元素的索引，而不是返回元素本身。</p>\n<p><code>arr.findLastIndex()</code>方法与<code>findIndex()</code>方法类似，只不过它是从右向左搜索，有点类似于<code>lastIndexOf</code>。</p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p><code>filter()</code> 方法返回一个由所有符合条件的元素组成的新数组。</p>\n<p><code>find</code>方法和<code>filter</code>方法的区别在于，<code>find</code>方法只返回第一个符合条件的元素，而<code>filter</code>方法返回所有符合条件的元素（数组形式）。</p>\n<pre><code>let results = arr.filter(function(item, index, array) &#123;\n    // 如果 true,那么 item 被 push 到 results，迭代继续\n    // 如果什么都没找到，则返回空数组\n&#125;);\n</code></pre>\n"},{"title":"日期与时间","date":"2022-08-28T16:00:00.000Z","_content":"# 日期与时间\n\n在JavaScript中，有一个内置对象，专门用来存储日期和时间，并且给我们提供了日期和时间的管理方法。下面我们就来了解一下这些管理时间的方法。\n\n## 创建`Date()`对象\n\n### 使用`new Date()`来创建一个`Date()`对象。\n\n在调用的时候我们可以添加一些参数，具体参数如下：\n\n- `new Date():`\n\n第一种，我们不带任何参数————创建一个表示当前日期和时间的`Date`对象。\n\n    let nowTime = new Date();\n    alert(nowTime);//显示当前日期和时间\n\n- `new Date(milliseconds):`\n\n创建一个对象，它的时间等于自1970年1月1日之后所经过的毫秒数。\n\n    let time = new Date(0);\n    alert(time);//显示1970年1月1日0时0分0秒\n    let time1 = new Date(1000);\n    alert(time1);//显示1970年1月1日0时0分1秒\n\n这里传入的参数代表自1970-01-01 00:00:00 UTC+00:00时区所经过的毫秒数。这个整数被我们叫做`时间戳`。","source":"_posts/JavaScript/日期与时间.md","raw":"---\ntitle: 日期与时间\ndate: 2022-8-29\ntags: [前端]\ncategories: [JavaScript]\n---\n# 日期与时间\n\n在JavaScript中，有一个内置对象，专门用来存储日期和时间，并且给我们提供了日期和时间的管理方法。下面我们就来了解一下这些管理时间的方法。\n\n## 创建`Date()`对象\n\n### 使用`new Date()`来创建一个`Date()`对象。\n\n在调用的时候我们可以添加一些参数，具体参数如下：\n\n- `new Date():`\n\n第一种，我们不带任何参数————创建一个表示当前日期和时间的`Date`对象。\n\n    let nowTime = new Date();\n    alert(nowTime);//显示当前日期和时间\n\n- `new Date(milliseconds):`\n\n创建一个对象，它的时间等于自1970年1月1日之后所经过的毫秒数。\n\n    let time = new Date(0);\n    alert(time);//显示1970年1月1日0时0分0秒\n    let time1 = new Date(1000);\n    alert(time1);//显示1970年1月1日0时0分1秒\n\n这里传入的参数代表自1970-01-01 00:00:00 UTC+00:00时区所经过的毫秒数。这个整数被我们叫做`时间戳`。","slug":"JavaScript/日期与时间","published":1,"updated":"2023-01-10T04:28:41.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj2006g9kbm2mc1bpyg","content":"<h1 id=\"日期与时间\"><a href=\"#日期与时间\" class=\"headerlink\" title=\"日期与时间\"></a>日期与时间</h1><p>在JavaScript中，有一个内置对象，专门用来存储日期和时间，并且给我们提供了日期和时间的管理方法。下面我们就来了解一下这些管理时间的方法。</p>\n<h2 id=\"创建Date-对象\"><a href=\"#创建Date-对象\" class=\"headerlink\" title=\"创建Date()对象\"></a>创建<code>Date()</code>对象</h2><h3 id=\"使用new-Date-来创建一个Date-对象。\"><a href=\"#使用new-Date-来创建一个Date-对象。\" class=\"headerlink\" title=\"使用new Date()来创建一个Date()对象。\"></a>使用<code>new Date()</code>来创建一个<code>Date()</code>对象。</h3><p>在调用的时候我们可以添加一些参数，具体参数如下：</p>\n<ul>\n<li><code>new Date():</code></li>\n</ul>\n<p>第一种，我们不带任何参数————创建一个表示当前日期和时间的<code>Date</code>对象。</p>\n<pre><code>let nowTime = new Date();\nalert(nowTime);//显示当前日期和时间\n</code></pre>\n<ul>\n<li><code>new Date(milliseconds):</code></li>\n</ul>\n<p>创建一个对象，它的时间等于自1970年1月1日之后所经过的毫秒数。</p>\n<pre><code>let time = new Date(0);\nalert(time);//显示1970年1月1日0时0分0秒\nlet time1 = new Date(1000);\nalert(time1);//显示1970年1月1日0时0分1秒\n</code></pre>\n<p>这里传入的参数代表自1970-01-01 00:00:00 UTC+00:00时区所经过的毫秒数。这个整数被我们叫做<code>时间戳</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"日期与时间\"><a href=\"#日期与时间\" class=\"headerlink\" title=\"日期与时间\"></a>日期与时间</h1><p>在JavaScript中，有一个内置对象，专门用来存储日期和时间，并且给我们提供了日期和时间的管理方法。下面我们就来了解一下这些管理时间的方法。</p>\n<h2 id=\"创建Date-对象\"><a href=\"#创建Date-对象\" class=\"headerlink\" title=\"创建Date()对象\"></a>创建<code>Date()</code>对象</h2><h3 id=\"使用new-Date-来创建一个Date-对象。\"><a href=\"#使用new-Date-来创建一个Date-对象。\" class=\"headerlink\" title=\"使用new Date()来创建一个Date()对象。\"></a>使用<code>new Date()</code>来创建一个<code>Date()</code>对象。</h3><p>在调用的时候我们可以添加一些参数，具体参数如下：</p>\n<ul>\n<li><code>new Date():</code></li>\n</ul>\n<p>第一种，我们不带任何参数————创建一个表示当前日期和时间的<code>Date</code>对象。</p>\n<pre><code>let nowTime = new Date();\nalert(nowTime);//显示当前日期和时间\n</code></pre>\n<ul>\n<li><code>new Date(milliseconds):</code></li>\n</ul>\n<p>创建一个对象，它的时间等于自1970年1月1日之后所经过的毫秒数。</p>\n<pre><code>let time = new Date(0);\nalert(time);//显示1970年1月1日0时0分0秒\nlet time1 = new Date(1000);\nalert(time1);//显示1970年1月1日0时0分1秒\n</code></pre>\n<p>这里传入的参数代表自1970-01-01 00:00:00 UTC+00:00时区所经过的毫秒数。这个整数被我们叫做<code>时间戳</code>。</p>\n"},{"title":"注册事件（绑定事件）","date":"2022-09-18T16:00:00.000Z","_content":"# 注册事件（绑定事件）\n\n注册事件也就是给元素添加事件，成为注册事件或者绑定事件。\n\n注册事件的方法有两种：\n\n1. 传统方法注册事件\n2. 方法监听注册事件\n\n那么这两种方法有什么区别呢？\n\n## 传统方法注册事件\n\n传统方法注册事件，就是直接在元素上添加事件属性，然后给事件属性赋值，这个值就是事件处理函数。\n\n我们事件经常利用`on`开头,比如`onclick`、`onmouseover`、`onmouseout`等等。\n\n这种方法注册事件有一个特性：唯一性\n\n也就是说，如果一个元素上有多个事件，那么这个元素上只能有一个事件处理函数。如果有多个事件注册，那么最后一个注册事件会覆盖前面的事件。\n\n## 方法监听注册事件\n\n这是w3c的标准，也是我们推荐使用的方法。\n\n方法监听注册事件，就是利用`addEventListener`方法来注册事件。\n\n    Element[i].addEventListener(event, function, useCapture);\n\n这个方法有三个参数：\n\n1. event：事件类型，比如`click`、`mouseover`、`mouseout`等等。\n2. function：事件处理函数。\n3. useCapture：是否在捕获阶段执行事件处理函数。默认值为false，表示在冒泡阶段执行事件处理函数。\n\n**注意：**\n\nie8及以下版本不支持这个方法。  看来好东西都是有兼容性的问题。\n\n这个方法的特点呢，就是不会出现唯一性问题，也就是说，如果一个元素上有多个事件，那么这个元素上可以有多个事件处理函数。它会按照我们注册事件的顺序依次执行。","source":"_posts/JavaScript/注册事件（绑定事件）.md","raw":"---\ntitle: 注册事件（绑定事件）\ndate: 2022-9-19\ntags: [前端]\ncategories: [JavaScript]\n---\n# 注册事件（绑定事件）\n\n注册事件也就是给元素添加事件，成为注册事件或者绑定事件。\n\n注册事件的方法有两种：\n\n1. 传统方法注册事件\n2. 方法监听注册事件\n\n那么这两种方法有什么区别呢？\n\n## 传统方法注册事件\n\n传统方法注册事件，就是直接在元素上添加事件属性，然后给事件属性赋值，这个值就是事件处理函数。\n\n我们事件经常利用`on`开头,比如`onclick`、`onmouseover`、`onmouseout`等等。\n\n这种方法注册事件有一个特性：唯一性\n\n也就是说，如果一个元素上有多个事件，那么这个元素上只能有一个事件处理函数。如果有多个事件注册，那么最后一个注册事件会覆盖前面的事件。\n\n## 方法监听注册事件\n\n这是w3c的标准，也是我们推荐使用的方法。\n\n方法监听注册事件，就是利用`addEventListener`方法来注册事件。\n\n    Element[i].addEventListener(event, function, useCapture);\n\n这个方法有三个参数：\n\n1. event：事件类型，比如`click`、`mouseover`、`mouseout`等等。\n2. function：事件处理函数。\n3. useCapture：是否在捕获阶段执行事件处理函数。默认值为false，表示在冒泡阶段执行事件处理函数。\n\n**注意：**\n\nie8及以下版本不支持这个方法。  看来好东西都是有兼容性的问题。\n\n这个方法的特点呢，就是不会出现唯一性问题，也就是说，如果一个元素上有多个事件，那么这个元素上可以有多个事件处理函数。它会按照我们注册事件的顺序依次执行。","slug":"JavaScript/注册事件（绑定事件）","published":1,"updated":"2023-01-09T11:46:45.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj3006j9kbmb0rgds3g","content":"<h1 id=\"注册事件（绑定事件）\"><a href=\"#注册事件（绑定事件）\" class=\"headerlink\" title=\"注册事件（绑定事件）\"></a>注册事件（绑定事件）</h1><p>注册事件也就是给元素添加事件，成为注册事件或者绑定事件。</p>\n<p>注册事件的方法有两种：</p>\n<ol>\n<li>传统方法注册事件</li>\n<li>方法监听注册事件</li>\n</ol>\n<p>那么这两种方法有什么区别呢？</p>\n<h2 id=\"传统方法注册事件\"><a href=\"#传统方法注册事件\" class=\"headerlink\" title=\"传统方法注册事件\"></a>传统方法注册事件</h2><p>传统方法注册事件，就是直接在元素上添加事件属性，然后给事件属性赋值，这个值就是事件处理函数。</p>\n<p>我们事件经常利用<code>on</code>开头,比如<code>onclick</code>、<code>onmouseover</code>、<code>onmouseout</code>等等。</p>\n<p>这种方法注册事件有一个特性：唯一性</p>\n<p>也就是说，如果一个元素上有多个事件，那么这个元素上只能有一个事件处理函数。如果有多个事件注册，那么最后一个注册事件会覆盖前面的事件。</p>\n<h2 id=\"方法监听注册事件\"><a href=\"#方法监听注册事件\" class=\"headerlink\" title=\"方法监听注册事件\"></a>方法监听注册事件</h2><p>这是w3c的标准，也是我们推荐使用的方法。</p>\n<p>方法监听注册事件，就是利用<code>addEventListener</code>方法来注册事件。</p>\n<pre><code>Element[i].addEventListener(event, function, useCapture);\n</code></pre>\n<p>这个方法有三个参数：</p>\n<ol>\n<li>event：事件类型，比如<code>click</code>、<code>mouseover</code>、<code>mouseout</code>等等。</li>\n<li>function：事件处理函数。</li>\n<li>useCapture：是否在捕获阶段执行事件处理函数。默认值为false，表示在冒泡阶段执行事件处理函数。</li>\n</ol>\n<p><strong>注意：</strong></p>\n<p>ie8及以下版本不支持这个方法。  看来好东西都是有兼容性的问题。</p>\n<p>这个方法的特点呢，就是不会出现唯一性问题，也就是说，如果一个元素上有多个事件，那么这个元素上可以有多个事件处理函数。它会按照我们注册事件的顺序依次执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"注册事件（绑定事件）\"><a href=\"#注册事件（绑定事件）\" class=\"headerlink\" title=\"注册事件（绑定事件）\"></a>注册事件（绑定事件）</h1><p>注册事件也就是给元素添加事件，成为注册事件或者绑定事件。</p>\n<p>注册事件的方法有两种：</p>\n<ol>\n<li>传统方法注册事件</li>\n<li>方法监听注册事件</li>\n</ol>\n<p>那么这两种方法有什么区别呢？</p>\n<h2 id=\"传统方法注册事件\"><a href=\"#传统方法注册事件\" class=\"headerlink\" title=\"传统方法注册事件\"></a>传统方法注册事件</h2><p>传统方法注册事件，就是直接在元素上添加事件属性，然后给事件属性赋值，这个值就是事件处理函数。</p>\n<p>我们事件经常利用<code>on</code>开头,比如<code>onclick</code>、<code>onmouseover</code>、<code>onmouseout</code>等等。</p>\n<p>这种方法注册事件有一个特性：唯一性</p>\n<p>也就是说，如果一个元素上有多个事件，那么这个元素上只能有一个事件处理函数。如果有多个事件注册，那么最后一个注册事件会覆盖前面的事件。</p>\n<h2 id=\"方法监听注册事件\"><a href=\"#方法监听注册事件\" class=\"headerlink\" title=\"方法监听注册事件\"></a>方法监听注册事件</h2><p>这是w3c的标准，也是我们推荐使用的方法。</p>\n<p>方法监听注册事件，就是利用<code>addEventListener</code>方法来注册事件。</p>\n<pre><code>Element[i].addEventListener(event, function, useCapture);\n</code></pre>\n<p>这个方法有三个参数：</p>\n<ol>\n<li>event：事件类型，比如<code>click</code>、<code>mouseover</code>、<code>mouseout</code>等等。</li>\n<li>function：事件处理函数。</li>\n<li>useCapture：是否在捕获阶段执行事件处理函数。默认值为false，表示在冒泡阶段执行事件处理函数。</li>\n</ol>\n<p><strong>注意：</strong></p>\n<p>ie8及以下版本不支持这个方法。  看来好东西都是有兼容性的问题。</p>\n<p>这个方法的特点呢，就是不会出现唯一性问题，也就是说，如果一个元素上有多个事件，那么这个元素上可以有多个事件处理函数。它会按照我们注册事件的顺序依次执行。</p>\n"},{"title":"深入浏览器渲染原理","date":"2023-05-10T16:00:00.000Z","_content":"# 深入浏览器渲染原理\n\n1. 网页的解析过程\n2. 浏览器渲染流程\n3. 回流和重绘解析\n4. 合成和性能优化\n5. defer和async属性\n\n# 1.网页的解析过程\n\n1. 浏览器输入一个域名\n2. 经过域名解析（DNS解析），得到服务器的IP地址。\n3. 通过IP地址请求相应的页面，随后返回页面代码（一般只返回html），浏览器进行解析。\n    1. 如果遇到css资源，向服务器请求\n    2. 如果遇到js文件，再次向服务器请求\n\n## 1.2浏览器内核\n\n**常见的浏览器内核**\n\n- Trident（三叉戟)：IE、360安全浏览器、搜狗高速浏览器、百度浏览器、UC浏览器；\n- Gecko（壁虎)：Mozilla Firefox;\n- Presto(急板乐曲)->Blink(眨眼)：Opera\n- Webkit:Safari、360极速浏览器、搜狗高速浏览器、移动端浏览器(Android、iOS)\n- Webkit->Blink Google Chrome,Edge\n\n浏览器内核也叫排版引擎、页面渲染引擎、样板引擎。\n\n# 2.**渲染页面的详细流程：**\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1606121aea146e696fe22c252f5b225~tplv-k3u1fbpfcp-watermark.image?)\n\n1. 解析一：HTML解析过程\n    - 默认情况下服务器会给浏览器返回.html文件，所以解析html是所有步骤的开始\n    - 解析HTML会构件DOM tree。\n2. 解析二：CSS文件解析\n    - 在解析过程中，如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件。\n        - 注意：下载CSS文件是不会影响DOM解析的\n    - 浏览器下载完CSS文件之后，就会对CSS文件进行解析，解析出对应的规则树\n        - 我们称为CSSOM（CSS对象模型）\n3. 解析三：构建Render Tree\n    - 根据DOM Tree与CSSOM Tree结合，就可以生成Render Tree。\n    - 注意：\n        - （1）link元素不会阻塞DOM Tree的构建过程，但是会阻塞RenderTree的构建过程，这是因为在Render Tree的构建过程中，需要CSSOM Tree。\n        - Render Tree和DOM Tree不是一一对应的关系，比如display值为none的元素，不会出现在Render Tree中。\n4. 解析四：布局和绘制\n    - 第四步在渲染树（Render Tree）上进行布局，并且计算每个节点的几何体。\n        - 渲染树会表示哪些节点以及其他样式，但是不表示每个节点的尺寸位置等信息\n        - 布局是确定呈现树中所有节点的宽度、高度和位置信息。\n    - 第五步是将每个节点绘制在屏幕上\n        - 在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点\n        - 包括将元素的可见部分进行绘制，比如文本、颜色、边框等等。\n\n# 3. 回流和重绘\n\n## 3.1 理解回流reflow(重排)\n\n- 第一次确定节点的大小和位置，称之为布局（layout）\n- 之后对节点大小、位置修改重新计算就叫做回流\n\n## 3.2 引起回流的情况\n\n- DOM结构发生变化（添加/删除节点）\n- 改变了布局（修改一些属性width height等等）\n- 窗口尺寸发生改变\n- 调用getComputedStyle方法获取尺寸、位置信息\n\n## 3.3 理解重绘\n\n- 第一次渲染内容称为绘制\n- 之后重新渲染称之为重绘\n\n## 3.4 引起重绘的情况\n\n- 修改背景颜色、文字颜色、边框颜色、样式等等。\n\n## 注意：\n\n回流一定会引起重绘，回流很消耗性能。\n\n开发中要尽力避免发生回流\n\n1. 修改样式尽量一次性更改\n2. 尽量避免频繁操作DOM\n3. 尽量避免通过getComputedStyle获取尺寸、位置等信息\n4. 对某些元素使用position的absolute或者fixed。\n\n# 4.特殊解析-composite合成\n\n在绘制的过程中，可以将布局后的元素绘制到多个合成图层中。\n\n- 这是浏览器的一种优化手段\n\n默认情况下，标准流的内容都是被绘制在同一个图层中的。\n\n- 一些特殊的属性，会创建一个新的图层，在这个新的图层里面对界面进行更改，只会在该图层进行回流或者重绘，这样对性能要求更低。\n\n下面是一些会形成新图层的属性：\n\n1. 3D transforms\n2. video canvas iframe\n3. opacity 动画转换时\n4. position:fixed\n5. will-change\n6. animation或者transition设置了opacity transform\n\n虽然这样确实可以优化性能，但是它以内存管理为代价，所以不能过度使用。\n\n# 5. script元素与页面解析的关系\n\n在HTML解析的过程中，如果遇到script元素时，会等script元素下载解析完毕之后，才会继续执行，才会构建DOM树。\n\n**原因**\n\n因为JavaScript作用之一是操作DOM，如果等到DOM渲染完成之后再执行JavaScript，可能又会对DOM进行一些更改，造成回流，影响性能。所以遇到script元素时，会先执行script元素，在继续构建DOM。\n\n# 6.defer与async使用\n\n- defer:不会阻塞DOM tree的构建，告诉浏览器不用等待脚本下载，继续解析HTML。\n\n如果代多个defer，他们是会按照顺序执行的。\n\n- async:同样也可以不阻塞页面。\n\n浏览器不会因为async脚本阻塞，async脚本不能保证顺序，但是它独立下载、独立运行，不会等待其他脚本。并且async不能保证脚本在DOMContentLoaded之前或者之后执行。","source":"_posts/JavaScript/深入浏览器渲染原理.md","raw":"---\ntitle: 深入浏览器渲染原理\ndate: [2023-5-11]\ntags: [前端]\ncategories: [JavaScript]\n---\n# 深入浏览器渲染原理\n\n1. 网页的解析过程\n2. 浏览器渲染流程\n3. 回流和重绘解析\n4. 合成和性能优化\n5. defer和async属性\n\n# 1.网页的解析过程\n\n1. 浏览器输入一个域名\n2. 经过域名解析（DNS解析），得到服务器的IP地址。\n3. 通过IP地址请求相应的页面，随后返回页面代码（一般只返回html），浏览器进行解析。\n    1. 如果遇到css资源，向服务器请求\n    2. 如果遇到js文件，再次向服务器请求\n\n## 1.2浏览器内核\n\n**常见的浏览器内核**\n\n- Trident（三叉戟)：IE、360安全浏览器、搜狗高速浏览器、百度浏览器、UC浏览器；\n- Gecko（壁虎)：Mozilla Firefox;\n- Presto(急板乐曲)->Blink(眨眼)：Opera\n- Webkit:Safari、360极速浏览器、搜狗高速浏览器、移动端浏览器(Android、iOS)\n- Webkit->Blink Google Chrome,Edge\n\n浏览器内核也叫排版引擎、页面渲染引擎、样板引擎。\n\n# 2.**渲染页面的详细流程：**\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1606121aea146e696fe22c252f5b225~tplv-k3u1fbpfcp-watermark.image?)\n\n1. 解析一：HTML解析过程\n    - 默认情况下服务器会给浏览器返回.html文件，所以解析html是所有步骤的开始\n    - 解析HTML会构件DOM tree。\n2. 解析二：CSS文件解析\n    - 在解析过程中，如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件。\n        - 注意：下载CSS文件是不会影响DOM解析的\n    - 浏览器下载完CSS文件之后，就会对CSS文件进行解析，解析出对应的规则树\n        - 我们称为CSSOM（CSS对象模型）\n3. 解析三：构建Render Tree\n    - 根据DOM Tree与CSSOM Tree结合，就可以生成Render Tree。\n    - 注意：\n        - （1）link元素不会阻塞DOM Tree的构建过程，但是会阻塞RenderTree的构建过程，这是因为在Render Tree的构建过程中，需要CSSOM Tree。\n        - Render Tree和DOM Tree不是一一对应的关系，比如display值为none的元素，不会出现在Render Tree中。\n4. 解析四：布局和绘制\n    - 第四步在渲染树（Render Tree）上进行布局，并且计算每个节点的几何体。\n        - 渲染树会表示哪些节点以及其他样式，但是不表示每个节点的尺寸位置等信息\n        - 布局是确定呈现树中所有节点的宽度、高度和位置信息。\n    - 第五步是将每个节点绘制在屏幕上\n        - 在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点\n        - 包括将元素的可见部分进行绘制，比如文本、颜色、边框等等。\n\n# 3. 回流和重绘\n\n## 3.1 理解回流reflow(重排)\n\n- 第一次确定节点的大小和位置，称之为布局（layout）\n- 之后对节点大小、位置修改重新计算就叫做回流\n\n## 3.2 引起回流的情况\n\n- DOM结构发生变化（添加/删除节点）\n- 改变了布局（修改一些属性width height等等）\n- 窗口尺寸发生改变\n- 调用getComputedStyle方法获取尺寸、位置信息\n\n## 3.3 理解重绘\n\n- 第一次渲染内容称为绘制\n- 之后重新渲染称之为重绘\n\n## 3.4 引起重绘的情况\n\n- 修改背景颜色、文字颜色、边框颜色、样式等等。\n\n## 注意：\n\n回流一定会引起重绘，回流很消耗性能。\n\n开发中要尽力避免发生回流\n\n1. 修改样式尽量一次性更改\n2. 尽量避免频繁操作DOM\n3. 尽量避免通过getComputedStyle获取尺寸、位置等信息\n4. 对某些元素使用position的absolute或者fixed。\n\n# 4.特殊解析-composite合成\n\n在绘制的过程中，可以将布局后的元素绘制到多个合成图层中。\n\n- 这是浏览器的一种优化手段\n\n默认情况下，标准流的内容都是被绘制在同一个图层中的。\n\n- 一些特殊的属性，会创建一个新的图层，在这个新的图层里面对界面进行更改，只会在该图层进行回流或者重绘，这样对性能要求更低。\n\n下面是一些会形成新图层的属性：\n\n1. 3D transforms\n2. video canvas iframe\n3. opacity 动画转换时\n4. position:fixed\n5. will-change\n6. animation或者transition设置了opacity transform\n\n虽然这样确实可以优化性能，但是它以内存管理为代价，所以不能过度使用。\n\n# 5. script元素与页面解析的关系\n\n在HTML解析的过程中，如果遇到script元素时，会等script元素下载解析完毕之后，才会继续执行，才会构建DOM树。\n\n**原因**\n\n因为JavaScript作用之一是操作DOM，如果等到DOM渲染完成之后再执行JavaScript，可能又会对DOM进行一些更改，造成回流，影响性能。所以遇到script元素时，会先执行script元素，在继续构建DOM。\n\n# 6.defer与async使用\n\n- defer:不会阻塞DOM tree的构建，告诉浏览器不用等待脚本下载，继续解析HTML。\n\n如果代多个defer，他们是会按照顺序执行的。\n\n- async:同样也可以不阻塞页面。\n\n浏览器不会因为async脚本阻塞，async脚本不能保证顺序，但是它独立下载、独立运行，不会等待其他脚本。并且async不能保证脚本在DOMContentLoaded之前或者之后执行。","slug":"JavaScript/深入浏览器渲染原理","published":1,"updated":"2023-05-11T12:47:03.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj5006m9kbm35rt4hnt","content":"<h1 id=\"深入浏览器渲染原理\"><a href=\"#深入浏览器渲染原理\" class=\"headerlink\" title=\"深入浏览器渲染原理\"></a>深入浏览器渲染原理</h1><ol>\n<li>网页的解析过程</li>\n<li>浏览器渲染流程</li>\n<li>回流和重绘解析</li>\n<li>合成和性能优化</li>\n<li>defer和async属性</li>\n</ol>\n<h1 id=\"1-网页的解析过程\"><a href=\"#1-网页的解析过程\" class=\"headerlink\" title=\"1.网页的解析过程\"></a>1.网页的解析过程</h1><ol>\n<li>浏览器输入一个域名</li>\n<li>经过域名解析（DNS解析），得到服务器的IP地址。</li>\n<li>通过IP地址请求相应的页面，随后返回页面代码（一般只返回html），浏览器进行解析。<ol>\n<li>如果遇到css资源，向服务器请求</li>\n<li>如果遇到js文件，再次向服务器请求</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"1-2浏览器内核\"><a href=\"#1-2浏览器内核\" class=\"headerlink\" title=\"1.2浏览器内核\"></a>1.2浏览器内核</h2><p><strong>常见的浏览器内核</strong></p>\n<ul>\n<li>Trident（三叉戟)：IE、360安全浏览器、搜狗高速浏览器、百度浏览器、UC浏览器；</li>\n<li>Gecko（壁虎)：Mozilla Firefox;</li>\n<li>Presto(急板乐曲)-&gt;Blink(眨眼)：Opera</li>\n<li>Webkit:Safari、360极速浏览器、搜狗高速浏览器、移动端浏览器(Android、iOS)</li>\n<li>Webkit-&gt;Blink Google Chrome,Edge</li>\n</ul>\n<p>浏览器内核也叫排版引擎、页面渲染引擎、样板引擎。</p>\n<h1 id=\"2-渲染页面的详细流程：\"><a href=\"#2-渲染页面的详细流程：\" class=\"headerlink\" title=\"2.渲染页面的详细流程：\"></a>2.<strong>渲染页面的详细流程：</strong></h1><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1606121aea146e696fe22c252f5b225~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ol>\n<li>解析一：HTML解析过程<ul>\n<li>默认情况下服务器会给浏览器返回.html文件，所以解析html是所有步骤的开始</li>\n<li>解析HTML会构件DOM tree。</li>\n</ul>\n</li>\n<li>解析二：CSS文件解析<ul>\n<li>在解析过程中，如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件。<ul>\n<li>注意：下载CSS文件是不会影响DOM解析的</li>\n</ul>\n</li>\n<li>浏览器下载完CSS文件之后，就会对CSS文件进行解析，解析出对应的规则树<ul>\n<li>我们称为CSSOM（CSS对象模型）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解析三：构建Render Tree<ul>\n<li>根据DOM Tree与CSSOM Tree结合，就可以生成Render Tree。</li>\n<li>注意：<ul>\n<li>（1）link元素不会阻塞DOM Tree的构建过程，但是会阻塞RenderTree的构建过程，这是因为在Render Tree的构建过程中，需要CSSOM Tree。</li>\n<li>Render Tree和DOM Tree不是一一对应的关系，比如display值为none的元素，不会出现在Render Tree中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解析四：布局和绘制<ul>\n<li>第四步在渲染树（Render Tree）上进行布局，并且计算每个节点的几何体。<ul>\n<li>渲染树会表示哪些节点以及其他样式，但是不表示每个节点的尺寸位置等信息</li>\n<li>布局是确定呈现树中所有节点的宽度、高度和位置信息。</li>\n</ul>\n</li>\n<li>第五步是将每个节点绘制在屏幕上<ul>\n<li>在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点</li>\n<li>包括将元素的可见部分进行绘制，比如文本、颜色、边框等等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"3-回流和重绘\"><a href=\"#3-回流和重绘\" class=\"headerlink\" title=\"3. 回流和重绘\"></a>3. 回流和重绘</h1><h2 id=\"3-1-理解回流reflow-重排\"><a href=\"#3-1-理解回流reflow-重排\" class=\"headerlink\" title=\"3.1 理解回流reflow(重排)\"></a>3.1 理解回流reflow(重排)</h2><ul>\n<li>第一次确定节点的大小和位置，称之为布局（layout）</li>\n<li>之后对节点大小、位置修改重新计算就叫做回流</li>\n</ul>\n<h2 id=\"3-2-引起回流的情况\"><a href=\"#3-2-引起回流的情况\" class=\"headerlink\" title=\"3.2 引起回流的情况\"></a>3.2 引起回流的情况</h2><ul>\n<li>DOM结构发生变化（添加&#x2F;删除节点）</li>\n<li>改变了布局（修改一些属性width height等等）</li>\n<li>窗口尺寸发生改变</li>\n<li>调用getComputedStyle方法获取尺寸、位置信息</li>\n</ul>\n<h2 id=\"3-3-理解重绘\"><a href=\"#3-3-理解重绘\" class=\"headerlink\" title=\"3.3 理解重绘\"></a>3.3 理解重绘</h2><ul>\n<li>第一次渲染内容称为绘制</li>\n<li>之后重新渲染称之为重绘</li>\n</ul>\n<h2 id=\"3-4-引起重绘的情况\"><a href=\"#3-4-引起重绘的情况\" class=\"headerlink\" title=\"3.4 引起重绘的情况\"></a>3.4 引起重绘的情况</h2><ul>\n<li>修改背景颜色、文字颜色、边框颜色、样式等等。</li>\n</ul>\n<h2 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><p>回流一定会引起重绘，回流很消耗性能。</p>\n<p>开发中要尽力避免发生回流</p>\n<ol>\n<li>修改样式尽量一次性更改</li>\n<li>尽量避免频繁操作DOM</li>\n<li>尽量避免通过getComputedStyle获取尺寸、位置等信息</li>\n<li>对某些元素使用position的absolute或者fixed。</li>\n</ol>\n<h1 id=\"4-特殊解析-composite合成\"><a href=\"#4-特殊解析-composite合成\" class=\"headerlink\" title=\"4.特殊解析-composite合成\"></a>4.特殊解析-composite合成</h1><p>在绘制的过程中，可以将布局后的元素绘制到多个合成图层中。</p>\n<ul>\n<li>这是浏览器的一种优化手段</li>\n</ul>\n<p>默认情况下，标准流的内容都是被绘制在同一个图层中的。</p>\n<ul>\n<li>一些特殊的属性，会创建一个新的图层，在这个新的图层里面对界面进行更改，只会在该图层进行回流或者重绘，这样对性能要求更低。</li>\n</ul>\n<p>下面是一些会形成新图层的属性：</p>\n<ol>\n<li>3D transforms</li>\n<li>video canvas iframe</li>\n<li>opacity 动画转换时</li>\n<li>position:fixed</li>\n<li>will-change</li>\n<li>animation或者transition设置了opacity transform</li>\n</ol>\n<p>虽然这样确实可以优化性能，但是它以内存管理为代价，所以不能过度使用。</p>\n<h1 id=\"5-script元素与页面解析的关系\"><a href=\"#5-script元素与页面解析的关系\" class=\"headerlink\" title=\"5. script元素与页面解析的关系\"></a>5. script元素与页面解析的关系</h1><p>在HTML解析的过程中，如果遇到script元素时，会等script元素下载解析完毕之后，才会继续执行，才会构建DOM树。</p>\n<p><strong>原因</strong></p>\n<p>因为JavaScript作用之一是操作DOM，如果等到DOM渲染完成之后再执行JavaScript，可能又会对DOM进行一些更改，造成回流，影响性能。所以遇到script元素时，会先执行script元素，在继续构建DOM。</p>\n<h1 id=\"6-defer与async使用\"><a href=\"#6-defer与async使用\" class=\"headerlink\" title=\"6.defer与async使用\"></a>6.defer与async使用</h1><ul>\n<li>defer:不会阻塞DOM tree的构建，告诉浏览器不用等待脚本下载，继续解析HTML。</li>\n</ul>\n<p>如果代多个defer，他们是会按照顺序执行的。</p>\n<ul>\n<li>async:同样也可以不阻塞页面。</li>\n</ul>\n<p>浏览器不会因为async脚本阻塞，async脚本不能保证顺序，但是它独立下载、独立运行，不会等待其他脚本。并且async不能保证脚本在DOMContentLoaded之前或者之后执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"深入浏览器渲染原理\"><a href=\"#深入浏览器渲染原理\" class=\"headerlink\" title=\"深入浏览器渲染原理\"></a>深入浏览器渲染原理</h1><ol>\n<li>网页的解析过程</li>\n<li>浏览器渲染流程</li>\n<li>回流和重绘解析</li>\n<li>合成和性能优化</li>\n<li>defer和async属性</li>\n</ol>\n<h1 id=\"1-网页的解析过程\"><a href=\"#1-网页的解析过程\" class=\"headerlink\" title=\"1.网页的解析过程\"></a>1.网页的解析过程</h1><ol>\n<li>浏览器输入一个域名</li>\n<li>经过域名解析（DNS解析），得到服务器的IP地址。</li>\n<li>通过IP地址请求相应的页面，随后返回页面代码（一般只返回html），浏览器进行解析。<ol>\n<li>如果遇到css资源，向服务器请求</li>\n<li>如果遇到js文件，再次向服务器请求</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"1-2浏览器内核\"><a href=\"#1-2浏览器内核\" class=\"headerlink\" title=\"1.2浏览器内核\"></a>1.2浏览器内核</h2><p><strong>常见的浏览器内核</strong></p>\n<ul>\n<li>Trident（三叉戟)：IE、360安全浏览器、搜狗高速浏览器、百度浏览器、UC浏览器；</li>\n<li>Gecko（壁虎)：Mozilla Firefox;</li>\n<li>Presto(急板乐曲)-&gt;Blink(眨眼)：Opera</li>\n<li>Webkit:Safari、360极速浏览器、搜狗高速浏览器、移动端浏览器(Android、iOS)</li>\n<li>Webkit-&gt;Blink Google Chrome,Edge</li>\n</ul>\n<p>浏览器内核也叫排版引擎、页面渲染引擎、样板引擎。</p>\n<h1 id=\"2-渲染页面的详细流程：\"><a href=\"#2-渲染页面的详细流程：\" class=\"headerlink\" title=\"2.渲染页面的详细流程：\"></a>2.<strong>渲染页面的详细流程：</strong></h1><p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1606121aea146e696fe22c252f5b225~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ol>\n<li>解析一：HTML解析过程<ul>\n<li>默认情况下服务器会给浏览器返回.html文件，所以解析html是所有步骤的开始</li>\n<li>解析HTML会构件DOM tree。</li>\n</ul>\n</li>\n<li>解析二：CSS文件解析<ul>\n<li>在解析过程中，如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件。<ul>\n<li>注意：下载CSS文件是不会影响DOM解析的</li>\n</ul>\n</li>\n<li>浏览器下载完CSS文件之后，就会对CSS文件进行解析，解析出对应的规则树<ul>\n<li>我们称为CSSOM（CSS对象模型）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解析三：构建Render Tree<ul>\n<li>根据DOM Tree与CSSOM Tree结合，就可以生成Render Tree。</li>\n<li>注意：<ul>\n<li>（1）link元素不会阻塞DOM Tree的构建过程，但是会阻塞RenderTree的构建过程，这是因为在Render Tree的构建过程中，需要CSSOM Tree。</li>\n<li>Render Tree和DOM Tree不是一一对应的关系，比如display值为none的元素，不会出现在Render Tree中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>解析四：布局和绘制<ul>\n<li>第四步在渲染树（Render Tree）上进行布局，并且计算每个节点的几何体。<ul>\n<li>渲染树会表示哪些节点以及其他样式，但是不表示每个节点的尺寸位置等信息</li>\n<li>布局是确定呈现树中所有节点的宽度、高度和位置信息。</li>\n</ul>\n</li>\n<li>第五步是将每个节点绘制在屏幕上<ul>\n<li>在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点</li>\n<li>包括将元素的可见部分进行绘制，比如文本、颜色、边框等等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"3-回流和重绘\"><a href=\"#3-回流和重绘\" class=\"headerlink\" title=\"3. 回流和重绘\"></a>3. 回流和重绘</h1><h2 id=\"3-1-理解回流reflow-重排\"><a href=\"#3-1-理解回流reflow-重排\" class=\"headerlink\" title=\"3.1 理解回流reflow(重排)\"></a>3.1 理解回流reflow(重排)</h2><ul>\n<li>第一次确定节点的大小和位置，称之为布局（layout）</li>\n<li>之后对节点大小、位置修改重新计算就叫做回流</li>\n</ul>\n<h2 id=\"3-2-引起回流的情况\"><a href=\"#3-2-引起回流的情况\" class=\"headerlink\" title=\"3.2 引起回流的情况\"></a>3.2 引起回流的情况</h2><ul>\n<li>DOM结构发生变化（添加&#x2F;删除节点）</li>\n<li>改变了布局（修改一些属性width height等等）</li>\n<li>窗口尺寸发生改变</li>\n<li>调用getComputedStyle方法获取尺寸、位置信息</li>\n</ul>\n<h2 id=\"3-3-理解重绘\"><a href=\"#3-3-理解重绘\" class=\"headerlink\" title=\"3.3 理解重绘\"></a>3.3 理解重绘</h2><ul>\n<li>第一次渲染内容称为绘制</li>\n<li>之后重新渲染称之为重绘</li>\n</ul>\n<h2 id=\"3-4-引起重绘的情况\"><a href=\"#3-4-引起重绘的情况\" class=\"headerlink\" title=\"3.4 引起重绘的情况\"></a>3.4 引起重绘的情况</h2><ul>\n<li>修改背景颜色、文字颜色、边框颜色、样式等等。</li>\n</ul>\n<h2 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><p>回流一定会引起重绘，回流很消耗性能。</p>\n<p>开发中要尽力避免发生回流</p>\n<ol>\n<li>修改样式尽量一次性更改</li>\n<li>尽量避免频繁操作DOM</li>\n<li>尽量避免通过getComputedStyle获取尺寸、位置等信息</li>\n<li>对某些元素使用position的absolute或者fixed。</li>\n</ol>\n<h1 id=\"4-特殊解析-composite合成\"><a href=\"#4-特殊解析-composite合成\" class=\"headerlink\" title=\"4.特殊解析-composite合成\"></a>4.特殊解析-composite合成</h1><p>在绘制的过程中，可以将布局后的元素绘制到多个合成图层中。</p>\n<ul>\n<li>这是浏览器的一种优化手段</li>\n</ul>\n<p>默认情况下，标准流的内容都是被绘制在同一个图层中的。</p>\n<ul>\n<li>一些特殊的属性，会创建一个新的图层，在这个新的图层里面对界面进行更改，只会在该图层进行回流或者重绘，这样对性能要求更低。</li>\n</ul>\n<p>下面是一些会形成新图层的属性：</p>\n<ol>\n<li>3D transforms</li>\n<li>video canvas iframe</li>\n<li>opacity 动画转换时</li>\n<li>position:fixed</li>\n<li>will-change</li>\n<li>animation或者transition设置了opacity transform</li>\n</ol>\n<p>虽然这样确实可以优化性能，但是它以内存管理为代价，所以不能过度使用。</p>\n<h1 id=\"5-script元素与页面解析的关系\"><a href=\"#5-script元素与页面解析的关系\" class=\"headerlink\" title=\"5. script元素与页面解析的关系\"></a>5. script元素与页面解析的关系</h1><p>在HTML解析的过程中，如果遇到script元素时，会等script元素下载解析完毕之后，才会继续执行，才会构建DOM树。</p>\n<p><strong>原因</strong></p>\n<p>因为JavaScript作用之一是操作DOM，如果等到DOM渲染完成之后再执行JavaScript，可能又会对DOM进行一些更改，造成回流，影响性能。所以遇到script元素时，会先执行script元素，在继续构建DOM。</p>\n<h1 id=\"6-defer与async使用\"><a href=\"#6-defer与async使用\" class=\"headerlink\" title=\"6.defer与async使用\"></a>6.defer与async使用</h1><ul>\n<li>defer:不会阻塞DOM tree的构建，告诉浏览器不用等待脚本下载，继续解析HTML。</li>\n</ul>\n<p>如果代多个defer，他们是会按照顺序执行的。</p>\n<ul>\n<li>async:同样也可以不阻塞页面。</li>\n</ul>\n<p>浏览器不会因为async脚本阻塞，async脚本不能保证顺序，但是它独立下载、独立运行，不会等待其他脚本。并且async不能保证脚本在DOMContentLoaded之前或者之后执行。</p>\n"},{"title":"箭头函数","date":"2022-10-07T13:23:00.000Z","_content":"# 箭头函数\n\n在定义函数的时候，除了可以使用前面的声明函数和函数表达式之外，我们这里还可以使用箭头函数。\n\n**其实箭头函数可以理解为函数表达式的简写模式。**\n\n例如：\n\n*函数表达式：*\n\n    let sum = funcition(a, b) {\n        return a + b;\n    }\n\n*箭头函数：*\n\n    let sum = (a,b) => {\n        return a + b;\n    }\n\n    或者：\n    let sum = (a,b) => a + b;\n\n**注意：**\n\n- 箭头函数的参数只能有一个，如果有多个，需要使用小括号括起来。\n- 箭头函数如果没有参数时，括号里面是空的是，但是不能省略括号。\n\n**多行的箭头函数**\n\n箭头函数不仅仅可以写一行代码，但是书写多行代码的时候，我们需要使用花括号是将代码块包含起来。\n\n    let sum = (a,b) =>{\n        let c = a + b;\n        return c;\n    };\n    console.log(sum(1,2));","source":"_posts/JavaScript/箭头函数.md","raw":"---\ntitle: 箭头函数\ndate: 2022-10-7 21:23\ntags: [前端]\ncategories: [JavaScript]\n---\n# 箭头函数\n\n在定义函数的时候，除了可以使用前面的声明函数和函数表达式之外，我们这里还可以使用箭头函数。\n\n**其实箭头函数可以理解为函数表达式的简写模式。**\n\n例如：\n\n*函数表达式：*\n\n    let sum = funcition(a, b) {\n        return a + b;\n    }\n\n*箭头函数：*\n\n    let sum = (a,b) => {\n        return a + b;\n    }\n\n    或者：\n    let sum = (a,b) => a + b;\n\n**注意：**\n\n- 箭头函数的参数只能有一个，如果有多个，需要使用小括号括起来。\n- 箭头函数如果没有参数时，括号里面是空的是，但是不能省略括号。\n\n**多行的箭头函数**\n\n箭头函数不仅仅可以写一行代码，但是书写多行代码的时候，我们需要使用花括号是将代码块包含起来。\n\n    let sum = (a,b) =>{\n        let c = a + b;\n        return c;\n    };\n    console.log(sum(1,2));","slug":"JavaScript/箭头函数","published":1,"updated":"2023-01-08T11:39:32.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj6006p9kbmakb36n27","content":"<h1 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h1><p>在定义函数的时候，除了可以使用前面的声明函数和函数表达式之外，我们这里还可以使用箭头函数。</p>\n<p><strong>其实箭头函数可以理解为函数表达式的简写模式。</strong></p>\n<p>例如：</p>\n<p><em>函数表达式：</em></p>\n<pre><code>let sum = funcition(a, b) &#123;\n    return a + b;\n&#125;\n</code></pre>\n<p><em>箭头函数：</em></p>\n<pre><code>let sum = (a,b) =&gt; &#123;\n    return a + b;\n&#125;\n\n或者：\nlet sum = (a,b) =&gt; a + b;\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>箭头函数的参数只能有一个，如果有多个，需要使用小括号括起来。</li>\n<li>箭头函数如果没有参数时，括号里面是空的是，但是不能省略括号。</li>\n</ul>\n<p><strong>多行的箭头函数</strong></p>\n<p>箭头函数不仅仅可以写一行代码，但是书写多行代码的时候，我们需要使用花括号是将代码块包含起来。</p>\n<pre><code>let sum = (a,b) =&gt;&#123;\n    let c = a + b;\n    return c;\n&#125;;\nconsole.log(sum(1,2));\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h1><p>在定义函数的时候，除了可以使用前面的声明函数和函数表达式之外，我们这里还可以使用箭头函数。</p>\n<p><strong>其实箭头函数可以理解为函数表达式的简写模式。</strong></p>\n<p>例如：</p>\n<p><em>函数表达式：</em></p>\n<pre><code>let sum = funcition(a, b) &#123;\n    return a + b;\n&#125;\n</code></pre>\n<p><em>箭头函数：</em></p>\n<pre><code>let sum = (a,b) =&gt; &#123;\n    return a + b;\n&#125;\n\n或者：\nlet sum = (a,b) =&gt; a + b;\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>箭头函数的参数只能有一个，如果有多个，需要使用小括号括起来。</li>\n<li>箭头函数如果没有参数时，括号里面是空的是，但是不能省略括号。</li>\n</ul>\n<p><strong>多行的箭头函数</strong></p>\n<p>箭头函数不仅仅可以写一行代码，但是书写多行代码的时候，我们需要使用花括号是将代码块包含起来。</p>\n<pre><code>let sum = (a,b) =&gt;&#123;\n    let c = a + b;\n    return c;\n&#125;;\nconsole.log(sum(1,2));\n</code></pre>\n"},{"title":"节点操作之创建节点","date":"2022-09-13T16:01:00.000Z","_content":"# 节点操作之创建节点\n\n在实际开发中，我们经常会遇到在用户使用过程中，我们需要动态创建一个文本框，也就是用户在点击某些按钮之后，我们要给这个页面添加一个新的节点。这种操作在节点操作里面叫做创建节点。那么创建节点有哪些方式呢？\n\n## 创建元素节点 \n\n`document.createElement('tagName');`\n\n通过创建变迁米昂指定的html元素，从而达到创建元素的目的。因为创建的元素在最开始的时候是不存在的，所以我们称为动态创建元素节点。\n\n创建节点之后，我们还需要将所创建的这个节点添加到dom树里面去。\n\n## 添加节点\n\n我们创建节点之后，我们打开浏览器运行，很明显：我们创建的节点并没有出现，这是因为，浏览器显示的是dom树，而我们创建的节点并没有添加到dom树里面去，所以我们需要将创建的节点添加到dom树里面去。下面有两种方法将创建的节点添加到dom树里面去。\n\n1. `appendChild()`\n\n    fatherNode.appendChild(childNode);\n\n这个方法将一个我们已经创建的节点添加到指定父节点的子节点列表的最后一个。也就是追加元素，有点类似于数组里面的`push`方法。就是将一个元素添加到数组的最后一个。\n\n2. `insertBefore()`\n\n    fatherNode.insertBefore(newNode, 指定元素);\n\n是不是觉得第一个添加方法局限性很大，只能在最后面一个进行添加。那么这第二个方法就可以很好的解决这个问题。\n\n这个方法是将一个新的节点添加到指定父节点的子节点列表的指定位置。也就是说，我们可以在指定的位置之前插入一个新的节点。\n\n`newMode`是我们创建的节点（需要添加的节点），`指定元素`是我们要在哪个元素之前插入新的节点。\n\n## 代码实现\n\n下面的代码仅为代码片段：\n\n        // 创建一个div节点\n        var div = document.createElement('div');\n        // 设置div的内容\n        div.innerHTML = '我是一个div';\n        // 获取body\n        var body = document.getElementsByTagName('body')[0];\n        // 将div添加到body里面\n        body.appendChild(div);\n\n这里我们先创建div节点，然后获取body节点，然后将div节点添加到body节点里面去。这里我们使用的是通过`appendChild()`方法将div节点添加到body节点里面去。也就是将创建的节点直接添加到body节点的子节点列表的最后一个。\n\n        // 创建一个p节点\n        var p = document.createElement('p');\n        // 设置p的内容\n        p.innerHTML = '我是一个p';\n        // 获取body\n        var body = document.getElementsByTagName('body')[0];\n        // 将p添加到body里面\n        body.insertBefore(p, div[0]);\n\n第二段代码前面思路是一样的创建节点 --> 获取目标节点 --> 添加节点。这里我们使用的是`insertBefore()`方法将p节点添加到body节点里面去。也就是将创建的节点添加到body节点的子节点列表的指定位置。这里我们将p节点添加到body节点的子节点列表的第一个位置。","source":"_posts/JavaScript/节点操作之创建节点.md","raw":"---\ntitle: 节点操作之创建节点\ndate: 2022-9-14 0:01\ntags: [前端]\ncategories: [JavaScript,DOM]\n---\n# 节点操作之创建节点\n\n在实际开发中，我们经常会遇到在用户使用过程中，我们需要动态创建一个文本框，也就是用户在点击某些按钮之后，我们要给这个页面添加一个新的节点。这种操作在节点操作里面叫做创建节点。那么创建节点有哪些方式呢？\n\n## 创建元素节点 \n\n`document.createElement('tagName');`\n\n通过创建变迁米昂指定的html元素，从而达到创建元素的目的。因为创建的元素在最开始的时候是不存在的，所以我们称为动态创建元素节点。\n\n创建节点之后，我们还需要将所创建的这个节点添加到dom树里面去。\n\n## 添加节点\n\n我们创建节点之后，我们打开浏览器运行，很明显：我们创建的节点并没有出现，这是因为，浏览器显示的是dom树，而我们创建的节点并没有添加到dom树里面去，所以我们需要将创建的节点添加到dom树里面去。下面有两种方法将创建的节点添加到dom树里面去。\n\n1. `appendChild()`\n\n    fatherNode.appendChild(childNode);\n\n这个方法将一个我们已经创建的节点添加到指定父节点的子节点列表的最后一个。也就是追加元素，有点类似于数组里面的`push`方法。就是将一个元素添加到数组的最后一个。\n\n2. `insertBefore()`\n\n    fatherNode.insertBefore(newNode, 指定元素);\n\n是不是觉得第一个添加方法局限性很大，只能在最后面一个进行添加。那么这第二个方法就可以很好的解决这个问题。\n\n这个方法是将一个新的节点添加到指定父节点的子节点列表的指定位置。也就是说，我们可以在指定的位置之前插入一个新的节点。\n\n`newMode`是我们创建的节点（需要添加的节点），`指定元素`是我们要在哪个元素之前插入新的节点。\n\n## 代码实现\n\n下面的代码仅为代码片段：\n\n        // 创建一个div节点\n        var div = document.createElement('div');\n        // 设置div的内容\n        div.innerHTML = '我是一个div';\n        // 获取body\n        var body = document.getElementsByTagName('body')[0];\n        // 将div添加到body里面\n        body.appendChild(div);\n\n这里我们先创建div节点，然后获取body节点，然后将div节点添加到body节点里面去。这里我们使用的是通过`appendChild()`方法将div节点添加到body节点里面去。也就是将创建的节点直接添加到body节点的子节点列表的最后一个。\n\n        // 创建一个p节点\n        var p = document.createElement('p');\n        // 设置p的内容\n        p.innerHTML = '我是一个p';\n        // 获取body\n        var body = document.getElementsByTagName('body')[0];\n        // 将p添加到body里面\n        body.insertBefore(p, div[0]);\n\n第二段代码前面思路是一样的创建节点 --> 获取目标节点 --> 添加节点。这里我们使用的是`insertBefore()`方法将p节点添加到body节点里面去。也就是将创建的节点添加到body节点的子节点列表的指定位置。这里我们将p节点添加到body节点的子节点列表的第一个位置。","slug":"JavaScript/节点操作之创建节点","published":1,"updated":"2023-01-08T11:39:42.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj7006s9kbm9wmm6swb","content":"<h1 id=\"节点操作之创建节点\"><a href=\"#节点操作之创建节点\" class=\"headerlink\" title=\"节点操作之创建节点\"></a>节点操作之创建节点</h1><p>在实际开发中，我们经常会遇到在用户使用过程中，我们需要动态创建一个文本框，也就是用户在点击某些按钮之后，我们要给这个页面添加一个新的节点。这种操作在节点操作里面叫做创建节点。那么创建节点有哪些方式呢？</p>\n<h2 id=\"创建元素节点\"><a href=\"#创建元素节点\" class=\"headerlink\" title=\"创建元素节点\"></a>创建元素节点</h2><p><code>document.createElement(&#39;tagName&#39;);</code></p>\n<p>通过创建变迁米昂指定的html元素，从而达到创建元素的目的。因为创建的元素在最开始的时候是不存在的，所以我们称为动态创建元素节点。</p>\n<p>创建节点之后，我们还需要将所创建的这个节点添加到dom树里面去。</p>\n<h2 id=\"添加节点\"><a href=\"#添加节点\" class=\"headerlink\" title=\"添加节点\"></a>添加节点</h2><p>我们创建节点之后，我们打开浏览器运行，很明显：我们创建的节点并没有出现，这是因为，浏览器显示的是dom树，而我们创建的节点并没有添加到dom树里面去，所以我们需要将创建的节点添加到dom树里面去。下面有两种方法将创建的节点添加到dom树里面去。</p>\n<ol>\n<li><p><code>appendChild()</code></p>\n<p> fatherNode.appendChild(childNode);</p>\n</li>\n</ol>\n<p>这个方法将一个我们已经创建的节点添加到指定父节点的子节点列表的最后一个。也就是追加元素，有点类似于数组里面的<code>push</code>方法。就是将一个元素添加到数组的最后一个。</p>\n<ol start=\"2\">\n<li><p><code>insertBefore()</code></p>\n<p> fatherNode.insertBefore(newNode, 指定元素);</p>\n</li>\n</ol>\n<p>是不是觉得第一个添加方法局限性很大，只能在最后面一个进行添加。那么这第二个方法就可以很好的解决这个问题。</p>\n<p>这个方法是将一个新的节点添加到指定父节点的子节点列表的指定位置。也就是说，我们可以在指定的位置之前插入一个新的节点。</p>\n<p><code>newMode</code>是我们创建的节点（需要添加的节点），<code>指定元素</code>是我们要在哪个元素之前插入新的节点。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>下面的代码仅为代码片段：</p>\n<pre><code>    // 创建一个div节点\n    var div = document.createElement(&#39;div&#39;);\n    // 设置div的内容\n    div.innerHTML = &#39;我是一个div&#39;;\n    // 获取body\n    var body = document.getElementsByTagName(&#39;body&#39;)[0];\n    // 将div添加到body里面\n    body.appendChild(div);\n</code></pre>\n<p>这里我们先创建div节点，然后获取body节点，然后将div节点添加到body节点里面去。这里我们使用的是通过<code>appendChild()</code>方法将div节点添加到body节点里面去。也就是将创建的节点直接添加到body节点的子节点列表的最后一个。</p>\n<pre><code>    // 创建一个p节点\n    var p = document.createElement(&#39;p&#39;);\n    // 设置p的内容\n    p.innerHTML = &#39;我是一个p&#39;;\n    // 获取body\n    var body = document.getElementsByTagName(&#39;body&#39;)[0];\n    // 将p添加到body里面\n    body.insertBefore(p, div[0]);\n</code></pre>\n<p>第二段代码前面思路是一样的创建节点 –&gt; 获取目标节点 –&gt; 添加节点。这里我们使用的是<code>insertBefore()</code>方法将p节点添加到body节点里面去。也就是将创建的节点添加到body节点的子节点列表的指定位置。这里我们将p节点添加到body节点的子节点列表的第一个位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"节点操作之创建节点\"><a href=\"#节点操作之创建节点\" class=\"headerlink\" title=\"节点操作之创建节点\"></a>节点操作之创建节点</h1><p>在实际开发中，我们经常会遇到在用户使用过程中，我们需要动态创建一个文本框，也就是用户在点击某些按钮之后，我们要给这个页面添加一个新的节点。这种操作在节点操作里面叫做创建节点。那么创建节点有哪些方式呢？</p>\n<h2 id=\"创建元素节点\"><a href=\"#创建元素节点\" class=\"headerlink\" title=\"创建元素节点\"></a>创建元素节点</h2><p><code>document.createElement(&#39;tagName&#39;);</code></p>\n<p>通过创建变迁米昂指定的html元素，从而达到创建元素的目的。因为创建的元素在最开始的时候是不存在的，所以我们称为动态创建元素节点。</p>\n<p>创建节点之后，我们还需要将所创建的这个节点添加到dom树里面去。</p>\n<h2 id=\"添加节点\"><a href=\"#添加节点\" class=\"headerlink\" title=\"添加节点\"></a>添加节点</h2><p>我们创建节点之后，我们打开浏览器运行，很明显：我们创建的节点并没有出现，这是因为，浏览器显示的是dom树，而我们创建的节点并没有添加到dom树里面去，所以我们需要将创建的节点添加到dom树里面去。下面有两种方法将创建的节点添加到dom树里面去。</p>\n<ol>\n<li><p><code>appendChild()</code></p>\n<p> fatherNode.appendChild(childNode);</p>\n</li>\n</ol>\n<p>这个方法将一个我们已经创建的节点添加到指定父节点的子节点列表的最后一个。也就是追加元素，有点类似于数组里面的<code>push</code>方法。就是将一个元素添加到数组的最后一个。</p>\n<ol start=\"2\">\n<li><p><code>insertBefore()</code></p>\n<p> fatherNode.insertBefore(newNode, 指定元素);</p>\n</li>\n</ol>\n<p>是不是觉得第一个添加方法局限性很大，只能在最后面一个进行添加。那么这第二个方法就可以很好的解决这个问题。</p>\n<p>这个方法是将一个新的节点添加到指定父节点的子节点列表的指定位置。也就是说，我们可以在指定的位置之前插入一个新的节点。</p>\n<p><code>newMode</code>是我们创建的节点（需要添加的节点），<code>指定元素</code>是我们要在哪个元素之前插入新的节点。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>下面的代码仅为代码片段：</p>\n<pre><code>    // 创建一个div节点\n    var div = document.createElement(&#39;div&#39;);\n    // 设置div的内容\n    div.innerHTML = &#39;我是一个div&#39;;\n    // 获取body\n    var body = document.getElementsByTagName(&#39;body&#39;)[0];\n    // 将div添加到body里面\n    body.appendChild(div);\n</code></pre>\n<p>这里我们先创建div节点，然后获取body节点，然后将div节点添加到body节点里面去。这里我们使用的是通过<code>appendChild()</code>方法将div节点添加到body节点里面去。也就是将创建的节点直接添加到body节点的子节点列表的最后一个。</p>\n<pre><code>    // 创建一个p节点\n    var p = document.createElement(&#39;p&#39;);\n    // 设置p的内容\n    p.innerHTML = &#39;我是一个p&#39;;\n    // 获取body\n    var body = document.getElementsByTagName(&#39;body&#39;)[0];\n    // 将p添加到body里面\n    body.insertBefore(p, div[0]);\n</code></pre>\n<p>第二段代码前面思路是一样的创建节点 –&gt; 获取目标节点 –&gt; 添加节点。这里我们使用的是<code>insertBefore()</code>方法将p节点添加到body节点里面去。也就是将创建的节点添加到body节点的子节点列表的指定位置。这里我们将p节点添加到body节点的子节点列表的第一个位置。</p>\n"},{"title":"节点操作之获取兄弟节点","date":"2022-09-13T04:54:00.000Z","_content":"# 节点操作之获取兄弟节点\n\n前面我们了解了如何获取元素，我们通过`document.getElementById`等等来获取元素，但是这样的方法有很大的局限性，我们只能一个一个的去获取元素，很不方便。\n\n那么有没有一种更方便的方式呢？\n\n下面我们就开始学习节点操作。\n\n## 兄弟节点\n\n1. `nextSibling`：获取下一个兄弟节点\n\n    node.nextSibling\n\nnextSibling属性返回当前节点的下一个兄弟节点，如果没有则返回null。\n\n这个方法是返回当前元素的下一个兄弟元素的节点，包括文本节点，元素节点，样式节点等等。\n\n2. `previousSibling`：获取上一个兄弟节点\n\n    node.previousSibling\n\npreviousSibling属性返回当前节点的上一个兄弟节点，如果没有则返回null。同样也是包含所有的节点：元素节点，文本节点，样式节点等等。\n\n前面两个获取范围太广了，我们要是只要获取到元素怎么办呢?\n\n3. `nextElementSibling`：获取下一个兄弟元素\n\n    node.nextElementSibling\n\nnextElementSibling属性返回当前节点的下一个兄弟`元素`节点，如果没有则返回null。\n\n4. `previousElementSibling`：获取上一个兄弟元素\n\n    node.previousElementSibling\n\nprviouseElementSibling属性返回当前节点的上一个兄弟`元素`节点，如果没有则返回null。\n\n**其中：3.4有兼容性问题，只有ie9以上才能实现**","source":"_posts/JavaScript/节点操作.md","raw":"---\ntitle: 节点操作之获取兄弟节点\ndate: 2022-9-13 12:54\ntags: [前端]\ncategories: [JavaScript,DOM]\n---\n# 节点操作之获取兄弟节点\n\n前面我们了解了如何获取元素，我们通过`document.getElementById`等等来获取元素，但是这样的方法有很大的局限性，我们只能一个一个的去获取元素，很不方便。\n\n那么有没有一种更方便的方式呢？\n\n下面我们就开始学习节点操作。\n\n## 兄弟节点\n\n1. `nextSibling`：获取下一个兄弟节点\n\n    node.nextSibling\n\nnextSibling属性返回当前节点的下一个兄弟节点，如果没有则返回null。\n\n这个方法是返回当前元素的下一个兄弟元素的节点，包括文本节点，元素节点，样式节点等等。\n\n2. `previousSibling`：获取上一个兄弟节点\n\n    node.previousSibling\n\npreviousSibling属性返回当前节点的上一个兄弟节点，如果没有则返回null。同样也是包含所有的节点：元素节点，文本节点，样式节点等等。\n\n前面两个获取范围太广了，我们要是只要获取到元素怎么办呢?\n\n3. `nextElementSibling`：获取下一个兄弟元素\n\n    node.nextElementSibling\n\nnextElementSibling属性返回当前节点的下一个兄弟`元素`节点，如果没有则返回null。\n\n4. `previousElementSibling`：获取上一个兄弟元素\n\n    node.previousElementSibling\n\nprviouseElementSibling属性返回当前节点的上一个兄弟`元素`节点，如果没有则返回null。\n\n**其中：3.4有兼容性问题，只有ie9以上才能实现**","slug":"JavaScript/节点操作","published":1,"updated":"2023-01-08T11:39:39.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj8006v9kbm0kx55jfw","content":"<h1 id=\"节点操作之获取兄弟节点\"><a href=\"#节点操作之获取兄弟节点\" class=\"headerlink\" title=\"节点操作之获取兄弟节点\"></a>节点操作之获取兄弟节点</h1><p>前面我们了解了如何获取元素，我们通过<code>document.getElementById</code>等等来获取元素，但是这样的方法有很大的局限性，我们只能一个一个的去获取元素，很不方便。</p>\n<p>那么有没有一种更方便的方式呢？</p>\n<p>下面我们就开始学习节点操作。</p>\n<h2 id=\"兄弟节点\"><a href=\"#兄弟节点\" class=\"headerlink\" title=\"兄弟节点\"></a>兄弟节点</h2><ol>\n<li><p><code>nextSibling</code>：获取下一个兄弟节点</p>\n<p> node.nextSibling</p>\n</li>\n</ol>\n<p>nextSibling属性返回当前节点的下一个兄弟节点，如果没有则返回null。</p>\n<p>这个方法是返回当前元素的下一个兄弟元素的节点，包括文本节点，元素节点，样式节点等等。</p>\n<ol start=\"2\">\n<li><p><code>previousSibling</code>：获取上一个兄弟节点</p>\n<p> node.previousSibling</p>\n</li>\n</ol>\n<p>previousSibling属性返回当前节点的上一个兄弟节点，如果没有则返回null。同样也是包含所有的节点：元素节点，文本节点，样式节点等等。</p>\n<p>前面两个获取范围太广了，我们要是只要获取到元素怎么办呢?</p>\n<ol start=\"3\">\n<li><p><code>nextElementSibling</code>：获取下一个兄弟元素</p>\n<p> node.nextElementSibling</p>\n</li>\n</ol>\n<p>nextElementSibling属性返回当前节点的下一个兄弟<code>元素</code>节点，如果没有则返回null。</p>\n<ol start=\"4\">\n<li><p><code>previousElementSibling</code>：获取上一个兄弟元素</p>\n<p> node.previousElementSibling</p>\n</li>\n</ol>\n<p>prviouseElementSibling属性返回当前节点的上一个兄弟<code>元素</code>节点，如果没有则返回null。</p>\n<p><strong>其中：3.4有兼容性问题，只有ie9以上才能实现</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"节点操作之获取兄弟节点\"><a href=\"#节点操作之获取兄弟节点\" class=\"headerlink\" title=\"节点操作之获取兄弟节点\"></a>节点操作之获取兄弟节点</h1><p>前面我们了解了如何获取元素，我们通过<code>document.getElementById</code>等等来获取元素，但是这样的方法有很大的局限性，我们只能一个一个的去获取元素，很不方便。</p>\n<p>那么有没有一种更方便的方式呢？</p>\n<p>下面我们就开始学习节点操作。</p>\n<h2 id=\"兄弟节点\"><a href=\"#兄弟节点\" class=\"headerlink\" title=\"兄弟节点\"></a>兄弟节点</h2><ol>\n<li><p><code>nextSibling</code>：获取下一个兄弟节点</p>\n<p> node.nextSibling</p>\n</li>\n</ol>\n<p>nextSibling属性返回当前节点的下一个兄弟节点，如果没有则返回null。</p>\n<p>这个方法是返回当前元素的下一个兄弟元素的节点，包括文本节点，元素节点，样式节点等等。</p>\n<ol start=\"2\">\n<li><p><code>previousSibling</code>：获取上一个兄弟节点</p>\n<p> node.previousSibling</p>\n</li>\n</ol>\n<p>previousSibling属性返回当前节点的上一个兄弟节点，如果没有则返回null。同样也是包含所有的节点：元素节点，文本节点，样式节点等等。</p>\n<p>前面两个获取范围太广了，我们要是只要获取到元素怎么办呢?</p>\n<ol start=\"3\">\n<li><p><code>nextElementSibling</code>：获取下一个兄弟元素</p>\n<p> node.nextElementSibling</p>\n</li>\n</ol>\n<p>nextElementSibling属性返回当前节点的下一个兄弟<code>元素</code>节点，如果没有则返回null。</p>\n<ol start=\"4\">\n<li><p><code>previousElementSibling</code>：获取上一个兄弟元素</p>\n<p> node.previousElementSibling</p>\n</li>\n</ol>\n<p>prviouseElementSibling属性返回当前节点的上一个兄弟<code>元素</code>节点，如果没有则返回null。</p>\n<p><strong>其中：3.4有兼容性问题，只有ie9以上才能实现</strong></p>\n"},{"title":"节点操作之删除节点","date":"2022-09-14T02:28:00.000Z","_content":"# 节点操作之删除节点\n\n前面我们学习了如何创建节点，以及如何将创建的节点添加到DOM数里面去，这一节我们将会了解如何删除节点。\n\n在一个评论区，可能会出现这样的情况，用户写了一个评论之后，忽然觉得这个评论有点欠妥，想要将这条评论删除，我们知道这条评论肯定是一个节点，删除评论就意味着要删除节点。\n\n## 删除节点\n\n    node.removeChild(childNode)\n\n删除节点的方法是`node.removeChild(childNode)`，这个方法接受一个参数，就是要删除的节点，这个节点必须是`node`的子节点，否则会报错。\n\n这个方法返回的结果是被删除的这个节点。","source":"_posts/JavaScript/节点操作之删除节点.md","raw":"---\ntitle: 节点操作之删除节点\ndate: 2022-9-14 10:28\ntags: [前端]\ncategories: [JavaScript,DOM]\n---\n# 节点操作之删除节点\n\n前面我们学习了如何创建节点，以及如何将创建的节点添加到DOM数里面去，这一节我们将会了解如何删除节点。\n\n在一个评论区，可能会出现这样的情况，用户写了一个评论之后，忽然觉得这个评论有点欠妥，想要将这条评论删除，我们知道这条评论肯定是一个节点，删除评论就意味着要删除节点。\n\n## 删除节点\n\n    node.removeChild(childNode)\n\n删除节点的方法是`node.removeChild(childNode)`，这个方法接受一个参数，就是要删除的节点，这个节点必须是`node`的子节点，否则会报错。\n\n这个方法返回的结果是被删除的这个节点。","slug":"JavaScript/节点操作之删除节点","published":1,"updated":"2023-01-08T11:39:48.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmj8006y9kbmg86m5yxs","content":"<h1 id=\"节点操作之删除节点\"><a href=\"#节点操作之删除节点\" class=\"headerlink\" title=\"节点操作之删除节点\"></a>节点操作之删除节点</h1><p>前面我们学习了如何创建节点，以及如何将创建的节点添加到DOM数里面去，这一节我们将会了解如何删除节点。</p>\n<p>在一个评论区，可能会出现这样的情况，用户写了一个评论之后，忽然觉得这个评论有点欠妥，想要将这条评论删除，我们知道这条评论肯定是一个节点，删除评论就意味着要删除节点。</p>\n<h2 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h2><pre><code>node.removeChild(childNode)\n</code></pre>\n<p>删除节点的方法是<code>node.removeChild(childNode)</code>，这个方法接受一个参数，就是要删除的节点，这个节点必须是<code>node</code>的子节点，否则会报错。</p>\n<p>这个方法返回的结果是被删除的这个节点。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"节点操作之删除节点\"><a href=\"#节点操作之删除节点\" class=\"headerlink\" title=\"节点操作之删除节点\"></a>节点操作之删除节点</h1><p>前面我们学习了如何创建节点，以及如何将创建的节点添加到DOM数里面去，这一节我们将会了解如何删除节点。</p>\n<p>在一个评论区，可能会出现这样的情况，用户写了一个评论之后，忽然觉得这个评论有点欠妥，想要将这条评论删除，我们知道这条评论肯定是一个节点，删除评论就意味着要删除节点。</p>\n<h2 id=\"删除节点\"><a href=\"#删除节点\" class=\"headerlink\" title=\"删除节点\"></a>删除节点</h2><pre><code>node.removeChild(childNode)\n</code></pre>\n<p>删除节点的方法是<code>node.removeChild(childNode)</code>，这个方法接受一个参数，就是要删除的节点，这个节点必须是<code>node</code>的子节点，否则会报错。</p>\n<p>这个方法返回的结果是被删除的这个节点。</p>\n"},{"title":"节点操作之复制节点","date":"2022-09-16T16:39:00.000Z","_content":"# 节点操作之复制节点\n\n在前面的文章中，我们介绍了如何创建节点，如何删除节点，如何修改节点，本文将介绍如何复制节点。\n\n复制节点就有人说了，为什么还需要用js来赋值节点，我自己CV大法不行吗?但是在我们世纪开发过程中，我们可能就会遇到，用户点击某一个按钮之后，需要在页面上创建一个节点，这个节点的内容和某一个已经存在的节点的内容是一样的，这个时候，我们就需要用到复制节点了。\n\n而单纯的CV大法就会失效，行不通。\n\n## 复制节点（克隆节点）\n\n    node.cloneNode()\n\n方法可以复制一个节点，这个方法有一个参数，这个参数是一个布尔值，如果这个值为true[深拷贝]，那么这个节点的所有子节点也会被复制(文本节点、样式节点、属性节点)，如果这个值为false[浅拷贝]，那么这个节点的所有子节点不会被复制（只复制标签）。\n","source":"_posts/JavaScript/节点操作之复制节点.md","raw":"---\ntitle: 节点操作之复制节点\ndate: 2022-9-17 00:39\ntags: [前端]\ncategories: [JavaScript,DOM]\n---\n# 节点操作之复制节点\n\n在前面的文章中，我们介绍了如何创建节点，如何删除节点，如何修改节点，本文将介绍如何复制节点。\n\n复制节点就有人说了，为什么还需要用js来赋值节点，我自己CV大法不行吗?但是在我们世纪开发过程中，我们可能就会遇到，用户点击某一个按钮之后，需要在页面上创建一个节点，这个节点的内容和某一个已经存在的节点的内容是一样的，这个时候，我们就需要用到复制节点了。\n\n而单纯的CV大法就会失效，行不通。\n\n## 复制节点（克隆节点）\n\n    node.cloneNode()\n\n方法可以复制一个节点，这个方法有一个参数，这个参数是一个布尔值，如果这个值为true[深拷贝]，那么这个节点的所有子节点也会被复制(文本节点、样式节点、属性节点)，如果这个值为false[浅拷贝]，那么这个节点的所有子节点不会被复制（只复制标签）。\n","slug":"JavaScript/节点操作之复制节点","published":1,"updated":"2023-01-08T11:39:45.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmja00729kbm7id98gy4","content":"<h1 id=\"节点操作之复制节点\"><a href=\"#节点操作之复制节点\" class=\"headerlink\" title=\"节点操作之复制节点\"></a>节点操作之复制节点</h1><p>在前面的文章中，我们介绍了如何创建节点，如何删除节点，如何修改节点，本文将介绍如何复制节点。</p>\n<p>复制节点就有人说了，为什么还需要用js来赋值节点，我自己CV大法不行吗?但是在我们世纪开发过程中，我们可能就会遇到，用户点击某一个按钮之后，需要在页面上创建一个节点，这个节点的内容和某一个已经存在的节点的内容是一样的，这个时候，我们就需要用到复制节点了。</p>\n<p>而单纯的CV大法就会失效，行不通。</p>\n<h2 id=\"复制节点（克隆节点）\"><a href=\"#复制节点（克隆节点）\" class=\"headerlink\" title=\"复制节点（克隆节点）\"></a>复制节点（克隆节点）</h2><pre><code>node.cloneNode()\n</code></pre>\n<p>方法可以复制一个节点，这个方法有一个参数，这个参数是一个布尔值，如果这个值为true[深拷贝]，那么这个节点的所有子节点也会被复制(文本节点、样式节点、属性节点)，如果这个值为false[浅拷贝]，那么这个节点的所有子节点不会被复制（只复制标签）。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"节点操作之复制节点\"><a href=\"#节点操作之复制节点\" class=\"headerlink\" title=\"节点操作之复制节点\"></a>节点操作之复制节点</h1><p>在前面的文章中，我们介绍了如何创建节点，如何删除节点，如何修改节点，本文将介绍如何复制节点。</p>\n<p>复制节点就有人说了，为什么还需要用js来赋值节点，我自己CV大法不行吗?但是在我们世纪开发过程中，我们可能就会遇到，用户点击某一个按钮之后，需要在页面上创建一个节点，这个节点的内容和某一个已经存在的节点的内容是一样的，这个时候，我们就需要用到复制节点了。</p>\n<p>而单纯的CV大法就会失效，行不通。</p>\n<h2 id=\"复制节点（克隆节点）\"><a href=\"#复制节点（克隆节点）\" class=\"headerlink\" title=\"复制节点（克隆节点）\"></a>复制节点（克隆节点）</h2><pre><code>node.cloneNode()\n</code></pre>\n<p>方法可以复制一个节点，这个方法有一个参数，这个参数是一个布尔值，如果这个值为true[深拷贝]，那么这个节点的所有子节点也会被复制(文本节点、样式节点、属性节点)，如果这个值为false[浅拷贝]，那么这个节点的所有子节点不会被复制（只复制标签）。</p>\n"},{"title":"闭包","date":"2022-12-31T16:00:00.000Z","_content":"# 我终于搞懂了js里面的闭包\n\n一提到闭包，大家就会想起JavaScript中的闭包，没错，闭包是JavaScript的一大特色，这是因为有了闭包，让JavaScript可以做一些特别的工作。\n\n但是闭包对于很多人来说很亲切却又很陌生。为什么呢？  \n因为闭包在JavaScript中非常常见，但是呢闭包又是JavaScript中的一大难点，被称作JavaScript里面的三座大山。\n\n今天我给大家带来我对闭包的理解：\n\n## 1.准备工作\n\n在了解闭包之前，我们需要知道两个东西：\n\n- 作用域\n- 函数在定义时的一些小知识\n\n### 1.1作用域\n\n在JavaScript中，定义变量时所在的作用域，决定了这个变量的可见性。\n\nJavaScript中有两种作用域：全局作用域与局部作用域。\n\n- 全局作用域：在这里定义的变量，整个代码都可以访问到这变量。\n- 局部作用域：在这里定义的变量，在该局部作用域和上级作用域可以访问到\n\n也就是说，全局作用域下可以有多个局部作用域，在某个局部作用域里面也可以存在多个（子）局部作用域。\n\n我们可以这样理解，全局作用域是祖先作用域，剩下的作用域可以被分为子局部作用域、孙局部作用域、、、、、、\n\n就像这样：\n\n![123.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/899e1cebae844ee1a7c99a6ebacc86a2~tplv-k3u1fbpfcp-watermark.image?)\n\n当我们需要查找一个变量的值的时候，我们JavaScript的引擎就会这样去寻找：\n\n如果是在局部作用域查找该变量的值，JavaScript首先会在本局部作用域查找这个变量，如果查找到，就使用该变量；如果没有找到，就会往上一级作用域查找，依次类推。这就是我们所说的就近原则。\n\n我么可以发现：查找变量都是向本作用域或者上级作用域查找。而不会向下级作用域查找，这是因为我们不能访问下级作用域的变量。但是闭包的出现，就能解决这个问题。\n\n不着急，我们慢慢往下看。\n\n### 1.2函数定义时的一些小知识\n\n我这里只讲述函数定义时作用域的知识：\n\n函数在定义的时候就会与定义时所在的变量作用域绑定，就比如函数在全局作用域下定义，那么这个函数就一直处在全局作用域；如果函数在某一个局部作用域下定义，那么该函数就与这个局部作用域绑定。\n\n并且在函数内部也会形成一个局部作用域，这里面定义的变量只能在函数内部使用。\n\n## 2.上正菜：闭包\n\n在了解了前面的知识之后，我们就可以开始我们今天的正菜了：闭包。\n\n前面我们知道函数内部是一个局部作用域，并且在函数外部是不能访问到函数内部的变量的。\n\n```js\nfunction f(){\n\tlet a = 2;\n\tconsole.log(a);\n}\n\nf();// 2\nconsole.log(a);// 报错 变量a没有定义\n```\n\n有了闭包之后，这一切都不一样了。闭包：**就是能够读取其他函数内部变量的函数**。是的，你没有看错，闭包其实是一个函数。\n\n我们先弄一个闭包出来，然后我们再来讲讲闭包是怎么实现的。\n\n```js\nfunction f1(){\n\tlet a = 10;\n\tlet b = 20;\n\tfunction f2(){\n\t\treturn a;\n\t}\n\treturn f2();\n}\nlet c = f1();\nconsole.log(c);// 10\n```\n\n很神奇吧，在函数外部，我们居然读取到了函数内部变量的值。\n\n这是因为，`f1`函数内部定义了一个`f2`函数，因为`f2`函数是在`f1`内部定义的，多以`f2`的作用域就为`f1`局部作用域里面的又一个子局部作用域。\n\n根据前面我们的铺垫可知：\n\n- 在`f2`函数作用域内可以访问到`f1`的变量。\n\n所以当`f2`作为`f1`的返回值的时候，就把`f2`能访问到的变量的值也返回回去了。这样就导致，外部调用`f1`函数的时候，返回一个`f2`函数，`f2`函数里面又可以访问到`f1`内部的变量。最终`f1`函数外部也能访问`f1`内部的变量了。\n\n有点绕，但是闭包就是这样一个原理。\n\n### 2.1闭包作用\n\n1. 闭包可以读取函数内部的变量\n2. 闭包可以使得变量的值始终保存在内存中\n\n针对第一点，闭包可以实现对象的某些私有方法。  \n第二点，这提醒我们要慎用闭包，虽然它很灵活，但是不小心开发者就会写一个闭包出来，有可能会造成内存泄露。\n\n## 总结\n\n一直在路上，2023新的一年，新的开始。坚持不懈的学习，终会有成功的那一天。","source":"_posts/JavaScript/闭包.md","raw":"---\ntitle: 闭包\ndate: 2023-1-1\ntags: 前端\ncategories: JavaScript\n---\n# 我终于搞懂了js里面的闭包\n\n一提到闭包，大家就会想起JavaScript中的闭包，没错，闭包是JavaScript的一大特色，这是因为有了闭包，让JavaScript可以做一些特别的工作。\n\n但是闭包对于很多人来说很亲切却又很陌生。为什么呢？  \n因为闭包在JavaScript中非常常见，但是呢闭包又是JavaScript中的一大难点，被称作JavaScript里面的三座大山。\n\n今天我给大家带来我对闭包的理解：\n\n## 1.准备工作\n\n在了解闭包之前，我们需要知道两个东西：\n\n- 作用域\n- 函数在定义时的一些小知识\n\n### 1.1作用域\n\n在JavaScript中，定义变量时所在的作用域，决定了这个变量的可见性。\n\nJavaScript中有两种作用域：全局作用域与局部作用域。\n\n- 全局作用域：在这里定义的变量，整个代码都可以访问到这变量。\n- 局部作用域：在这里定义的变量，在该局部作用域和上级作用域可以访问到\n\n也就是说，全局作用域下可以有多个局部作用域，在某个局部作用域里面也可以存在多个（子）局部作用域。\n\n我们可以这样理解，全局作用域是祖先作用域，剩下的作用域可以被分为子局部作用域、孙局部作用域、、、、、、\n\n就像这样：\n\n![123.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/899e1cebae844ee1a7c99a6ebacc86a2~tplv-k3u1fbpfcp-watermark.image?)\n\n当我们需要查找一个变量的值的时候，我们JavaScript的引擎就会这样去寻找：\n\n如果是在局部作用域查找该变量的值，JavaScript首先会在本局部作用域查找这个变量，如果查找到，就使用该变量；如果没有找到，就会往上一级作用域查找，依次类推。这就是我们所说的就近原则。\n\n我么可以发现：查找变量都是向本作用域或者上级作用域查找。而不会向下级作用域查找，这是因为我们不能访问下级作用域的变量。但是闭包的出现，就能解决这个问题。\n\n不着急，我们慢慢往下看。\n\n### 1.2函数定义时的一些小知识\n\n我这里只讲述函数定义时作用域的知识：\n\n函数在定义的时候就会与定义时所在的变量作用域绑定，就比如函数在全局作用域下定义，那么这个函数就一直处在全局作用域；如果函数在某一个局部作用域下定义，那么该函数就与这个局部作用域绑定。\n\n并且在函数内部也会形成一个局部作用域，这里面定义的变量只能在函数内部使用。\n\n## 2.上正菜：闭包\n\n在了解了前面的知识之后，我们就可以开始我们今天的正菜了：闭包。\n\n前面我们知道函数内部是一个局部作用域，并且在函数外部是不能访问到函数内部的变量的。\n\n```js\nfunction f(){\n\tlet a = 2;\n\tconsole.log(a);\n}\n\nf();// 2\nconsole.log(a);// 报错 变量a没有定义\n```\n\n有了闭包之后，这一切都不一样了。闭包：**就是能够读取其他函数内部变量的函数**。是的，你没有看错，闭包其实是一个函数。\n\n我们先弄一个闭包出来，然后我们再来讲讲闭包是怎么实现的。\n\n```js\nfunction f1(){\n\tlet a = 10;\n\tlet b = 20;\n\tfunction f2(){\n\t\treturn a;\n\t}\n\treturn f2();\n}\nlet c = f1();\nconsole.log(c);// 10\n```\n\n很神奇吧，在函数外部，我们居然读取到了函数内部变量的值。\n\n这是因为，`f1`函数内部定义了一个`f2`函数，因为`f2`函数是在`f1`内部定义的，多以`f2`的作用域就为`f1`局部作用域里面的又一个子局部作用域。\n\n根据前面我们的铺垫可知：\n\n- 在`f2`函数作用域内可以访问到`f1`的变量。\n\n所以当`f2`作为`f1`的返回值的时候，就把`f2`能访问到的变量的值也返回回去了。这样就导致，外部调用`f1`函数的时候，返回一个`f2`函数，`f2`函数里面又可以访问到`f1`内部的变量。最终`f1`函数外部也能访问`f1`内部的变量了。\n\n有点绕，但是闭包就是这样一个原理。\n\n### 2.1闭包作用\n\n1. 闭包可以读取函数内部的变量\n2. 闭包可以使得变量的值始终保存在内存中\n\n针对第一点，闭包可以实现对象的某些私有方法。  \n第二点，这提醒我们要慎用闭包，虽然它很灵活，但是不小心开发者就会写一个闭包出来，有可能会造成内存泄露。\n\n## 总结\n\n一直在路上，2023新的一年，新的开始。坚持不懈的学习，终会有成功的那一天。","slug":"JavaScript/闭包","published":1,"updated":"2023-01-08T11:11:18.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjb00759kbm4vu2dx26","content":"<h1 id=\"我终于搞懂了js里面的闭包\"><a href=\"#我终于搞懂了js里面的闭包\" class=\"headerlink\" title=\"我终于搞懂了js里面的闭包\"></a>我终于搞懂了js里面的闭包</h1><p>一提到闭包，大家就会想起JavaScript中的闭包，没错，闭包是JavaScript的一大特色，这是因为有了闭包，让JavaScript可以做一些特别的工作。</p>\n<p>但是闭包对于很多人来说很亲切却又很陌生。为什么呢？<br>因为闭包在JavaScript中非常常见，但是呢闭包又是JavaScript中的一大难点，被称作JavaScript里面的三座大山。</p>\n<p>今天我给大家带来我对闭包的理解：</p>\n<h2 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1.准备工作\"></a>1.准备工作</h2><p>在了解闭包之前，我们需要知道两个东西：</p>\n<ul>\n<li>作用域</li>\n<li>函数在定义时的一些小知识</li>\n</ul>\n<h3 id=\"1-1作用域\"><a href=\"#1-1作用域\" class=\"headerlink\" title=\"1.1作用域\"></a>1.1作用域</h3><p>在JavaScript中，定义变量时所在的作用域，决定了这个变量的可见性。</p>\n<p>JavaScript中有两种作用域：全局作用域与局部作用域。</p>\n<ul>\n<li>全局作用域：在这里定义的变量，整个代码都可以访问到这变量。</li>\n<li>局部作用域：在这里定义的变量，在该局部作用域和上级作用域可以访问到</li>\n</ul>\n<p>也就是说，全局作用域下可以有多个局部作用域，在某个局部作用域里面也可以存在多个（子）局部作用域。</p>\n<p>我们可以这样理解，全局作用域是祖先作用域，剩下的作用域可以被分为子局部作用域、孙局部作用域、、、、、、</p>\n<p>就像这样：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/899e1cebae844ee1a7c99a6ebacc86a2~tplv-k3u1fbpfcp-watermark.image\" alt=\"123.png\"></p>\n<p>当我们需要查找一个变量的值的时候，我们JavaScript的引擎就会这样去寻找：</p>\n<p>如果是在局部作用域查找该变量的值，JavaScript首先会在本局部作用域查找这个变量，如果查找到，就使用该变量；如果没有找到，就会往上一级作用域查找，依次类推。这就是我们所说的就近原则。</p>\n<p>我么可以发现：查找变量都是向本作用域或者上级作用域查找。而不会向下级作用域查找，这是因为我们不能访问下级作用域的变量。但是闭包的出现，就能解决这个问题。</p>\n<p>不着急，我们慢慢往下看。</p>\n<h3 id=\"1-2函数定义时的一些小知识\"><a href=\"#1-2函数定义时的一些小知识\" class=\"headerlink\" title=\"1.2函数定义时的一些小知识\"></a>1.2函数定义时的一些小知识</h3><p>我这里只讲述函数定义时作用域的知识：</p>\n<p>函数在定义的时候就会与定义时所在的变量作用域绑定，就比如函数在全局作用域下定义，那么这个函数就一直处在全局作用域；如果函数在某一个局部作用域下定义，那么该函数就与这个局部作用域绑定。</p>\n<p>并且在函数内部也会形成一个局部作用域，这里面定义的变量只能在函数内部使用。</p>\n<h2 id=\"2-上正菜：闭包\"><a href=\"#2-上正菜：闭包\" class=\"headerlink\" title=\"2.上正菜：闭包\"></a>2.上正菜：闭包</h2><p>在了解了前面的知识之后，我们就可以开始我们今天的正菜了：闭包。</p>\n<p>前面我们知道函数内部是一个局部作用域，并且在函数外部是不能访问到函数内部的变量的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>();<span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);<span class=\"comment\">// 报错 变量a没有定义</span></span><br></pre></td></tr></table></figure>\n\n<p>有了闭包之后，这一切都不一样了。闭包：<strong>就是能够读取其他函数内部变量的函数</strong>。是的，你没有看错，闭包其实是一个函数。</p>\n<p>我们先弄一个闭包出来，然后我们再来讲讲闭包是怎么实现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">f2</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"title function_\">f1</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);<span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>很神奇吧，在函数外部，我们居然读取到了函数内部变量的值。</p>\n<p>这是因为，<code>f1</code>函数内部定义了一个<code>f2</code>函数，因为<code>f2</code>函数是在<code>f1</code>内部定义的，多以<code>f2</code>的作用域就为<code>f1</code>局部作用域里面的又一个子局部作用域。</p>\n<p>根据前面我们的铺垫可知：</p>\n<ul>\n<li>在<code>f2</code>函数作用域内可以访问到<code>f1</code>的变量。</li>\n</ul>\n<p>所以当<code>f2</code>作为<code>f1</code>的返回值的时候，就把<code>f2</code>能访问到的变量的值也返回回去了。这样就导致，外部调用<code>f1</code>函数的时候，返回一个<code>f2</code>函数，<code>f2</code>函数里面又可以访问到<code>f1</code>内部的变量。最终<code>f1</code>函数外部也能访问<code>f1</code>内部的变量了。</p>\n<p>有点绕，但是闭包就是这样一个原理。</p>\n<h3 id=\"2-1闭包作用\"><a href=\"#2-1闭包作用\" class=\"headerlink\" title=\"2.1闭包作用\"></a>2.1闭包作用</h3><ol>\n<li>闭包可以读取函数内部的变量</li>\n<li>闭包可以使得变量的值始终保存在内存中</li>\n</ol>\n<p>针对第一点，闭包可以实现对象的某些私有方法。<br>第二点，这提醒我们要慎用闭包，虽然它很灵活，但是不小心开发者就会写一个闭包出来，有可能会造成内存泄露。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一直在路上，2023新的一年，新的开始。坚持不懈的学习，终会有成功的那一天。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我终于搞懂了js里面的闭包\"><a href=\"#我终于搞懂了js里面的闭包\" class=\"headerlink\" title=\"我终于搞懂了js里面的闭包\"></a>我终于搞懂了js里面的闭包</h1><p>一提到闭包，大家就会想起JavaScript中的闭包，没错，闭包是JavaScript的一大特色，这是因为有了闭包，让JavaScript可以做一些特别的工作。</p>\n<p>但是闭包对于很多人来说很亲切却又很陌生。为什么呢？<br>因为闭包在JavaScript中非常常见，但是呢闭包又是JavaScript中的一大难点，被称作JavaScript里面的三座大山。</p>\n<p>今天我给大家带来我对闭包的理解：</p>\n<h2 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1.准备工作\"></a>1.准备工作</h2><p>在了解闭包之前，我们需要知道两个东西：</p>\n<ul>\n<li>作用域</li>\n<li>函数在定义时的一些小知识</li>\n</ul>\n<h3 id=\"1-1作用域\"><a href=\"#1-1作用域\" class=\"headerlink\" title=\"1.1作用域\"></a>1.1作用域</h3><p>在JavaScript中，定义变量时所在的作用域，决定了这个变量的可见性。</p>\n<p>JavaScript中有两种作用域：全局作用域与局部作用域。</p>\n<ul>\n<li>全局作用域：在这里定义的变量，整个代码都可以访问到这变量。</li>\n<li>局部作用域：在这里定义的变量，在该局部作用域和上级作用域可以访问到</li>\n</ul>\n<p>也就是说，全局作用域下可以有多个局部作用域，在某个局部作用域里面也可以存在多个（子）局部作用域。</p>\n<p>我们可以这样理解，全局作用域是祖先作用域，剩下的作用域可以被分为子局部作用域、孙局部作用域、、、、、、</p>\n<p>就像这样：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/899e1cebae844ee1a7c99a6ebacc86a2~tplv-k3u1fbpfcp-watermark.image\" alt=\"123.png\"></p>\n<p>当我们需要查找一个变量的值的时候，我们JavaScript的引擎就会这样去寻找：</p>\n<p>如果是在局部作用域查找该变量的值，JavaScript首先会在本局部作用域查找这个变量，如果查找到，就使用该变量；如果没有找到，就会往上一级作用域查找，依次类推。这就是我们所说的就近原则。</p>\n<p>我么可以发现：查找变量都是向本作用域或者上级作用域查找。而不会向下级作用域查找，这是因为我们不能访问下级作用域的变量。但是闭包的出现，就能解决这个问题。</p>\n<p>不着急，我们慢慢往下看。</p>\n<h3 id=\"1-2函数定义时的一些小知识\"><a href=\"#1-2函数定义时的一些小知识\" class=\"headerlink\" title=\"1.2函数定义时的一些小知识\"></a>1.2函数定义时的一些小知识</h3><p>我这里只讲述函数定义时作用域的知识：</p>\n<p>函数在定义的时候就会与定义时所在的变量作用域绑定，就比如函数在全局作用域下定义，那么这个函数就一直处在全局作用域；如果函数在某一个局部作用域下定义，那么该函数就与这个局部作用域绑定。</p>\n<p>并且在函数内部也会形成一个局部作用域，这里面定义的变量只能在函数内部使用。</p>\n<h2 id=\"2-上正菜：闭包\"><a href=\"#2-上正菜：闭包\" class=\"headerlink\" title=\"2.上正菜：闭包\"></a>2.上正菜：闭包</h2><p>在了解了前面的知识之后，我们就可以开始我们今天的正菜了：闭包。</p>\n<p>前面我们知道函数内部是一个局部作用域，并且在函数外部是不能访问到函数内部的变量的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>();<span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);<span class=\"comment\">// 报错 变量a没有定义</span></span><br></pre></td></tr></table></figure>\n\n<p>有了闭包之后，这一切都不一样了。闭包：<strong>就是能够读取其他函数内部变量的函数</strong>。是的，你没有看错，闭包其实是一个函数。</p>\n<p>我们先弄一个闭包出来，然后我们再来讲讲闭包是怎么实现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> b = <span class=\"number\">20</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"title function_\">f2</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"title function_\">f1</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);<span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>很神奇吧，在函数外部，我们居然读取到了函数内部变量的值。</p>\n<p>这是因为，<code>f1</code>函数内部定义了一个<code>f2</code>函数，因为<code>f2</code>函数是在<code>f1</code>内部定义的，多以<code>f2</code>的作用域就为<code>f1</code>局部作用域里面的又一个子局部作用域。</p>\n<p>根据前面我们的铺垫可知：</p>\n<ul>\n<li>在<code>f2</code>函数作用域内可以访问到<code>f1</code>的变量。</li>\n</ul>\n<p>所以当<code>f2</code>作为<code>f1</code>的返回值的时候，就把<code>f2</code>能访问到的变量的值也返回回去了。这样就导致，外部调用<code>f1</code>函数的时候，返回一个<code>f2</code>函数，<code>f2</code>函数里面又可以访问到<code>f1</code>内部的变量。最终<code>f1</code>函数外部也能访问<code>f1</code>内部的变量了。</p>\n<p>有点绕，但是闭包就是这样一个原理。</p>\n<h3 id=\"2-1闭包作用\"><a href=\"#2-1闭包作用\" class=\"headerlink\" title=\"2.1闭包作用\"></a>2.1闭包作用</h3><ol>\n<li>闭包可以读取函数内部的变量</li>\n<li>闭包可以使得变量的值始终保存在内存中</li>\n</ol>\n<p>针对第一点，闭包可以实现对象的某些私有方法。<br>第二点，这提醒我们要慎用闭包，虽然它很灵活，但是不小心开发者就会写一个闭包出来，有可能会造成内存泄露。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一直在路上，2023新的一年，新的开始。坚持不懈的学习，终会有成功的那一天。</p>\n"},{"title":"解构赋值","date":"2022-09-28T16:00:00.000Z","_content":"# 解构赋值\n\n在js中，我们经常会将对象或者数组里面的一部分数据作为参数传递给函数，如果我们使用传统的`.`方法会很麻烦。\n\n解构赋值就很好的解决了这样一种问题。\n\n解构赋值是一种特殊的语法，可以将对象或者数组中的数据解构出来，然后赋值给变量。\n\n## 数组解构\n\n```js\n    let arr = [1,2,3,4,5];\n    let [a,b,c,d,e] = arr;\n    console.log(a,b,c,d,e); // 1 2 3 4 5\n```\n\n通过上面的例子，我们可以看到通过解构赋值，我们将数组的数据分别赋值给了变量a,b,c,d,e。\n\n**注意：**\n\n解构并不会破坏原来的数组，他只是将数组每个位置的数据赋值了某个变量，数组没有发生改变。\n\n当然，有人会有这样一个问题，要是中间有一个数据我不需要，那该怎么办呢?\n\n```js\n    let arr = [1,2,3,4,5];\n    let [a,,c,d,e] = arr;\n    console.log(a,c,d,e); // 1 3 4 5\n```\n\n上面的代码我们看到，数组里面`2`的数据是没有被复制的，这是因为我们使用了`空位`，空位就是在解构赋值的时候，如果某个位置没有数据，那么就会使用空位。  \n空位不会影响后面的数据，所以`3`的数据还是会被赋值给`c`。 \n上面代码有两个`,`连着，两个逗号中间就是一个空位。\n\n## 对象解构\n\n```js\n    let obj = {\n        name: 'zhangsan',\n        age: 22,\n    }\n    let {name,age} = obj;\n    console.log(name,age); // zhangsan 22\n```\n\n通过上面的例子，我们可以看到，对象的解构赋值和数组的解构赋值是一样的，只不过对象的解构赋值是通过`{}`来进行解构的。\n\n**注意：**\n\n- 我们进行对象解构的时候，定义的变量要与对象里面的属性一样，不可以是其他字符，否则获取不到我们想要的数据。\n\n- 还有就是，对象解构赋值的时候，如果对象里面没有我们想要的属性，那么就会报错(undefined)。\n\n在数组解构中我们解构时变量顺序可以改变，不会影响到我们最后的结果。\n\n```js\n    let obj = {\n        name: 'zhangsan',\n        age: 22,\n    }\n    let {age,name} = obj;\n    console.log(name,age); // zhangsan 22\n```\n前面我们说到如果我们定义了一个对象不存在的属性，那么就会报错；我们可以这样解决：  \n我们可以给这些缺失的属性添加一个默认值。\n\n```js\n    let obj = {\n        name: '海绵宝宝'，\n        age: 22,\n    }\n    let {name, age, add:'比奇堡'} = obj；\n    console.log(name,age,add); // 海绵宝宝 22 比奇堡\n```\n\n上面的代码我们可以看到，我们给`add`属性添加了一个默认值，当我们获取`add`属性的时候，如果对象里面没有`add`属性，那么就会使用默认值。\n\n## 剩余模式\n\n前面我们提到过`空位`，那么要是我们只要前面一部分数据，后面所有数据想要赋值到其他地方，如果使用传统方法肯定费时费力。那么该怎么办呢？\n\n这时候剩余模式就派上了大用场：\n\n```js\n    let arr = [1,2,3,4,5];\n    let [a,...b] = arr;\n    console.log(a,b); // 1 [2,3,4,5]\n```\n这段代码中，我们将数组第一个数据赋值给`a`，其余全部数据保存在`b`里面。\n\n## 嵌套解构\n\n在实际开发中，我们难免会遇到，某个对象里面还包含着函数这样的结构，那么这种解构赋值又该如何操作呢？\n\n嵌套解构可以做到，它的要求就是等号左侧的结构需要与右侧结构一致。\n\n```js\n    let obj = {\n        ID: { name: '海绵宝宝', age: 22 },\n        aihao: '抓水母',\n        arr: [1, 2, 3],\n    }\n    let { ID: { name, age }, aihao, arr: [a, b, c] } = obj;\n    console.log(name, age, aihao, a, b, c); // 海绵宝宝 22 抓水母 1 2 3\n```","source":"_posts/JavaScript/解构赋值.md","raw":"---\ntitle: 解构赋值\ndate: 2022-9-29\ntags: [前端]\ncategories: [JavaScript,ES6]\n---\n# 解构赋值\n\n在js中，我们经常会将对象或者数组里面的一部分数据作为参数传递给函数，如果我们使用传统的`.`方法会很麻烦。\n\n解构赋值就很好的解决了这样一种问题。\n\n解构赋值是一种特殊的语法，可以将对象或者数组中的数据解构出来，然后赋值给变量。\n\n## 数组解构\n\n```js\n    let arr = [1,2,3,4,5];\n    let [a,b,c,d,e] = arr;\n    console.log(a,b,c,d,e); // 1 2 3 4 5\n```\n\n通过上面的例子，我们可以看到通过解构赋值，我们将数组的数据分别赋值给了变量a,b,c,d,e。\n\n**注意：**\n\n解构并不会破坏原来的数组，他只是将数组每个位置的数据赋值了某个变量，数组没有发生改变。\n\n当然，有人会有这样一个问题，要是中间有一个数据我不需要，那该怎么办呢?\n\n```js\n    let arr = [1,2,3,4,5];\n    let [a,,c,d,e] = arr;\n    console.log(a,c,d,e); // 1 3 4 5\n```\n\n上面的代码我们看到，数组里面`2`的数据是没有被复制的，这是因为我们使用了`空位`，空位就是在解构赋值的时候，如果某个位置没有数据，那么就会使用空位。  \n空位不会影响后面的数据，所以`3`的数据还是会被赋值给`c`。 \n上面代码有两个`,`连着，两个逗号中间就是一个空位。\n\n## 对象解构\n\n```js\n    let obj = {\n        name: 'zhangsan',\n        age: 22,\n    }\n    let {name,age} = obj;\n    console.log(name,age); // zhangsan 22\n```\n\n通过上面的例子，我们可以看到，对象的解构赋值和数组的解构赋值是一样的，只不过对象的解构赋值是通过`{}`来进行解构的。\n\n**注意：**\n\n- 我们进行对象解构的时候，定义的变量要与对象里面的属性一样，不可以是其他字符，否则获取不到我们想要的数据。\n\n- 还有就是，对象解构赋值的时候，如果对象里面没有我们想要的属性，那么就会报错(undefined)。\n\n在数组解构中我们解构时变量顺序可以改变，不会影响到我们最后的结果。\n\n```js\n    let obj = {\n        name: 'zhangsan',\n        age: 22,\n    }\n    let {age,name} = obj;\n    console.log(name,age); // zhangsan 22\n```\n前面我们说到如果我们定义了一个对象不存在的属性，那么就会报错；我们可以这样解决：  \n我们可以给这些缺失的属性添加一个默认值。\n\n```js\n    let obj = {\n        name: '海绵宝宝'，\n        age: 22,\n    }\n    let {name, age, add:'比奇堡'} = obj；\n    console.log(name,age,add); // 海绵宝宝 22 比奇堡\n```\n\n上面的代码我们可以看到，我们给`add`属性添加了一个默认值，当我们获取`add`属性的时候，如果对象里面没有`add`属性，那么就会使用默认值。\n\n## 剩余模式\n\n前面我们提到过`空位`，那么要是我们只要前面一部分数据，后面所有数据想要赋值到其他地方，如果使用传统方法肯定费时费力。那么该怎么办呢？\n\n这时候剩余模式就派上了大用场：\n\n```js\n    let arr = [1,2,3,4,5];\n    let [a,...b] = arr;\n    console.log(a,b); // 1 [2,3,4,5]\n```\n这段代码中，我们将数组第一个数据赋值给`a`，其余全部数据保存在`b`里面。\n\n## 嵌套解构\n\n在实际开发中，我们难免会遇到，某个对象里面还包含着函数这样的结构，那么这种解构赋值又该如何操作呢？\n\n嵌套解构可以做到，它的要求就是等号左侧的结构需要与右侧结构一致。\n\n```js\n    let obj = {\n        ID: { name: '海绵宝宝', age: 22 },\n        aihao: '抓水母',\n        arr: [1, 2, 3],\n    }\n    let { ID: { name, age }, aihao, arr: [a, b, c] } = obj;\n    console.log(name, age, aihao, a, b, c); // 海绵宝宝 22 抓水母 1 2 3\n```","slug":"JavaScript/解构赋值","published":1,"updated":"2023-01-10T02:37:43.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjc00799kbm6cy82ja9","content":"<h1 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h1><p>在js中，我们经常会将对象或者数组里面的一部分数据作为参数传递给函数，如果我们使用传统的<code>.</code>方法会很麻烦。</p>\n<p>解构赋值就很好的解决了这样一种问题。</p>\n<p>解构赋值是一种特殊的语法，可以将对象或者数组中的数据解构出来，然后赋值给变量。</p>\n<h2 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a,b,c,d,e] = arr;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a,b,c,d,e); <span class=\"comment\">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们可以看到通过解构赋值，我们将数组的数据分别赋值给了变量a,b,c,d,e。</p>\n<p><strong>注意：</strong></p>\n<p>解构并不会破坏原来的数组，他只是将数组每个位置的数据赋值了某个变量，数组没有发生改变。</p>\n<p>当然，有人会有这样一个问题，要是中间有一个数据我不需要，那该怎么办呢?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a,,c,d,e] = arr;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a,c,d,e); <span class=\"comment\">// 1 3 4 5</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码我们看到，数组里面<code>2</code>的数据是没有被复制的，这是因为我们使用了<code>空位</code>，空位就是在解构赋值的时候，如果某个位置没有数据，那么就会使用空位。<br>空位不会影响后面的数据，所以<code>3</code>的数据还是会被赋值给<code>c</code>。<br>上面代码有两个<code>,</code>连着，两个逗号中间就是一个空位。</p>\n<h2 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zhangsan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;name,age&#125; = obj;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name,age); <span class=\"comment\">// zhangsan 22</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们可以看到，对象的解构赋值和数组的解构赋值是一样的，只不过对象的解构赋值是通过<code>&#123;&#125;</code>来进行解构的。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>我们进行对象解构的时候，定义的变量要与对象里面的属性一样，不可以是其他字符，否则获取不到我们想要的数据。</p>\n</li>\n<li><p>还有就是，对象解构赋值的时候，如果对象里面没有我们想要的属性，那么就会报错(undefined)。</p>\n</li>\n</ul>\n<p>在数组解构中我们解构时变量顺序可以改变，不会影响到我们最后的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zhangsan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;age,name&#125; = obj;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name,age); <span class=\"comment\">// zhangsan 22</span></span><br></pre></td></tr></table></figure>\n<p>前面我们说到如果我们定义了一个对象不存在的属性，那么就会报错；我们可以这样解决：<br>我们可以给这些缺失的属性添加一个默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;海绵宝宝&#x27;</span>，</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;name, age, <span class=\"attr\">add</span>:<span class=\"string\">&#x27;比奇堡&#x27;</span>&#125; = obj；</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name,age,add); <span class=\"comment\">// 海绵宝宝 22 比奇堡</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码我们可以看到，我们给<code>add</code>属性添加了一个默认值，当我们获取<code>add</code>属性的时候，如果对象里面没有<code>add</code>属性，那么就会使用默认值。</p>\n<h2 id=\"剩余模式\"><a href=\"#剩余模式\" class=\"headerlink\" title=\"剩余模式\"></a>剩余模式</h2><p>前面我们提到过<code>空位</code>，那么要是我们只要前面一部分数据，后面所有数据想要赋值到其他地方，如果使用传统方法肯定费时费力。那么该怎么办呢？</p>\n<p>这时候剩余模式就派上了大用场：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a,...b] = arr;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a,b); <span class=\"comment\">// 1 [2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<p>这段代码中，我们将数组第一个数据赋值给<code>a</code>，其余全部数据保存在<code>b</code>里面。</p>\n<h2 id=\"嵌套解构\"><a href=\"#嵌套解构\" class=\"headerlink\" title=\"嵌套解构\"></a>嵌套解构</h2><p>在实际开发中，我们难免会遇到，某个对象里面还包含着函数这样的结构，那么这种解构赋值又该如何操作呢？</p>\n<p>嵌套解构可以做到，它的要求就是等号左侧的结构需要与右侧结构一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">ID</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;海绵宝宝&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">22</span> &#125;,</span><br><span class=\"line\">    <span class=\"attr\">aihao</span>: <span class=\"string\">&#x27;抓水母&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">arr</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">ID</span>: &#123; name, age &#125;, aihao, <span class=\"attr\">arr</span>: [a, b, c] &#125; = obj;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name, age, aihao, a, b, c); <span class=\"comment\">// 海绵宝宝 22 抓水母 1 2 3</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h1><p>在js中，我们经常会将对象或者数组里面的一部分数据作为参数传递给函数，如果我们使用传统的<code>.</code>方法会很麻烦。</p>\n<p>解构赋值就很好的解决了这样一种问题。</p>\n<p>解构赋值是一种特殊的语法，可以将对象或者数组中的数据解构出来，然后赋值给变量。</p>\n<h2 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a,b,c,d,e] = arr;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a,b,c,d,e); <span class=\"comment\">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们可以看到通过解构赋值，我们将数组的数据分别赋值给了变量a,b,c,d,e。</p>\n<p><strong>注意：</strong></p>\n<p>解构并不会破坏原来的数组，他只是将数组每个位置的数据赋值了某个变量，数组没有发生改变。</p>\n<p>当然，有人会有这样一个问题，要是中间有一个数据我不需要，那该怎么办呢?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a,,c,d,e] = arr;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a,c,d,e); <span class=\"comment\">// 1 3 4 5</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码我们看到，数组里面<code>2</code>的数据是没有被复制的，这是因为我们使用了<code>空位</code>，空位就是在解构赋值的时候，如果某个位置没有数据，那么就会使用空位。<br>空位不会影响后面的数据，所以<code>3</code>的数据还是会被赋值给<code>c</code>。<br>上面代码有两个<code>,</code>连着，两个逗号中间就是一个空位。</p>\n<h2 id=\"对象解构\"><a href=\"#对象解构\" class=\"headerlink\" title=\"对象解构\"></a>对象解构</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zhangsan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;name,age&#125; = obj;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name,age); <span class=\"comment\">// zhangsan 22</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们可以看到，对象的解构赋值和数组的解构赋值是一样的，只不过对象的解构赋值是通过<code>&#123;&#125;</code>来进行解构的。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>我们进行对象解构的时候，定义的变量要与对象里面的属性一样，不可以是其他字符，否则获取不到我们想要的数据。</p>\n</li>\n<li><p>还有就是，对象解构赋值的时候，如果对象里面没有我们想要的属性，那么就会报错(undefined)。</p>\n</li>\n</ul>\n<p>在数组解构中我们解构时变量顺序可以改变，不会影响到我们最后的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;zhangsan&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;age,name&#125; = obj;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name,age); <span class=\"comment\">// zhangsan 22</span></span><br></pre></td></tr></table></figure>\n<p>前面我们说到如果我们定义了一个对象不存在的属性，那么就会报错；我们可以这样解决：<br>我们可以给这些缺失的属性添加一个默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;海绵宝宝&#x27;</span>，</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;name, age, <span class=\"attr\">add</span>:<span class=\"string\">&#x27;比奇堡&#x27;</span>&#125; = obj；</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name,age,add); <span class=\"comment\">// 海绵宝宝 22 比奇堡</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码我们可以看到，我们给<code>add</code>属性添加了一个默认值，当我们获取<code>add</code>属性的时候，如果对象里面没有<code>add</code>属性，那么就会使用默认值。</p>\n<h2 id=\"剩余模式\"><a href=\"#剩余模式\" class=\"headerlink\" title=\"剩余模式\"></a>剩余模式</h2><p>前面我们提到过<code>空位</code>，那么要是我们只要前面一部分数据，后面所有数据想要赋值到其他地方，如果使用传统方法肯定费时费力。那么该怎么办呢？</p>\n<p>这时候剩余模式就派上了大用场：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [a,...b] = arr;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a,b); <span class=\"comment\">// 1 [2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<p>这段代码中，我们将数组第一个数据赋值给<code>a</code>，其余全部数据保存在<code>b</code>里面。</p>\n<h2 id=\"嵌套解构\"><a href=\"#嵌套解构\" class=\"headerlink\" title=\"嵌套解构\"></a>嵌套解构</h2><p>在实际开发中，我们难免会遇到，某个对象里面还包含着函数这样的结构，那么这种解构赋值又该如何操作呢？</p>\n<p>嵌套解构可以做到，它的要求就是等号左侧的结构需要与右侧结构一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">ID</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;海绵宝宝&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">22</span> &#125;,</span><br><span class=\"line\">    <span class=\"attr\">aihao</span>: <span class=\"string\">&#x27;抓水母&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">arr</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">ID</span>: &#123; name, age &#125;, aihao, <span class=\"attr\">arr</span>: [a, b, c] &#125; = obj;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name, age, aihao, a, b, c); <span class=\"comment\">// 海绵宝宝 22 抓水母 1 2 3</span></span><br></pre></td></tr></table></figure>"},{"title":"Vue3中的Mixinyu extends","data":["2023-3-21"],"categroies":["Vue3"],"_content":"\n# Vue3中的Mixin与extends\n\n组件之间有时候会存在一些相同的代码逻辑，我们此时就需要对相同的代码逻辑进行抽取。\n\n这个时候我们就可以使用到Mixin这种方式。\n\n- Mixin提供了一种非常灵活的方式，用来分发Vue组件中可复用的功能。\n- 一个Mixin对象可以包含任何组件选项\n- 当组件使用Mixin对象时，所有Mixin对象选项将被混入该组件本身的选项当中。\n\n## Mixin的基本使用\n\n[见代码](https://github.com/zml212/vue3_learn/tree/master/vue_vite_learn/src/17_Mixin%E4%B8%8Eextends%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)\n\n### Mixin的合并规则\n\n如果Mixin对象中的选项和组件对象中的选项发生了冲突，Vue会这样处理：\n\n- 如果data函数的返回值对象与Mixin发生了冲突\n\t- 返回值对象默认情况下会进行合并\n\t- 如果data的返回值与Mixin发生了冲突，那么会保留组件自身的数据\n\n- 如果与生命周期函数发生冲突\n\t- 生命周期钩子函数会被合并到一个数组，并且都会执行\n\n- 值为对象的一个选项，比如methods、components、directives，将会被合并为同一个对象\n\t- 比如都有methods选项，并且都定义了方法，那么他们都会生效\n\t- 但是如果对象的key相同，那么组件内部的会取代Mixin的\n\n### 全局混入Mixin\n\n如果我们组件当中，某些选项是所有组件都需要的，这个时候我们可以使用全局Mixin\n\n- 全局Mixin可以使用应用app的方法Mixin来完成注册\n- 一旦注册，那么全局混入的选项将会影响每一个组件\n\n## Vue3中的extends\n\n另外一个类似于Mixin的方式就是通过extends属性\n\n- 允许声明扩展另一个组件，类似于Mixin","source":"_posts/Vue3/Mixin.md","raw":"---\ntitle: Vue3中的Mixinyu extends\ndata: [2023-3-21]\ntags: [前端]\ncategroies: [Vue3]\n---\n\n# Vue3中的Mixin与extends\n\n组件之间有时候会存在一些相同的代码逻辑，我们此时就需要对相同的代码逻辑进行抽取。\n\n这个时候我们就可以使用到Mixin这种方式。\n\n- Mixin提供了一种非常灵活的方式，用来分发Vue组件中可复用的功能。\n- 一个Mixin对象可以包含任何组件选项\n- 当组件使用Mixin对象时，所有Mixin对象选项将被混入该组件本身的选项当中。\n\n## Mixin的基本使用\n\n[见代码](https://github.com/zml212/vue3_learn/tree/master/vue_vite_learn/src/17_Mixin%E4%B8%8Eextends%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)\n\n### Mixin的合并规则\n\n如果Mixin对象中的选项和组件对象中的选项发生了冲突，Vue会这样处理：\n\n- 如果data函数的返回值对象与Mixin发生了冲突\n\t- 返回值对象默认情况下会进行合并\n\t- 如果data的返回值与Mixin发生了冲突，那么会保留组件自身的数据\n\n- 如果与生命周期函数发生冲突\n\t- 生命周期钩子函数会被合并到一个数组，并且都会执行\n\n- 值为对象的一个选项，比如methods、components、directives，将会被合并为同一个对象\n\t- 比如都有methods选项，并且都定义了方法，那么他们都会生效\n\t- 但是如果对象的key相同，那么组件内部的会取代Mixin的\n\n### 全局混入Mixin\n\n如果我们组件当中，某些选项是所有组件都需要的，这个时候我们可以使用全局Mixin\n\n- 全局Mixin可以使用应用app的方法Mixin来完成注册\n- 一旦注册，那么全局混入的选项将会影响每一个组件\n\n## Vue3中的extends\n\n另外一个类似于Mixin的方式就是通过extends属性\n\n- 允许声明扩展另一个组件，类似于Mixin","slug":"Vue3/Mixin","published":1,"date":"2023-03-21T11:26:07.240Z","updated":"2023-03-22T07:12:23.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjd007c9kbme7dvbvq9","content":"<h1 id=\"Vue3中的Mixin与extends\"><a href=\"#Vue3中的Mixin与extends\" class=\"headerlink\" title=\"Vue3中的Mixin与extends\"></a>Vue3中的Mixin与extends</h1><p>组件之间有时候会存在一些相同的代码逻辑，我们此时就需要对相同的代码逻辑进行抽取。</p>\n<p>这个时候我们就可以使用到Mixin这种方式。</p>\n<ul>\n<li>Mixin提供了一种非常灵活的方式，用来分发Vue组件中可复用的功能。</li>\n<li>一个Mixin对象可以包含任何组件选项</li>\n<li>当组件使用Mixin对象时，所有Mixin对象选项将被混入该组件本身的选项当中。</li>\n</ul>\n<h2 id=\"Mixin的基本使用\"><a href=\"#Mixin的基本使用\" class=\"headerlink\" title=\"Mixin的基本使用\"></a>Mixin的基本使用</h2><p><a href=\"https://github.com/zml212/vue3_learn/tree/master/vue_vite_learn/src/17_Mixin%E4%B8%8Eextends%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\">见代码</a></p>\n<h3 id=\"Mixin的合并规则\"><a href=\"#Mixin的合并规则\" class=\"headerlink\" title=\"Mixin的合并规则\"></a>Mixin的合并规则</h3><p>如果Mixin对象中的选项和组件对象中的选项发生了冲突，Vue会这样处理：</p>\n<ul>\n<li><p>如果data函数的返回值对象与Mixin发生了冲突</p>\n<ul>\n<li>返回值对象默认情况下会进行合并</li>\n<li>如果data的返回值与Mixin发生了冲突，那么会保留组件自身的数据</li>\n</ul>\n</li>\n<li><p>如果与生命周期函数发生冲突</p>\n<ul>\n<li>生命周期钩子函数会被合并到一个数组，并且都会执行</li>\n</ul>\n</li>\n<li><p>值为对象的一个选项，比如methods、components、directives，将会被合并为同一个对象</p>\n<ul>\n<li>比如都有methods选项，并且都定义了方法，那么他们都会生效</li>\n<li>但是如果对象的key相同，那么组件内部的会取代Mixin的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"全局混入Mixin\"><a href=\"#全局混入Mixin\" class=\"headerlink\" title=\"全局混入Mixin\"></a>全局混入Mixin</h3><p>如果我们组件当中，某些选项是所有组件都需要的，这个时候我们可以使用全局Mixin</p>\n<ul>\n<li>全局Mixin可以使用应用app的方法Mixin来完成注册</li>\n<li>一旦注册，那么全局混入的选项将会影响每一个组件</li>\n</ul>\n<h2 id=\"Vue3中的extends\"><a href=\"#Vue3中的extends\" class=\"headerlink\" title=\"Vue3中的extends\"></a>Vue3中的extends</h2><p>另外一个类似于Mixin的方式就是通过extends属性</p>\n<ul>\n<li>允许声明扩展另一个组件，类似于Mixin</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue3中的Mixin与extends\"><a href=\"#Vue3中的Mixin与extends\" class=\"headerlink\" title=\"Vue3中的Mixin与extends\"></a>Vue3中的Mixin与extends</h1><p>组件之间有时候会存在一些相同的代码逻辑，我们此时就需要对相同的代码逻辑进行抽取。</p>\n<p>这个时候我们就可以使用到Mixin这种方式。</p>\n<ul>\n<li>Mixin提供了一种非常灵活的方式，用来分发Vue组件中可复用的功能。</li>\n<li>一个Mixin对象可以包含任何组件选项</li>\n<li>当组件使用Mixin对象时，所有Mixin对象选项将被混入该组件本身的选项当中。</li>\n</ul>\n<h2 id=\"Mixin的基本使用\"><a href=\"#Mixin的基本使用\" class=\"headerlink\" title=\"Mixin的基本使用\"></a>Mixin的基本使用</h2><p><a href=\"https://github.com/zml212/vue3_learn/tree/master/vue_vite_learn/src/17_Mixin%E4%B8%8Eextends%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\">见代码</a></p>\n<h3 id=\"Mixin的合并规则\"><a href=\"#Mixin的合并规则\" class=\"headerlink\" title=\"Mixin的合并规则\"></a>Mixin的合并规则</h3><p>如果Mixin对象中的选项和组件对象中的选项发生了冲突，Vue会这样处理：</p>\n<ul>\n<li><p>如果data函数的返回值对象与Mixin发生了冲突</p>\n<ul>\n<li>返回值对象默认情况下会进行合并</li>\n<li>如果data的返回值与Mixin发生了冲突，那么会保留组件自身的数据</li>\n</ul>\n</li>\n<li><p>如果与生命周期函数发生冲突</p>\n<ul>\n<li>生命周期钩子函数会被合并到一个数组，并且都会执行</li>\n</ul>\n</li>\n<li><p>值为对象的一个选项，比如methods、components、directives，将会被合并为同一个对象</p>\n<ul>\n<li>比如都有methods选项，并且都定义了方法，那么他们都会生效</li>\n<li>但是如果对象的key相同，那么组件内部的会取代Mixin的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"全局混入Mixin\"><a href=\"#全局混入Mixin\" class=\"headerlink\" title=\"全局混入Mixin\"></a>全局混入Mixin</h3><p>如果我们组件当中，某些选项是所有组件都需要的，这个时候我们可以使用全局Mixin</p>\n<ul>\n<li>全局Mixin可以使用应用app的方法Mixin来完成注册</li>\n<li>一旦注册，那么全局混入的选项将会影响每一个组件</li>\n</ul>\n<h2 id=\"Vue3中的extends\"><a href=\"#Vue3中的extends\" class=\"headerlink\" title=\"Vue3中的extends\"></a>Vue3中的extends</h2><p>另外一个类似于Mixin的方式就是通过extends属性</p>\n<ul>\n<li>允许声明扩展另一个组件，类似于Mixin</li>\n</ul>\n"},{"title":"Setup的基本使用","date":"2023-03-21T16:00:00.000Z","_content":"\n# Setup的基本使用\n\nsetup是Vue3中新出现的一个选项，可以用来替代之前所编写的大部分的其他选项，比如methods、computed、watch等等。\n\n## setup函数的参数\n\n主要有两个参数：\n\n- props\n- context\n\n### props参数\n\n父组件传递过来的属性。\n\n### context参数\n\n## setup函数的返回值","source":"_posts/Vue3/Setup.md","raw":"---\ntitle: Setup的基本使用\ndate: [2023-3-22]\ntags: [前端]\ncategories: [Vue3]\n---\n\n# Setup的基本使用\n\nsetup是Vue3中新出现的一个选项，可以用来替代之前所编写的大部分的其他选项，比如methods、computed、watch等等。\n\n## setup函数的参数\n\n主要有两个参数：\n\n- props\n- context\n\n### props参数\n\n父组件传递过来的属性。\n\n### context参数\n\n## setup函数的返回值","slug":"Vue3/Setup","published":1,"updated":"2023-03-22T07:37:43.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmje007g9kbm4xlz3ch3","content":"<h1 id=\"Setup的基本使用\"><a href=\"#Setup的基本使用\" class=\"headerlink\" title=\"Setup的基本使用\"></a>Setup的基本使用</h1><p>setup是Vue3中新出现的一个选项，可以用来替代之前所编写的大部分的其他选项，比如methods、computed、watch等等。</p>\n<h2 id=\"setup函数的参数\"><a href=\"#setup函数的参数\" class=\"headerlink\" title=\"setup函数的参数\"></a>setup函数的参数</h2><p>主要有两个参数：</p>\n<ul>\n<li>props</li>\n<li>context</li>\n</ul>\n<h3 id=\"props参数\"><a href=\"#props参数\" class=\"headerlink\" title=\"props参数\"></a>props参数</h3><p>父组件传递过来的属性。</p>\n<h3 id=\"context参数\"><a href=\"#context参数\" class=\"headerlink\" title=\"context参数\"></a>context参数</h3><h2 id=\"setup函数的返回值\"><a href=\"#setup函数的返回值\" class=\"headerlink\" title=\"setup函数的返回值\"></a>setup函数的返回值</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Setup的基本使用\"><a href=\"#Setup的基本使用\" class=\"headerlink\" title=\"Setup的基本使用\"></a>Setup的基本使用</h1><p>setup是Vue3中新出现的一个选项，可以用来替代之前所编写的大部分的其他选项，比如methods、computed、watch等等。</p>\n<h2 id=\"setup函数的参数\"><a href=\"#setup函数的参数\" class=\"headerlink\" title=\"setup函数的参数\"></a>setup函数的参数</h2><p>主要有两个参数：</p>\n<ul>\n<li>props</li>\n<li>context</li>\n</ul>\n<h3 id=\"props参数\"><a href=\"#props参数\" class=\"headerlink\" title=\"props参数\"></a>props参数</h3><p>父组件传递过来的属性。</p>\n<h3 id=\"context参数\"><a href=\"#context参数\" class=\"headerlink\" title=\"context参数\"></a>context参数</h3><h2 id=\"setup函数的返回值\"><a href=\"#setup函数的返回值\" class=\"headerlink\" title=\"setup函数的返回值\"></a>setup函数的返回值</h2>"},{"title":"Vue3组件化开发（一）","data":["2023-2-20"],"_content":"\n# Vue3组件化开发（一）\n\n## 为什么需要组件化开发\n\n在前端工程化中，流行的框架都是使用的组件化开发模式，这是因为在前端开发逻辑中，有许多重复的代码，我们将这些重复的代码封装进一个组件里面，提高代码的复用性。同时，我们也可以将一些公共的代码抽离出来，这样我们在开发的时候，只需要引入这个组件就可以了，这样就可以减少我们的代码量，同时也可以使得我们的代码更加的简洁。\n\n## Vue3中的组件化开发\n\n### 组件的定义\n\n在vue中，我们页面有很多板块，比如一个企业的官网，里面有导航栏，轮播图，新闻列表，底部等等，我们可以将这些板块封装成一个个的组件，然后在页面中引入这些组件，这样就可以实现页面的复用。\n\n这是Vue官网的一幅图：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc39bc668b74022a6dde247f7d3c306~tplv-k3u1fbpfcp-watermark.image?)\n\n可以看到在一个页面中。可以将页面分成很多板块，比如头部、主体部分、侧边栏、或者还可以有底部。在主题部分又可以有子组件等等。\n\n在Vue中，我们可以将这些板块封装成一个个的组件，然后在页面中引入这些组件，这样就可以实现页面的复用。\n\n### 组件的注册\n\n在Vue中注册有两种方式：\n\n- 全局注册\n- 局部注册\n\n首先我们来全局注册：\n\n首先准备一个要挂载的模板：\n\n```html\n<template id=\"template\">\n<!-- <div>{{msg}}</div> -->\n    <my-component></my-component>\n    <compont-b></compont-b>\n</template>\n```\n\n可以看到里面有两个组件，一个是my-component，一个是compont-b。\n\n接下来就是这两个组件的代码：\n\n```html\n<template id=\"compont-b\">\n    <h1>标题</h1>\n    <h2>{{msg}}</h2>\n</template>\n```\n\n```html\n<template id=\"component\">\n    <h2>我是componted组件</h2>\n</template>\n```\n\n下面我们来注册这两个组件：\n\n第一步：创建一个Vue应用\n\n```js\nconst app = Vue.createApp({\n    template: '#template',\n})\n```\n\n这时候app就是一个Vue的实例，我们可以把这个实例挂载到html中的某个元素上。比如：`<div id=\"app\"></div>`。\n\n第二步：注册组件\n\n```js\nApp.component('my-component',{\n    template: '#component',\n});\nApp.component('compont-b',{\n    template: '#compont-b',\n    data(){\n        return {\n            msg: '我是compont-b组件'\n        }\n    }\n});\n```\n\n注册组件的时候，我们使用的是`component`，这个方法有两个参数，第一个参数是组件的名称，第二个参数是组件的配置。组件名称也就是我们等会在页面中使用的组件名称。\n\n在组件的配置里面我们还可以写data,methods等等，这些都是我们平时写的Vue的配置。\n\n第三步：挂载\n\n```js\nApp.mount('#app');\n```\n\n这段代码表示我们将名为app的Vue实例挂载到id为app的元素上。\n\n\n小知识：\n\n- 定义组件名称组件有两种：\n    - 驼峰命名法：`MyComponent`(仅在脚手架中生效)\n    - 中划线命名法：`my-component`\n\n接下来就是局部注册组件：\n\n全局组件有一个缺点，就是在页面一加载的时候，就会将所有的全局组件进行加载，但是有时候我们并不需要将所有组件都加载出来，这样就会造成性能浪费。\n\n并且使用打包工具进行打包的时候，如果该全局组件没有用到，依然会进行打包。导致文件多余。\n\n所以就出现了局部组件来解决这个问题。\n\n在前面进行全局注册的时候，我们使用的是`App.component`，这个方法是全局注册组件的方法，那么局部注册组件的方法是什么呢？\n\n`components`来定义一个组件，这个方法有一个参数，就是组件的配置。\n\n之前我们vue实例里面有`data`，`methods`等等属性，compoments选项是一个对象，里面的键值对是：`组件名称:组件对象`。\n\n就像这样：\n\n```vue\n    const app = {\n        template: \"#template\",\n        // 注册局部组件\n        components:{\n            // key:value\n            // key:组件名称\n            // value组件对象\n            \"component-a\":{\n                template:\"#component-a\",\n                data: function () {\n                    return {\n                        msg:\"局部\",\n                    }\n                }\n            }\n        }\n    };\n    const App = Vue.createApp(app);\n```\n\n我们在这里注册了一个局部组件，与之前全局注册同的是：全局注册使用的是`App.component`，而局部注册使用的是`components`。也就是在根组件里面使用components选项来注册组件。在里面我们以键值对的形式来注册组件。","source":"_posts/Vue3/Vue3组件化开发（一）.md","raw":"---\ntitle: Vue3组件化开发（一）\ndata: [2023-2-20]\ntags: [前端]\ncategories: [Vue3]\n---\n\n# Vue3组件化开发（一）\n\n## 为什么需要组件化开发\n\n在前端工程化中，流行的框架都是使用的组件化开发模式，这是因为在前端开发逻辑中，有许多重复的代码，我们将这些重复的代码封装进一个组件里面，提高代码的复用性。同时，我们也可以将一些公共的代码抽离出来，这样我们在开发的时候，只需要引入这个组件就可以了，这样就可以减少我们的代码量，同时也可以使得我们的代码更加的简洁。\n\n## Vue3中的组件化开发\n\n### 组件的定义\n\n在vue中，我们页面有很多板块，比如一个企业的官网，里面有导航栏，轮播图，新闻列表，底部等等，我们可以将这些板块封装成一个个的组件，然后在页面中引入这些组件，这样就可以实现页面的复用。\n\n这是Vue官网的一幅图：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc39bc668b74022a6dde247f7d3c306~tplv-k3u1fbpfcp-watermark.image?)\n\n可以看到在一个页面中。可以将页面分成很多板块，比如头部、主体部分、侧边栏、或者还可以有底部。在主题部分又可以有子组件等等。\n\n在Vue中，我们可以将这些板块封装成一个个的组件，然后在页面中引入这些组件，这样就可以实现页面的复用。\n\n### 组件的注册\n\n在Vue中注册有两种方式：\n\n- 全局注册\n- 局部注册\n\n首先我们来全局注册：\n\n首先准备一个要挂载的模板：\n\n```html\n<template id=\"template\">\n<!-- <div>{{msg}}</div> -->\n    <my-component></my-component>\n    <compont-b></compont-b>\n</template>\n```\n\n可以看到里面有两个组件，一个是my-component，一个是compont-b。\n\n接下来就是这两个组件的代码：\n\n```html\n<template id=\"compont-b\">\n    <h1>标题</h1>\n    <h2>{{msg}}</h2>\n</template>\n```\n\n```html\n<template id=\"component\">\n    <h2>我是componted组件</h2>\n</template>\n```\n\n下面我们来注册这两个组件：\n\n第一步：创建一个Vue应用\n\n```js\nconst app = Vue.createApp({\n    template: '#template',\n})\n```\n\n这时候app就是一个Vue的实例，我们可以把这个实例挂载到html中的某个元素上。比如：`<div id=\"app\"></div>`。\n\n第二步：注册组件\n\n```js\nApp.component('my-component',{\n    template: '#component',\n});\nApp.component('compont-b',{\n    template: '#compont-b',\n    data(){\n        return {\n            msg: '我是compont-b组件'\n        }\n    }\n});\n```\n\n注册组件的时候，我们使用的是`component`，这个方法有两个参数，第一个参数是组件的名称，第二个参数是组件的配置。组件名称也就是我们等会在页面中使用的组件名称。\n\n在组件的配置里面我们还可以写data,methods等等，这些都是我们平时写的Vue的配置。\n\n第三步：挂载\n\n```js\nApp.mount('#app');\n```\n\n这段代码表示我们将名为app的Vue实例挂载到id为app的元素上。\n\n\n小知识：\n\n- 定义组件名称组件有两种：\n    - 驼峰命名法：`MyComponent`(仅在脚手架中生效)\n    - 中划线命名法：`my-component`\n\n接下来就是局部注册组件：\n\n全局组件有一个缺点，就是在页面一加载的时候，就会将所有的全局组件进行加载，但是有时候我们并不需要将所有组件都加载出来，这样就会造成性能浪费。\n\n并且使用打包工具进行打包的时候，如果该全局组件没有用到，依然会进行打包。导致文件多余。\n\n所以就出现了局部组件来解决这个问题。\n\n在前面进行全局注册的时候，我们使用的是`App.component`，这个方法是全局注册组件的方法，那么局部注册组件的方法是什么呢？\n\n`components`来定义一个组件，这个方法有一个参数，就是组件的配置。\n\n之前我们vue实例里面有`data`，`methods`等等属性，compoments选项是一个对象，里面的键值对是：`组件名称:组件对象`。\n\n就像这样：\n\n```vue\n    const app = {\n        template: \"#template\",\n        // 注册局部组件\n        components:{\n            // key:value\n            // key:组件名称\n            // value组件对象\n            \"component-a\":{\n                template:\"#component-a\",\n                data: function () {\n                    return {\n                        msg:\"局部\",\n                    }\n                }\n            }\n        }\n    };\n    const App = Vue.createApp(app);\n```\n\n我们在这里注册了一个局部组件，与之前全局注册同的是：全局注册使用的是`App.component`，而局部注册使用的是`components`。也就是在根组件里面使用components选项来注册组件。在里面我们以键值对的形式来注册组件。","slug":"Vue3/Vue3组件化开发（一）","published":1,"date":"2023-02-20T02:05:14.903Z","updated":"2023-02-21T01:00:31.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjg007j9kbmh0yy5q5g","content":"<h1 id=\"Vue3组件化开发（一）\"><a href=\"#Vue3组件化开发（一）\" class=\"headerlink\" title=\"Vue3组件化开发（一）\"></a>Vue3组件化开发（一）</h1><h2 id=\"为什么需要组件化开发\"><a href=\"#为什么需要组件化开发\" class=\"headerlink\" title=\"为什么需要组件化开发\"></a>为什么需要组件化开发</h2><p>在前端工程化中，流行的框架都是使用的组件化开发模式，这是因为在前端开发逻辑中，有许多重复的代码，我们将这些重复的代码封装进一个组件里面，提高代码的复用性。同时，我们也可以将一些公共的代码抽离出来，这样我们在开发的时候，只需要引入这个组件就可以了，这样就可以减少我们的代码量，同时也可以使得我们的代码更加的简洁。</p>\n<h2 id=\"Vue3中的组件化开发\"><a href=\"#Vue3中的组件化开发\" class=\"headerlink\" title=\"Vue3中的组件化开发\"></a>Vue3中的组件化开发</h2><h3 id=\"组件的定义\"><a href=\"#组件的定义\" class=\"headerlink\" title=\"组件的定义\"></a>组件的定义</h3><p>在vue中，我们页面有很多板块，比如一个企业的官网，里面有导航栏，轮播图，新闻列表，底部等等，我们可以将这些板块封装成一个个的组件，然后在页面中引入这些组件，这样就可以实现页面的复用。</p>\n<p>这是Vue官网的一幅图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc39bc668b74022a6dde247f7d3c306~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>可以看到在一个页面中。可以将页面分成很多板块，比如头部、主体部分、侧边栏、或者还可以有底部。在主题部分又可以有子组件等等。</p>\n<p>在Vue中，我们可以将这些板块封装成一个个的组件，然后在页面中引入这些组件，这样就可以实现页面的复用。</p>\n<h3 id=\"组件的注册\"><a href=\"#组件的注册\" class=\"headerlink\" title=\"组件的注册\"></a>组件的注册</h3><p>在Vue中注册有两种方式：</p>\n<ul>\n<li>全局注册</li>\n<li>局部注册</li>\n</ul>\n<p>首先我们来全局注册：</p>\n<p>首先准备一个要挂载的模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;template&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">compont-b</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">compont-b</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到里面有两个组件，一个是my-component，一个是compont-b。</p>\n<p>接下来就是这两个组件的代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;compont-b&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;component&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是componted组件<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面我们来注册这两个组件：</p>\n<p>第一步：创建一个Vue应用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"title class_\">Vue</span>.<span class=\"title function_\">createApp</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">template</span>: <span class=\"string\">&#x27;#template&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这时候app就是一个Vue的实例，我们可以把这个实例挂载到html中的某个元素上。比如：<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>。</p>\n<p>第二步：注册组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">App</span>.<span class=\"title function_\">component</span>(<span class=\"string\">&#x27;my-component&#x27;</span>,&#123;</span><br><span class=\"line\">    <span class=\"attr\">template</span>: <span class=\"string\">&#x27;#component&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"title class_\">App</span>.<span class=\"title function_\">component</span>(<span class=\"string\">&#x27;compont-b&#x27;</span>,&#123;</span><br><span class=\"line\">    <span class=\"attr\">template</span>: <span class=\"string\">&#x27;#compont-b&#x27;</span>,</span><br><span class=\"line\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;我是compont-b组件&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>注册组件的时候，我们使用的是<code>component</code>，这个方法有两个参数，第一个参数是组件的名称，第二个参数是组件的配置。组件名称也就是我们等会在页面中使用的组件名称。</p>\n<p>在组件的配置里面我们还可以写data,methods等等，这些都是我们平时写的Vue的配置。</p>\n<p>第三步：挂载</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">App</span>.<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码表示我们将名为app的Vue实例挂载到id为app的元素上。</p>\n<p>小知识：</p>\n<ul>\n<li>定义组件名称组件有两种：<ul>\n<li>驼峰命名法：<code>MyComponent</code>(仅在脚手架中生效)</li>\n<li>中划线命名法：<code>my-component</code></li>\n</ul>\n</li>\n</ul>\n<p>接下来就是局部注册组件：</p>\n<p>全局组件有一个缺点，就是在页面一加载的时候，就会将所有的全局组件进行加载，但是有时候我们并不需要将所有组件都加载出来，这样就会造成性能浪费。</p>\n<p>并且使用打包工具进行打包的时候，如果该全局组件没有用到，依然会进行打包。导致文件多余。</p>\n<p>所以就出现了局部组件来解决这个问题。</p>\n<p>在前面进行全局注册的时候，我们使用的是<code>App.component</code>，这个方法是全局注册组件的方法，那么局部注册组件的方法是什么呢？</p>\n<p><code>components</code>来定义一个组件，这个方法有一个参数，就是组件的配置。</p>\n<p>之前我们vue实例里面有<code>data</code>，<code>methods</code>等等属性，compoments选项是一个对象，里面的键值对是：<code>组件名称:组件对象</code>。</p>\n<p>就像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const app = &#123;</span><br><span class=\"line\">    template: &quot;#template&quot;,</span><br><span class=\"line\">    // 注册局部组件</span><br><span class=\"line\">    components:&#123;</span><br><span class=\"line\">        // key:value</span><br><span class=\"line\">        // key:组件名称</span><br><span class=\"line\">        // value组件对象</span><br><span class=\"line\">        &quot;component-a&quot;:&#123;</span><br><span class=\"line\">            template:&quot;#component-a&quot;,</span><br><span class=\"line\">            data: function () &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    msg:&quot;局部&quot;,</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const App = Vue.createApp(app);</span><br></pre></td></tr></table></figure>\n\n<p>我们在这里注册了一个局部组件，与之前全局注册同的是：全局注册使用的是<code>App.component</code>，而局部注册使用的是<code>components</code>。也就是在根组件里面使用components选项来注册组件。在里面我们以键值对的形式来注册组件。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue3组件化开发（一）\"><a href=\"#Vue3组件化开发（一）\" class=\"headerlink\" title=\"Vue3组件化开发（一）\"></a>Vue3组件化开发（一）</h1><h2 id=\"为什么需要组件化开发\"><a href=\"#为什么需要组件化开发\" class=\"headerlink\" title=\"为什么需要组件化开发\"></a>为什么需要组件化开发</h2><p>在前端工程化中，流行的框架都是使用的组件化开发模式，这是因为在前端开发逻辑中，有许多重复的代码，我们将这些重复的代码封装进一个组件里面，提高代码的复用性。同时，我们也可以将一些公共的代码抽离出来，这样我们在开发的时候，只需要引入这个组件就可以了，这样就可以减少我们的代码量，同时也可以使得我们的代码更加的简洁。</p>\n<h2 id=\"Vue3中的组件化开发\"><a href=\"#Vue3中的组件化开发\" class=\"headerlink\" title=\"Vue3中的组件化开发\"></a>Vue3中的组件化开发</h2><h3 id=\"组件的定义\"><a href=\"#组件的定义\" class=\"headerlink\" title=\"组件的定义\"></a>组件的定义</h3><p>在vue中，我们页面有很多板块，比如一个企业的官网，里面有导航栏，轮播图，新闻列表，底部等等，我们可以将这些板块封装成一个个的组件，然后在页面中引入这些组件，这样就可以实现页面的复用。</p>\n<p>这是Vue官网的一幅图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdc39bc668b74022a6dde247f7d3c306~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>可以看到在一个页面中。可以将页面分成很多板块，比如头部、主体部分、侧边栏、或者还可以有底部。在主题部分又可以有子组件等等。</p>\n<p>在Vue中，我们可以将这些板块封装成一个个的组件，然后在页面中引入这些组件，这样就可以实现页面的复用。</p>\n<h3 id=\"组件的注册\"><a href=\"#组件的注册\" class=\"headerlink\" title=\"组件的注册\"></a>组件的注册</h3><p>在Vue中注册有两种方式：</p>\n<ul>\n<li>全局注册</li>\n<li>局部注册</li>\n</ul>\n<p>首先我们来全局注册：</p>\n<p>首先准备一个要挂载的模板：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;template&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">compont-b</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">compont-b</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到里面有两个组件，一个是my-component，一个是compont-b。</p>\n<p>接下来就是这两个组件的代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;compont-b&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;component&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是componted组件<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>下面我们来注册这两个组件：</p>\n<p>第一步：创建一个Vue应用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"title class_\">Vue</span>.<span class=\"title function_\">createApp</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">template</span>: <span class=\"string\">&#x27;#template&#x27;</span>,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这时候app就是一个Vue的实例，我们可以把这个实例挂载到html中的某个元素上。比如：<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>。</p>\n<p>第二步：注册组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">App</span>.<span class=\"title function_\">component</span>(<span class=\"string\">&#x27;my-component&#x27;</span>,&#123;</span><br><span class=\"line\">    <span class=\"attr\">template</span>: <span class=\"string\">&#x27;#component&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"title class_\">App</span>.<span class=\"title function_\">component</span>(<span class=\"string\">&#x27;compont-b&#x27;</span>,&#123;</span><br><span class=\"line\">    <span class=\"attr\">template</span>: <span class=\"string\">&#x27;#compont-b&#x27;</span>,</span><br><span class=\"line\">    <span class=\"title function_\">data</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;我是compont-b组件&#x27;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>注册组件的时候，我们使用的是<code>component</code>，这个方法有两个参数，第一个参数是组件的名称，第二个参数是组件的配置。组件名称也就是我们等会在页面中使用的组件名称。</p>\n<p>在组件的配置里面我们还可以写data,methods等等，这些都是我们平时写的Vue的配置。</p>\n<p>第三步：挂载</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">App</span>.<span class=\"title function_\">mount</span>(<span class=\"string\">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码表示我们将名为app的Vue实例挂载到id为app的元素上。</p>\n<p>小知识：</p>\n<ul>\n<li>定义组件名称组件有两种：<ul>\n<li>驼峰命名法：<code>MyComponent</code>(仅在脚手架中生效)</li>\n<li>中划线命名法：<code>my-component</code></li>\n</ul>\n</li>\n</ul>\n<p>接下来就是局部注册组件：</p>\n<p>全局组件有一个缺点，就是在页面一加载的时候，就会将所有的全局组件进行加载，但是有时候我们并不需要将所有组件都加载出来，这样就会造成性能浪费。</p>\n<p>并且使用打包工具进行打包的时候，如果该全局组件没有用到，依然会进行打包。导致文件多余。</p>\n<p>所以就出现了局部组件来解决这个问题。</p>\n<p>在前面进行全局注册的时候，我们使用的是<code>App.component</code>，这个方法是全局注册组件的方法，那么局部注册组件的方法是什么呢？</p>\n<p><code>components</code>来定义一个组件，这个方法有一个参数，就是组件的配置。</p>\n<p>之前我们vue实例里面有<code>data</code>，<code>methods</code>等等属性，compoments选项是一个对象，里面的键值对是：<code>组件名称:组件对象</code>。</p>\n<p>就像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const app = &#123;</span><br><span class=\"line\">    template: &quot;#template&quot;,</span><br><span class=\"line\">    // 注册局部组件</span><br><span class=\"line\">    components:&#123;</span><br><span class=\"line\">        // key:value</span><br><span class=\"line\">        // key:组件名称</span><br><span class=\"line\">        // value组件对象</span><br><span class=\"line\">        &quot;component-a&quot;:&#123;</span><br><span class=\"line\">            template:&quot;#component-a&quot;,</span><br><span class=\"line\">            data: function () &#123;</span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    msg:&quot;局部&quot;,</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const App = Vue.createApp(app);</span><br></pre></td></tr></table></figure>\n\n<p>我们在这里注册了一个局部组件，与之前全局注册同的是：全局注册使用的是<code>App.component</code>，而局部注册使用的是<code>components</code>。也就是在根组件里面使用components选项来注册组件。在里面我们以键值对的形式来注册组件。</p>\n"},{"title":"Vue3中的过渡动画","data":["2023-3-13"],"_content":"\n# Vue3中的过渡动画效果\n\n在日常网页的开发中，难免会有一些动画的交互效果。\n\n首先我们将要有动画效果的盒子使用`transition`标签包裹起来，然后给这个标签给予一个`name`属性，这个属性我们在后面css的类名中会用到。\n\n比如：\n\n```html\n<transition name=\"hmbb\">\n<div v-if=\"isTrue\" class=\"style\">我是组件的内容</div>\n</transition>\n```\n\n这就是一个用`transition`标签包裹起来的盒子，我们给其name属性赋值为`hmbb`。\n\n这个时候我们就可以在`style`标签里面给这个盒子设置相应的动画样式了。\n\n在vue3中，有这样几个状态：\n\n- v-enter-from：定义组件进入过渡的开始状态，在元素被插入之前生效，在元素插入后的下一帧失效。\n- v-enter-acticve：定义过渡生效时的状态，在整个过渡阶段中应用，在元素插入之前生效，在过渡动画效果完成后移除，在这里面我们可以定义一些过渡的效果，延迟以及速度变化的曲线。\n- v-enter-to：组件过渡开始\n- v-leave-from\n- v-leave-active\n- v-leave-to\n\n","source":"_posts/Vue3/Vue3中的动画.md","raw":"---\ntitle: Vue3中的过渡动画\ndata: [2023-3-13]\ntags: [前端]\ncategories: [Vue3]\n---\n\n# Vue3中的过渡动画效果\n\n在日常网页的开发中，难免会有一些动画的交互效果。\n\n首先我们将要有动画效果的盒子使用`transition`标签包裹起来，然后给这个标签给予一个`name`属性，这个属性我们在后面css的类名中会用到。\n\n比如：\n\n```html\n<transition name=\"hmbb\">\n<div v-if=\"isTrue\" class=\"style\">我是组件的内容</div>\n</transition>\n```\n\n这就是一个用`transition`标签包裹起来的盒子，我们给其name属性赋值为`hmbb`。\n\n这个时候我们就可以在`style`标签里面给这个盒子设置相应的动画样式了。\n\n在vue3中，有这样几个状态：\n\n- v-enter-from：定义组件进入过渡的开始状态，在元素被插入之前生效，在元素插入后的下一帧失效。\n- v-enter-acticve：定义过渡生效时的状态，在整个过渡阶段中应用，在元素插入之前生效，在过渡动画效果完成后移除，在这里面我们可以定义一些过渡的效果，延迟以及速度变化的曲线。\n- v-enter-to：组件过渡开始\n- v-leave-from\n- v-leave-active\n- v-leave-to\n\n","slug":"Vue3/Vue3中的动画","published":1,"date":"2023-03-13T11:01:46.806Z","updated":"2023-03-13T11:15:28.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjh007n9kbmak0ndok8","content":"<h1 id=\"Vue3中的过渡动画效果\"><a href=\"#Vue3中的过渡动画效果\" class=\"headerlink\" title=\"Vue3中的过渡动画效果\"></a>Vue3中的过渡动画效果</h1><p>在日常网页的开发中，难免会有一些动画的交互效果。</p>\n<p>首先我们将要有动画效果的盒子使用<code>transition</code>标签包裹起来，然后给这个标签给予一个<code>name</code>属性，这个属性我们在后面css的类名中会用到。</p>\n<p>比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hmbb&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;isTrue&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;style&quot;</span>&gt;</span>我是组件的内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个用<code>transition</code>标签包裹起来的盒子，我们给其name属性赋值为<code>hmbb</code>。</p>\n<p>这个时候我们就可以在<code>style</code>标签里面给这个盒子设置相应的动画样式了。</p>\n<p>在vue3中，有这样几个状态：</p>\n<ul>\n<li>v-enter-from：定义组件进入过渡的开始状态，在元素被插入之前生效，在元素插入后的下一帧失效。</li>\n<li>v-enter-acticve：定义过渡生效时的状态，在整个过渡阶段中应用，在元素插入之前生效，在过渡动画效果完成后移除，在这里面我们可以定义一些过渡的效果，延迟以及速度变化的曲线。</li>\n<li>v-enter-to：组件过渡开始</li>\n<li>v-leave-from</li>\n<li>v-leave-active</li>\n<li>v-leave-to</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue3中的过渡动画效果\"><a href=\"#Vue3中的过渡动画效果\" class=\"headerlink\" title=\"Vue3中的过渡动画效果\"></a>Vue3中的过渡动画效果</h1><p>在日常网页的开发中，难免会有一些动画的交互效果。</p>\n<p>首先我们将要有动画效果的盒子使用<code>transition</code>标签包裹起来，然后给这个标签给予一个<code>name</code>属性，这个属性我们在后面css的类名中会用到。</p>\n<p>比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hmbb&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;isTrue&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;style&quot;</span>&gt;</span>我是组件的内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个用<code>transition</code>标签包裹起来的盒子，我们给其name属性赋值为<code>hmbb</code>。</p>\n<p>这个时候我们就可以在<code>style</code>标签里面给这个盒子设置相应的动画样式了。</p>\n<p>在vue3中，有这样几个状态：</p>\n<ul>\n<li>v-enter-from：定义组件进入过渡的开始状态，在元素被插入之前生效，在元素插入后的下一帧失效。</li>\n<li>v-enter-acticve：定义过渡生效时的状态，在整个过渡阶段中应用，在元素插入之前生效，在过渡动画效果完成后移除，在这里面我们可以定义一些过渡的效果，延迟以及速度变化的曲线。</li>\n<li>v-enter-to：组件过渡开始</li>\n<li>v-leave-from</li>\n<li>v-leave-active</li>\n<li>v-leave-to</li>\n</ul>\n"},{"title":"Vue中的插槽","data":["2023-2-28"],"_content":"\n# Vue中的插槽\n\n在Vue的开发中，我们对于某一个组件，其中某个位置所摆放的元素是什么，是充满不确定性的。比如在手机购物软件中，我们顶部的导航栏，可以分为三个部分，比如左侧部分，右侧部分。\n\n但是我们不知道这个左侧部分和右侧部分的内容是什么，这个时候我们就可以使用插槽来解决这个问题。\n\n## 插槽的基本使用\n\n在Vue中，我们定义插槽使用的是`slot`。\n\n```html\n<template>\n  <div>\n    <h2>我是组件开始</h2>\n    <slot></slot>\n    <h2>我是组件结束</h2>\n  </div>\n</template>\n```\n\n这就是一个很简单的插槽组件，我们暂时命名这个组件为`MySlot`。在定义好这个组件之后，我们需要将这个组件注册到Vue中。\n\n就像这样：\n\n```js\nimport MySlot from \"./MySlot.vue\";\n\nexport default {\n  name: \"app\",\n  components: {\n    MySlot,\n  },\n};\n```\n\n我们这里将插槽组件进行局部注册之后，我们就可以在`app`组件里面使用这个插槽组件了。\n\n```html\n<template>\n  <my-slot>\n    <button>按钮</button>\n  </my-slot>\n  <my-slot>\n    <h5>我是文本</h5>\n    <button>按钮2</button>\n  </my-slot>\n</template>\n```\n\n在使用的时候，我们将注册的组件写到`app`的模板里面，然后我们这个组件里面写上自己需要放进去的内容，内容可以写按钮，文本框等等一些元素。包括其他一些组件。\n\n以上就是插槽的一些基本使用方法。\n\n## 具名插槽的使用\n\n在前面的示例中，我们插槽组件只有一个插槽，如果某个插槽组件包含多个插槽，那我们使用的时候就需要使用具名插槽。\n\n首先具名插槽，需要在插槽组件中进行定义（给每个插槽加上属于他们自己的名字），就像这样：\n\n```html\n// name : NavBar\n<template>\n  <div class=\"nav-bar\">\n    <div class=\"left\">\n      <slot name=\"left\"></slot>\n    </div>\n    <div class=\"center\">\n      <slot name=\"center\"></slot>\n    </div>\n    <div class=\"right\">\n      <slot name=\"right\"></slot>\n    </div>\n  </div>\n</template>\n```\n\n上面我们定义了三个插槽,我们分别命名为`left`，`center`，`right`。\n\n然后将这个组件在app组件里面注册，我们就开始使用这个插槽：\n\n```html\n<template>\n  <nav-bar>\n    <template v-slot:left>\n      <button>左边按钮</button>\n    </template>\n    <template v-slot:center>\n      <div>中间文字</div>\n    </template>\n    <template v-slot:right>\n      <li>列表</li>\n    </template>\n  </nav-bar>\n</template>\n```\n\n在使用具名插槽的时候，我们需要将插槽的名字写在`v-slot`里面，然后我们需要将每个插槽的东西写在对应的`template`里面。\n\n## 作用域插槽\n\nVue.js 中的作用域插槽（scoped slot）是一种特殊类型的插槽，它允许组件在其插槽内部访问来自父组件作用域中的数据。通过作用域插槽，子组件可以使用父组件的数据来自定义渲染逻辑，从而实现更高级别的组件复用和封装。\n\n在 Vue.js 中，通常使用 <slot> 标签在组件模板中定义插槽，例如：\n\n```html\n<!-- 子组件模板 -->\n<template>\n  <div>\n    <h2>{{ title }}</h2>\n    <slot></slot>\n  </div>\n</template>\n```\n\n然后，在父组件中，可以通过在 <template> 标签内使用 <slot> 标签来插入内容，并使用 v-slot 指令来定义作用域插槽，例如：\n\n```html\n<!-- 父组件模板 -->\n<template>\n  <div>\n    <my-component>\n      <template v-slot:default>\n        <p>{{ message }}</p>\n      </template>\n    </my-component>\n  </div>\n</template>\n```\n\n","source":"_posts/Vue3/Vue中的插槽.md","raw":"---\ntitle: Vue中的插槽\ndata: [2023-2-28]\ntags: [前端]\ncategories: [Vue]\n---\n\n# Vue中的插槽\n\n在Vue的开发中，我们对于某一个组件，其中某个位置所摆放的元素是什么，是充满不确定性的。比如在手机购物软件中，我们顶部的导航栏，可以分为三个部分，比如左侧部分，右侧部分。\n\n但是我们不知道这个左侧部分和右侧部分的内容是什么，这个时候我们就可以使用插槽来解决这个问题。\n\n## 插槽的基本使用\n\n在Vue中，我们定义插槽使用的是`slot`。\n\n```html\n<template>\n  <div>\n    <h2>我是组件开始</h2>\n    <slot></slot>\n    <h2>我是组件结束</h2>\n  </div>\n</template>\n```\n\n这就是一个很简单的插槽组件，我们暂时命名这个组件为`MySlot`。在定义好这个组件之后，我们需要将这个组件注册到Vue中。\n\n就像这样：\n\n```js\nimport MySlot from \"./MySlot.vue\";\n\nexport default {\n  name: \"app\",\n  components: {\n    MySlot,\n  },\n};\n```\n\n我们这里将插槽组件进行局部注册之后，我们就可以在`app`组件里面使用这个插槽组件了。\n\n```html\n<template>\n  <my-slot>\n    <button>按钮</button>\n  </my-slot>\n  <my-slot>\n    <h5>我是文本</h5>\n    <button>按钮2</button>\n  </my-slot>\n</template>\n```\n\n在使用的时候，我们将注册的组件写到`app`的模板里面，然后我们这个组件里面写上自己需要放进去的内容，内容可以写按钮，文本框等等一些元素。包括其他一些组件。\n\n以上就是插槽的一些基本使用方法。\n\n## 具名插槽的使用\n\n在前面的示例中，我们插槽组件只有一个插槽，如果某个插槽组件包含多个插槽，那我们使用的时候就需要使用具名插槽。\n\n首先具名插槽，需要在插槽组件中进行定义（给每个插槽加上属于他们自己的名字），就像这样：\n\n```html\n// name : NavBar\n<template>\n  <div class=\"nav-bar\">\n    <div class=\"left\">\n      <slot name=\"left\"></slot>\n    </div>\n    <div class=\"center\">\n      <slot name=\"center\"></slot>\n    </div>\n    <div class=\"right\">\n      <slot name=\"right\"></slot>\n    </div>\n  </div>\n</template>\n```\n\n上面我们定义了三个插槽,我们分别命名为`left`，`center`，`right`。\n\n然后将这个组件在app组件里面注册，我们就开始使用这个插槽：\n\n```html\n<template>\n  <nav-bar>\n    <template v-slot:left>\n      <button>左边按钮</button>\n    </template>\n    <template v-slot:center>\n      <div>中间文字</div>\n    </template>\n    <template v-slot:right>\n      <li>列表</li>\n    </template>\n  </nav-bar>\n</template>\n```\n\n在使用具名插槽的时候，我们需要将插槽的名字写在`v-slot`里面，然后我们需要将每个插槽的东西写在对应的`template`里面。\n\n## 作用域插槽\n\nVue.js 中的作用域插槽（scoped slot）是一种特殊类型的插槽，它允许组件在其插槽内部访问来自父组件作用域中的数据。通过作用域插槽，子组件可以使用父组件的数据来自定义渲染逻辑，从而实现更高级别的组件复用和封装。\n\n在 Vue.js 中，通常使用 <slot> 标签在组件模板中定义插槽，例如：\n\n```html\n<!-- 子组件模板 -->\n<template>\n  <div>\n    <h2>{{ title }}</h2>\n    <slot></slot>\n  </div>\n</template>\n```\n\n然后，在父组件中，可以通过在 <template> 标签内使用 <slot> 标签来插入内容，并使用 v-slot 指令来定义作用域插槽，例如：\n\n```html\n<!-- 父组件模板 -->\n<template>\n  <div>\n    <my-component>\n      <template v-slot:default>\n        <p>{{ message }}</p>\n      </template>\n    </my-component>\n  </div>\n</template>\n```\n\n","slug":"Vue3/Vue中的插槽","published":1,"date":"2023-02-28T09:15:34.354Z","updated":"2023-02-28T13:03:27.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmji007q9kbmfotj5p8g","content":"<h1 id=\"Vue中的插槽\"><a href=\"#Vue中的插槽\" class=\"headerlink\" title=\"Vue中的插槽\"></a>Vue中的插槽</h1><p>在Vue的开发中，我们对于某一个组件，其中某个位置所摆放的元素是什么，是充满不确定性的。比如在手机购物软件中，我们顶部的导航栏，可以分为三个部分，比如左侧部分，右侧部分。</p>\n<p>但是我们不知道这个左侧部分和右侧部分的内容是什么，这个时候我们就可以使用插槽来解决这个问题。</p>\n<h2 id=\"插槽的基本使用\"><a href=\"#插槽的基本使用\" class=\"headerlink\" title=\"插槽的基本使用\"></a>插槽的基本使用</h2><p>在Vue中，我们定义插槽使用的是<code>slot</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是组件开始<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是组件结束<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个很简单的插槽组件，我们暂时命名这个组件为<code>MySlot</code>。在定义好这个组件之后，我们需要将这个组件注册到Vue中。</p>\n<p>就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">MySlot</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MySlot.vue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;app&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">components</span>: &#123;</span><br><span class=\"line\">    <span class=\"title class_\">MySlot</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里将插槽组件进行局部注册之后，我们就可以在<code>app</code>组件里面使用这个插槽组件了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">my-slot</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>我是文本<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>按钮2<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">my-slot</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在使用的时候，我们将注册的组件写到<code>app</code>的模板里面，然后我们这个组件里面写上自己需要放进去的内容，内容可以写按钮，文本框等等一些元素。包括其他一些组件。</p>\n<p>以上就是插槽的一些基本使用方法。</p>\n<h2 id=\"具名插槽的使用\"><a href=\"#具名插槽的使用\" class=\"headerlink\" title=\"具名插槽的使用\"></a>具名插槽的使用</h2><p>在前面的示例中，我们插槽组件只有一个插槽，如果某个插槽组件包含多个插槽，那我们使用的时候就需要使用具名插槽。</p>\n<p>首先具名插槽，需要在插槽组件中进行定义（给每个插槽加上属于他们自己的名字），就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// name : NavBar</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;nav-bar&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;left&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;left&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;center&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;center&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;right&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;right&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面我们定义了三个插槽,我们分别命名为<code>left</code>，<code>center</code>，<code>right</code>。</p>\n<p>然后将这个组件在app组件里面注册，我们就开始使用这个插槽：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav-bar</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:left</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>左边按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:center</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>中间文字<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:right</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav-bar</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在使用具名插槽的时候，我们需要将插槽的名字写在<code>v-slot</code>里面，然后我们需要将每个插槽的东西写在对应的<code>template</code>里面。</p>\n<h2 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h2><p>Vue.js 中的作用域插槽（scoped slot）是一种特殊类型的插槽，它允许组件在其插槽内部访问来自父组件作用域中的数据。通过作用域插槽，子组件可以使用父组件的数据来自定义渲染逻辑，从而实现更高级别的组件复用和封装。</p>\n<p>在 Vue.js 中，通常使用 <slot> 标签在组件模板中定义插槽，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 子组件模板 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后，在父组件中，可以通过在 <template> 标签内使用 <slot> 标签来插入内容，并使用 v-slot 指令来定义作用域插槽，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 父组件模板 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:default</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue中的插槽\"><a href=\"#Vue中的插槽\" class=\"headerlink\" title=\"Vue中的插槽\"></a>Vue中的插槽</h1><p>在Vue的开发中，我们对于某一个组件，其中某个位置所摆放的元素是什么，是充满不确定性的。比如在手机购物软件中，我们顶部的导航栏，可以分为三个部分，比如左侧部分，右侧部分。</p>\n<p>但是我们不知道这个左侧部分和右侧部分的内容是什么，这个时候我们就可以使用插槽来解决这个问题。</p>\n<h2 id=\"插槽的基本使用\"><a href=\"#插槽的基本使用\" class=\"headerlink\" title=\"插槽的基本使用\"></a>插槽的基本使用</h2><p>在Vue中，我们定义插槽使用的是<code>slot</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是组件开始<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是组件结束<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这就是一个很简单的插槽组件，我们暂时命名这个组件为<code>MySlot</code>。在定义好这个组件之后，我们需要将这个组件注册到Vue中。</p>\n<p>就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">MySlot</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MySlot.vue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;app&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">components</span>: &#123;</span><br><span class=\"line\">    <span class=\"title class_\">MySlot</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们这里将插槽组件进行局部注册之后，我们就可以在<code>app</code>组件里面使用这个插槽组件了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">my-slot</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">my-slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>我是文本<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>按钮2<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">my-slot</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在使用的时候，我们将注册的组件写到<code>app</code>的模板里面，然后我们这个组件里面写上自己需要放进去的内容，内容可以写按钮，文本框等等一些元素。包括其他一些组件。</p>\n<p>以上就是插槽的一些基本使用方法。</p>\n<h2 id=\"具名插槽的使用\"><a href=\"#具名插槽的使用\" class=\"headerlink\" title=\"具名插槽的使用\"></a>具名插槽的使用</h2><p>在前面的示例中，我们插槽组件只有一个插槽，如果某个插槽组件包含多个插槽，那我们使用的时候就需要使用具名插槽。</p>\n<p>首先具名插槽，需要在插槽组件中进行定义（给每个插槽加上属于他们自己的名字），就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// name : NavBar</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;nav-bar&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;left&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;left&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;center&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;center&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;right&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;right&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面我们定义了三个插槽,我们分别命名为<code>left</code>，<code>center</code>，<code>right</code>。</p>\n<p>然后将这个组件在app组件里面注册，我们就开始使用这个插槽：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">nav-bar</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:left</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span>左边按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:center</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>中间文字<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:right</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav-bar</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在使用具名插槽的时候，我们需要将插槽的名字写在<code>v-slot</code>里面，然后我们需要将每个插槽的东西写在对应的<code>template</code>里面。</p>\n<h2 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h2><p>Vue.js 中的作用域插槽（scoped slot）是一种特殊类型的插槽，它允许组件在其插槽内部访问来自父组件作用域中的数据。通过作用域插槽，子组件可以使用父组件的数据来自定义渲染逻辑，从而实现更高级别的组件复用和封装。</p>\n<p>在 Vue.js 中，通常使用 <slot> 标签在组件模板中定义插槽，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 子组件模板 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后，在父组件中，可以通过在 <template> 标签内使用 <slot> 标签来插入内容，并使用 v-slot 指令来定义作用域插槽，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 父组件模板 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:default</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Vue3的Options-API","data":"2023-1-26","_content":"\n# Vue3的Options-API\n\n\n[TOC]\n\n## 计算属性\n\n在模板当中，我们可以使用插值语`{{}}`法来显示data里面的一些数据\n\n但是在某些情况下，我么可能需要将数据进行一些转化之后再显示，或者将多个数据结合起来进行显示\n\n- 比如我们需要将多个data数据进行运算、三元运算符来决定结果、数据进行某种转化之后显示\n- 在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算，在模板中放入太多的逻辑毁容模板显得臃肿不堪且难以维护，并且如果要在多个地方都使用，这样会有大量重复的代码。\n\n解决办法：\n\n1. 将逻辑抽离到methods当中，放到methods里面的options里面，但是这样有一个弊端，所有的data数据的使用过程都变成了方法的调用\n2. 可以使用计算属性computed。\n\n### 什么是计算属性\n\n官方：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性，计算属性将被混入到组件实例中，所有的getter和setter的this上下文自动绑定为组件实例。\n\n**计算属性的用法：**\n\n选项： compted\n类型： { [key: string]: Function | { get: Function, set: Function } }\n\n例子：\n\n```js\ncomputed: {\n    getName: function () {\n        return this.firstName + this.lastName;\n    },\n    getResult: function () {\n        return this.score >= 60 ? '及格' : '不及格';\n    },\n    getMsg: function () {\n        return this.message.split(\"\").reverse().join('');\n    }\n}\n```\n\n这就是计算属性，这里我们使用的是函数的方式，注意：计算属性看起来是一个函数，但是我们在使用的时候并不需要加上`()`,而是直接使用属性的方式来使用。并且计算属性有缓存，这些函数只会执行一次，除非依赖的响应式数据发生了变化。\n\n计算属性与模板语法，计算属性与methods的区别，代码在这里：1.[模板语法](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/01_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95.html)    2.[methods](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/02_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_methods.html)   3.[计算属性](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/03_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_computed.html)\n\n当计算属性所依赖的数据发生改变的时候，计算属性会重新计算。\n\n### 计算属性的getter与setter\n\n计算属性大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。也就是当我们把计算属性里面写成函数的形式，就代表我们使用的计算属性的getter方法。\n\n## 侦听器watch\n\n在开发当中，我们data中返回的对象当中定义了数据，这个数据通过插值语法等方式绑定到template当中，当数据发生变化的时候，template会自动更新来显示最新的数据，但是在某些情况下，我们下网在代码逻辑中监听某个数据的变化，这个时候就需要用到侦听器watch来实现了。\n\nwatch也是一个配置项，所以我们写的时候与methods一样，写在vue实例当中。\n\n```js\nwatch: {\n    msg: function (newValue, oldValue) {\n        console.log('msg发生了变化');\n        console.log('newValue', newValue);\n        console.log('oldValue', oldValue);\n    }\n}\n```\n\n我们要监听哪个数据发生了变化，前面就写谁，后面就是一个函数，这个函数有两个参数，第一个参数是新值，第二个参数是旧值。\n\n**注意：**\n\n默认情况下我们侦听器只会针对侦听的数据的本身的改变（内部发生的改变时不会被侦听的）。就比如对象内部的一个属性发生了变化，默认情况下是侦听不到的。\n\n想要侦听到对象内部的属性发生了变化，我们需要在配置项中加上deep:true。深度侦听。\n\n```js\ninfo: {\n    handler: function (newValue, oldValue) {\n        console.log('info发生了变化', newValue, oldValue);\n    },\n    deep: true, // 深度侦听，可以监听到对象内部的键值对发生改变\n}\n```\n\n这样就开启了深度侦听，就算对象里面一个属性发生了变化，也会被侦听到。\n\n下面还有一个立即执行的配置项：也就是页面一加载的时候，就会执行一次这个侦听。\n\n```js\ninfo: {\n    handler: function (newValue, oldValue) {\n        console.log('info发生了变化', newValue, oldValue);\n    },\n    deep: true, // 深度侦听，可以监听到对象内部的键值对发生改变\n    immediate: true, // 立即执行\n}\n```\n\n","source":"_posts/Vue3/vue3的Options-API.md","raw":"---\ntitle: Vue3的Options-API\ndata: 2023-1-26\ntags: [前端]\ncategories: [Vue3]\n---\n\n# Vue3的Options-API\n\n\n[TOC]\n\n## 计算属性\n\n在模板当中，我们可以使用插值语`{{}}`法来显示data里面的一些数据\n\n但是在某些情况下，我么可能需要将数据进行一些转化之后再显示，或者将多个数据结合起来进行显示\n\n- 比如我们需要将多个data数据进行运算、三元运算符来决定结果、数据进行某种转化之后显示\n- 在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算，在模板中放入太多的逻辑毁容模板显得臃肿不堪且难以维护，并且如果要在多个地方都使用，这样会有大量重复的代码。\n\n解决办法：\n\n1. 将逻辑抽离到methods当中，放到methods里面的options里面，但是这样有一个弊端，所有的data数据的使用过程都变成了方法的调用\n2. 可以使用计算属性computed。\n\n### 什么是计算属性\n\n官方：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性，计算属性将被混入到组件实例中，所有的getter和setter的this上下文自动绑定为组件实例。\n\n**计算属性的用法：**\n\n选项： compted\n类型： { [key: string]: Function | { get: Function, set: Function } }\n\n例子：\n\n```js\ncomputed: {\n    getName: function () {\n        return this.firstName + this.lastName;\n    },\n    getResult: function () {\n        return this.score >= 60 ? '及格' : '不及格';\n    },\n    getMsg: function () {\n        return this.message.split(\"\").reverse().join('');\n    }\n}\n```\n\n这就是计算属性，这里我们使用的是函数的方式，注意：计算属性看起来是一个函数，但是我们在使用的时候并不需要加上`()`,而是直接使用属性的方式来使用。并且计算属性有缓存，这些函数只会执行一次，除非依赖的响应式数据发生了变化。\n\n计算属性与模板语法，计算属性与methods的区别，代码在这里：1.[模板语法](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/01_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95.html)    2.[methods](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/02_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_methods.html)   3.[计算属性](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/03_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_computed.html)\n\n当计算属性所依赖的数据发生改变的时候，计算属性会重新计算。\n\n### 计算属性的getter与setter\n\n计算属性大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。也就是当我们把计算属性里面写成函数的形式，就代表我们使用的计算属性的getter方法。\n\n## 侦听器watch\n\n在开发当中，我们data中返回的对象当中定义了数据，这个数据通过插值语法等方式绑定到template当中，当数据发生变化的时候，template会自动更新来显示最新的数据，但是在某些情况下，我们下网在代码逻辑中监听某个数据的变化，这个时候就需要用到侦听器watch来实现了。\n\nwatch也是一个配置项，所以我们写的时候与methods一样，写在vue实例当中。\n\n```js\nwatch: {\n    msg: function (newValue, oldValue) {\n        console.log('msg发生了变化');\n        console.log('newValue', newValue);\n        console.log('oldValue', oldValue);\n    }\n}\n```\n\n我们要监听哪个数据发生了变化，前面就写谁，后面就是一个函数，这个函数有两个参数，第一个参数是新值，第二个参数是旧值。\n\n**注意：**\n\n默认情况下我们侦听器只会针对侦听的数据的本身的改变（内部发生的改变时不会被侦听的）。就比如对象内部的一个属性发生了变化，默认情况下是侦听不到的。\n\n想要侦听到对象内部的属性发生了变化，我们需要在配置项中加上deep:true。深度侦听。\n\n```js\ninfo: {\n    handler: function (newValue, oldValue) {\n        console.log('info发生了变化', newValue, oldValue);\n    },\n    deep: true, // 深度侦听，可以监听到对象内部的键值对发生改变\n}\n```\n\n这样就开启了深度侦听，就算对象里面一个属性发生了变化，也会被侦听到。\n\n下面还有一个立即执行的配置项：也就是页面一加载的时候，就会执行一次这个侦听。\n\n```js\ninfo: {\n    handler: function (newValue, oldValue) {\n        console.log('info发生了变化', newValue, oldValue);\n    },\n    deep: true, // 深度侦听，可以监听到对象内部的键值对发生改变\n    immediate: true, // 立即执行\n}\n```\n\n","slug":"Vue3/vue3的Options-API","published":1,"date":"2023-01-26T04:31:35.020Z","updated":"2023-01-27T02:40:11.356Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjj007u9kbm1s2r2nlg","content":"<h1 id=\"Vue3的Options-API\"><a href=\"#Vue3的Options-API\" class=\"headerlink\" title=\"Vue3的Options-API\"></a>Vue3的Options-API</h1><p>[TOC]</p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>在模板当中，我们可以使用插值语<code>&#123;&#123;&#125;&#125;</code>法来显示data里面的一些数据</p>\n<p>但是在某些情况下，我么可能需要将数据进行一些转化之后再显示，或者将多个数据结合起来进行显示</p>\n<ul>\n<li>比如我们需要将多个data数据进行运算、三元运算符来决定结果、数据进行某种转化之后显示</li>\n<li>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算，在模板中放入太多的逻辑毁容模板显得臃肿不堪且难以维护，并且如果要在多个地方都使用，这样会有大量重复的代码。</li>\n</ul>\n<p>解决办法：</p>\n<ol>\n<li>将逻辑抽离到methods当中，放到methods里面的options里面，但是这样有一个弊端，所有的data数据的使用过程都变成了方法的调用</li>\n<li>可以使用计算属性computed。</li>\n</ol>\n<h3 id=\"什么是计算属性\"><a href=\"#什么是计算属性\" class=\"headerlink\" title=\"什么是计算属性\"></a>什么是计算属性</h3><p>官方：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性，计算属性将被混入到组件实例中，所有的getter和setter的this上下文自动绑定为组件实例。</p>\n<p><strong>计算属性的用法：</strong></p>\n<p>选项： compted<br>类型： { [key: string]: Function | { get: Function, set: Function } }</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">firstName</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">lastName</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">getResult</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">score</span> &gt;= <span class=\"number\">60</span> ? <span class=\"string\">&#x27;及格&#x27;</span> : <span class=\"string\">&#x27;不及格&#x27;</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">getMsg</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">message</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;&quot;</span>).<span class=\"title function_\">reverse</span>().<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是计算属性，这里我们使用的是函数的方式，注意：计算属性看起来是一个函数，但是我们在使用的时候并不需要加上<code>()</code>,而是直接使用属性的方式来使用。并且计算属性有缓存，这些函数只会执行一次，除非依赖的响应式数据发生了变化。</p>\n<p>计算属性与模板语法，计算属性与methods的区别，代码在这里：1.<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/01_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95.html\">模板语法</a>    2.<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/02_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_methods.html\">methods</a>   3.<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/03_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_computed.html\">计算属性</a></p>\n<p>当计算属性所依赖的数据发生改变的时候，计算属性会重新计算。</p>\n<h3 id=\"计算属性的getter与setter\"><a href=\"#计算属性的getter与setter\" class=\"headerlink\" title=\"计算属性的getter与setter\"></a>计算属性的getter与setter</h3><p>计算属性大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。也就是当我们把计算属性里面写成函数的形式，就代表我们使用的计算属性的getter方法。</p>\n<h2 id=\"侦听器watch\"><a href=\"#侦听器watch\" class=\"headerlink\" title=\"侦听器watch\"></a>侦听器watch</h2><p>在开发当中，我们data中返回的对象当中定义了数据，这个数据通过插值语法等方式绑定到template当中，当数据发生变化的时候，template会自动更新来显示最新的数据，但是在某些情况下，我们下网在代码逻辑中监听某个数据的变化，这个时候就需要用到侦听器watch来实现了。</p>\n<p>watch也是一个配置项，所以我们写的时候与methods一样，写在vue实例当中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"keyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;msg发生了变化&#x27;</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;newValue&#x27;</span>, newValue);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;oldValue&#x27;</span>, oldValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们要监听哪个数据发生了变化，前面就写谁，后面就是一个函数，这个函数有两个参数，第一个参数是新值，第二个参数是旧值。</p>\n<p><strong>注意：</strong></p>\n<p>默认情况下我们侦听器只会针对侦听的数据的本身的改变（内部发生的改变时不会被侦听的）。就比如对象内部的一个属性发生了变化，默认情况下是侦听不到的。</p>\n<p>想要侦听到对象内部的属性发生了变化，我们需要在配置项中加上deep:true。深度侦听。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">handler</span>: <span class=\"keyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;info发生了变化&#x27;</span>, newValue, oldValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 深度侦听，可以监听到对象内部的键值对发生改变</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就开启了深度侦听，就算对象里面一个属性发生了变化，也会被侦听到。</p>\n<p>下面还有一个立即执行的配置项：也就是页面一加载的时候，就会执行一次这个侦听。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">handler</span>: <span class=\"keyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;info发生了变化&#x27;</span>, newValue, oldValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 深度侦听，可以监听到对象内部的键值对发生改变</span></span><br><span class=\"line\">    <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue3的Options-API\"><a href=\"#Vue3的Options-API\" class=\"headerlink\" title=\"Vue3的Options-API\"></a>Vue3的Options-API</h1><p>[TOC]</p>\n<h2 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h2><p>在模板当中，我们可以使用插值语<code>&#123;&#123;&#125;&#125;</code>法来显示data里面的一些数据</p>\n<p>但是在某些情况下，我么可能需要将数据进行一些转化之后再显示，或者将多个数据结合起来进行显示</p>\n<ul>\n<li>比如我们需要将多个data数据进行运算、三元运算符来决定结果、数据进行某种转化之后显示</li>\n<li>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算，在模板中放入太多的逻辑毁容模板显得臃肿不堪且难以维护，并且如果要在多个地方都使用，这样会有大量重复的代码。</li>\n</ul>\n<p>解决办法：</p>\n<ol>\n<li>将逻辑抽离到methods当中，放到methods里面的options里面，但是这样有一个弊端，所有的data数据的使用过程都变成了方法的调用</li>\n<li>可以使用计算属性computed。</li>\n</ol>\n<h3 id=\"什么是计算属性\"><a href=\"#什么是计算属性\" class=\"headerlink\" title=\"什么是计算属性\"></a>什么是计算属性</h3><p>官方：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性，计算属性将被混入到组件实例中，所有的getter和setter的this上下文自动绑定为组件实例。</p>\n<p><strong>计算属性的用法：</strong></p>\n<p>选项： compted<br>类型： { [key: string]: Function | { get: Function, set: Function } }</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">computed</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">getName</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">firstName</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">lastName</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">getResult</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">score</span> &gt;= <span class=\"number\">60</span> ? <span class=\"string\">&#x27;及格&#x27;</span> : <span class=\"string\">&#x27;不及格&#x27;</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">getMsg</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">message</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&quot;&quot;</span>).<span class=\"title function_\">reverse</span>().<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是计算属性，这里我们使用的是函数的方式，注意：计算属性看起来是一个函数，但是我们在使用的时候并不需要加上<code>()</code>,而是直接使用属性的方式来使用。并且计算属性有缓存，这些函数只会执行一次，除非依赖的响应式数据发生了变化。</p>\n<p>计算属性与模板语法，计算属性与methods的区别，代码在这里：1.<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/01_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95.html\">模板语法</a>    2.<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/02_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_methods.html\">methods</a>   3.<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/06_%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/03_%E4%B8%89%E4%B8%AA%E6%A1%88%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0_computed.html\">计算属性</a></p>\n<p>当计算属性所依赖的数据发生改变的时候，计算属性会重新计算。</p>\n<h3 id=\"计算属性的getter与setter\"><a href=\"#计算属性的getter与setter\" class=\"headerlink\" title=\"计算属性的getter与setter\"></a>计算属性的getter与setter</h3><p>计算属性大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。也就是当我们把计算属性里面写成函数的形式，就代表我们使用的计算属性的getter方法。</p>\n<h2 id=\"侦听器watch\"><a href=\"#侦听器watch\" class=\"headerlink\" title=\"侦听器watch\"></a>侦听器watch</h2><p>在开发当中，我们data中返回的对象当中定义了数据，这个数据通过插值语法等方式绑定到template当中，当数据发生变化的时候，template会自动更新来显示最新的数据，但是在某些情况下，我们下网在代码逻辑中监听某个数据的变化，这个时候就需要用到侦听器watch来实现了。</p>\n<p>watch也是一个配置项，所以我们写的时候与methods一样，写在vue实例当中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">msg</span>: <span class=\"keyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;msg发生了变化&#x27;</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;newValue&#x27;</span>, newValue);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;oldValue&#x27;</span>, oldValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们要监听哪个数据发生了变化，前面就写谁，后面就是一个函数，这个函数有两个参数，第一个参数是新值，第二个参数是旧值。</p>\n<p><strong>注意：</strong></p>\n<p>默认情况下我们侦听器只会针对侦听的数据的本身的改变（内部发生的改变时不会被侦听的）。就比如对象内部的一个属性发生了变化，默认情况下是侦听不到的。</p>\n<p>想要侦听到对象内部的属性发生了变化，我们需要在配置项中加上deep:true。深度侦听。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">handler</span>: <span class=\"keyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;info发生了变化&#x27;</span>, newValue, oldValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 深度侦听，可以监听到对象内部的键值对发生改变</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就开启了深度侦听，就算对象里面一个属性发生了变化，也会被侦听到。</p>\n<p>下面还有一个立即执行的配置项：也就是页面一加载的时候，就会执行一次这个侦听。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">info</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">handler</span>: <span class=\"keyword\">function</span> (<span class=\"params\">newValue, oldValue</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;info发生了变化&#x27;</span>, newValue, oldValue);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">deep</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 深度侦听，可以监听到对象内部的键值对发生改变</span></span><br><span class=\"line\">    <span class=\"attr\">immediate</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Vue3的表单开发和开发模式","data":"2023-1-27","_content":"\n# Vue3的表单开发和开发模式\n\n[TOC]\n\n## 1.表单开发\n\n### v-model的使用\n\nv-model指令可以在表单input textarea select组件上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\n在官方的说法当中，v-model其实背后有两个操作：\n\n- v-bind绑定value属性的值\n- v-on绑定input事件监听到函数中，函数会获取到最新的值赋值到绑定的属性当中。\n\nv-model语法：\n\n`v-model=\"要绑定的属性\"`\n\n比如：\n\n```html\n<input type=\"text\" v-model=\"msg\">\n<div>{{msg}}</div>\n```\n\n在这里我们将`msg`的属性双向绑定，也就是说我们在input输入框中输入的值会实时的显示在div标签中。\n\n### v-model使用场景\n\n1. 可以在文本框内使用v-model来实现双向数据绑定\n\n```html\n<textarea name=\"text\" id=\"test\" cols=\"30\" rows=\"10\" v-model=\"info\"></textarea>\n```\n\n在下面的data中，我们定义了一个info变量，用来存储文本框中的值。\n\n```js\ninfo: 'hello world!',\n```\n\n此时我们默认在文本框中显示的是hello world!，我们可以在文本框中输入任意内容，此时info的值也会随之改变。\n\n2. 可以在单选框中使用v-model来实现双向数据绑定\n\n```html\n<input type=\"radio\" v-model=\"isAgree\" name=\"1\">同意协议\n<input type=\"radio\" v-model=\"isAgree\" name=\"1\">不同意协议\n```\n\n在下面的data中，我们定义了一个isAgree变量，用来存储单选框中的值。\n\n```js\nisAgree: false,\n```\n\n3. 可以在复选框中使用v-model来实现双向数据绑定\n\n```html\n<label for=\"a\">\n    <input type=\"checkbox\" v-model=\"hobbies\" value=\"篮球\">篮球\n</label>\n<label for=\"b\">\n    <input type=\"checkbox\" v-model=\"hobbies\" value=\"足球\">足球\n</label>\n<label for=\"c\">\n    <input type=\"checkbox\" v-model=\"hobbies\" value=\"羽毛球\">羽毛球\n</label>\n```\n\n在下面的data中，我们定义了一个hobbies数组，用来存储复选框中的值。\n\n```js\nhobbies: [],\n```\n\n4. 可以在下拉框中使用v-model来实现双向数据绑定\n\n```html\n<select name=\"shuiguo\" id=\"sg\" v-model=\"shuiguo\">\n    <option value=\"juzi\">橘子</option>\n    <option value=\"taozi\">水蜜桃</option>\n    <option value=\"xiangjiao\">香蕉</option>\n</select>\n```\n\n在下面的data中，我们定义了一个shuiguo变量，用来存储下拉框中的值。\n\n```js\nshuiguo:'',\n```\n\n### v-model的值绑定\n\n在上面的例子中，我们都是对数据进行写死处理，但是在实际开发中我们需要渲染的数据，往往是从服务器返回回来的数据。\n\n比如我们有一个下拉框，需要从服务器获取数据，然后渲染到下拉框中。\n\n```html\n<select name=\"test\" id=\"test\">\n    <option v-for=\"item in list\" value=\"item.value\">{{item.name}}</option>\n</select>\n```\n\n### v-model的修饰符\n\nv-model有一些修饰符，可以对v-model的值进行修饰。\n\n1. lazy\n\n在前面的例子中，我们发现，只要输入框的数据一发生变化，这边就会侦听到，然后发生改变。但是我们不希望改变得这么频繁，这个时候我们就需要用到lazy这个修饰符。\n\n就像这样：\n\n```html\n<input type=\"text\" v-model.lazy=\"text\">\n<div>result:{{text}}</div>\n```\n\n这时候我们只有在提交（回车/输入框失去焦点时）的时候，数据才会发生改变。\n\n`lazy`的本质其实是将原来v-model用于双向绑定的事件从`input`改为`change`。\n\n2. number\n\n为什么需要这个修饰符呢，这是因为在输入框中，我们输入的是数字，但是v-model进行绑定的时候，他默认是字符串类型。\n\n这个时候我们就需要用到number这个修饰符。\n\n```html\n<input type=\"text\" v-model.number=\"number\">\n```\n\n在这种情况下，我们在输入框输入的除数字之外的字符，一律不会被绑定在number上。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0b8ba7b01e4e3b840d67607c480b71~tplv-k3u1fbpfcp-watermark.image?)  \n\n3. trim\n\n在开发当中，我们可能需要将输入框中的内容去掉前后的空格，这个时候我们就需要用到trim这个修饰符。\n\n```html\n<input type=\"text\" v-model.trim=\"text\">\n```\n\n这个时候我们输入的内容，前后的空格都会被去掉。","source":"_posts/Vue3/vue3的表单开发和开发模式.md","raw":"---\ntitle: Vue3的表单开发和开发模式\ndata: 2023-1-27\ntags: [前端]\ncategories: [Vue3]\n---\n\n# Vue3的表单开发和开发模式\n\n[TOC]\n\n## 1.表单开发\n\n### v-model的使用\n\nv-model指令可以在表单input textarea select组件上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\n在官方的说法当中，v-model其实背后有两个操作：\n\n- v-bind绑定value属性的值\n- v-on绑定input事件监听到函数中，函数会获取到最新的值赋值到绑定的属性当中。\n\nv-model语法：\n\n`v-model=\"要绑定的属性\"`\n\n比如：\n\n```html\n<input type=\"text\" v-model=\"msg\">\n<div>{{msg}}</div>\n```\n\n在这里我们将`msg`的属性双向绑定，也就是说我们在input输入框中输入的值会实时的显示在div标签中。\n\n### v-model使用场景\n\n1. 可以在文本框内使用v-model来实现双向数据绑定\n\n```html\n<textarea name=\"text\" id=\"test\" cols=\"30\" rows=\"10\" v-model=\"info\"></textarea>\n```\n\n在下面的data中，我们定义了一个info变量，用来存储文本框中的值。\n\n```js\ninfo: 'hello world!',\n```\n\n此时我们默认在文本框中显示的是hello world!，我们可以在文本框中输入任意内容，此时info的值也会随之改变。\n\n2. 可以在单选框中使用v-model来实现双向数据绑定\n\n```html\n<input type=\"radio\" v-model=\"isAgree\" name=\"1\">同意协议\n<input type=\"radio\" v-model=\"isAgree\" name=\"1\">不同意协议\n```\n\n在下面的data中，我们定义了一个isAgree变量，用来存储单选框中的值。\n\n```js\nisAgree: false,\n```\n\n3. 可以在复选框中使用v-model来实现双向数据绑定\n\n```html\n<label for=\"a\">\n    <input type=\"checkbox\" v-model=\"hobbies\" value=\"篮球\">篮球\n</label>\n<label for=\"b\">\n    <input type=\"checkbox\" v-model=\"hobbies\" value=\"足球\">足球\n</label>\n<label for=\"c\">\n    <input type=\"checkbox\" v-model=\"hobbies\" value=\"羽毛球\">羽毛球\n</label>\n```\n\n在下面的data中，我们定义了一个hobbies数组，用来存储复选框中的值。\n\n```js\nhobbies: [],\n```\n\n4. 可以在下拉框中使用v-model来实现双向数据绑定\n\n```html\n<select name=\"shuiguo\" id=\"sg\" v-model=\"shuiguo\">\n    <option value=\"juzi\">橘子</option>\n    <option value=\"taozi\">水蜜桃</option>\n    <option value=\"xiangjiao\">香蕉</option>\n</select>\n```\n\n在下面的data中，我们定义了一个shuiguo变量，用来存储下拉框中的值。\n\n```js\nshuiguo:'',\n```\n\n### v-model的值绑定\n\n在上面的例子中，我们都是对数据进行写死处理，但是在实际开发中我们需要渲染的数据，往往是从服务器返回回来的数据。\n\n比如我们有一个下拉框，需要从服务器获取数据，然后渲染到下拉框中。\n\n```html\n<select name=\"test\" id=\"test\">\n    <option v-for=\"item in list\" value=\"item.value\">{{item.name}}</option>\n</select>\n```\n\n### v-model的修饰符\n\nv-model有一些修饰符，可以对v-model的值进行修饰。\n\n1. lazy\n\n在前面的例子中，我们发现，只要输入框的数据一发生变化，这边就会侦听到，然后发生改变。但是我们不希望改变得这么频繁，这个时候我们就需要用到lazy这个修饰符。\n\n就像这样：\n\n```html\n<input type=\"text\" v-model.lazy=\"text\">\n<div>result:{{text}}</div>\n```\n\n这时候我们只有在提交（回车/输入框失去焦点时）的时候，数据才会发生改变。\n\n`lazy`的本质其实是将原来v-model用于双向绑定的事件从`input`改为`change`。\n\n2. number\n\n为什么需要这个修饰符呢，这是因为在输入框中，我们输入的是数字，但是v-model进行绑定的时候，他默认是字符串类型。\n\n这个时候我们就需要用到number这个修饰符。\n\n```html\n<input type=\"text\" v-model.number=\"number\">\n```\n\n在这种情况下，我们在输入框输入的除数字之外的字符，一律不会被绑定在number上。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0b8ba7b01e4e3b840d67607c480b71~tplv-k3u1fbpfcp-watermark.image?)  \n\n3. trim\n\n在开发当中，我们可能需要将输入框中的内容去掉前后的空格，这个时候我们就需要用到trim这个修饰符。\n\n```html\n<input type=\"text\" v-model.trim=\"text\">\n```\n\n这个时候我们输入的内容，前后的空格都会被去掉。","slug":"Vue3/vue3的表单开发和开发模式","published":1,"date":"2023-01-27T02:28:03.275Z","updated":"2023-02-09T12:47:53.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjj007x9kbm1por4r6y","content":"<h1 id=\"Vue3的表单开发和开发模式\"><a href=\"#Vue3的表单开发和开发模式\" class=\"headerlink\" title=\"Vue3的表单开发和开发模式\"></a>Vue3的表单开发和开发模式</h1><p>[TOC]</p>\n<h2 id=\"1-表单开发\"><a href=\"#1-表单开发\" class=\"headerlink\" title=\"1.表单开发\"></a>1.表单开发</h2><h3 id=\"v-model的使用\"><a href=\"#v-model的使用\" class=\"headerlink\" title=\"v-model的使用\"></a>v-model的使用</h3><p>v-model指令可以在表单input textarea select组件上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>\n<p>在官方的说法当中，v-model其实背后有两个操作：</p>\n<ul>\n<li>v-bind绑定value属性的值</li>\n<li>v-on绑定input事件监听到函数中，函数会获取到最新的值赋值到绑定的属性当中。</li>\n</ul>\n<p>v-model语法：</p>\n<p><code>v-model=&quot;要绑定的属性&quot;</code></p>\n<p>比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;msg&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里我们将<code>msg</code>的属性双向绑定，也就是说我们在input输入框中输入的值会实时的显示在div标签中。</p>\n<h3 id=\"v-model使用场景\"><a href=\"#v-model使用场景\" class=\"headerlink\" title=\"v-model使用场景\"></a>v-model使用场景</h3><ol>\n<li>可以在文本框内使用v-model来实现双向数据绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test&quot;</span> <span class=\"attr\">cols</span>=<span class=\"string\">&quot;30&quot;</span> <span class=\"attr\">rows</span>=<span class=\"string\">&quot;10&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;info&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在下面的data中，我们定义了一个info变量，用来存储文本框中的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">info</span>: <span class=\"string\">&#x27;hello world!&#x27;</span>,</span><br></pre></td></tr></table></figure>\n\n<p>此时我们默认在文本框中显示的是hello world!，我们可以在文本框中输入任意内容，此时info的值也会随之改变。</p>\n<ol start=\"2\">\n<li>可以在单选框中使用v-model来实现双向数据绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;isAgree&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span>同意协议</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;isAgree&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span>不同意协议</span><br></pre></td></tr></table></figure>\n\n<p>在下面的data中，我们定义了一个isAgree变量，用来存储单选框中的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">isAgree</span>: <span class=\"literal\">false</span>,</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>可以在复选框中使用v-model来实现双向数据绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;hobbies&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;篮球&quot;</span>&gt;</span>篮球</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;hobbies&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;足球&quot;</span>&gt;</span>足球</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;hobbies&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;羽毛球&quot;</span>&gt;</span>羽毛球</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在下面的data中，我们定义了一个hobbies数组，用来存储复选框中的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">hobbies</span>: [],</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>可以在下拉框中使用v-model来实现双向数据绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;shuiguo&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sg&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;shuiguo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;juzi&quot;</span>&gt;</span>橘子<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;taozi&quot;</span>&gt;</span>水蜜桃<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;xiangjiao&quot;</span>&gt;</span>香蕉<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在下面的data中，我们定义了一个shuiguo变量，用来存储下拉框中的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">shuiguo</span>:<span class=\"string\">&#x27;&#x27;</span>,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"v-model的值绑定\"><a href=\"#v-model的值绑定\" class=\"headerlink\" title=\"v-model的值绑定\"></a>v-model的值绑定</h3><p>在上面的例子中，我们都是对数据进行写死处理，但是在实际开发中我们需要渲染的数据，往往是从服务器返回回来的数据。</p>\n<p>比如我们有一个下拉框，需要从服务器获取数据，然后渲染到下拉框中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in list&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;item.value&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"v-model的修饰符\"><a href=\"#v-model的修饰符\" class=\"headerlink\" title=\"v-model的修饰符\"></a>v-model的修饰符</h3><p>v-model有一些修饰符，可以对v-model的值进行修饰。</p>\n<ol>\n<li>lazy</li>\n</ol>\n<p>在前面的例子中，我们发现，只要输入框的数据一发生变化，这边就会侦听到，然后发生改变。但是我们不希望改变得这么频繁，这个时候我们就需要用到lazy这个修饰符。</p>\n<p>就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model.lazy</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>result:&#123;&#123;text&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候我们只有在提交（回车&#x2F;输入框失去焦点时）的时候，数据才会发生改变。</p>\n<p><code>lazy</code>的本质其实是将原来v-model用于双向绑定的事件从<code>input</code>改为<code>change</code>。</p>\n<ol start=\"2\">\n<li>number</li>\n</ol>\n<p>为什么需要这个修饰符呢，这是因为在输入框中，我们输入的是数字，但是v-model进行绑定的时候，他默认是字符串类型。</p>\n<p>这个时候我们就需要用到number这个修饰符。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，我们在输入框输入的除数字之外的字符，一律不会被绑定在number上。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0b8ba7b01e4e3b840d67607c480b71~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\">  </p>\n<ol start=\"3\">\n<li>trim</li>\n</ol>\n<p>在开发当中，我们可能需要将输入框中的内容去掉前后的空格，这个时候我们就需要用到trim这个修饰符。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model.trim</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候我们输入的内容，前后的空格都会被去掉。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue3的表单开发和开发模式\"><a href=\"#Vue3的表单开发和开发模式\" class=\"headerlink\" title=\"Vue3的表单开发和开发模式\"></a>Vue3的表单开发和开发模式</h1><p>[TOC]</p>\n<h2 id=\"1-表单开发\"><a href=\"#1-表单开发\" class=\"headerlink\" title=\"1.表单开发\"></a>1.表单开发</h2><h3 id=\"v-model的使用\"><a href=\"#v-model的使用\" class=\"headerlink\" title=\"v-model的使用\"></a>v-model的使用</h3><p>v-model指令可以在表单input textarea select组件上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>\n<p>在官方的说法当中，v-model其实背后有两个操作：</p>\n<ul>\n<li>v-bind绑定value属性的值</li>\n<li>v-on绑定input事件监听到函数中，函数会获取到最新的值赋值到绑定的属性当中。</li>\n</ul>\n<p>v-model语法：</p>\n<p><code>v-model=&quot;要绑定的属性&quot;</code></p>\n<p>比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;msg&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这里我们将<code>msg</code>的属性双向绑定，也就是说我们在input输入框中输入的值会实时的显示在div标签中。</p>\n<h3 id=\"v-model使用场景\"><a href=\"#v-model使用场景\" class=\"headerlink\" title=\"v-model使用场景\"></a>v-model使用场景</h3><ol>\n<li>可以在文本框内使用v-model来实现双向数据绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test&quot;</span> <span class=\"attr\">cols</span>=<span class=\"string\">&quot;30&quot;</span> <span class=\"attr\">rows</span>=<span class=\"string\">&quot;10&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;info&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在下面的data中，我们定义了一个info变量，用来存储文本框中的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">info</span>: <span class=\"string\">&#x27;hello world!&#x27;</span>,</span><br></pre></td></tr></table></figure>\n\n<p>此时我们默认在文本框中显示的是hello world!，我们可以在文本框中输入任意内容，此时info的值也会随之改变。</p>\n<ol start=\"2\">\n<li>可以在单选框中使用v-model来实现双向数据绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;isAgree&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span>同意协议</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;isAgree&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span>不同意协议</span><br></pre></td></tr></table></figure>\n\n<p>在下面的data中，我们定义了一个isAgree变量，用来存储单选框中的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">isAgree</span>: <span class=\"literal\">false</span>,</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>可以在复选框中使用v-model来实现双向数据绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;a&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;hobbies&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;篮球&quot;</span>&gt;</span>篮球</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;b&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;hobbies&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;足球&quot;</span>&gt;</span>足球</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;c&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;hobbies&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;羽毛球&quot;</span>&gt;</span>羽毛球</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在下面的data中，我们定义了一个hobbies数组，用来存储复选框中的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">hobbies</span>: [],</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>可以在下拉框中使用v-model来实现双向数据绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;shuiguo&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sg&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;shuiguo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;juzi&quot;</span>&gt;</span>橘子<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;taozi&quot;</span>&gt;</span>水蜜桃<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;xiangjiao&quot;</span>&gt;</span>香蕉<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在下面的data中，我们定义了一个shuiguo变量，用来存储下拉框中的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">shuiguo</span>:<span class=\"string\">&#x27;&#x27;</span>,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"v-model的值绑定\"><a href=\"#v-model的值绑定\" class=\"headerlink\" title=\"v-model的值绑定\"></a>v-model的值绑定</h3><p>在上面的例子中，我们都是对数据进行写死处理，但是在实际开发中我们需要渲染的数据，往往是从服务器返回回来的数据。</p>\n<p>比如我们有一个下拉框，需要从服务器获取数据，然后渲染到下拉框中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;test&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;test&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in list&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;item.value&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"v-model的修饰符\"><a href=\"#v-model的修饰符\" class=\"headerlink\" title=\"v-model的修饰符\"></a>v-model的修饰符</h3><p>v-model有一些修饰符，可以对v-model的值进行修饰。</p>\n<ol>\n<li>lazy</li>\n</ol>\n<p>在前面的例子中，我们发现，只要输入框的数据一发生变化，这边就会侦听到，然后发生改变。但是我们不希望改变得这么频繁，这个时候我们就需要用到lazy这个修饰符。</p>\n<p>就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model.lazy</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>result:&#123;&#123;text&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这时候我们只有在提交（回车&#x2F;输入框失去焦点时）的时候，数据才会发生改变。</p>\n<p><code>lazy</code>的本质其实是将原来v-model用于双向绑定的事件从<code>input</code>改为<code>change</code>。</p>\n<ol start=\"2\">\n<li>number</li>\n</ol>\n<p>为什么需要这个修饰符呢，这是因为在输入框中，我们输入的是数字，但是v-model进行绑定的时候，他默认是字符串类型。</p>\n<p>这个时候我们就需要用到number这个修饰符。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model.number</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，我们在输入框输入的除数字之外的字符，一律不会被绑定在number上。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd0b8ba7b01e4e3b840d67607c480b71~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\">  </p>\n<ol start=\"3\">\n<li>trim</li>\n</ol>\n<p>在开发当中，我们可能需要将输入框中的内容去掉前后的空格，这个时候我们就需要用到trim这个修饰符。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model.trim</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个时候我们输入的内容，前后的空格都会被去掉。</p>\n"},{"title":"Vue3当中的一些基本指令","date":"2023-01-22T16:00:00.000Z","_content":"# Vue3当中的一些基本语法\n[TOC]\n\n## 插值语法\n\n在vue的模板里面，我们可以使用花括号来实现一个插值语法：\n\n`<div>{{count}}</div>`\n\n在插值语法里面可以使用vue实例对象data里面的数据，并且可以写一些基本的表达式，不是语句！\n\n里面可以只是一个变量，也可以对变量进行一些运算（加减乘除等等），也可以使用函数，还可以使用三元表达式。\n\n但是不能使用语句。\n\n## v-once指令\n\n- v-once指令用于指定元素或者组件只渲染一次：\n\t- 当属局发生变化的时候，元素或者组件以及其所有的子元素，都会被视为静态内容并且跳过。\n\t- 该指令可以用于性能优化\n\t- 如果是里面的子节点也只会被渲染一次：\n```html\n\t<div v-once>\n\t\t<h2>{{counter}}</h2>\n\t</div>\n```\n\n## v-text指令\n\n用于更新元素的textContent:\n\n```html\n<div v-text = \"msg\"></div>\n// 等价于\n<div>{{msg}}</div>\n```\n\n## v-html指令\n\n默认情况下，如果我们展示的内容本身是html的，那么vue并不会对其进行特殊的解析。\n\n如果我们希望这个html内容可以被vue解析出来，那么我们可以使用v-html来展示。\n\n用法：\n\n```html\n\t <div>{{msg}}</div>\n     <div v-html=\"msg\"></div>\n```\n\n## v-pre指令\n\nv-pre用于跳过元素和他的子元素的编译过程，显示原始的Mustache标签。\n\n跳过不需要编译的节点，加快编译的速度。\n\n`<div v-pre>{{message}}</div>`这样的运行效果就是只会出现message。\n\n## v-cloak指令\n\n这个指令保持在元素上直到关联组件实例结束编译\n\n和css规则如[v-cloak]{display:none}一起使用时，这个指令可以隐藏未编译的Mustache标签知道组件实例准备完毕。\n\n## v-bind的绑定属性 \n\n在实际开发当中,除了会动态绑定一些内容之外，我们可能还会需要动态绑定一些属性。这个时候就需要用到v-bind这个属性。\n\n- 我们可以动态绑定某个标签的class属性，或者a标签的href属性。 \n\n绑定属性我们使用v-bind：\n\n- 缩写：：\n- 预期： any(with argument)|Object(without argument)\n- 参数： attr Or Prop(optional)\n- 修饰符：camel --> 将kebab-case attribute 名转换为camelCase\n- 用法: 动态地绑定一个或者多个attribute，或者一个组件prop到表达式\n\n例子：\n\n`<a v-bind:href=\"url\">{{msg}}</a>`\n\n```js\ndata: function () {\n        return {\n            msg: '我的博客',\n            url: \"https://www.zmlblog.top\"\n        }\n    },\n```\n\n这样我们就把url与超链接的地址给绑定起来了。\n\n上面是v-bind 的基础使用，也就是原始的写法，但是这样写起来有点麻烦，vue给我们提供了一个语法糖：\n\n`<a :href=\"url\">{{msg}}</a>`\n\n也就是在v-bind可以直接简写为一个`:`。\n\n实例在这里：[这里]()\n\n### v-bind绑定class属性\n\n在实际开发当中，可能某个元素的class是动态的，处于某个状态的时候，字体颜色为黑色；处于另一个状态的时候，字体颜色为红色。\n\n这个时候就需要使用v-bind来绑定class，绑定class有两种方式：\n\n- 对象语法\n- 数组语法\n\n**对象语法：`{'active':boolean}`**\n\n可以看到在对象语法当中前面用引号括起来的就是可以绑定的类名，后面跟上了一个布尔值，当这个布尔值为真的时候，该类名就会被绑定到该元素；如果布尔值为假，那么这个类名就不会被绑定到这个元素上。\n\n既然是一个对象，那么里面也可以是多个键值对，就像这样：`<div v-bind:class=\"{'fontColor':isTrue,'title':isTrue}\">哈哈哈哈哈哈哈</div>`。\n示例代码地址：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/02_v-bind%E7%BB%91%E5%AE%9Aclass-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95.html)\n\n在对象语法里面`{'active':boolean}`,active是用引号括起来的，当然我们也可以不使用引号，这样的话这个类名就会去data里面寻找，看在data里面有没有active这个变量，然后找到里面存放的类名。\n\n我们使用v-bind绑定class还可以与静态的class进行结合：\n\n```js\n<div class=\"abc\" :class=\"{'fontColor':isTrue,'title':isTrue}\">\n    123123\n</div>\n```\n\n最后渲染出来的结果就是类名有：abc fontColor  title\n\n**数组语法：[className,className,三元表达式.....]**\n\n`<div :class=\"['fontColor','title']\">hhhhhhh</div>`\n\n这样绑定的就是两个类名：fontColor  title\n\n当然我们也可以去data里面寻找我们需要的类名：\n\n`<div :class=\"['fontColor',title]\">hhhhhhh</div>`\n\n这段代码其中第二个值中代表的类名就需要在data里面寻找\n\n我们还可以使用三元运算符：\n\n```js\n<div :class=\"['fontColor',isTrue?'title':'']\">\n    hhhhhhh\n</div>\n\n```\n\n在这里我们就会去判断isTrue是否为真，如果为真，那么就把title这个类名绑定到元素上，否则就绑定一个空的类名（也就是不绑定任何类名）。\n\n但是这样写三元表达式，代码不优雅，更优雅的方式是，在数组里面我们写上一个对象，就像这样：\n\n```js\n<div :class=\"['fontColor',{title:isTrue}]\">\n    hhhhhhh\n</div>\n```\n\n这样是不是就更加优雅了呢？\n\n示例代码在：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/03_v-bind%E7%BB%91%E5%AE%9Aclass%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95.html)\n\n### v-bind绑定style\n\nCSS Property名可以使用驼峰式(camelCase)或者短横线分隔(kebab-case,记得用引号括起来)的方式来命名。\n\n同样的绑定方式也有两种：\n- 对象语法\n- 数组语法\n\n**对象语法：**\n\n用法：`:style=\"{属性名:'属性值'}\"`\n\n可以看到在css属性值哪里有一个单引号，这是必须的，不然vue就会将属性值看做一个变量来解析。\n\n命名方式：\n\n- 驼峰： fontSize\n- 短横线：font-size,使用短横线这种方式的时候，必须将属性名用引号引起来。\n\n实例代码：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/04_v-bind%E7%BB%91%E5%AE%9Astyle-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95.html)\n\n**数组语法：**\n\n在开发当中，我们想要把多个对象里面的css属性写到一起，我们就可以使用数组的方式，将前面的对象作为数组的元素写到一起：`<div :style=\"[styleObj,styleObj2]\">哈哈哈哈</div>`\n\n注意：\n\n如果使用数组语法的时候，如果数组里面对象的css属性有重复的，那么浏览器会根据最后一个（最右边的）属性来渲染。\n\n示例代码在：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/05_v-bind%E7%BB%91%E5%AE%9Astyle%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95.html)\n\n## 动态绑定属性\n\n在某些情况下，我们属性的名称可能也是不固定的：\n\n- 前端我们无论绑定src,href,class,style属性名都是固定的。如果属性名称不是固定，我们可以使用<font color=red>:[属性值]='值'</font>的格式来定义，这种绑定的方式，我们称之为动态绑定属性。 \n\n就像这样：\n\n`div :[name]=\"styleObj\">hhhhhh</div>`\n```js\nname: 'style',\nstyleObj: {\ncolor: 'red',\nfontSize: '40px',\n    },\n```\n\n里面的`name`可以换成其他的变量。\n\n示例代码在:[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/06_v-bind%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7.html)\n\n还有一个v-bind直接绑定一个对象：示例看[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/07_v-bind%E7%9B%B4%E6%8E%A5%E7%BB%91%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.html)\n\n## v-on指令\n\n**v-on绑定事件：**\n\n前面我们学习了这么多的指令，但是都是一些静态的，在前端开发当中，一个重要的特性就是与用户的交互。这个时候我们就需要用到v-on指令。\n\n用来监听胡勇大声的时间，比如点击、拖拽、键盘点击事件等等\n\n**v-on的使用：**\n- 简写：@\n- 预期：Function|Inline Statement | Object\n- 参数： event\n- <div id=\"v-on修饰符\">修饰符：</div>\n```\n .stop  调用event.stopPropagation()\n .prevent  调用 event.preventDefault()\n .capture  添加事件侦听器时使用capture模式\n .self  只当事件是从侦听器绑定的元素本身触发时才触发回调\n .{keyAlias}  仅当事件是从特定触发时才触发回调\n .once   只触发一次回调\n .left  只当鼠标点击左键时触发\n .right  只当鼠标点击右键时触发\n .middle  只当鼠标点击中键时触发\n .passive  {passive:true} 模式添加侦听器\n```\n- 绑定事件监听\n\n### v-on基本使用\n\n一个简单的例子：\n\n`<button v-on:click=\"add\">点我加一</button>`\n\n这个时候就是一个完整的v-on写法了，在v-on后面加上一个冒号，然后加上事件的类型（此时我们添加的点击事件），然后在后面加上事件要调用的事件函数。\n\n也有语法糖：\n\n`<button @click=\"add\">点我加一</button>`:也就是将v-on简写为`@`.\n\n如果我们要处理的事件不是很复杂，我们可以直接写一个表达式在等号后面：`<button @click=\"this.count++\">点我加一</button>`\n\n我们还可以绑定一个对象:\n\n在绑定对象的时候，语法是这样的：`v-on={'事件类型':'事件函数',......}`\n\n示例在[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/08_v-on%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html)\n\n### v-on的参数传递\n\n在函数事件当中，可能会需要传递一些参数，这个时候就需要使用到v-on的参数传递。\n\n在获取事件对象的时候，如果一个事件函数不需要传入其他参数，可以直接不写参数，在事件函数里面可以直接获取到事件对象，就像这样：\n\n```html\n    <button @click=\"btn1Click\">按钮1</button>\n```\n```js\nbtn1Click: function (event) {\n                console.log(event);\n        },\n```\n\n这样就可以拿到事件对象。如果需要传入多个参数，那么这样就不行了。\n\n就需要像下面这样写：\n\n```html\n<button @click=\"btn2Click($event,'海绵宝宝')\">按钮2</button>\n```\n```js\nbtn2Click: function (event, name) {\n    console.log(event);\n    console.log(name);\n}\n```\n\n可以看到在模板里面我们获取事件对象使用的是`$event`，这是一个固定写法。\n\n示例代码在:[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/09_v-on%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.html)\n\n### v-on修饰符\n\nv-on支持修饰符，修饰符相当于对事件进行了一些特殊处理：\n\n具体修饰符见[上面](#v-on修饰符)\n\n示例代码在[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/10_v-on%E4%BF%AE%E9%A5%B0%E7%AC%A6.html)","source":"_posts/Vue3/vue基本指令.md","raw":"---\ntitle: Vue3当中的一些基本指令\ndate: 2023-1-23\ntags: [前端]\ncategories: [Vue3]\n---\n# Vue3当中的一些基本语法\n[TOC]\n\n## 插值语法\n\n在vue的模板里面，我们可以使用花括号来实现一个插值语法：\n\n`<div>{{count}}</div>`\n\n在插值语法里面可以使用vue实例对象data里面的数据，并且可以写一些基本的表达式，不是语句！\n\n里面可以只是一个变量，也可以对变量进行一些运算（加减乘除等等），也可以使用函数，还可以使用三元表达式。\n\n但是不能使用语句。\n\n## v-once指令\n\n- v-once指令用于指定元素或者组件只渲染一次：\n\t- 当属局发生变化的时候，元素或者组件以及其所有的子元素，都会被视为静态内容并且跳过。\n\t- 该指令可以用于性能优化\n\t- 如果是里面的子节点也只会被渲染一次：\n```html\n\t<div v-once>\n\t\t<h2>{{counter}}</h2>\n\t</div>\n```\n\n## v-text指令\n\n用于更新元素的textContent:\n\n```html\n<div v-text = \"msg\"></div>\n// 等价于\n<div>{{msg}}</div>\n```\n\n## v-html指令\n\n默认情况下，如果我们展示的内容本身是html的，那么vue并不会对其进行特殊的解析。\n\n如果我们希望这个html内容可以被vue解析出来，那么我们可以使用v-html来展示。\n\n用法：\n\n```html\n\t <div>{{msg}}</div>\n     <div v-html=\"msg\"></div>\n```\n\n## v-pre指令\n\nv-pre用于跳过元素和他的子元素的编译过程，显示原始的Mustache标签。\n\n跳过不需要编译的节点，加快编译的速度。\n\n`<div v-pre>{{message}}</div>`这样的运行效果就是只会出现message。\n\n## v-cloak指令\n\n这个指令保持在元素上直到关联组件实例结束编译\n\n和css规则如[v-cloak]{display:none}一起使用时，这个指令可以隐藏未编译的Mustache标签知道组件实例准备完毕。\n\n## v-bind的绑定属性 \n\n在实际开发当中,除了会动态绑定一些内容之外，我们可能还会需要动态绑定一些属性。这个时候就需要用到v-bind这个属性。\n\n- 我们可以动态绑定某个标签的class属性，或者a标签的href属性。 \n\n绑定属性我们使用v-bind：\n\n- 缩写：：\n- 预期： any(with argument)|Object(without argument)\n- 参数： attr Or Prop(optional)\n- 修饰符：camel --> 将kebab-case attribute 名转换为camelCase\n- 用法: 动态地绑定一个或者多个attribute，或者一个组件prop到表达式\n\n例子：\n\n`<a v-bind:href=\"url\">{{msg}}</a>`\n\n```js\ndata: function () {\n        return {\n            msg: '我的博客',\n            url: \"https://www.zmlblog.top\"\n        }\n    },\n```\n\n这样我们就把url与超链接的地址给绑定起来了。\n\n上面是v-bind 的基础使用，也就是原始的写法，但是这样写起来有点麻烦，vue给我们提供了一个语法糖：\n\n`<a :href=\"url\">{{msg}}</a>`\n\n也就是在v-bind可以直接简写为一个`:`。\n\n实例在这里：[这里]()\n\n### v-bind绑定class属性\n\n在实际开发当中，可能某个元素的class是动态的，处于某个状态的时候，字体颜色为黑色；处于另一个状态的时候，字体颜色为红色。\n\n这个时候就需要使用v-bind来绑定class，绑定class有两种方式：\n\n- 对象语法\n- 数组语法\n\n**对象语法：`{'active':boolean}`**\n\n可以看到在对象语法当中前面用引号括起来的就是可以绑定的类名，后面跟上了一个布尔值，当这个布尔值为真的时候，该类名就会被绑定到该元素；如果布尔值为假，那么这个类名就不会被绑定到这个元素上。\n\n既然是一个对象，那么里面也可以是多个键值对，就像这样：`<div v-bind:class=\"{'fontColor':isTrue,'title':isTrue}\">哈哈哈哈哈哈哈</div>`。\n示例代码地址：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/02_v-bind%E7%BB%91%E5%AE%9Aclass-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95.html)\n\n在对象语法里面`{'active':boolean}`,active是用引号括起来的，当然我们也可以不使用引号，这样的话这个类名就会去data里面寻找，看在data里面有没有active这个变量，然后找到里面存放的类名。\n\n我们使用v-bind绑定class还可以与静态的class进行结合：\n\n```js\n<div class=\"abc\" :class=\"{'fontColor':isTrue,'title':isTrue}\">\n    123123\n</div>\n```\n\n最后渲染出来的结果就是类名有：abc fontColor  title\n\n**数组语法：[className,className,三元表达式.....]**\n\n`<div :class=\"['fontColor','title']\">hhhhhhh</div>`\n\n这样绑定的就是两个类名：fontColor  title\n\n当然我们也可以去data里面寻找我们需要的类名：\n\n`<div :class=\"['fontColor',title]\">hhhhhhh</div>`\n\n这段代码其中第二个值中代表的类名就需要在data里面寻找\n\n我们还可以使用三元运算符：\n\n```js\n<div :class=\"['fontColor',isTrue?'title':'']\">\n    hhhhhhh\n</div>\n\n```\n\n在这里我们就会去判断isTrue是否为真，如果为真，那么就把title这个类名绑定到元素上，否则就绑定一个空的类名（也就是不绑定任何类名）。\n\n但是这样写三元表达式，代码不优雅，更优雅的方式是，在数组里面我们写上一个对象，就像这样：\n\n```js\n<div :class=\"['fontColor',{title:isTrue}]\">\n    hhhhhhh\n</div>\n```\n\n这样是不是就更加优雅了呢？\n\n示例代码在：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/03_v-bind%E7%BB%91%E5%AE%9Aclass%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95.html)\n\n### v-bind绑定style\n\nCSS Property名可以使用驼峰式(camelCase)或者短横线分隔(kebab-case,记得用引号括起来)的方式来命名。\n\n同样的绑定方式也有两种：\n- 对象语法\n- 数组语法\n\n**对象语法：**\n\n用法：`:style=\"{属性名:'属性值'}\"`\n\n可以看到在css属性值哪里有一个单引号，这是必须的，不然vue就会将属性值看做一个变量来解析。\n\n命名方式：\n\n- 驼峰： fontSize\n- 短横线：font-size,使用短横线这种方式的时候，必须将属性名用引号引起来。\n\n实例代码：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/04_v-bind%E7%BB%91%E5%AE%9Astyle-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95.html)\n\n**数组语法：**\n\n在开发当中，我们想要把多个对象里面的css属性写到一起，我们就可以使用数组的方式，将前面的对象作为数组的元素写到一起：`<div :style=\"[styleObj,styleObj2]\">哈哈哈哈</div>`\n\n注意：\n\n如果使用数组语法的时候，如果数组里面对象的css属性有重复的，那么浏览器会根据最后一个（最右边的）属性来渲染。\n\n示例代码在：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/05_v-bind%E7%BB%91%E5%AE%9Astyle%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95.html)\n\n## 动态绑定属性\n\n在某些情况下，我们属性的名称可能也是不固定的：\n\n- 前端我们无论绑定src,href,class,style属性名都是固定的。如果属性名称不是固定，我们可以使用<font color=red>:[属性值]='值'</font>的格式来定义，这种绑定的方式，我们称之为动态绑定属性。 \n\n就像这样：\n\n`div :[name]=\"styleObj\">hhhhhh</div>`\n```js\nname: 'style',\nstyleObj: {\ncolor: 'red',\nfontSize: '40px',\n    },\n```\n\n里面的`name`可以换成其他的变量。\n\n示例代码在:[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/06_v-bind%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7.html)\n\n还有一个v-bind直接绑定一个对象：示例看[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/07_v-bind%E7%9B%B4%E6%8E%A5%E7%BB%91%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.html)\n\n## v-on指令\n\n**v-on绑定事件：**\n\n前面我们学习了这么多的指令，但是都是一些静态的，在前端开发当中，一个重要的特性就是与用户的交互。这个时候我们就需要用到v-on指令。\n\n用来监听胡勇大声的时间，比如点击、拖拽、键盘点击事件等等\n\n**v-on的使用：**\n- 简写：@\n- 预期：Function|Inline Statement | Object\n- 参数： event\n- <div id=\"v-on修饰符\">修饰符：</div>\n```\n .stop  调用event.stopPropagation()\n .prevent  调用 event.preventDefault()\n .capture  添加事件侦听器时使用capture模式\n .self  只当事件是从侦听器绑定的元素本身触发时才触发回调\n .{keyAlias}  仅当事件是从特定触发时才触发回调\n .once   只触发一次回调\n .left  只当鼠标点击左键时触发\n .right  只当鼠标点击右键时触发\n .middle  只当鼠标点击中键时触发\n .passive  {passive:true} 模式添加侦听器\n```\n- 绑定事件监听\n\n### v-on基本使用\n\n一个简单的例子：\n\n`<button v-on:click=\"add\">点我加一</button>`\n\n这个时候就是一个完整的v-on写法了，在v-on后面加上一个冒号，然后加上事件的类型（此时我们添加的点击事件），然后在后面加上事件要调用的事件函数。\n\n也有语法糖：\n\n`<button @click=\"add\">点我加一</button>`:也就是将v-on简写为`@`.\n\n如果我们要处理的事件不是很复杂，我们可以直接写一个表达式在等号后面：`<button @click=\"this.count++\">点我加一</button>`\n\n我们还可以绑定一个对象:\n\n在绑定对象的时候，语法是这样的：`v-on={'事件类型':'事件函数',......}`\n\n示例在[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/08_v-on%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html)\n\n### v-on的参数传递\n\n在函数事件当中，可能会需要传递一些参数，这个时候就需要使用到v-on的参数传递。\n\n在获取事件对象的时候，如果一个事件函数不需要传入其他参数，可以直接不写参数，在事件函数里面可以直接获取到事件对象，就像这样：\n\n```html\n    <button @click=\"btn1Click\">按钮1</button>\n```\n```js\nbtn1Click: function (event) {\n                console.log(event);\n        },\n```\n\n这样就可以拿到事件对象。如果需要传入多个参数，那么这样就不行了。\n\n就需要像下面这样写：\n\n```html\n<button @click=\"btn2Click($event,'海绵宝宝')\">按钮2</button>\n```\n```js\nbtn2Click: function (event, name) {\n    console.log(event);\n    console.log(name);\n}\n```\n\n可以看到在模板里面我们获取事件对象使用的是`$event`，这是一个固定写法。\n\n示例代码在:[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/09_v-on%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.html)\n\n### v-on修饰符\n\nv-on支持修饰符，修饰符相当于对事件进行了一些特殊处理：\n\n具体修饰符见[上面](#v-on修饰符)\n\n示例代码在[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/10_v-on%E4%BF%AE%E9%A5%B0%E7%AC%A6.html)","slug":"Vue3/vue基本指令","published":1,"updated":"2023-01-24T05:37:33.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjl00819kbmenn7f7xp","content":"<h1 id=\"Vue3当中的一些基本语法\"><a href=\"#Vue3当中的一些基本语法\" class=\"headerlink\" title=\"Vue3当中的一些基本语法\"></a>Vue3当中的一些基本语法</h1><p>[TOC]</p>\n<h2 id=\"插值语法\"><a href=\"#插值语法\" class=\"headerlink\" title=\"插值语法\"></a>插值语法</h2><p>在vue的模板里面，我们可以使用花括号来实现一个插值语法：</p>\n<p><code>&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</code></p>\n<p>在插值语法里面可以使用vue实例对象data里面的数据，并且可以写一些基本的表达式，不是语句！</p>\n<p>里面可以只是一个变量，也可以对变量进行一些运算（加减乘除等等），也可以使用函数，还可以使用三元表达式。</p>\n<p>但是不能使用语句。</p>\n<h2 id=\"v-once指令\"><a href=\"#v-once指令\" class=\"headerlink\" title=\"v-once指令\"></a>v-once指令</h2><ul>\n<li>v-once指令用于指定元素或者组件只渲染一次：<ul>\n<li>当属局发生变化的时候，元素或者组件以及其所有的子元素，都会被视为静态内容并且跳过。</li>\n<li>该指令可以用于性能优化</li>\n<li>如果是里面的子节点也只会被渲染一次：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-once</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;counter&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"v-text指令\"><a href=\"#v-text指令\" class=\"headerlink\" title=\"v-text指令\"></a>v-text指令</h2><p>用于更新元素的textContent:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-text</span> = <span class=\"string\">&quot;msg&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">// 等价于</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"v-html指令\"><a href=\"#v-html指令\" class=\"headerlink\" title=\"v-html指令\"></a>v-html指令</h2><p>默认情况下，如果我们展示的内容本身是html的，那么vue并不会对其进行特殊的解析。</p>\n<p>如果我们希望这个html内容可以被vue解析出来，那么我们可以使用v-html来展示。</p>\n<p>用法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">&quot;msg&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"v-pre指令\"><a href=\"#v-pre指令\" class=\"headerlink\" title=\"v-pre指令\"></a>v-pre指令</h2><p>v-pre用于跳过元素和他的子元素的编译过程，显示原始的Mustache标签。</p>\n<p>跳过不需要编译的节点，加快编译的速度。</p>\n<p><code>&lt;div v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</code>这样的运行效果就是只会出现message。</p>\n<h2 id=\"v-cloak指令\"><a href=\"#v-cloak指令\" class=\"headerlink\" title=\"v-cloak指令\"></a>v-cloak指令</h2><p>这个指令保持在元素上直到关联组件实例结束编译</p>\n<p>和css规则如[v-cloak]{display:none}一起使用时，这个指令可以隐藏未编译的Mustache标签知道组件实例准备完毕。</p>\n<h2 id=\"v-bind的绑定属性\"><a href=\"#v-bind的绑定属性\" class=\"headerlink\" title=\"v-bind的绑定属性\"></a>v-bind的绑定属性</h2><p>在实际开发当中,除了会动态绑定一些内容之外，我们可能还会需要动态绑定一些属性。这个时候就需要用到v-bind这个属性。</p>\n<ul>\n<li>我们可以动态绑定某个标签的class属性，或者a标签的href属性。</li>\n</ul>\n<p>绑定属性我们使用v-bind：</p>\n<ul>\n<li>缩写：：</li>\n<li>预期： any(with argument)|Object(without argument)</li>\n<li>参数： attr Or Prop(optional)</li>\n<li>修饰符：camel –&gt; 将kebab-case attribute 名转换为camelCase</li>\n<li>用法: 动态地绑定一个或者多个attribute，或者一个组件prop到表达式</li>\n</ul>\n<p>例子：</p>\n<p><code>&lt;a v-bind:href=&quot;url&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/a&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">data</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;我的博客&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://www.zmlblog.top&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就把url与超链接的地址给绑定起来了。</p>\n<p>上面是v-bind 的基础使用，也就是原始的写法，但是这样写起来有点麻烦，vue给我们提供了一个语法糖：</p>\n<p><code>&lt;a :href=&quot;url&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/a&gt;</code></p>\n<p>也就是在v-bind可以直接简写为一个<code>:</code>。</p>\n<p>实例在这里：<a href=\"\">这里</a></p>\n<h3 id=\"v-bind绑定class属性\"><a href=\"#v-bind绑定class属性\" class=\"headerlink\" title=\"v-bind绑定class属性\"></a>v-bind绑定class属性</h3><p>在实际开发当中，可能某个元素的class是动态的，处于某个状态的时候，字体颜色为黑色；处于另一个状态的时候，字体颜色为红色。</p>\n<p>这个时候就需要使用v-bind来绑定class，绑定class有两种方式：</p>\n<ul>\n<li>对象语法</li>\n<li>数组语法</li>\n</ul>\n<p><strong>对象语法：<code>&#123;&#39;active&#39;:boolean&#125;</code></strong></p>\n<p>可以看到在对象语法当中前面用引号括起来的就是可以绑定的类名，后面跟上了一个布尔值，当这个布尔值为真的时候，该类名就会被绑定到该元素；如果布尔值为假，那么这个类名就不会被绑定到这个元素上。</p>\n<p>既然是一个对象，那么里面也可以是多个键值对，就像这样：<code>&lt;div v-bind:class=&quot;&#123;&#39;fontColor&#39;:isTrue,&#39;title&#39;:isTrue&#125;&quot;&gt;哈哈哈哈哈哈哈&lt;/div&gt;</code>。<br>示例代码地址：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/02_v-bind%E7%BB%91%E5%AE%9Aclass-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95.html\">这里</a></p>\n<p>在对象语法里面<code>&#123;&#39;active&#39;:boolean&#125;</code>,active是用引号括起来的，当然我们也可以不使用引号，这样的话这个类名就会去data里面寻找，看在data里面有没有active这个变量，然后找到里面存放的类名。</p>\n<p>我们使用v-bind绑定class还可以与静态的class进行结合：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"keyword\">class</span>=<span class=\"string\">&quot;abc&quot;</span> :<span class=\"keyword\">class</span>=<span class=\"string\">&quot;&#123;&#x27;fontColor&#x27;:isTrue,&#x27;title&#x27;:isTrue&#125;&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"number\">123123</span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>最后渲染出来的结果就是类名有：abc fontColor  title</p>\n<p><strong>数组语法：[className,className,三元表达式…..]</strong></p>\n<p><code>&lt;div :class=&quot;[&#39;fontColor&#39;,&#39;title&#39;]&quot;&gt;hhhhhhh&lt;/div&gt;</code></p>\n<p>这样绑定的就是两个类名：fontColor  title</p>\n<p>当然我们也可以去data里面寻找我们需要的类名：</p>\n<p><code>&lt;div :class=&quot;[&#39;fontColor&#39;,title]&quot;&gt;hhhhhhh&lt;/div&gt;</code></p>\n<p>这段代码其中第二个值中代表的类名就需要在data里面寻找</p>\n<p>我们还可以使用三元运算符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div :<span class=\"keyword\">class</span>=<span class=\"string\">&quot;[&#x27;fontColor&#x27;,isTrue?&#x27;title&#x27;:&#x27;&#x27;]&quot;</span>&gt;</span><br><span class=\"line\">    hhhhhhh</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这里我们就会去判断isTrue是否为真，如果为真，那么就把title这个类名绑定到元素上，否则就绑定一个空的类名（也就是不绑定任何类名）。</p>\n<p>但是这样写三元表达式，代码不优雅，更优雅的方式是，在数组里面我们写上一个对象，就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div :<span class=\"keyword\">class</span>=<span class=\"string\">&quot;[&#x27;fontColor&#x27;,&#123;title:isTrue&#125;]&quot;</span>&gt;</span><br><span class=\"line\">    hhhhhhh</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样是不是就更加优雅了呢？</p>\n<p>示例代码在：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/03_v-bind%E7%BB%91%E5%AE%9Aclass%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95.html\">这里</a></p>\n<h3 id=\"v-bind绑定style\"><a href=\"#v-bind绑定style\" class=\"headerlink\" title=\"v-bind绑定style\"></a>v-bind绑定style</h3><p>CSS Property名可以使用驼峰式(camelCase)或者短横线分隔(kebab-case,记得用引号括起来)的方式来命名。</p>\n<p>同样的绑定方式也有两种：</p>\n<ul>\n<li>对象语法</li>\n<li>数组语法</li>\n</ul>\n<p><strong>对象语法：</strong></p>\n<p>用法：<code>:style=&quot;&#123;属性名:&#39;属性值&#39;&#125;&quot;</code></p>\n<p>可以看到在css属性值哪里有一个单引号，这是必须的，不然vue就会将属性值看做一个变量来解析。</p>\n<p>命名方式：</p>\n<ul>\n<li>驼峰： fontSize</li>\n<li>短横线：font-size,使用短横线这种方式的时候，必须将属性名用引号引起来。</li>\n</ul>\n<p>实例代码：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/04_v-bind%E7%BB%91%E5%AE%9Astyle-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95.html\">这里</a></p>\n<p><strong>数组语法：</strong></p>\n<p>在开发当中，我们想要把多个对象里面的css属性写到一起，我们就可以使用数组的方式，将前面的对象作为数组的元素写到一起：<code>&lt;div :style=&quot;[styleObj,styleObj2]&quot;&gt;哈哈哈哈&lt;/div&gt;</code></p>\n<p>注意：</p>\n<p>如果使用数组语法的时候，如果数组里面对象的css属性有重复的，那么浏览器会根据最后一个（最右边的）属性来渲染。</p>\n<p>示例代码在：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/05_v-bind%E7%BB%91%E5%AE%9Astyle%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95.html\">这里</a></p>\n<h2 id=\"动态绑定属性\"><a href=\"#动态绑定属性\" class=\"headerlink\" title=\"动态绑定属性\"></a>动态绑定属性</h2><p>在某些情况下，我们属性的名称可能也是不固定的：</p>\n<ul>\n<li>前端我们无论绑定src,href,class,style属性名都是固定的。如果属性名称不是固定，我们可以使用<font color=red>:[属性值]&#x3D;’值’</font>的格式来定义，这种绑定的方式，我们称之为动态绑定属性。</li>\n</ul>\n<p>就像这样：</p>\n<p><code>div :[name]=&quot;styleObj&quot;&gt;hhhhhh&lt;/div&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name</span>: <span class=\"string\">&#x27;style&#x27;</span>,</span><br><span class=\"line\"><span class=\"attr\">styleObj</span>: &#123;</span><br><span class=\"line\"><span class=\"attr\">color</span>: <span class=\"string\">&#x27;red&#x27;</span>,</span><br><span class=\"line\"><span class=\"attr\">fontSize</span>: <span class=\"string\">&#x27;40px&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>里面的<code>name</code>可以换成其他的变量。</p>\n<p>示例代码在:<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/06_v-bind%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7.html\">这里</a></p>\n<p>还有一个v-bind直接绑定一个对象：示例看<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/07_v-bind%E7%9B%B4%E6%8E%A5%E7%BB%91%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.html\">这里</a></p>\n<h2 id=\"v-on指令\"><a href=\"#v-on指令\" class=\"headerlink\" title=\"v-on指令\"></a>v-on指令</h2><p><strong>v-on绑定事件：</strong></p>\n<p>前面我们学习了这么多的指令，但是都是一些静态的，在前端开发当中，一个重要的特性就是与用户的交互。这个时候我们就需要用到v-on指令。</p>\n<p>用来监听胡勇大声的时间，比如点击、拖拽、键盘点击事件等等</p>\n<p><strong>v-on的使用：</strong></p>\n<ul>\n<li>简写：@</li>\n<li>预期：Function|Inline Statement | Object</li>\n<li>参数： event</li>\n<li><div id=\"v-on修饰符\">修饰符：</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.stop  调用event.stopPropagation()</span><br><span class=\"line\">.prevent  调用 event.preventDefault()</span><br><span class=\"line\">.capture  添加事件侦听器时使用capture模式</span><br><span class=\"line\">.self  只当事件是从侦听器绑定的元素本身触发时才触发回调</span><br><span class=\"line\">.&#123;keyAlias&#125;  仅当事件是从特定触发时才触发回调</span><br><span class=\"line\">.once   只触发一次回调</span><br><span class=\"line\">.left  只当鼠标点击左键时触发</span><br><span class=\"line\">.right  只当鼠标点击右键时触发</span><br><span class=\"line\">.middle  只当鼠标点击中键时触发</span><br><span class=\"line\">.passive  &#123;passive:true&#125; 模式添加侦听器</span><br></pre></td></tr></table></figure></li>\n<li>绑定事件监听</li>\n</ul>\n<h3 id=\"v-on基本使用\"><a href=\"#v-on基本使用\" class=\"headerlink\" title=\"v-on基本使用\"></a>v-on基本使用</h3><p>一个简单的例子：</p>\n<p><code>&lt;button v-on:click=&quot;add&quot;&gt;点我加一&lt;/button&gt;</code></p>\n<p>这个时候就是一个完整的v-on写法了，在v-on后面加上一个冒号，然后加上事件的类型（此时我们添加的点击事件），然后在后面加上事件要调用的事件函数。</p>\n<p>也有语法糖：</p>\n<p><code>&lt;button @click=&quot;add&quot;&gt;点我加一&lt;/button&gt;</code>:也就是将v-on简写为<code>@</code>.</p>\n<p>如果我们要处理的事件不是很复杂，我们可以直接写一个表达式在等号后面：<code>&lt;button @click=&quot;this.count++&quot;&gt;点我加一&lt;/button&gt;</code></p>\n<p>我们还可以绑定一个对象:</p>\n<p>在绑定对象的时候，语法是这样的：<code>v-on=&#123;&#39;事件类型&#39;:&#39;事件函数&#39;,......&#125;</code></p>\n<p>示例在<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/08_v-on%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html\">这里</a></p>\n<h3 id=\"v-on的参数传递\"><a href=\"#v-on的参数传递\" class=\"headerlink\" title=\"v-on的参数传递\"></a>v-on的参数传递</h3><p>在函数事件当中，可能会需要传递一些参数，这个时候就需要使用到v-on的参数传递。</p>\n<p>在获取事件对象的时候，如果一个事件函数不需要传入其他参数，可以直接不写参数，在事件函数里面可以直接获取到事件对象，就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">btn1Click</span>: <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event);</span><br><span class=\"line\">        &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以拿到事件对象。如果需要传入多个参数，那么这样就不行了。</p>\n<p>就需要像下面这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;btn2Click($event,&#x27;海绵宝宝&#x27;)&quot;</span>&gt;</span>按钮2<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">btn2Click</span>: <span class=\"keyword\">function</span> (<span class=\"params\">event, name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在模板里面我们获取事件对象使用的是<code>$event</code>，这是一个固定写法。</p>\n<p>示例代码在:<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/09_v-on%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.html\">这里</a></p>\n<h3 id=\"v-on修饰符\"><a href=\"#v-on修饰符\" class=\"headerlink\" title=\"v-on修饰符\"></a>v-on修饰符</h3><p>v-on支持修饰符，修饰符相当于对事件进行了一些特殊处理：</p>\n<p>具体修饰符见<a href=\"#v-on%E4%BF%AE%E9%A5%B0%E7%AC%A6\">上面</a></p>\n<p>示例代码在<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/10_v-on%E4%BF%AE%E9%A5%B0%E7%AC%A6.html\">这里</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue3当中的一些基本语法\"><a href=\"#Vue3当中的一些基本语法\" class=\"headerlink\" title=\"Vue3当中的一些基本语法\"></a>Vue3当中的一些基本语法</h1><p>[TOC]</p>\n<h2 id=\"插值语法\"><a href=\"#插值语法\" class=\"headerlink\" title=\"插值语法\"></a>插值语法</h2><p>在vue的模板里面，我们可以使用花括号来实现一个插值语法：</p>\n<p><code>&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</code></p>\n<p>在插值语法里面可以使用vue实例对象data里面的数据，并且可以写一些基本的表达式，不是语句！</p>\n<p>里面可以只是一个变量，也可以对变量进行一些运算（加减乘除等等），也可以使用函数，还可以使用三元表达式。</p>\n<p>但是不能使用语句。</p>\n<h2 id=\"v-once指令\"><a href=\"#v-once指令\" class=\"headerlink\" title=\"v-once指令\"></a>v-once指令</h2><ul>\n<li>v-once指令用于指定元素或者组件只渲染一次：<ul>\n<li>当属局发生变化的时候，元素或者组件以及其所有的子元素，都会被视为静态内容并且跳过。</li>\n<li>该指令可以用于性能优化</li>\n<li>如果是里面的子节点也只会被渲染一次：<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-once</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;counter&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"v-text指令\"><a href=\"#v-text指令\" class=\"headerlink\" title=\"v-text指令\"></a>v-text指令</h2><p>用于更新元素的textContent:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-text</span> = <span class=\"string\">&quot;msg&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">// 等价于</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"v-html指令\"><a href=\"#v-html指令\" class=\"headerlink\" title=\"v-html指令\"></a>v-html指令</h2><p>默认情况下，如果我们展示的内容本身是html的，那么vue并不会对其进行特殊的解析。</p>\n<p>如果我们希望这个html内容可以被vue解析出来，那么我们可以使用v-html来展示。</p>\n<p>用法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-html</span>=<span class=\"string\">&quot;msg&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"v-pre指令\"><a href=\"#v-pre指令\" class=\"headerlink\" title=\"v-pre指令\"></a>v-pre指令</h2><p>v-pre用于跳过元素和他的子元素的编译过程，显示原始的Mustache标签。</p>\n<p>跳过不需要编译的节点，加快编译的速度。</p>\n<p><code>&lt;div v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</code>这样的运行效果就是只会出现message。</p>\n<h2 id=\"v-cloak指令\"><a href=\"#v-cloak指令\" class=\"headerlink\" title=\"v-cloak指令\"></a>v-cloak指令</h2><p>这个指令保持在元素上直到关联组件实例结束编译</p>\n<p>和css规则如[v-cloak]{display:none}一起使用时，这个指令可以隐藏未编译的Mustache标签知道组件实例准备完毕。</p>\n<h2 id=\"v-bind的绑定属性\"><a href=\"#v-bind的绑定属性\" class=\"headerlink\" title=\"v-bind的绑定属性\"></a>v-bind的绑定属性</h2><p>在实际开发当中,除了会动态绑定一些内容之外，我们可能还会需要动态绑定一些属性。这个时候就需要用到v-bind这个属性。</p>\n<ul>\n<li>我们可以动态绑定某个标签的class属性，或者a标签的href属性。</li>\n</ul>\n<p>绑定属性我们使用v-bind：</p>\n<ul>\n<li>缩写：：</li>\n<li>预期： any(with argument)|Object(without argument)</li>\n<li>参数： attr Or Prop(optional)</li>\n<li>修饰符：camel –&gt; 将kebab-case attribute 名转换为camelCase</li>\n<li>用法: 动态地绑定一个或者多个attribute，或者一个组件prop到表达式</li>\n</ul>\n<p>例子：</p>\n<p><code>&lt;a v-bind:href=&quot;url&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/a&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">data</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;我的博客&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">url</span>: <span class=\"string\">&quot;https://www.zmlblog.top&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就把url与超链接的地址给绑定起来了。</p>\n<p>上面是v-bind 的基础使用，也就是原始的写法，但是这样写起来有点麻烦，vue给我们提供了一个语法糖：</p>\n<p><code>&lt;a :href=&quot;url&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/a&gt;</code></p>\n<p>也就是在v-bind可以直接简写为一个<code>:</code>。</p>\n<p>实例在这里：<a href=\"\">这里</a></p>\n<h3 id=\"v-bind绑定class属性\"><a href=\"#v-bind绑定class属性\" class=\"headerlink\" title=\"v-bind绑定class属性\"></a>v-bind绑定class属性</h3><p>在实际开发当中，可能某个元素的class是动态的，处于某个状态的时候，字体颜色为黑色；处于另一个状态的时候，字体颜色为红色。</p>\n<p>这个时候就需要使用v-bind来绑定class，绑定class有两种方式：</p>\n<ul>\n<li>对象语法</li>\n<li>数组语法</li>\n</ul>\n<p><strong>对象语法：<code>&#123;&#39;active&#39;:boolean&#125;</code></strong></p>\n<p>可以看到在对象语法当中前面用引号括起来的就是可以绑定的类名，后面跟上了一个布尔值，当这个布尔值为真的时候，该类名就会被绑定到该元素；如果布尔值为假，那么这个类名就不会被绑定到这个元素上。</p>\n<p>既然是一个对象，那么里面也可以是多个键值对，就像这样：<code>&lt;div v-bind:class=&quot;&#123;&#39;fontColor&#39;:isTrue,&#39;title&#39;:isTrue&#125;&quot;&gt;哈哈哈哈哈哈哈&lt;/div&gt;</code>。<br>示例代码地址：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/02_v-bind%E7%BB%91%E5%AE%9Aclass-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95.html\">这里</a></p>\n<p>在对象语法里面<code>&#123;&#39;active&#39;:boolean&#125;</code>,active是用引号括起来的，当然我们也可以不使用引号，这样的话这个类名就会去data里面寻找，看在data里面有没有active这个变量，然后找到里面存放的类名。</p>\n<p>我们使用v-bind绑定class还可以与静态的class进行结合：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"keyword\">class</span>=<span class=\"string\">&quot;abc&quot;</span> :<span class=\"keyword\">class</span>=<span class=\"string\">&quot;&#123;&#x27;fontColor&#x27;:isTrue,&#x27;title&#x27;:isTrue&#125;&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"number\">123123</span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>最后渲染出来的结果就是类名有：abc fontColor  title</p>\n<p><strong>数组语法：[className,className,三元表达式…..]</strong></p>\n<p><code>&lt;div :class=&quot;[&#39;fontColor&#39;,&#39;title&#39;]&quot;&gt;hhhhhhh&lt;/div&gt;</code></p>\n<p>这样绑定的就是两个类名：fontColor  title</p>\n<p>当然我们也可以去data里面寻找我们需要的类名：</p>\n<p><code>&lt;div :class=&quot;[&#39;fontColor&#39;,title]&quot;&gt;hhhhhhh&lt;/div&gt;</code></p>\n<p>这段代码其中第二个值中代表的类名就需要在data里面寻找</p>\n<p>我们还可以使用三元运算符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div :<span class=\"keyword\">class</span>=<span class=\"string\">&quot;[&#x27;fontColor&#x27;,isTrue?&#x27;title&#x27;:&#x27;&#x27;]&quot;</span>&gt;</span><br><span class=\"line\">    hhhhhhh</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这里我们就会去判断isTrue是否为真，如果为真，那么就把title这个类名绑定到元素上，否则就绑定一个空的类名（也就是不绑定任何类名）。</p>\n<p>但是这样写三元表达式，代码不优雅，更优雅的方式是，在数组里面我们写上一个对象，就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div :<span class=\"keyword\">class</span>=<span class=\"string\">&quot;[&#x27;fontColor&#x27;,&#123;title:isTrue&#125;]&quot;</span>&gt;</span><br><span class=\"line\">    hhhhhhh</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样是不是就更加优雅了呢？</p>\n<p>示例代码在：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/03_v-bind%E7%BB%91%E5%AE%9Aclass%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95.html\">这里</a></p>\n<h3 id=\"v-bind绑定style\"><a href=\"#v-bind绑定style\" class=\"headerlink\" title=\"v-bind绑定style\"></a>v-bind绑定style</h3><p>CSS Property名可以使用驼峰式(camelCase)或者短横线分隔(kebab-case,记得用引号括起来)的方式来命名。</p>\n<p>同样的绑定方式也有两种：</p>\n<ul>\n<li>对象语法</li>\n<li>数组语法</li>\n</ul>\n<p><strong>对象语法：</strong></p>\n<p>用法：<code>:style=&quot;&#123;属性名:&#39;属性值&#39;&#125;&quot;</code></p>\n<p>可以看到在css属性值哪里有一个单引号，这是必须的，不然vue就会将属性值看做一个变量来解析。</p>\n<p>命名方式：</p>\n<ul>\n<li>驼峰： fontSize</li>\n<li>短横线：font-size,使用短横线这种方式的时候，必须将属性名用引号引起来。</li>\n</ul>\n<p>实例代码：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/04_v-bind%E7%BB%91%E5%AE%9Astyle-%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95.html\">这里</a></p>\n<p><strong>数组语法：</strong></p>\n<p>在开发当中，我们想要把多个对象里面的css属性写到一起，我们就可以使用数组的方式，将前面的对象作为数组的元素写到一起：<code>&lt;div :style=&quot;[styleObj,styleObj2]&quot;&gt;哈哈哈哈&lt;/div&gt;</code></p>\n<p>注意：</p>\n<p>如果使用数组语法的时候，如果数组里面对象的css属性有重复的，那么浏览器会根据最后一个（最右边的）属性来渲染。</p>\n<p>示例代码在：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/05_v-bind%E7%BB%91%E5%AE%9Astyle%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95.html\">这里</a></p>\n<h2 id=\"动态绑定属性\"><a href=\"#动态绑定属性\" class=\"headerlink\" title=\"动态绑定属性\"></a>动态绑定属性</h2><p>在某些情况下，我们属性的名称可能也是不固定的：</p>\n<ul>\n<li>前端我们无论绑定src,href,class,style属性名都是固定的。如果属性名称不是固定，我们可以使用<font color=red>:[属性值]&#x3D;’值’</font>的格式来定义，这种绑定的方式，我们称之为动态绑定属性。</li>\n</ul>\n<p>就像这样：</p>\n<p><code>div :[name]=&quot;styleObj&quot;&gt;hhhhhh&lt;/div&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name</span>: <span class=\"string\">&#x27;style&#x27;</span>,</span><br><span class=\"line\"><span class=\"attr\">styleObj</span>: &#123;</span><br><span class=\"line\"><span class=\"attr\">color</span>: <span class=\"string\">&#x27;red&#x27;</span>,</span><br><span class=\"line\"><span class=\"attr\">fontSize</span>: <span class=\"string\">&#x27;40px&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>里面的<code>name</code>可以换成其他的变量。</p>\n<p>示例代码在:<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/06_v-bind%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7.html\">这里</a></p>\n<p>还有一个v-bind直接绑定一个对象：示例看<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/07_v-bind%E7%9B%B4%E6%8E%A5%E7%BB%91%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.html\">这里</a></p>\n<h2 id=\"v-on指令\"><a href=\"#v-on指令\" class=\"headerlink\" title=\"v-on指令\"></a>v-on指令</h2><p><strong>v-on绑定事件：</strong></p>\n<p>前面我们学习了这么多的指令，但是都是一些静态的，在前端开发当中，一个重要的特性就是与用户的交互。这个时候我们就需要用到v-on指令。</p>\n<p>用来监听胡勇大声的时间，比如点击、拖拽、键盘点击事件等等</p>\n<p><strong>v-on的使用：</strong></p>\n<ul>\n<li>简写：@</li>\n<li>预期：Function|Inline Statement | Object</li>\n<li>参数： event</li>\n<li><div id=\"v-on修饰符\">修饰符：</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.stop  调用event.stopPropagation()</span><br><span class=\"line\">.prevent  调用 event.preventDefault()</span><br><span class=\"line\">.capture  添加事件侦听器时使用capture模式</span><br><span class=\"line\">.self  只当事件是从侦听器绑定的元素本身触发时才触发回调</span><br><span class=\"line\">.&#123;keyAlias&#125;  仅当事件是从特定触发时才触发回调</span><br><span class=\"line\">.once   只触发一次回调</span><br><span class=\"line\">.left  只当鼠标点击左键时触发</span><br><span class=\"line\">.right  只当鼠标点击右键时触发</span><br><span class=\"line\">.middle  只当鼠标点击中键时触发</span><br><span class=\"line\">.passive  &#123;passive:true&#125; 模式添加侦听器</span><br></pre></td></tr></table></figure></li>\n<li>绑定事件监听</li>\n</ul>\n<h3 id=\"v-on基本使用\"><a href=\"#v-on基本使用\" class=\"headerlink\" title=\"v-on基本使用\"></a>v-on基本使用</h3><p>一个简单的例子：</p>\n<p><code>&lt;button v-on:click=&quot;add&quot;&gt;点我加一&lt;/button&gt;</code></p>\n<p>这个时候就是一个完整的v-on写法了，在v-on后面加上一个冒号，然后加上事件的类型（此时我们添加的点击事件），然后在后面加上事件要调用的事件函数。</p>\n<p>也有语法糖：</p>\n<p><code>&lt;button @click=&quot;add&quot;&gt;点我加一&lt;/button&gt;</code>:也就是将v-on简写为<code>@</code>.</p>\n<p>如果我们要处理的事件不是很复杂，我们可以直接写一个表达式在等号后面：<code>&lt;button @click=&quot;this.count++&quot;&gt;点我加一&lt;/button&gt;</code></p>\n<p>我们还可以绑定一个对象:</p>\n<p>在绑定对象的时候，语法是这样的：<code>v-on=&#123;&#39;事件类型&#39;:&#39;事件函数&#39;,......&#125;</code></p>\n<p>示例在<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/08_v-on%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html\">这里</a></p>\n<h3 id=\"v-on的参数传递\"><a href=\"#v-on的参数传递\" class=\"headerlink\" title=\"v-on的参数传递\"></a>v-on的参数传递</h3><p>在函数事件当中，可能会需要传递一些参数，这个时候就需要使用到v-on的参数传递。</p>\n<p>在获取事件对象的时候，如果一个事件函数不需要传入其他参数，可以直接不写参数，在事件函数里面可以直接获取到事件对象，就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">btn1Click</span>: <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">                <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event);</span><br><span class=\"line\">        &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以拿到事件对象。如果需要传入多个参数，那么这样就不行了。</p>\n<p>就需要像下面这样写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">&quot;btn2Click($event,&#x27;海绵宝宝&#x27;)&quot;</span>&gt;</span>按钮2<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">btn2Click</span>: <span class=\"keyword\">function</span> (<span class=\"params\">event, name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在模板里面我们获取事件对象使用的是<code>$event</code>，这是一个固定写法。</p>\n<p>示例代码在:<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/09_v-on%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92.html\">这里</a></p>\n<h3 id=\"v-on修饰符\"><a href=\"#v-on修饰符\" class=\"headerlink\" title=\"v-on修饰符\"></a>v-on修饰符</h3><p>v-on支持修饰符，修饰符相当于对事件进行了一些特殊处理：</p>\n<p>具体修饰符见<a href=\"#v-on%E4%BF%AE%E9%A5%B0%E7%AC%A6\">上面</a></p>\n<p>示例代码在<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/03_v-bind%E5%92%8Cv-on%E7%9A%84%E4%BD%BF%E7%94%A8/10_v-on%E4%BF%AE%E9%A5%B0%E7%AC%A6.html\">这里</a></p>\n"},{"title":"Vue中webpack基础打包","data":["2023-2-21"],"categroies":["Vue3"],"_content":"\n# Vue中Webpack基础打包\n\n## 什么是webpack\n\n在前端开发中，我们经常听到工程化这个词语，并且在前端开发中，我们经常会使用一些预编译的框架，比如scss等等，并且还会有导包。这些如果直接放在浏览器中是无法正常运行的。所以我们需要一个工具来帮助我们将这些文件进行打包，这个工具就是webpack。\n\n打包工具不仅仅可以在这些文件转换为浏览器能运行的文件，还可以对这些文件进行压缩，合并等操作。\n\n## Webpack在Vue中需要打包一些什么文件\n\n- 对javascript的打包\n    - 将ES6的语法转换为ES5的语法\n    - 对TypeScript的处理\n- 对CSS的处理\n    - 对CSS文件模块进行加载处理\n    - 对预编译css文件进行处理\n- 资源文件\n    - 图片img的加载\n    - 字体font的加载\n- HTML的处理\n    - 打包HTML文件\n- 处理Vue项目SFC文件\n    - 对.vue文件进行打包\n\n## Webpack的基本配置\n\n在","source":"_posts/Vue3/webpack基础打包.md","raw":"---\ntitle: Vue中webpack基础打包\ndata: [2023-2-21]\ntags: [前端]\ncategroies: [Vue3]\n---\n\n# Vue中Webpack基础打包\n\n## 什么是webpack\n\n在前端开发中，我们经常听到工程化这个词语，并且在前端开发中，我们经常会使用一些预编译的框架，比如scss等等，并且还会有导包。这些如果直接放在浏览器中是无法正常运行的。所以我们需要一个工具来帮助我们将这些文件进行打包，这个工具就是webpack。\n\n打包工具不仅仅可以在这些文件转换为浏览器能运行的文件，还可以对这些文件进行压缩，合并等操作。\n\n## Webpack在Vue中需要打包一些什么文件\n\n- 对javascript的打包\n    - 将ES6的语法转换为ES5的语法\n    - 对TypeScript的处理\n- 对CSS的处理\n    - 对CSS文件模块进行加载处理\n    - 对预编译css文件进行处理\n- 资源文件\n    - 图片img的加载\n    - 字体font的加载\n- HTML的处理\n    - 打包HTML文件\n- 处理Vue项目SFC文件\n    - 对.vue文件进行打包\n\n## Webpack的基本配置\n\n在","slug":"Vue3/webpack基础打包","published":1,"date":"2023-02-21T02:01:03.259Z","updated":"2023-02-21T12:14:50.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjp00849kbmhwnp9vct","content":"<h1 id=\"Vue中Webpack基础打包\"><a href=\"#Vue中Webpack基础打包\" class=\"headerlink\" title=\"Vue中Webpack基础打包\"></a>Vue中Webpack基础打包</h1><h2 id=\"什么是webpack\"><a href=\"#什么是webpack\" class=\"headerlink\" title=\"什么是webpack\"></a>什么是webpack</h2><p>在前端开发中，我们经常听到工程化这个词语，并且在前端开发中，我们经常会使用一些预编译的框架，比如scss等等，并且还会有导包。这些如果直接放在浏览器中是无法正常运行的。所以我们需要一个工具来帮助我们将这些文件进行打包，这个工具就是webpack。</p>\n<p>打包工具不仅仅可以在这些文件转换为浏览器能运行的文件，还可以对这些文件进行压缩，合并等操作。</p>\n<h2 id=\"Webpack在Vue中需要打包一些什么文件\"><a href=\"#Webpack在Vue中需要打包一些什么文件\" class=\"headerlink\" title=\"Webpack在Vue中需要打包一些什么文件\"></a>Webpack在Vue中需要打包一些什么文件</h2><ul>\n<li>对javascript的打包<ul>\n<li>将ES6的语法转换为ES5的语法</li>\n<li>对TypeScript的处理</li>\n</ul>\n</li>\n<li>对CSS的处理<ul>\n<li>对CSS文件模块进行加载处理</li>\n<li>对预编译css文件进行处理</li>\n</ul>\n</li>\n<li>资源文件<ul>\n<li>图片img的加载</li>\n<li>字体font的加载</li>\n</ul>\n</li>\n<li>HTML的处理<ul>\n<li>打包HTML文件</li>\n</ul>\n</li>\n<li>处理Vue项目SFC文件<ul>\n<li>对.vue文件进行打包</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Webpack的基本配置\"><a href=\"#Webpack的基本配置\" class=\"headerlink\" title=\"Webpack的基本配置\"></a>Webpack的基本配置</h2><p>在</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue中Webpack基础打包\"><a href=\"#Vue中Webpack基础打包\" class=\"headerlink\" title=\"Vue中Webpack基础打包\"></a>Vue中Webpack基础打包</h1><h2 id=\"什么是webpack\"><a href=\"#什么是webpack\" class=\"headerlink\" title=\"什么是webpack\"></a>什么是webpack</h2><p>在前端开发中，我们经常听到工程化这个词语，并且在前端开发中，我们经常会使用一些预编译的框架，比如scss等等，并且还会有导包。这些如果直接放在浏览器中是无法正常运行的。所以我们需要一个工具来帮助我们将这些文件进行打包，这个工具就是webpack。</p>\n<p>打包工具不仅仅可以在这些文件转换为浏览器能运行的文件，还可以对这些文件进行压缩，合并等操作。</p>\n<h2 id=\"Webpack在Vue中需要打包一些什么文件\"><a href=\"#Webpack在Vue中需要打包一些什么文件\" class=\"headerlink\" title=\"Webpack在Vue中需要打包一些什么文件\"></a>Webpack在Vue中需要打包一些什么文件</h2><ul>\n<li>对javascript的打包<ul>\n<li>将ES6的语法转换为ES5的语法</li>\n<li>对TypeScript的处理</li>\n</ul>\n</li>\n<li>对CSS的处理<ul>\n<li>对CSS文件模块进行加载处理</li>\n<li>对预编译css文件进行处理</li>\n</ul>\n</li>\n<li>资源文件<ul>\n<li>图片img的加载</li>\n<li>字体font的加载</li>\n</ul>\n</li>\n<li>HTML的处理<ul>\n<li>打包HTML文件</li>\n</ul>\n</li>\n<li>处理Vue项目SFC文件<ul>\n<li>对.vue文件进行打包</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Webpack的基本配置\"><a href=\"#Webpack的基本配置\" class=\"headerlink\" title=\"Webpack的基本配置\"></a>Webpack的基本配置</h2><p>在</p>\n"},{"title":"CSS中的盒子模型","date":"2023-04-03T16:00:00.000Z","_content":"\n# CSS中的盒子模型\n\n在网页中，可以把每一个元素都看做一个盒子。\n\n每个盒子包含内容、内边距、边框、外边距这四个部分。\n\n## 边框（border）\n\n边框的方向有四个：top、right、bottom、left。\n\n边框属性：\n\n- 边框的厚度：`border-width` \n\t- value: 与之前设置长度的方式一样\n- 边框的样式：`border-style`\n\t- none(无) dotted（虚线） solid（实线） double（双实线）\n- 边框的颜色：`border-color`\n\t- 与其他设置颜色的方式一样\n\n简写方式：\n\n- border-width: value1 value2 value3 value4;\n\t- 此时的作用顺序为:上右下左。\n- border-width: value1 value2;\n\t- 此时的作用顺序为：value1 上下、value2 左右。\n- border-width: value1 value2 value3;\n\t- 此时的作用顺序为： value1  上部、value2  左右 、value3 下部。 \n\nborder的综合写法：\n\n```CSS\nborder: width style color;\n```\n","source":"_posts/双体web/CSS.md","raw":"---\ntitle: CSS中的盒子模型\ndate: [2023-4-4]\ntags: [前端]\ncategories: [CSS]\n---\n\n# CSS中的盒子模型\n\n在网页中，可以把每一个元素都看做一个盒子。\n\n每个盒子包含内容、内边距、边框、外边距这四个部分。\n\n## 边框（border）\n\n边框的方向有四个：top、right、bottom、left。\n\n边框属性：\n\n- 边框的厚度：`border-width` \n\t- value: 与之前设置长度的方式一样\n- 边框的样式：`border-style`\n\t- none(无) dotted（虚线） solid（实线） double（双实线）\n- 边框的颜色：`border-color`\n\t- 与其他设置颜色的方式一样\n\n简写方式：\n\n- border-width: value1 value2 value3 value4;\n\t- 此时的作用顺序为:上右下左。\n- border-width: value1 value2;\n\t- 此时的作用顺序为：value1 上下、value2 左右。\n- border-width: value1 value2 value3;\n\t- 此时的作用顺序为： value1  上部、value2  左右 、value3 下部。 \n\nborder的综合写法：\n\n```CSS\nborder: width style color;\n```\n","slug":"双体web/CSS","published":1,"updated":"2023-04-06T06:27:15.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjr00889kbm6ngmae0j","content":"<h1 id=\"CSS中的盒子模型\"><a href=\"#CSS中的盒子模型\" class=\"headerlink\" title=\"CSS中的盒子模型\"></a>CSS中的盒子模型</h1><p>在网页中，可以把每一个元素都看做一个盒子。</p>\n<p>每个盒子包含内容、内边距、边框、外边距这四个部分。</p>\n<h2 id=\"边框（border）\"><a href=\"#边框（border）\" class=\"headerlink\" title=\"边框（border）\"></a>边框（border）</h2><p>边框的方向有四个：top、right、bottom、left。</p>\n<p>边框属性：</p>\n<ul>\n<li>边框的厚度：<code>border-width</code> <ul>\n<li>value: 与之前设置长度的方式一样</li>\n</ul>\n</li>\n<li>边框的样式：<code>border-style</code><ul>\n<li>none(无) dotted（虚线） solid（实线） double（双实线）</li>\n</ul>\n</li>\n<li>边框的颜色：<code>border-color</code><ul>\n<li>与其他设置颜色的方式一样</li>\n</ul>\n</li>\n</ul>\n<p>简写方式：</p>\n<ul>\n<li>border-width: value1 value2 value3 value4;<ul>\n<li>此时的作用顺序为:上右下左。</li>\n</ul>\n</li>\n<li>border-width: value1 value2;<ul>\n<li>此时的作用顺序为：value1 上下、value2 左右。</li>\n</ul>\n</li>\n<li>border-width: value1 value2 value3;<ul>\n<li>此时的作用顺序为： value1  上部、value2  左右 、value3 下部。</li>\n</ul>\n</li>\n</ul>\n<p>border的综合写法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">border</span>: width style color;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS中的盒子模型\"><a href=\"#CSS中的盒子模型\" class=\"headerlink\" title=\"CSS中的盒子模型\"></a>CSS中的盒子模型</h1><p>在网页中，可以把每一个元素都看做一个盒子。</p>\n<p>每个盒子包含内容、内边距、边框、外边距这四个部分。</p>\n<h2 id=\"边框（border）\"><a href=\"#边框（border）\" class=\"headerlink\" title=\"边框（border）\"></a>边框（border）</h2><p>边框的方向有四个：top、right、bottom、left。</p>\n<p>边框属性：</p>\n<ul>\n<li>边框的厚度：<code>border-width</code> <ul>\n<li>value: 与之前设置长度的方式一样</li>\n</ul>\n</li>\n<li>边框的样式：<code>border-style</code><ul>\n<li>none(无) dotted（虚线） solid（实线） double（双实线）</li>\n</ul>\n</li>\n<li>边框的颜色：<code>border-color</code><ul>\n<li>与其他设置颜色的方式一样</li>\n</ul>\n</li>\n</ul>\n<p>简写方式：</p>\n<ul>\n<li>border-width: value1 value2 value3 value4;<ul>\n<li>此时的作用顺序为:上右下左。</li>\n</ul>\n</li>\n<li>border-width: value1 value2;<ul>\n<li>此时的作用顺序为：value1 上下、value2 左右。</li>\n</ul>\n</li>\n<li>border-width: value1 value2 value3;<ul>\n<li>此时的作用顺序为： value1  上部、value2  左右 、value3 下部。</li>\n</ul>\n</li>\n</ul>\n<p>border的综合写法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">border</span>: width style color;</span><br></pre></td></tr></table></figure>\n"},{"title":"vue基础之模板语法2","data":"2023-1-25","_content":"\n# Vue基础之模板语法（二）\n\n[TOC]\n\n## 条件渲染\n\n在某些情况下，我们需要根据当前的条件决定某些元素或者组件是否渲染，这个时候我们就需要进行条件判断。\n\nvue提供了下面的几个指令来进行条件判断：\n\n- v-if\n- v-elseb\n- v-else-if\n- v-show\n\n### v-if  v-else  v-else-if\n\n这三个指令都是根据条件来渲染某一块的内容，这些内容只有条件为true的时候，才会渲染出来；这三个指令与JavaScript的条件语句if  else  else if类似。\n\n多个条件判断例子：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/02_%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93.html)\n\n**v-if的渲染原理：**\n\n- v-if是惰性的\n- 当条件为false的时候，他里面内容不会被渲染或者被销毁掉\n- 当条件为true的时候，才会真正的渲染里面的内容\n\n### Template元素\n\n因为v-if是一个指令，所以必须将其添加到一个元素上面：\n\n- 但是如果我们希望切换的是多个元素的时候，我们之前使用的div来切换，但是我们并不希望div这种元素被渲染，这个时候就可以用到template元素。\n\n示例代码在：[这里]()\n\n### v-show\n\nv-show与v-if的用法看起来是一样的，同样也是根据一个条件决定是否显示元素或者组件\n\n示例代码地址：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/04_v-show%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html)\n\n### v-if与v-show的区别：\n\n当他们判断条件都为真的时候没有什么区别，真正的区别在于他们判断条件为false的时候，我们可以看到在v-if中，源代码是找不到这个html标签的，但是在v-show里面，我们可以看到源代码里面有这样一个标签，并且设置的样式为`display:none`，也就是说使用v-show的时候，这个标签一直都存在。\n\n**注意：**\n\n- 用法上的区别：\n  - v-show是不支持template的\n  - v-show不可以与v-else一起使用\n- 本质的区别：\n  - v-show元素无论是否需要渲染到浏览器上，它的DOM实际上一直都在渲染，只是通过CSS的display属性隐藏起来了\n  - v-if条件为false的时候，其对应的元素压根不会渲染到DOM当中\n\n也就是说如果v-if的条件为假，那么这个元素根本不会渲染，那么如果某个元素对于显示与隐藏的切换不频繁，那么使用v-if更加节约性能；如果某个元素切换比较频繁，那么使用v-show更加节约性能。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69bb0d345ac465ca8e3ae4a01366f7a~tplv-k3u1fbpfcp-watermark.image?)\n\n示例代码在：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/05_v-if%E4%B8%8Ev-show%E7%9A%84%E5%8C%BA%E5%88%AB.html)\n\n## 列表渲染\n\n在实际的开发当中，我们可能会从服务器拿到一些数据，需要用列表的形式展示出来，这个时候我们就需要使用列表渲染。\n\n在vue当中，列表渲染需要使用到v-for，v-for就类似于JavaScript中的for循环，可以用来遍历一组数据。\n\n### v-for基本使用\n\n**v-for遍历数组：**\n\nv-for的基本格式是：`item in 数组`\n\n- 数组通常是来自data或者prop，也可以是其他方式\n- item是我们给每项元素起的一个别名，这个别名可以自定义\n\n语法示例：\n\n```html\n<ul>\n    <li v-for=\"num in arr\">{{num}}</li>\n</ul>\n```\n\n这里我们只获取到了数组里面的内容，要是我们还想获取索引怎么办呢？我们可以这样操作：\n\n```html\n<ol>\n    <li v-for=\"(num,index) in arr\">{{num}},{{index}}</li>\n</ol>\n```\n\n就是在前面加上一个括号，括号里面有两个参数，第一个就是我们获取的内容，第二个参数就是我们的索引。\n\n**v-for遍历对象：**\n\n前面我们了解了如何使用v-for遍历一个数组，其实v-for还可以用来遍历对象：\n\n`v-for=\"item in Obj\"`\n\n众所周知，在对象里面有key-value键值对，那么我们v-for第一个参数(item)拿到的是什么呢？\n\n答案是对象里面的value。\n\n想要拿到key，那么我们就可以这样操作：\n\n```html\n<ol>\n    <li v-for=\"(value,key) in obj\">{{key}}:{{value}}</li>\n</ol>\n```\n\n这样就拿到了key，如果想要拿到索引，我们可以接着看：\n\n```html\n<ol>\n    <li v-for=\"(value,key,index) in obj\">{{index}}--{{key}}:{{value}}</li>\n</ol>\n```\n\n这样第一个参数代表值，第二个参数代表键名，第三个参数代表索引。\n\n**v-for遍历数字：**\n\n也就是我们把原来放数组/对象那个位置，换成一个数字，那么v-for就会从1开始，一直遍历到你指定的那个数字：\n\n`<div v-for=\"number in 10\">{{number}}</div>`\n\n这段代码就是从1开始，一直遍历到10结束。\n\n同样的，我们想要获取索引，和之前的方法一样：`<div v-for=\"(number,index) in 10\">{{index}}--{{number}}</div>`\n\nv-for示例代码在这里：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/05_%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/01_v-for%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html)\n\n### v-for里面的template元素\n\n在渲染过程中，我们需要一个父级元素来遍历，然后用子元素来展示内容分，这个时候我们就会把那个父级元素用template来替换：\n\n```html\n<template v-for=\"(value,key) in message\">\n    <div>{{key}}:</div>\n    <div>{{value}}</div>\n    <hr>\n</template>\n```\n\n示例代码：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/05_%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/02_v-for%E4%B8%8Etamplate.html)\n\n### v-for一些小补充\n\n1. 数组更新检测\n\n在vue中，vue将数组一些方法进行了包裹，也就是说我们在vue中使用了这些方法，vue的视图会自动更新数组，然后重新渲染到页面上。这些被包裹的方法包括：\n\n- push()\n- pop()\n- shift()\n- unshift()\n- splice()\n- sort()\n- reverse()\n\n上面的方法会直接修改原来的数组，但是某些方法不会替换员阿里的数组，而是会生成新的数组，比如：filter()、concat()、slice()\n\n2. v-for中key的作用\n\n在使用v-for进行列表渲染的时候，我们通常会给元素或者组件绑定一个key属性\n\n首先我们来看什么是VNode：\n\n- 目前我们还没有学习到组件，所以我们现在可以把VNode理解为HTML元素创建出来的VNode。\n- VNode的全称是 Virtual Node，也就是虚拟节点，真实节点就是我们html文档里面DOM\n- 事实上，无论是组件还是元素，他们在vue中表现出来的都是一个一个的VNode。\n- VNode的本质就是一个JavaScript的对象，但是这个对象可以用来描述这个DOM\n- vue中template会先转换成VNode然后在渲染成真实DOM，最后展示到页面上。\n\n再来看看什么是虚拟DOM\n\n- 如果我们vue模板里面不止一个简单的div，还有一些其他的标签，这样一大堆元素，就会形成一个VNode Tree\n\n这里我们来看一个数组插入元素的案例：\n\n我们想在数组中间插入一个元素：\n\n原数组是这样的:`arr: ['a', 'b', 'c', 'd']`，然后我们给数组中间插入一个`f`，我们定义一个方法：\n\n```js\n insert: function () {\n    this.arr.splice(2, 0, 'f');\n}\n```\n\nvue是如何去更新这个视图的呢？\n\n我们可以猜测一下，是把整个数组重新渲染吗？这样难免太消耗性能了，其实vue使用的是diff算法，就是将旧的VNodes与新的VNodes进行对比，将不同的地方改掉，而不需要将整个数组重新渲染。\n\n在vue中会根据有没有key调用两个不同的方法：\n\n- 有key，那么就使用patchKeyedChildren方法\n- 没有key,那么就使用patchUnKeyedChildren方法","source":"_posts/Vue3/vue基础之模板语法2.md","raw":"---\ntitle: vue基础之模板语法2\ndata: 2023-1-25\ntags: [前端]\ncategories: [Vue3]\n---\n\n# Vue基础之模板语法（二）\n\n[TOC]\n\n## 条件渲染\n\n在某些情况下，我们需要根据当前的条件决定某些元素或者组件是否渲染，这个时候我们就需要进行条件判断。\n\nvue提供了下面的几个指令来进行条件判断：\n\n- v-if\n- v-elseb\n- v-else-if\n- v-show\n\n### v-if  v-else  v-else-if\n\n这三个指令都是根据条件来渲染某一块的内容，这些内容只有条件为true的时候，才会渲染出来；这三个指令与JavaScript的条件语句if  else  else if类似。\n\n多个条件判断例子：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/02_%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93.html)\n\n**v-if的渲染原理：**\n\n- v-if是惰性的\n- 当条件为false的时候，他里面内容不会被渲染或者被销毁掉\n- 当条件为true的时候，才会真正的渲染里面的内容\n\n### Template元素\n\n因为v-if是一个指令，所以必须将其添加到一个元素上面：\n\n- 但是如果我们希望切换的是多个元素的时候，我们之前使用的div来切换，但是我们并不希望div这种元素被渲染，这个时候就可以用到template元素。\n\n示例代码在：[这里]()\n\n### v-show\n\nv-show与v-if的用法看起来是一样的，同样也是根据一个条件决定是否显示元素或者组件\n\n示例代码地址：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/04_v-show%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html)\n\n### v-if与v-show的区别：\n\n当他们判断条件都为真的时候没有什么区别，真正的区别在于他们判断条件为false的时候，我们可以看到在v-if中，源代码是找不到这个html标签的，但是在v-show里面，我们可以看到源代码里面有这样一个标签，并且设置的样式为`display:none`，也就是说使用v-show的时候，这个标签一直都存在。\n\n**注意：**\n\n- 用法上的区别：\n  - v-show是不支持template的\n  - v-show不可以与v-else一起使用\n- 本质的区别：\n  - v-show元素无论是否需要渲染到浏览器上，它的DOM实际上一直都在渲染，只是通过CSS的display属性隐藏起来了\n  - v-if条件为false的时候，其对应的元素压根不会渲染到DOM当中\n\n也就是说如果v-if的条件为假，那么这个元素根本不会渲染，那么如果某个元素对于显示与隐藏的切换不频繁，那么使用v-if更加节约性能；如果某个元素切换比较频繁，那么使用v-show更加节约性能。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69bb0d345ac465ca8e3ae4a01366f7a~tplv-k3u1fbpfcp-watermark.image?)\n\n示例代码在：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/05_v-if%E4%B8%8Ev-show%E7%9A%84%E5%8C%BA%E5%88%AB.html)\n\n## 列表渲染\n\n在实际的开发当中，我们可能会从服务器拿到一些数据，需要用列表的形式展示出来，这个时候我们就需要使用列表渲染。\n\n在vue当中，列表渲染需要使用到v-for，v-for就类似于JavaScript中的for循环，可以用来遍历一组数据。\n\n### v-for基本使用\n\n**v-for遍历数组：**\n\nv-for的基本格式是：`item in 数组`\n\n- 数组通常是来自data或者prop，也可以是其他方式\n- item是我们给每项元素起的一个别名，这个别名可以自定义\n\n语法示例：\n\n```html\n<ul>\n    <li v-for=\"num in arr\">{{num}}</li>\n</ul>\n```\n\n这里我们只获取到了数组里面的内容，要是我们还想获取索引怎么办呢？我们可以这样操作：\n\n```html\n<ol>\n    <li v-for=\"(num,index) in arr\">{{num}},{{index}}</li>\n</ol>\n```\n\n就是在前面加上一个括号，括号里面有两个参数，第一个就是我们获取的内容，第二个参数就是我们的索引。\n\n**v-for遍历对象：**\n\n前面我们了解了如何使用v-for遍历一个数组，其实v-for还可以用来遍历对象：\n\n`v-for=\"item in Obj\"`\n\n众所周知，在对象里面有key-value键值对，那么我们v-for第一个参数(item)拿到的是什么呢？\n\n答案是对象里面的value。\n\n想要拿到key，那么我们就可以这样操作：\n\n```html\n<ol>\n    <li v-for=\"(value,key) in obj\">{{key}}:{{value}}</li>\n</ol>\n```\n\n这样就拿到了key，如果想要拿到索引，我们可以接着看：\n\n```html\n<ol>\n    <li v-for=\"(value,key,index) in obj\">{{index}}--{{key}}:{{value}}</li>\n</ol>\n```\n\n这样第一个参数代表值，第二个参数代表键名，第三个参数代表索引。\n\n**v-for遍历数字：**\n\n也就是我们把原来放数组/对象那个位置，换成一个数字，那么v-for就会从1开始，一直遍历到你指定的那个数字：\n\n`<div v-for=\"number in 10\">{{number}}</div>`\n\n这段代码就是从1开始，一直遍历到10结束。\n\n同样的，我们想要获取索引，和之前的方法一样：`<div v-for=\"(number,index) in 10\">{{index}}--{{number}}</div>`\n\nv-for示例代码在这里：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/05_%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/01_v-for%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html)\n\n### v-for里面的template元素\n\n在渲染过程中，我们需要一个父级元素来遍历，然后用子元素来展示内容分，这个时候我们就会把那个父级元素用template来替换：\n\n```html\n<template v-for=\"(value,key) in message\">\n    <div>{{key}}:</div>\n    <div>{{value}}</div>\n    <hr>\n</template>\n```\n\n示例代码：[这里](https://github.com/zml212/vue3_learn/blob/master/learn_vue3/05_%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/02_v-for%E4%B8%8Etamplate.html)\n\n### v-for一些小补充\n\n1. 数组更新检测\n\n在vue中，vue将数组一些方法进行了包裹，也就是说我们在vue中使用了这些方法，vue的视图会自动更新数组，然后重新渲染到页面上。这些被包裹的方法包括：\n\n- push()\n- pop()\n- shift()\n- unshift()\n- splice()\n- sort()\n- reverse()\n\n上面的方法会直接修改原来的数组，但是某些方法不会替换员阿里的数组，而是会生成新的数组，比如：filter()、concat()、slice()\n\n2. v-for中key的作用\n\n在使用v-for进行列表渲染的时候，我们通常会给元素或者组件绑定一个key属性\n\n首先我们来看什么是VNode：\n\n- 目前我们还没有学习到组件，所以我们现在可以把VNode理解为HTML元素创建出来的VNode。\n- VNode的全称是 Virtual Node，也就是虚拟节点，真实节点就是我们html文档里面DOM\n- 事实上，无论是组件还是元素，他们在vue中表现出来的都是一个一个的VNode。\n- VNode的本质就是一个JavaScript的对象，但是这个对象可以用来描述这个DOM\n- vue中template会先转换成VNode然后在渲染成真实DOM，最后展示到页面上。\n\n再来看看什么是虚拟DOM\n\n- 如果我们vue模板里面不止一个简单的div，还有一些其他的标签，这样一大堆元素，就会形成一个VNode Tree\n\n这里我们来看一个数组插入元素的案例：\n\n我们想在数组中间插入一个元素：\n\n原数组是这样的:`arr: ['a', 'b', 'c', 'd']`，然后我们给数组中间插入一个`f`，我们定义一个方法：\n\n```js\n insert: function () {\n    this.arr.splice(2, 0, 'f');\n}\n```\n\nvue是如何去更新这个视图的呢？\n\n我们可以猜测一下，是把整个数组重新渲染吗？这样难免太消耗性能了，其实vue使用的是diff算法，就是将旧的VNodes与新的VNodes进行对比，将不同的地方改掉，而不需要将整个数组重新渲染。\n\n在vue中会根据有没有key调用两个不同的方法：\n\n- 有key，那么就使用patchKeyedChildren方法\n- 没有key,那么就使用patchUnKeyedChildren方法","slug":"Vue3/vue基础之模板语法2","published":1,"date":"2023-01-24T05:42:14.538Z","updated":"2023-01-26T03:39:57.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjv008b9kbm2rm3e9v6","content":"<h1 id=\"Vue基础之模板语法（二）\"><a href=\"#Vue基础之模板语法（二）\" class=\"headerlink\" title=\"Vue基础之模板语法（二）\"></a>Vue基础之模板语法（二）</h1><p>[TOC]</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><p>在某些情况下，我们需要根据当前的条件决定某些元素或者组件是否渲染，这个时候我们就需要进行条件判断。</p>\n<p>vue提供了下面的几个指令来进行条件判断：</p>\n<ul>\n<li>v-if</li>\n<li>v-elseb</li>\n<li>v-else-if</li>\n<li>v-show</li>\n</ul>\n<h3 id=\"v-if-v-else-v-else-if\"><a href=\"#v-if-v-else-v-else-if\" class=\"headerlink\" title=\"v-if  v-else  v-else-if\"></a>v-if  v-else  v-else-if</h3><p>这三个指令都是根据条件来渲染某一块的内容，这些内容只有条件为true的时候，才会渲染出来；这三个指令与JavaScript的条件语句if  else  else if类似。</p>\n<p>多个条件判断例子：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/02_%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93.html\">这里</a></p>\n<p><strong>v-if的渲染原理：</strong></p>\n<ul>\n<li>v-if是惰性的</li>\n<li>当条件为false的时候，他里面内容不会被渲染或者被销毁掉</li>\n<li>当条件为true的时候，才会真正的渲染里面的内容</li>\n</ul>\n<h3 id=\"Template元素\"><a href=\"#Template元素\" class=\"headerlink\" title=\"Template元素\"></a>Template元素</h3><p>因为v-if是一个指令，所以必须将其添加到一个元素上面：</p>\n<ul>\n<li>但是如果我们希望切换的是多个元素的时候，我们之前使用的div来切换，但是我们并不希望div这种元素被渲染，这个时候就可以用到template元素。</li>\n</ul>\n<p>示例代码在：<a href=\"\">这里</a></p>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><p>v-show与v-if的用法看起来是一样的，同样也是根据一个条件决定是否显示元素或者组件</p>\n<p>示例代码地址：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/04_v-show%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html\">这里</a></p>\n<h3 id=\"v-if与v-show的区别：\"><a href=\"#v-if与v-show的区别：\" class=\"headerlink\" title=\"v-if与v-show的区别：\"></a>v-if与v-show的区别：</h3><p>当他们判断条件都为真的时候没有什么区别，真正的区别在于他们判断条件为false的时候，我们可以看到在v-if中，源代码是找不到这个html标签的，但是在v-show里面，我们可以看到源代码里面有这样一个标签，并且设置的样式为<code>display:none</code>，也就是说使用v-show的时候，这个标签一直都存在。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>用法上的区别：<ul>\n<li>v-show是不支持template的</li>\n<li>v-show不可以与v-else一起使用</li>\n</ul>\n</li>\n<li>本质的区别：<ul>\n<li>v-show元素无论是否需要渲染到浏览器上，它的DOM实际上一直都在渲染，只是通过CSS的display属性隐藏起来了</li>\n<li>v-if条件为false的时候，其对应的元素压根不会渲染到DOM当中</li>\n</ul>\n</li>\n</ul>\n<p>也就是说如果v-if的条件为假，那么这个元素根本不会渲染，那么如果某个元素对于显示与隐藏的切换不频繁，那么使用v-if更加节约性能；如果某个元素切换比较频繁，那么使用v-show更加节约性能。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69bb0d345ac465ca8e3ae4a01366f7a~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>示例代码在：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/05_v-if%E4%B8%8Ev-show%E7%9A%84%E5%8C%BA%E5%88%AB.html\">这里</a></p>\n<h2 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h2><p>在实际的开发当中，我们可能会从服务器拿到一些数据，需要用列表的形式展示出来，这个时候我们就需要使用列表渲染。</p>\n<p>在vue当中，列表渲染需要使用到v-for，v-for就类似于JavaScript中的for循环，可以用来遍历一组数据。</p>\n<h3 id=\"v-for基本使用\"><a href=\"#v-for基本使用\" class=\"headerlink\" title=\"v-for基本使用\"></a>v-for基本使用</h3><p><strong>v-for遍历数组：</strong></p>\n<p>v-for的基本格式是：<code>item in 数组</code></p>\n<ul>\n<li>数组通常是来自data或者prop，也可以是其他方式</li>\n<li>item是我们给每项元素起的一个别名，这个别名可以自定义</li>\n</ul>\n<p>语法示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;num in arr&quot;</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里我们只获取到了数组里面的内容，要是我们还想获取索引怎么办呢？我们可以这样操作：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(num,index) in arr&quot;</span>&gt;</span>&#123;&#123;num&#125;&#125;,&#123;&#123;index&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>就是在前面加上一个括号，括号里面有两个参数，第一个就是我们获取的内容，第二个参数就是我们的索引。</p>\n<p><strong>v-for遍历对象：</strong></p>\n<p>前面我们了解了如何使用v-for遍历一个数组，其实v-for还可以用来遍历对象：</p>\n<p><code>v-for=&quot;item in Obj&quot;</code></p>\n<p>众所周知，在对象里面有key-value键值对，那么我们v-for第一个参数(item)拿到的是什么呢？</p>\n<p>答案是对象里面的value。</p>\n<p>想要拿到key，那么我们就可以这样操作：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(value,key) in obj&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就拿到了key，如果想要拿到索引，我们可以接着看：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(value,key,index) in obj&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;--&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样第一个参数代表值，第二个参数代表键名，第三个参数代表索引。</p>\n<p><strong>v-for遍历数字：</strong></p>\n<p>也就是我们把原来放数组&#x2F;对象那个位置，换成一个数字，那么v-for就会从1开始，一直遍历到你指定的那个数字：</p>\n<p><code>&lt;div v-for=&quot;number in 10&quot;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;</code></p>\n<p>这段代码就是从1开始，一直遍历到10结束。</p>\n<p>同样的，我们想要获取索引，和之前的方法一样：<code>&lt;div v-for=&quot;(number,index) in 10&quot;&gt;&#123;&#123;index&#125;&#125;--&#123;&#123;number&#125;&#125;&lt;/div&gt;</code></p>\n<p>v-for示例代码在这里：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/05_%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/01_v-for%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html\">这里</a></p>\n<h3 id=\"v-for里面的template元素\"><a href=\"#v-for里面的template元素\" class=\"headerlink\" title=\"v-for里面的template元素\"></a>v-for里面的template元素</h3><p>在渲染过程中，我们需要一个父级元素来遍历，然后用子元素来展示内容分，这个时候我们就会把那个父级元素用template来替换：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(value,key) in message&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;key&#125;&#125;:<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>示例代码：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/05_%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/02_v-for%E4%B8%8Etamplate.html\">这里</a></p>\n<h3 id=\"v-for一些小补充\"><a href=\"#v-for一些小补充\" class=\"headerlink\" title=\"v-for一些小补充\"></a>v-for一些小补充</h3><ol>\n<li>数组更新检测</li>\n</ol>\n<p>在vue中，vue将数组一些方法进行了包裹，也就是说我们在vue中使用了这些方法，vue的视图会自动更新数组，然后重新渲染到页面上。这些被包裹的方法包括：</p>\n<ul>\n<li>push()</li>\n<li>pop()</li>\n<li>shift()</li>\n<li>unshift()</li>\n<li>splice()</li>\n<li>sort()</li>\n<li>reverse()</li>\n</ul>\n<p>上面的方法会直接修改原来的数组，但是某些方法不会替换员阿里的数组，而是会生成新的数组，比如：filter()、concat()、slice()</p>\n<ol start=\"2\">\n<li>v-for中key的作用</li>\n</ol>\n<p>在使用v-for进行列表渲染的时候，我们通常会给元素或者组件绑定一个key属性</p>\n<p>首先我们来看什么是VNode：</p>\n<ul>\n<li>目前我们还没有学习到组件，所以我们现在可以把VNode理解为HTML元素创建出来的VNode。</li>\n<li>VNode的全称是 Virtual Node，也就是虚拟节点，真实节点就是我们html文档里面DOM</li>\n<li>事实上，无论是组件还是元素，他们在vue中表现出来的都是一个一个的VNode。</li>\n<li>VNode的本质就是一个JavaScript的对象，但是这个对象可以用来描述这个DOM</li>\n<li>vue中template会先转换成VNode然后在渲染成真实DOM，最后展示到页面上。</li>\n</ul>\n<p>再来看看什么是虚拟DOM</p>\n<ul>\n<li>如果我们vue模板里面不止一个简单的div，还有一些其他的标签，这样一大堆元素，就会形成一个VNode Tree</li>\n</ul>\n<p>这里我们来看一个数组插入元素的案例：</p>\n<p>我们想在数组中间插入一个元素：</p>\n<p>原数组是这样的:<code>arr: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code>，然后我们给数组中间插入一个<code>f</code>，我们定义一个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"attr\">insert</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span>.<span class=\"title function_\">splice</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>vue是如何去更新这个视图的呢？</p>\n<p>我们可以猜测一下，是把整个数组重新渲染吗？这样难免太消耗性能了，其实vue使用的是diff算法，就是将旧的VNodes与新的VNodes进行对比，将不同的地方改掉，而不需要将整个数组重新渲染。</p>\n<p>在vue中会根据有没有key调用两个不同的方法：</p>\n<ul>\n<li>有key，那么就使用patchKeyedChildren方法</li>\n<li>没有key,那么就使用patchUnKeyedChildren方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue基础之模板语法（二）\"><a href=\"#Vue基础之模板语法（二）\" class=\"headerlink\" title=\"Vue基础之模板语法（二）\"></a>Vue基础之模板语法（二）</h1><p>[TOC]</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><p>在某些情况下，我们需要根据当前的条件决定某些元素或者组件是否渲染，这个时候我们就需要进行条件判断。</p>\n<p>vue提供了下面的几个指令来进行条件判断：</p>\n<ul>\n<li>v-if</li>\n<li>v-elseb</li>\n<li>v-else-if</li>\n<li>v-show</li>\n</ul>\n<h3 id=\"v-if-v-else-v-else-if\"><a href=\"#v-if-v-else-v-else-if\" class=\"headerlink\" title=\"v-if  v-else  v-else-if\"></a>v-if  v-else  v-else-if</h3><p>这三个指令都是根据条件来渲染某一块的内容，这些内容只有条件为true的时候，才会渲染出来；这三个指令与JavaScript的条件语句if  else  else if类似。</p>\n<p>多个条件判断例子：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/02_%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93.html\">这里</a></p>\n<p><strong>v-if的渲染原理：</strong></p>\n<ul>\n<li>v-if是惰性的</li>\n<li>当条件为false的时候，他里面内容不会被渲染或者被销毁掉</li>\n<li>当条件为true的时候，才会真正的渲染里面的内容</li>\n</ul>\n<h3 id=\"Template元素\"><a href=\"#Template元素\" class=\"headerlink\" title=\"Template元素\"></a>Template元素</h3><p>因为v-if是一个指令，所以必须将其添加到一个元素上面：</p>\n<ul>\n<li>但是如果我们希望切换的是多个元素的时候，我们之前使用的div来切换，但是我们并不希望div这种元素被渲染，这个时候就可以用到template元素。</li>\n</ul>\n<p>示例代码在：<a href=\"\">这里</a></p>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><p>v-show与v-if的用法看起来是一样的，同样也是根据一个条件决定是否显示元素或者组件</p>\n<p>示例代码地址：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/04_v-show%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html\">这里</a></p>\n<h3 id=\"v-if与v-show的区别：\"><a href=\"#v-if与v-show的区别：\" class=\"headerlink\" title=\"v-if与v-show的区别：\"></a>v-if与v-show的区别：</h3><p>当他们判断条件都为真的时候没有什么区别，真正的区别在于他们判断条件为false的时候，我们可以看到在v-if中，源代码是找不到这个html标签的，但是在v-show里面，我们可以看到源代码里面有这样一个标签，并且设置的样式为<code>display:none</code>，也就是说使用v-show的时候，这个标签一直都存在。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>用法上的区别：<ul>\n<li>v-show是不支持template的</li>\n<li>v-show不可以与v-else一起使用</li>\n</ul>\n</li>\n<li>本质的区别：<ul>\n<li>v-show元素无论是否需要渲染到浏览器上，它的DOM实际上一直都在渲染，只是通过CSS的display属性隐藏起来了</li>\n<li>v-if条件为false的时候，其对应的元素压根不会渲染到DOM当中</li>\n</ul>\n</li>\n</ul>\n<p>也就是说如果v-if的条件为假，那么这个元素根本不会渲染，那么如果某个元素对于显示与隐藏的切换不频繁，那么使用v-if更加节约性能；如果某个元素切换比较频繁，那么使用v-show更加节约性能。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69bb0d345ac465ca8e3ae4a01366f7a~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>示例代码在：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/04_%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/05_v-if%E4%B8%8Ev-show%E7%9A%84%E5%8C%BA%E5%88%AB.html\">这里</a></p>\n<h2 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h2><p>在实际的开发当中，我们可能会从服务器拿到一些数据，需要用列表的形式展示出来，这个时候我们就需要使用列表渲染。</p>\n<p>在vue当中，列表渲染需要使用到v-for，v-for就类似于JavaScript中的for循环，可以用来遍历一组数据。</p>\n<h3 id=\"v-for基本使用\"><a href=\"#v-for基本使用\" class=\"headerlink\" title=\"v-for基本使用\"></a>v-for基本使用</h3><p><strong>v-for遍历数组：</strong></p>\n<p>v-for的基本格式是：<code>item in 数组</code></p>\n<ul>\n<li>数组通常是来自data或者prop，也可以是其他方式</li>\n<li>item是我们给每项元素起的一个别名，这个别名可以自定义</li>\n</ul>\n<p>语法示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;num in arr&quot;</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里我们只获取到了数组里面的内容，要是我们还想获取索引怎么办呢？我们可以这样操作：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(num,index) in arr&quot;</span>&gt;</span>&#123;&#123;num&#125;&#125;,&#123;&#123;index&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>就是在前面加上一个括号，括号里面有两个参数，第一个就是我们获取的内容，第二个参数就是我们的索引。</p>\n<p><strong>v-for遍历对象：</strong></p>\n<p>前面我们了解了如何使用v-for遍历一个数组，其实v-for还可以用来遍历对象：</p>\n<p><code>v-for=&quot;item in Obj&quot;</code></p>\n<p>众所周知，在对象里面有key-value键值对，那么我们v-for第一个参数(item)拿到的是什么呢？</p>\n<p>答案是对象里面的value。</p>\n<p>想要拿到key，那么我们就可以这样操作：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(value,key) in obj&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就拿到了key，如果想要拿到索引，我们可以接着看：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(value,key,index) in obj&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;--&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样第一个参数代表值，第二个参数代表键名，第三个参数代表索引。</p>\n<p><strong>v-for遍历数字：</strong></p>\n<p>也就是我们把原来放数组&#x2F;对象那个位置，换成一个数字，那么v-for就会从1开始，一直遍历到你指定的那个数字：</p>\n<p><code>&lt;div v-for=&quot;number in 10&quot;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;</code></p>\n<p>这段代码就是从1开始，一直遍历到10结束。</p>\n<p>同样的，我们想要获取索引，和之前的方法一样：<code>&lt;div v-for=&quot;(number,index) in 10&quot;&gt;&#123;&#123;index&#125;&#125;--&#123;&#123;number&#125;&#125;&lt;/div&gt;</code></p>\n<p>v-for示例代码在这里：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/05_%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/01_v-for%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html\">这里</a></p>\n<h3 id=\"v-for里面的template元素\"><a href=\"#v-for里面的template元素\" class=\"headerlink\" title=\"v-for里面的template元素\"></a>v-for里面的template元素</h3><p>在渲染过程中，我们需要一个父级元素来遍历，然后用子元素来展示内容分，这个时候我们就会把那个父级元素用template来替换：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;(value,key) in message&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;key&#125;&#125;:<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>示例代码：<a href=\"https://github.com/zml212/vue3_learn/blob/master/learn_vue3/05_%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/02_v-for%E4%B8%8Etamplate.html\">这里</a></p>\n<h3 id=\"v-for一些小补充\"><a href=\"#v-for一些小补充\" class=\"headerlink\" title=\"v-for一些小补充\"></a>v-for一些小补充</h3><ol>\n<li>数组更新检测</li>\n</ol>\n<p>在vue中，vue将数组一些方法进行了包裹，也就是说我们在vue中使用了这些方法，vue的视图会自动更新数组，然后重新渲染到页面上。这些被包裹的方法包括：</p>\n<ul>\n<li>push()</li>\n<li>pop()</li>\n<li>shift()</li>\n<li>unshift()</li>\n<li>splice()</li>\n<li>sort()</li>\n<li>reverse()</li>\n</ul>\n<p>上面的方法会直接修改原来的数组，但是某些方法不会替换员阿里的数组，而是会生成新的数组，比如：filter()、concat()、slice()</p>\n<ol start=\"2\">\n<li>v-for中key的作用</li>\n</ol>\n<p>在使用v-for进行列表渲染的时候，我们通常会给元素或者组件绑定一个key属性</p>\n<p>首先我们来看什么是VNode：</p>\n<ul>\n<li>目前我们还没有学习到组件，所以我们现在可以把VNode理解为HTML元素创建出来的VNode。</li>\n<li>VNode的全称是 Virtual Node，也就是虚拟节点，真实节点就是我们html文档里面DOM</li>\n<li>事实上，无论是组件还是元素，他们在vue中表现出来的都是一个一个的VNode。</li>\n<li>VNode的本质就是一个JavaScript的对象，但是这个对象可以用来描述这个DOM</li>\n<li>vue中template会先转换成VNode然后在渲染成真实DOM，最后展示到页面上。</li>\n</ul>\n<p>再来看看什么是虚拟DOM</p>\n<ul>\n<li>如果我们vue模板里面不止一个简单的div，还有一些其他的标签，这样一大堆元素，就会形成一个VNode Tree</li>\n</ul>\n<p>这里我们来看一个数组插入元素的案例：</p>\n<p>我们想在数组中间插入一个元素：</p>\n<p>原数组是这样的:<code>arr: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code>，然后我们给数组中间插入一个<code>f</code>，我们定义一个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"attr\">insert</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span>.<span class=\"title function_\">splice</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>vue是如何去更新这个视图的呢？</p>\n<p>我们可以猜测一下，是把整个数组重新渲染吗？这样难免太消耗性能了，其实vue使用的是diff算法，就是将旧的VNodes与新的VNodes进行对比，将不同的地方改掉，而不需要将整个数组重新渲染。</p>\n<p>在vue中会根据有没有key调用两个不同的方法：</p>\n<ul>\n<li>有key，那么就使用patchKeyedChildren方法</li>\n<li>没有key,那么就使用patchUnKeyedChildren方法</li>\n</ul>\n"},{"title":"canvas基本使用","date":"2023-01-13T16:00:00.000Z","_content":"# canvas\n[TOC]\n## 使用canvas\n\ncanvas其实是html里面的一个标签，所以要是用canvas,必须先在html文档里面写一个canvas标签。\n\n```html\n\t<!-- canvas在低版本浏览器中有兼容性问题，需要提示用户 -->\n    <canvas width=\"500px\" height=\"400px\">\n        您的浏览器版本过低，无法使用canvas\n    </canvas>\n```\n在canvas标签里面，我们可以直接设置canvas元素的大小，这是canvas元素自带的属性，虽然我们也可以在css里面进行更改，但是不推荐，这样会导致一些奇奇怪怪的bug。\n\n但是canvas是HTML5才有的标签，所以就会存在一个兼容性问题，这个时候我们就需要提示用户：在canvas标签里面写上提示信息。\n\n这样如果该浏览器不支持canvas就会显示我们的提示信息，但是如果该浏览器支持canvas就不会显示该提示信息。\n\n### 使用canvas画一条直线\n这里需要使用到JavaScript。\n\n分为下面这几步：\n\n- 获取到canvas元素\n- 获取到canvas元素的上下文\n- 开启一条路径\n- 设置路径的起点\n- 设置路径的终点\n- 给直线上色\n- 关闭路径\n\n下面用代码来实现一下：\n```js\n\t// 获取到canvas元素\n    var canvas = document.querySelector('canvas');\n    // 获取到canvas操作权限（获取画布的上下文）\n    var c = canvas.getContext('2d');\n    // 开启一条路径\n    c.beginPath();\n    // 设置路径的起点\n    c.moveTo(0, 0);\n    // 设置路径终点\n    c.lineTo(500, 400);\n    // 进行上色\n    c.stroke();\n    // 关闭路径\n    c.closePath();\n```\n结果如下图：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d553a403ac14cc3bbecb30819e045f4~tplv-k3u1fbpfcp-watermark.image?)\n\n这里注意，对canvas操作的时候，只能使用原生的JavaScript，不能使用jQuery等js库。\n\n## 常用的方法和属性\n\n### 1.画直线\n\n- beginPath()   开启一个路径\n- closePath()   关闭一个路径\n- moveTo(x,y)  定义线条的开始坐标（x为横坐标，y为纵坐标）\n- lineTo(x,y)  定义线条的结束坐标  （x为横坐标，y为纵坐标）\n- strokeStyle  属性设置或者返回用于笔触的颜色、渐变或者模式\n- stroke  绘制一条路径\n- lineWidth  设置线宽\n\n注意：设置颜色和线宽的时候，需要在上色之前进行。\n\n示例：\n\n```js\n// 获取到canvas元素\n    var canvas = document.querySelector('canvas');\n    // 获取到canvas操作权限（获取画布的上下文）\n    var c = canvas.getContext('2d');\n\n\n    // 开启一条路径\n    c.beginPath();\n    // 设置路径的起点\n    c.moveTo(100, 100);\n    // 设置路径终点\n    c.lineTo(200, 200);\n\t// 设置直线颜色宽度\n    c.strokeStyle = \"red\";\n    c.lineWidth = 10;\n    // 进行上色\n    c.stroke();\n    // 关闭路径\n    c.closePath();\n```\n\n效果图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb0d7291a0541cdbc739930ddf5b392~tplv-k3u1fbpfcp-watermark.image?)\n\n在给直线设置颜色的时候需要加上引号，我们可以按照css设置颜色的当时进行设置：可以写颜色名、十六进制、rgb等等。\n\n同时设置线宽的时候不要加上单位，也不需要加上引号。\n\n### 2.画圆\n\n画圆需要用到的方法：\n|                 方法                 |            描述            |\n| :----------------------------------: | :------------------------: |\n|             beginPath()              |        开启一条路径        |\n| arc(x,y,r,startDeg,endDeg,direction) | 画圆的方法，参数解释在下面 |\n|             strokeStyle              |          描边颜色          |\n|              fillStyle               |          填充颜色          |\n|               stroke()               |          结束描边          |\n|                fill()                |          结束填充          |\n|             closePath()              |          关闭路径          |\n\n- arc(x,y,r,startDeg,endDeg,direction)方法参数：\n\t- x: 圆心所在位置的恒左边\n\t- y:圆心所在位置的纵坐标\n\t- r:所绘制圆的半径\n\t- startDeg:所绘制圆的起始位置（通常用Math.PI来计算）\n\t- endDeg:所绘制圆的结束位置（通常用Math.PI来计算）\n\t- direction:绘制方向，这里只有两个值，false表示顺时针方向绘制；true表示逆时针方向绘制。\n\n- fill()与stroke()的区别：\n\t- fill():是对整个图形的内部进行填充颜色\n\t- stroke():是对图形的边框进行描边上色\n\n例子时间：\n\n1. 使用描边：\n\n```js\n\tvar canvas = document.getElementsByTagName('canvas')[0];\n    var c = canvas.getContext('2d');\n    c.beginPath();\n    c.arc(200, 200, 50, 0, Math.PI * 2, false);\n    c.strokeStyle = \"red\";\n    c.stroke();\n    c.closePath();\n```\n\n为了节约篇幅，此处没有html代码`canvas宽高为400*400`。css中我设置一个1px的边框以及`#ccc`的背景颜色\n\n效果就是这样：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0985341f21fc450082fb70a497722658~tplv-k3u1fbpfcp-watermark.image?)\n\n这里我们圆心位置在（200,200）位置，然后半径为50px，起始点从0度开始（在这里起始点在3点钟方向，下面我们可以验证一下），Math.PI表示180度，所以一个完整的圆是Math.PI*2。\n\n下面来验证起始点为0的情况，起始点的位置。\n\n```js\n\tvar canvas = document.getElementsByTagName('canvas')[0];\n    var c = canvas.getContext('2d');\n    c.beginPath();\n    c.arc(200, 200, 50, 0, Math.PI * 1, false);\n    c.strokeStyle = \"red\";\n    c.stroke();\n    c.closePath();\n```\n\n效果图：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e84bb0461fe4ba2b9717523136cc5be~tplv-k3u1fbpfcp-watermark.image?)\n\n因为绘制方向我们选择的false,所以是顺时针绘制。在效果图可以看到当起点位置为0的时候，起始点就是在3点钟方向。\n\n### 3.画矩形\n\n绘制矩形的方法：\n\n开始路径与结束路径以及描边填充颜色都与上面的一样，我这里就不再赘述了。\n\n绘制矩形同样也有两个方法，一种只有边框，一种直接填充。\n\n|             方法             |         描述         |\n| :--------------------------: | :------------------: |\n|    fillStyle/strokeStyle     | 设置填充或者描边颜色 |\n|  fillRect(x,y,width,height)  |   绘制矩形（填充）   |\n| storkeRect(x,y,width,height) |   绘制矩形（描边）   |\n\n参数解释：\n- 在fillRect(x,y,width,height)/strokeRect(x,y,width,height)方法中有四个参数，x:代表\n\n注意：fillStyle/strokeStyle一定要写在fillRect/strokeRect之前，否则不起作用。\n\n例子：\n\n```js\n\tvar canvas = document.getElementsByTagName('canvas')[0];\n    var c = canvas.getContext('2d');\n    c.beginPath();\n    c.fillStyle = \"red\";\n    c.fillRect(50, 50, 100, 100);\n    c.closePath();\n\n    c.beginPath();\n    c.strokeStyle = \"orange\";\n    c.strokeRect(50, 160, 100, 100);\n    c.closePath();\n```\n\n这里为了节约篇幅，此处没有html代码`canvas宽高为400*400`。css中我设置一个1px的边框以及`#ccc`的背景颜色\n\n效果图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abab78de59954407959887d1c0d978f2~tplv-k3u1fbpfcp-watermark.image?)\n","source":"_posts/canvas/1.canvas入门.md","raw":"---\ntitle: canvas基本使用\ndate: 2023-1-14\ntags: [前端]\ncategories: [canvas]\n---\n# canvas\n[TOC]\n## 使用canvas\n\ncanvas其实是html里面的一个标签，所以要是用canvas,必须先在html文档里面写一个canvas标签。\n\n```html\n\t<!-- canvas在低版本浏览器中有兼容性问题，需要提示用户 -->\n    <canvas width=\"500px\" height=\"400px\">\n        您的浏览器版本过低，无法使用canvas\n    </canvas>\n```\n在canvas标签里面，我们可以直接设置canvas元素的大小，这是canvas元素自带的属性，虽然我们也可以在css里面进行更改，但是不推荐，这样会导致一些奇奇怪怪的bug。\n\n但是canvas是HTML5才有的标签，所以就会存在一个兼容性问题，这个时候我们就需要提示用户：在canvas标签里面写上提示信息。\n\n这样如果该浏览器不支持canvas就会显示我们的提示信息，但是如果该浏览器支持canvas就不会显示该提示信息。\n\n### 使用canvas画一条直线\n这里需要使用到JavaScript。\n\n分为下面这几步：\n\n- 获取到canvas元素\n- 获取到canvas元素的上下文\n- 开启一条路径\n- 设置路径的起点\n- 设置路径的终点\n- 给直线上色\n- 关闭路径\n\n下面用代码来实现一下：\n```js\n\t// 获取到canvas元素\n    var canvas = document.querySelector('canvas');\n    // 获取到canvas操作权限（获取画布的上下文）\n    var c = canvas.getContext('2d');\n    // 开启一条路径\n    c.beginPath();\n    // 设置路径的起点\n    c.moveTo(0, 0);\n    // 设置路径终点\n    c.lineTo(500, 400);\n    // 进行上色\n    c.stroke();\n    // 关闭路径\n    c.closePath();\n```\n结果如下图：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d553a403ac14cc3bbecb30819e045f4~tplv-k3u1fbpfcp-watermark.image?)\n\n这里注意，对canvas操作的时候，只能使用原生的JavaScript，不能使用jQuery等js库。\n\n## 常用的方法和属性\n\n### 1.画直线\n\n- beginPath()   开启一个路径\n- closePath()   关闭一个路径\n- moveTo(x,y)  定义线条的开始坐标（x为横坐标，y为纵坐标）\n- lineTo(x,y)  定义线条的结束坐标  （x为横坐标，y为纵坐标）\n- strokeStyle  属性设置或者返回用于笔触的颜色、渐变或者模式\n- stroke  绘制一条路径\n- lineWidth  设置线宽\n\n注意：设置颜色和线宽的时候，需要在上色之前进行。\n\n示例：\n\n```js\n// 获取到canvas元素\n    var canvas = document.querySelector('canvas');\n    // 获取到canvas操作权限（获取画布的上下文）\n    var c = canvas.getContext('2d');\n\n\n    // 开启一条路径\n    c.beginPath();\n    // 设置路径的起点\n    c.moveTo(100, 100);\n    // 设置路径终点\n    c.lineTo(200, 200);\n\t// 设置直线颜色宽度\n    c.strokeStyle = \"red\";\n    c.lineWidth = 10;\n    // 进行上色\n    c.stroke();\n    // 关闭路径\n    c.closePath();\n```\n\n效果图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb0d7291a0541cdbc739930ddf5b392~tplv-k3u1fbpfcp-watermark.image?)\n\n在给直线设置颜色的时候需要加上引号，我们可以按照css设置颜色的当时进行设置：可以写颜色名、十六进制、rgb等等。\n\n同时设置线宽的时候不要加上单位，也不需要加上引号。\n\n### 2.画圆\n\n画圆需要用到的方法：\n|                 方法                 |            描述            |\n| :----------------------------------: | :------------------------: |\n|             beginPath()              |        开启一条路径        |\n| arc(x,y,r,startDeg,endDeg,direction) | 画圆的方法，参数解释在下面 |\n|             strokeStyle              |          描边颜色          |\n|              fillStyle               |          填充颜色          |\n|               stroke()               |          结束描边          |\n|                fill()                |          结束填充          |\n|             closePath()              |          关闭路径          |\n\n- arc(x,y,r,startDeg,endDeg,direction)方法参数：\n\t- x: 圆心所在位置的恒左边\n\t- y:圆心所在位置的纵坐标\n\t- r:所绘制圆的半径\n\t- startDeg:所绘制圆的起始位置（通常用Math.PI来计算）\n\t- endDeg:所绘制圆的结束位置（通常用Math.PI来计算）\n\t- direction:绘制方向，这里只有两个值，false表示顺时针方向绘制；true表示逆时针方向绘制。\n\n- fill()与stroke()的区别：\n\t- fill():是对整个图形的内部进行填充颜色\n\t- stroke():是对图形的边框进行描边上色\n\n例子时间：\n\n1. 使用描边：\n\n```js\n\tvar canvas = document.getElementsByTagName('canvas')[0];\n    var c = canvas.getContext('2d');\n    c.beginPath();\n    c.arc(200, 200, 50, 0, Math.PI * 2, false);\n    c.strokeStyle = \"red\";\n    c.stroke();\n    c.closePath();\n```\n\n为了节约篇幅，此处没有html代码`canvas宽高为400*400`。css中我设置一个1px的边框以及`#ccc`的背景颜色\n\n效果就是这样：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0985341f21fc450082fb70a497722658~tplv-k3u1fbpfcp-watermark.image?)\n\n这里我们圆心位置在（200,200）位置，然后半径为50px，起始点从0度开始（在这里起始点在3点钟方向，下面我们可以验证一下），Math.PI表示180度，所以一个完整的圆是Math.PI*2。\n\n下面来验证起始点为0的情况，起始点的位置。\n\n```js\n\tvar canvas = document.getElementsByTagName('canvas')[0];\n    var c = canvas.getContext('2d');\n    c.beginPath();\n    c.arc(200, 200, 50, 0, Math.PI * 1, false);\n    c.strokeStyle = \"red\";\n    c.stroke();\n    c.closePath();\n```\n\n效果图：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e84bb0461fe4ba2b9717523136cc5be~tplv-k3u1fbpfcp-watermark.image?)\n\n因为绘制方向我们选择的false,所以是顺时针绘制。在效果图可以看到当起点位置为0的时候，起始点就是在3点钟方向。\n\n### 3.画矩形\n\n绘制矩形的方法：\n\n开始路径与结束路径以及描边填充颜色都与上面的一样，我这里就不再赘述了。\n\n绘制矩形同样也有两个方法，一种只有边框，一种直接填充。\n\n|             方法             |         描述         |\n| :--------------------------: | :------------------: |\n|    fillStyle/strokeStyle     | 设置填充或者描边颜色 |\n|  fillRect(x,y,width,height)  |   绘制矩形（填充）   |\n| storkeRect(x,y,width,height) |   绘制矩形（描边）   |\n\n参数解释：\n- 在fillRect(x,y,width,height)/strokeRect(x,y,width,height)方法中有四个参数，x:代表\n\n注意：fillStyle/strokeStyle一定要写在fillRect/strokeRect之前，否则不起作用。\n\n例子：\n\n```js\n\tvar canvas = document.getElementsByTagName('canvas')[0];\n    var c = canvas.getContext('2d');\n    c.beginPath();\n    c.fillStyle = \"red\";\n    c.fillRect(50, 50, 100, 100);\n    c.closePath();\n\n    c.beginPath();\n    c.strokeStyle = \"orange\";\n    c.strokeRect(50, 160, 100, 100);\n    c.closePath();\n```\n\n这里为了节约篇幅，此处没有html代码`canvas宽高为400*400`。css中我设置一个1px的边框以及`#ccc`的背景颜色\n\n效果图：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abab78de59954407959887d1c0d978f2~tplv-k3u1fbpfcp-watermark.image?)\n","slug":"canvas/1.canvas入门","published":1,"updated":"2023-01-14T07:08:52.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmjw008e9kbm6aqw9nwr","content":"<h1 id=\"canvas\"><a href=\"#canvas\" class=\"headerlink\" title=\"canvas\"></a>canvas</h1><p>[TOC]</p>\n<h2 id=\"使用canvas\"><a href=\"#使用canvas\" class=\"headerlink\" title=\"使用canvas\"></a>使用canvas</h2><p>canvas其实是html里面的一个标签，所以要是用canvas,必须先在html文档里面写一个canvas标签。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- canvas在低版本浏览器中有兼容性问题，需要提示用户 --&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;500px&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;400px&quot;</span>&gt;</span></span><br><span class=\"line\">       您的浏览器版本过低，无法使用canvas</span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在canvas标签里面，我们可以直接设置canvas元素的大小，这是canvas元素自带的属性，虽然我们也可以在css里面进行更改，但是不推荐，这样会导致一些奇奇怪怪的bug。</p>\n<p>但是canvas是HTML5才有的标签，所以就会存在一个兼容性问题，这个时候我们就需要提示用户：在canvas标签里面写上提示信息。</p>\n<p>这样如果该浏览器不支持canvas就会显示我们的提示信息，但是如果该浏览器支持canvas就不会显示该提示信息。</p>\n<h3 id=\"使用canvas画一条直线\"><a href=\"#使用canvas画一条直线\" class=\"headerlink\" title=\"使用canvas画一条直线\"></a>使用canvas画一条直线</h3><p>这里需要使用到JavaScript。</p>\n<p>分为下面这几步：</p>\n<ul>\n<li>获取到canvas元素</li>\n<li>获取到canvas元素的上下文</li>\n<li>开启一条路径</li>\n<li>设置路径的起点</li>\n<li>设置路径的终点</li>\n<li>给直线上色</li>\n<li>关闭路径</li>\n</ul>\n<p>下面用代码来实现一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取到canvas元素</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;canvas&#x27;</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 获取到canvas操作权限（获取画布的上下文）</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 开启一条路径</span></span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 设置路径的起点</span></span><br><span class=\"line\">   c.<span class=\"title function_\">moveTo</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 设置路径终点</span></span><br><span class=\"line\">   c.<span class=\"title function_\">lineTo</span>(<span class=\"number\">500</span>, <span class=\"number\">400</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 进行上色</span></span><br><span class=\"line\">   c.<span class=\"title function_\">stroke</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 关闭路径</span></span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n<p>结果如下图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d553a403ac14cc3bbecb30819e045f4~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>这里注意，对canvas操作的时候，只能使用原生的JavaScript，不能使用jQuery等js库。</p>\n<h2 id=\"常用的方法和属性\"><a href=\"#常用的方法和属性\" class=\"headerlink\" title=\"常用的方法和属性\"></a>常用的方法和属性</h2><h3 id=\"1-画直线\"><a href=\"#1-画直线\" class=\"headerlink\" title=\"1.画直线\"></a>1.画直线</h3><ul>\n<li>beginPath()   开启一个路径</li>\n<li>closePath()   关闭一个路径</li>\n<li>moveTo(x,y)  定义线条的开始坐标（x为横坐标，y为纵坐标）</li>\n<li>lineTo(x,y)  定义线条的结束坐标  （x为横坐标，y为纵坐标）</li>\n<li>strokeStyle  属性设置或者返回用于笔触的颜色、渐变或者模式</li>\n<li>stroke  绘制一条路径</li>\n<li>lineWidth  设置线宽</li>\n</ul>\n<p>注意：设置颜色和线宽的时候，需要在上色之前进行。</p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取到canvas元素</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;canvas&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 获取到canvas操作权限（获取画布的上下文）</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开启一条路径</span></span><br><span class=\"line\">    c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 设置路径的起点</span></span><br><span class=\"line\">    c.<span class=\"title function_\">moveTo</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置路径终点</span></span><br><span class=\"line\">    c.<span class=\"title function_\">lineTo</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 设置直线颜色宽度</span></span><br><span class=\"line\">    c.<span class=\"property\">strokeStyle</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">    c.<span class=\"property\">lineWidth</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 进行上色</span></span><br><span class=\"line\">    c.<span class=\"title function_\">stroke</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 关闭路径</span></span><br><span class=\"line\">    c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n\n<p>效果图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb0d7291a0541cdbc739930ddf5b392~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在给直线设置颜色的时候需要加上引号，我们可以按照css设置颜色的当时进行设置：可以写颜色名、十六进制、rgb等等。</p>\n<p>同时设置线宽的时候不要加上单位，也不需要加上引号。</p>\n<h3 id=\"2-画圆\"><a href=\"#2-画圆\" class=\"headerlink\" title=\"2.画圆\"></a>2.画圆</h3><p>画圆需要用到的方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">beginPath()</td>\n<td align=\"center\">开启一条路径</td>\n</tr>\n<tr>\n<td align=\"center\">arc(x,y,r,startDeg,endDeg,direction)</td>\n<td align=\"center\">画圆的方法，参数解释在下面</td>\n</tr>\n<tr>\n<td align=\"center\">strokeStyle</td>\n<td align=\"center\">描边颜色</td>\n</tr>\n<tr>\n<td align=\"center\">fillStyle</td>\n<td align=\"center\">填充颜色</td>\n</tr>\n<tr>\n<td align=\"center\">stroke()</td>\n<td align=\"center\">结束描边</td>\n</tr>\n<tr>\n<td align=\"center\">fill()</td>\n<td align=\"center\">结束填充</td>\n</tr>\n<tr>\n<td align=\"center\">closePath()</td>\n<td align=\"center\">关闭路径</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>arc(x,y,r,startDeg,endDeg,direction)方法参数：</p>\n<ul>\n<li>x: 圆心所在位置的恒左边</li>\n<li>y:圆心所在位置的纵坐标</li>\n<li>r:所绘制圆的半径</li>\n<li>startDeg:所绘制圆的起始位置（通常用Math.PI来计算）</li>\n<li>endDeg:所绘制圆的结束位置（通常用Math.PI来计算）</li>\n<li>direction:绘制方向，这里只有两个值，false表示顺时针方向绘制；true表示逆时针方向绘制。</li>\n</ul>\n</li>\n<li><p>fill()与stroke()的区别：</p>\n<ul>\n<li>fill():是对整个图形的内部进行填充颜色</li>\n<li>stroke():是对图形的边框进行描边上色</li>\n</ul>\n</li>\n</ul>\n<p>例子时间：</p>\n<ol>\n<li>使用描边：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;canvas&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   c.<span class=\"title function_\">arc</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * <span class=\"number\">2</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   c.<span class=\"property\">strokeStyle</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">   c.<span class=\"title function_\">stroke</span>();</span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n\n<p>为了节约篇幅，此处没有html代码<code>canvas宽高为400*400</code>。css中我设置一个1px的边框以及<code>#ccc</code>的背景颜色</p>\n<p>效果就是这样：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0985341f21fc450082fb70a497722658~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>这里我们圆心位置在（200,200）位置，然后半径为50px，起始点从0度开始（在这里起始点在3点钟方向，下面我们可以验证一下），Math.PI表示180度，所以一个完整的圆是Math.PI*2。</p>\n<p>下面来验证起始点为0的情况，起始点的位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;canvas&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   c.<span class=\"title function_\">arc</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   c.<span class=\"property\">strokeStyle</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">   c.<span class=\"title function_\">stroke</span>();</span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n\n<p>效果图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e84bb0461fe4ba2b9717523136cc5be~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>因为绘制方向我们选择的false,所以是顺时针绘制。在效果图可以看到当起点位置为0的时候，起始点就是在3点钟方向。</p>\n<h3 id=\"3-画矩形\"><a href=\"#3-画矩形\" class=\"headerlink\" title=\"3.画矩形\"></a>3.画矩形</h3><p>绘制矩形的方法：</p>\n<p>开始路径与结束路径以及描边填充颜色都与上面的一样，我这里就不再赘述了。</p>\n<p>绘制矩形同样也有两个方法，一种只有边框，一种直接填充。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">fillStyle&#x2F;strokeStyle</td>\n<td align=\"center\">设置填充或者描边颜色</td>\n</tr>\n<tr>\n<td align=\"center\">fillRect(x,y,width,height)</td>\n<td align=\"center\">绘制矩形（填充）</td>\n</tr>\n<tr>\n<td align=\"center\">storkeRect(x,y,width,height)</td>\n<td align=\"center\">绘制矩形（描边）</td>\n</tr>\n</tbody></table>\n<p>参数解释：</p>\n<ul>\n<li>在fillRect(x,y,width,height)&#x2F;strokeRect(x,y,width,height)方法中有四个参数，x:代表</li>\n</ul>\n<p>注意：fillStyle&#x2F;strokeStyle一定要写在fillRect&#x2F;strokeRect之前，否则不起作用。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;canvas&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   c.<span class=\"property\">fillStyle</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">   c.<span class=\"title function_\">fillRect</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   c.<span class=\"property\">strokeStyle</span> = <span class=\"string\">&quot;orange&quot;</span>;</span><br><span class=\"line\">   c.<span class=\"title function_\">strokeRect</span>(<span class=\"number\">50</span>, <span class=\"number\">160</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这里为了节约篇幅，此处没有html代码<code>canvas宽高为400*400</code>。css中我设置一个1px的边框以及<code>#ccc</code>的背景颜色</p>\n<p>效果图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abab78de59954407959887d1c0d978f2~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"canvas\"><a href=\"#canvas\" class=\"headerlink\" title=\"canvas\"></a>canvas</h1><p>[TOC]</p>\n<h2 id=\"使用canvas\"><a href=\"#使用canvas\" class=\"headerlink\" title=\"使用canvas\"></a>使用canvas</h2><p>canvas其实是html里面的一个标签，所以要是用canvas,必须先在html文档里面写一个canvas标签。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- canvas在低版本浏览器中有兼容性问题，需要提示用户 --&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;500px&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;400px&quot;</span>&gt;</span></span><br><span class=\"line\">       您的浏览器版本过低，无法使用canvas</span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在canvas标签里面，我们可以直接设置canvas元素的大小，这是canvas元素自带的属性，虽然我们也可以在css里面进行更改，但是不推荐，这样会导致一些奇奇怪怪的bug。</p>\n<p>但是canvas是HTML5才有的标签，所以就会存在一个兼容性问题，这个时候我们就需要提示用户：在canvas标签里面写上提示信息。</p>\n<p>这样如果该浏览器不支持canvas就会显示我们的提示信息，但是如果该浏览器支持canvas就不会显示该提示信息。</p>\n<h3 id=\"使用canvas画一条直线\"><a href=\"#使用canvas画一条直线\" class=\"headerlink\" title=\"使用canvas画一条直线\"></a>使用canvas画一条直线</h3><p>这里需要使用到JavaScript。</p>\n<p>分为下面这几步：</p>\n<ul>\n<li>获取到canvas元素</li>\n<li>获取到canvas元素的上下文</li>\n<li>开启一条路径</li>\n<li>设置路径的起点</li>\n<li>设置路径的终点</li>\n<li>给直线上色</li>\n<li>关闭路径</li>\n</ul>\n<p>下面用代码来实现一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取到canvas元素</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;canvas&#x27;</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 获取到canvas操作权限（获取画布的上下文）</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 开启一条路径</span></span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 设置路径的起点</span></span><br><span class=\"line\">   c.<span class=\"title function_\">moveTo</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 设置路径终点</span></span><br><span class=\"line\">   c.<span class=\"title function_\">lineTo</span>(<span class=\"number\">500</span>, <span class=\"number\">400</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 进行上色</span></span><br><span class=\"line\">   c.<span class=\"title function_\">stroke</span>();</span><br><span class=\"line\">   <span class=\"comment\">// 关闭路径</span></span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n<p>结果如下图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d553a403ac14cc3bbecb30819e045f4~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>这里注意，对canvas操作的时候，只能使用原生的JavaScript，不能使用jQuery等js库。</p>\n<h2 id=\"常用的方法和属性\"><a href=\"#常用的方法和属性\" class=\"headerlink\" title=\"常用的方法和属性\"></a>常用的方法和属性</h2><h3 id=\"1-画直线\"><a href=\"#1-画直线\" class=\"headerlink\" title=\"1.画直线\"></a>1.画直线</h3><ul>\n<li>beginPath()   开启一个路径</li>\n<li>closePath()   关闭一个路径</li>\n<li>moveTo(x,y)  定义线条的开始坐标（x为横坐标，y为纵坐标）</li>\n<li>lineTo(x,y)  定义线条的结束坐标  （x为横坐标，y为纵坐标）</li>\n<li>strokeStyle  属性设置或者返回用于笔触的颜色、渐变或者模式</li>\n<li>stroke  绘制一条路径</li>\n<li>lineWidth  设置线宽</li>\n</ul>\n<p>注意：设置颜色和线宽的时候，需要在上色之前进行。</p>\n<p>示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取到canvas元素</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;canvas&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 获取到canvas操作权限（获取画布的上下文）</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开启一条路径</span></span><br><span class=\"line\">    c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 设置路径的起点</span></span><br><span class=\"line\">    c.<span class=\"title function_\">moveTo</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 设置路径终点</span></span><br><span class=\"line\">    c.<span class=\"title function_\">lineTo</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 设置直线颜色宽度</span></span><br><span class=\"line\">    c.<span class=\"property\">strokeStyle</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">    c.<span class=\"property\">lineWidth</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 进行上色</span></span><br><span class=\"line\">    c.<span class=\"title function_\">stroke</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 关闭路径</span></span><br><span class=\"line\">    c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n\n<p>效果图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb0d7291a0541cdbc739930ddf5b392~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在给直线设置颜色的时候需要加上引号，我们可以按照css设置颜色的当时进行设置：可以写颜色名、十六进制、rgb等等。</p>\n<p>同时设置线宽的时候不要加上单位，也不需要加上引号。</p>\n<h3 id=\"2-画圆\"><a href=\"#2-画圆\" class=\"headerlink\" title=\"2.画圆\"></a>2.画圆</h3><p>画圆需要用到的方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">beginPath()</td>\n<td align=\"center\">开启一条路径</td>\n</tr>\n<tr>\n<td align=\"center\">arc(x,y,r,startDeg,endDeg,direction)</td>\n<td align=\"center\">画圆的方法，参数解释在下面</td>\n</tr>\n<tr>\n<td align=\"center\">strokeStyle</td>\n<td align=\"center\">描边颜色</td>\n</tr>\n<tr>\n<td align=\"center\">fillStyle</td>\n<td align=\"center\">填充颜色</td>\n</tr>\n<tr>\n<td align=\"center\">stroke()</td>\n<td align=\"center\">结束描边</td>\n</tr>\n<tr>\n<td align=\"center\">fill()</td>\n<td align=\"center\">结束填充</td>\n</tr>\n<tr>\n<td align=\"center\">closePath()</td>\n<td align=\"center\">关闭路径</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>arc(x,y,r,startDeg,endDeg,direction)方法参数：</p>\n<ul>\n<li>x: 圆心所在位置的恒左边</li>\n<li>y:圆心所在位置的纵坐标</li>\n<li>r:所绘制圆的半径</li>\n<li>startDeg:所绘制圆的起始位置（通常用Math.PI来计算）</li>\n<li>endDeg:所绘制圆的结束位置（通常用Math.PI来计算）</li>\n<li>direction:绘制方向，这里只有两个值，false表示顺时针方向绘制；true表示逆时针方向绘制。</li>\n</ul>\n</li>\n<li><p>fill()与stroke()的区别：</p>\n<ul>\n<li>fill():是对整个图形的内部进行填充颜色</li>\n<li>stroke():是对图形的边框进行描边上色</li>\n</ul>\n</li>\n</ul>\n<p>例子时间：</p>\n<ol>\n<li>使用描边：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;canvas&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   c.<span class=\"title function_\">arc</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * <span class=\"number\">2</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   c.<span class=\"property\">strokeStyle</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">   c.<span class=\"title function_\">stroke</span>();</span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n\n<p>为了节约篇幅，此处没有html代码<code>canvas宽高为400*400</code>。css中我设置一个1px的边框以及<code>#ccc</code>的背景颜色</p>\n<p>效果就是这样：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0985341f21fc450082fb70a497722658~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>这里我们圆心位置在（200,200）位置，然后半径为50px，起始点从0度开始（在这里起始点在3点钟方向，下面我们可以验证一下），Math.PI表示180度，所以一个完整的圆是Math.PI*2。</p>\n<p>下面来验证起始点为0的情况，起始点的位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;canvas&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   c.<span class=\"title function_\">arc</span>(<span class=\"number\">200</span>, <span class=\"number\">200</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">   c.<span class=\"property\">strokeStyle</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">   c.<span class=\"title function_\">stroke</span>();</span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n\n<p>效果图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e84bb0461fe4ba2b9717523136cc5be~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>因为绘制方向我们选择的false,所以是顺时针绘制。在效果图可以看到当起点位置为0的时候，起始点就是在3点钟方向。</p>\n<h3 id=\"3-画矩形\"><a href=\"#3-画矩形\" class=\"headerlink\" title=\"3.画矩形\"></a>3.画矩形</h3><p>绘制矩形的方法：</p>\n<p>开始路径与结束路径以及描边填充颜色都与上面的一样，我这里就不再赘述了。</p>\n<p>绘制矩形同样也有两个方法，一种只有边框，一种直接填充。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">fillStyle&#x2F;strokeStyle</td>\n<td align=\"center\">设置填充或者描边颜色</td>\n</tr>\n<tr>\n<td align=\"center\">fillRect(x,y,width,height)</td>\n<td align=\"center\">绘制矩形（填充）</td>\n</tr>\n<tr>\n<td align=\"center\">storkeRect(x,y,width,height)</td>\n<td align=\"center\">绘制矩形（描边）</td>\n</tr>\n</tbody></table>\n<p>参数解释：</p>\n<ul>\n<li>在fillRect(x,y,width,height)&#x2F;strokeRect(x,y,width,height)方法中有四个参数，x:代表</li>\n</ul>\n<p>注意：fillStyle&#x2F;strokeStyle一定要写在fillRect&#x2F;strokeRect之前，否则不起作用。</p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;canvas&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">   <span class=\"keyword\">var</span> c = canvas.<span class=\"title function_\">getContext</span>(<span class=\"string\">&#x27;2d&#x27;</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   c.<span class=\"property\">fillStyle</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">   c.<span class=\"title function_\">fillRect</span>(<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">   c.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">   c.<span class=\"property\">strokeStyle</span> = <span class=\"string\">&quot;orange&quot;</span>;</span><br><span class=\"line\">   c.<span class=\"title function_\">strokeRect</span>(<span class=\"number\">50</span>, <span class=\"number\">160</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">   c.<span class=\"title function_\">closePath</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这里为了节约篇幅，此处没有html代码<code>canvas宽高为400*400</code>。css中我设置一个1px的边框以及<code>#ccc</code>的背景颜色</p>\n<p>效果图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abab78de59954407959887d1c0d978f2~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n"},{"title":"EventEmitter类","date":"2022-12-15T16:00:00.000Z","_content":"# EventEmitter 类\n\n`eventEmitter`是`events`模块里面的一个对象，它的核心功能就是事件触发与事件监听器功能的封装。\n\n## 引入event模块\n\n代码：\n\n```js\n\tvar events = require('events');\n```\n\n我们通过`require`引入这个events模块之后，我们实例化一个`eventEmitter`对象\n\n```js\n\tvar eventEmitter = new events.EventEmitter();\n```\n\n这里注意：\n\n- 实例化对象使用`new`关键字\n- 后面的`EventEmitter`两个单词首字母都需要大写\n\n\n我们有了eventEmitter对象之后，就可以为指定的事件添加监听器了。\n\n在此之前，我们先定义两个监听器：\n\n```js\n\tvar listener1 = function(){\n\t\tconsole.log('我是第一个监听器');\n\t}\n\tvar listener2 = function(){\n\t\tconsole.log('我是第二个监听器');\n\t}\n```\n\n接下来就是为eventEmitter绑定监听器了。\n\n## 绑定监听器\n\n1. 使用`on`方法绑定：\n\t`eventEmitter.on('事件', 监听器);`\n\t使用`on`方法进行绑定的时候，可以多次使用从而绑定多个监听器，执行的时候按照绑定顺序进行执行。\n2. 使用`addListener`方法绑定：\n\t`eventEmitter.addListener('事件',监听器);`\n\t这个方法是将一个监听器添加到监听器数组的尾部。也就是将这个监听器添加到原来事件监听器数组的最后一个。\n3. 使用`once`方法绑定：\n\t`eventEmitter.once('事件',监听器);`\n\t看方法名字，我们就大致可以知道这个监听器只会执行一次，执行完毕之后就会解绑。\n\n### 栗子：\n\n```js\n\t// 默认事件名字为test\n\t\n\t// 方法一绑定监听器\n\teventEmitter.on('test',listener1);\n\teventEmitter.on('test',listener2);\n\t// 方法二绑定监听器\n\teventEmitter.addListener('test',listener1);\n\t// 方法三绑定监听器\n\teventEmitter.once('test',listener1);\n```\n\n上面我们使用了三种方式来绑定监听器，方法一中的监听器会按照绑定顺序执行；方法二中的监听器会最后一个执行，因为它位置事件监听器数组的最后一个，所以此时绑定的监听器会最后一个执行；方法绑定的监听器只会执行一次。\n\n## 解绑监听器\n\n前面我们知道了给事件绑定监听器，那么如何给事件解绑监听器呢？\n\n这里node.js为我们提供了两种方法：\n\n1. \t`removeListener(event, listener)`\n2. \t`removeAllListeners([event])`\n\n从名字我们就可以看出两个方法的不同，第一个只是移除指定事件上的指定监听器；第二则是移除指定事件上的所有监听器。\n\n### 栗子：\n\n```js\n\t// 方法一：\n\teventEmitter.removeListener('test',listener1);\n\t// 方法二：\n\teventEmitter.removeAllListener('test');\n```\n","source":"_posts/node学习/eventEmitter.md","raw":"---\ntitle: EventEmitter类\ndate: 2022-12-16\ntags: [前端]\ncategories: [node]\n---\n# EventEmitter 类\n\n`eventEmitter`是`events`模块里面的一个对象，它的核心功能就是事件触发与事件监听器功能的封装。\n\n## 引入event模块\n\n代码：\n\n```js\n\tvar events = require('events');\n```\n\n我们通过`require`引入这个events模块之后，我们实例化一个`eventEmitter`对象\n\n```js\n\tvar eventEmitter = new events.EventEmitter();\n```\n\n这里注意：\n\n- 实例化对象使用`new`关键字\n- 后面的`EventEmitter`两个单词首字母都需要大写\n\n\n我们有了eventEmitter对象之后，就可以为指定的事件添加监听器了。\n\n在此之前，我们先定义两个监听器：\n\n```js\n\tvar listener1 = function(){\n\t\tconsole.log('我是第一个监听器');\n\t}\n\tvar listener2 = function(){\n\t\tconsole.log('我是第二个监听器');\n\t}\n```\n\n接下来就是为eventEmitter绑定监听器了。\n\n## 绑定监听器\n\n1. 使用`on`方法绑定：\n\t`eventEmitter.on('事件', 监听器);`\n\t使用`on`方法进行绑定的时候，可以多次使用从而绑定多个监听器，执行的时候按照绑定顺序进行执行。\n2. 使用`addListener`方法绑定：\n\t`eventEmitter.addListener('事件',监听器);`\n\t这个方法是将一个监听器添加到监听器数组的尾部。也就是将这个监听器添加到原来事件监听器数组的最后一个。\n3. 使用`once`方法绑定：\n\t`eventEmitter.once('事件',监听器);`\n\t看方法名字，我们就大致可以知道这个监听器只会执行一次，执行完毕之后就会解绑。\n\n### 栗子：\n\n```js\n\t// 默认事件名字为test\n\t\n\t// 方法一绑定监听器\n\teventEmitter.on('test',listener1);\n\teventEmitter.on('test',listener2);\n\t// 方法二绑定监听器\n\teventEmitter.addListener('test',listener1);\n\t// 方法三绑定监听器\n\teventEmitter.once('test',listener1);\n```\n\n上面我们使用了三种方式来绑定监听器，方法一中的监听器会按照绑定顺序执行；方法二中的监听器会最后一个执行，因为它位置事件监听器数组的最后一个，所以此时绑定的监听器会最后一个执行；方法绑定的监听器只会执行一次。\n\n## 解绑监听器\n\n前面我们知道了给事件绑定监听器，那么如何给事件解绑监听器呢？\n\n这里node.js为我们提供了两种方法：\n\n1. \t`removeListener(event, listener)`\n2. \t`removeAllListeners([event])`\n\n从名字我们就可以看出两个方法的不同，第一个只是移除指定事件上的指定监听器；第二则是移除指定事件上的所有监听器。\n\n### 栗子：\n\n```js\n\t// 方法一：\n\teventEmitter.removeListener('test',listener1);\n\t// 方法二：\n\teventEmitter.removeAllListener('test');\n```\n","slug":"node学习/eventEmitter","published":1,"updated":"2023-01-10T02:21:58.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmk0008h9kbm65ixe2n6","content":"<h1 id=\"EventEmitter-类\"><a href=\"#EventEmitter-类\" class=\"headerlink\" title=\"EventEmitter 类\"></a>EventEmitter 类</h1><p><code>eventEmitter</code>是<code>events</code>模块里面的一个对象，它的核心功能就是事件触发与事件监听器功能的封装。</p>\n<h2 id=\"引入event模块\"><a href=\"#引入event模块\" class=\"headerlink\" title=\"引入event模块\"></a>引入event模块</h2><p>代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们通过<code>require</code>引入这个events模块之后，我们实例化一个<code>eventEmitter</code>对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eventEmitter = <span class=\"keyword\">new</span> events.<span class=\"title class_\">EventEmitter</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这里注意：</p>\n<ul>\n<li>实例化对象使用<code>new</code>关键字</li>\n<li>后面的<code>EventEmitter</code>两个单词首字母都需要大写</li>\n</ul>\n<p>我们有了eventEmitter对象之后，就可以为指定的事件添加监听器了。</p>\n<p>在此之前，我们先定义两个监听器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> listener1 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我是第一个监听器&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> listener2 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我是第二个监听器&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是为eventEmitter绑定监听器了。</p>\n<h2 id=\"绑定监听器\"><a href=\"#绑定监听器\" class=\"headerlink\" title=\"绑定监听器\"></a>绑定监听器</h2><ol>\n<li>使用<code>on</code>方法绑定：<br> <code>eventEmitter.on(&#39;事件&#39;, 监听器);</code><br> 使用<code>on</code>方法进行绑定的时候，可以多次使用从而绑定多个监听器，执行的时候按照绑定顺序进行执行。</li>\n<li>使用<code>addListener</code>方法绑定：<br> <code>eventEmitter.addListener(&#39;事件&#39;,监听器);</code><br> 这个方法是将一个监听器添加到监听器数组的尾部。也就是将这个监听器添加到原来事件监听器数组的最后一个。</li>\n<li>使用<code>once</code>方法绑定：<br> <code>eventEmitter.once(&#39;事件&#39;,监听器);</code><br> 看方法名字，我们就大致可以知道这个监听器只会执行一次，执行完毕之后就会解绑。</li>\n</ol>\n<h3 id=\"栗子：\"><a href=\"#栗子：\" class=\"headerlink\" title=\"栗子：\"></a>栗子：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认事件名字为test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法一绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener2);</span><br><span class=\"line\"><span class=\"comment\">// 方法二绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">addListener</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\"><span class=\"comment\">// 方法三绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">once</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br></pre></td></tr></table></figure>\n\n<p>上面我们使用了三种方式来绑定监听器，方法一中的监听器会按照绑定顺序执行；方法二中的监听器会最后一个执行，因为它位置事件监听器数组的最后一个，所以此时绑定的监听器会最后一个执行；方法绑定的监听器只会执行一次。</p>\n<h2 id=\"解绑监听器\"><a href=\"#解绑监听器\" class=\"headerlink\" title=\"解绑监听器\"></a>解绑监听器</h2><p>前面我们知道了给事件绑定监听器，那么如何给事件解绑监听器呢？</p>\n<p>这里node.js为我们提供了两种方法：</p>\n<ol>\n<li><pre><code>`removeListener(event, listener)`\n</code></pre>\n</li>\n<li><pre><code>`removeAllListeners([event])`\n</code></pre>\n</li>\n</ol>\n<p>从名字我们就可以看出两个方法的不同，第一个只是移除指定事件上的指定监听器；第二则是移除指定事件上的所有监听器。</p>\n<h3 id=\"栗子：-1\"><a href=\"#栗子：-1\" class=\"headerlink\" title=\"栗子：\"></a>栗子：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">removeListener</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\"><span class=\"comment\">// 方法二：</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">removeAllListener</span>(<span class=\"string\">&#x27;test&#x27;</span>);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"EventEmitter-类\"><a href=\"#EventEmitter-类\" class=\"headerlink\" title=\"EventEmitter 类\"></a>EventEmitter 类</h1><p><code>eventEmitter</code>是<code>events</code>模块里面的一个对象，它的核心功能就是事件触发与事件监听器功能的封装。</p>\n<h2 id=\"引入event模块\"><a href=\"#引入event模块\" class=\"headerlink\" title=\"引入event模块\"></a>引入event模块</h2><p>代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> events = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;events&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们通过<code>require</code>引入这个events模块之后，我们实例化一个<code>eventEmitter</code>对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eventEmitter = <span class=\"keyword\">new</span> events.<span class=\"title class_\">EventEmitter</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这里注意：</p>\n<ul>\n<li>实例化对象使用<code>new</code>关键字</li>\n<li>后面的<code>EventEmitter</code>两个单词首字母都需要大写</li>\n</ul>\n<p>我们有了eventEmitter对象之后，就可以为指定的事件添加监听器了。</p>\n<p>在此之前，我们先定义两个监听器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> listener1 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我是第一个监听器&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> listener2 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;我是第二个监听器&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就是为eventEmitter绑定监听器了。</p>\n<h2 id=\"绑定监听器\"><a href=\"#绑定监听器\" class=\"headerlink\" title=\"绑定监听器\"></a>绑定监听器</h2><ol>\n<li>使用<code>on</code>方法绑定：<br> <code>eventEmitter.on(&#39;事件&#39;, 监听器);</code><br> 使用<code>on</code>方法进行绑定的时候，可以多次使用从而绑定多个监听器，执行的时候按照绑定顺序进行执行。</li>\n<li>使用<code>addListener</code>方法绑定：<br> <code>eventEmitter.addListener(&#39;事件&#39;,监听器);</code><br> 这个方法是将一个监听器添加到监听器数组的尾部。也就是将这个监听器添加到原来事件监听器数组的最后一个。</li>\n<li>使用<code>once</code>方法绑定：<br> <code>eventEmitter.once(&#39;事件&#39;,监听器);</code><br> 看方法名字，我们就大致可以知道这个监听器只会执行一次，执行完毕之后就会解绑。</li>\n</ol>\n<h3 id=\"栗子：\"><a href=\"#栗子：\" class=\"headerlink\" title=\"栗子：\"></a>栗子：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认事件名字为test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法一绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener2);</span><br><span class=\"line\"><span class=\"comment\">// 方法二绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">addListener</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\"><span class=\"comment\">// 方法三绑定监听器</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">once</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br></pre></td></tr></table></figure>\n\n<p>上面我们使用了三种方式来绑定监听器，方法一中的监听器会按照绑定顺序执行；方法二中的监听器会最后一个执行，因为它位置事件监听器数组的最后一个，所以此时绑定的监听器会最后一个执行；方法绑定的监听器只会执行一次。</p>\n<h2 id=\"解绑监听器\"><a href=\"#解绑监听器\" class=\"headerlink\" title=\"解绑监听器\"></a>解绑监听器</h2><p>前面我们知道了给事件绑定监听器，那么如何给事件解绑监听器呢？</p>\n<p>这里node.js为我们提供了两种方法：</p>\n<ol>\n<li><pre><code>`removeListener(event, listener)`\n</code></pre>\n</li>\n<li><pre><code>`removeAllListeners([event])`\n</code></pre>\n</li>\n</ol>\n<p>从名字我们就可以看出两个方法的不同，第一个只是移除指定事件上的指定监听器；第二则是移除指定事件上的所有监听器。</p>\n<h3 id=\"栗子：-1\"><a href=\"#栗子：-1\" class=\"headerlink\" title=\"栗子：\"></a>栗子：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法一：</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">removeListener</span>(<span class=\"string\">&#x27;test&#x27;</span>,listener1);</span><br><span class=\"line\"><span class=\"comment\">// 方法二：</span></span><br><span class=\"line\">eventEmitter.<span class=\"title function_\">removeAllListener</span>(<span class=\"string\">&#x27;test&#x27;</span>);</span><br></pre></td></tr></table></figure>\n"},{"title":"HTML基础2","date":"2023-04-02T16:00:00.000Z","_content":"\n# 列表标签\n\n## 无序列表\n\n使用`<ul></ul>`。\n\n```HTML\n<ul>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n</ul>\n```\n\n四个无序列表。\n\n## 有序列表\n\n```HTML\n<ol>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n</ol>\n```\n\n## 表格\n\n与表格相关的标记\n\n|标记|描述|\n|:--:|:--:|\n|table|表标记|\n|tr|行标记|\n|th|表头标记|\n|td|列里面内容标记|\n\n```HTML\n<table>\n\t<tr>\n\t\t<th>\n\t\t\t表头\n\t\t</th>\n\t</tr>\n\t<tr>\n\t\t<td>\n\t\t\t里面的内容\n\t\t</td>\n\t</tr>\n<table>\n```\n\n属性：\n\n- cellspacing:  设置表格单元格的边距\n- cellpadding: 设置表格的内边距\n- border : 设置表格的边框厚度\n\n## 合并单元格\n\n单元列合并需要用到`colspan`属性，在要跨列的哪一行上设置`colspan`属性，值为要跨的列数。\n\n单元行合并需要用到`rowspan`属性，在要跨列的哪一列上设置`rowspan`属性，值为要跨的行数。\n\n## 表单标签\n\n使用`form`标签。\n\n其中`form`有两个属性：\n\n- action： 值为一个URL，表示表单内容提交到的位置。\n- method： 值为几种提交方式，POST、GET。表示提交的方式。\n\t- get ： 信息在URL中，安全性不高，并且会导致URL过长。\n\t- post:  表单里面的信息在地址栏看不见，对URL长度没有影响。\n\n### 常见的输入框类型\n\n- 输入框\n- 密码框\n- 下拉框\n- 单选框\n- 复选框\n- 提交按钮\n- 上传文件\n- 多行文本\n\n单行输入框：\n\n```HTML\n\t<input type=\"text\">\n```\n\n密码框：\n\n```HTML\n\t<input type=\"password\">\n```\n\n下拉框：\n\n```HTML\n\t<select> // 开始标签\n\t\t<option></option> // 选项标签\n\t\t<option></option>\n\t</select>\n```\n\n单选按钮：\n\n```HTML\n\t<input type=\"radio\" name=\"sex\">\n\t<input type=\"radio\" name=\"sex\">\n```\n\n注意：name属性值相同的为一组。\n\n提交按钮：\n\n```HTML\n\t<input type=\"submit\">\n```\n\n上传文件：\n\n```HTML\n\t<input type=\"file\">\n```\n\n多选框：\n\n```HTML\n\t<input type=\"checkbox\">\n\t<input type=\"checkbox\">\n```\n\n多行文本：\n\n```HTML\n\t<textarea></textarea>\n```\n\n重置按钮：\n\n```HTML\n\t<input type=\"reset\">\n```","source":"_posts/双体web/HTML列表标签.md","raw":"---\ntitle: HTML基础2\ndate: [2023-4-3]\ntags: [前端]\ncategories: [HTML]\n---\n\n# 列表标签\n\n## 无序列表\n\n使用`<ul></ul>`。\n\n```HTML\n<ul>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n\t<li></li>\n</ul>\n```\n\n四个无序列表。\n\n## 有序列表\n\n```HTML\n<ol>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n</ol>\n```\n\n## 表格\n\n与表格相关的标记\n\n|标记|描述|\n|:--:|:--:|\n|table|表标记|\n|tr|行标记|\n|th|表头标记|\n|td|列里面内容标记|\n\n```HTML\n<table>\n\t<tr>\n\t\t<th>\n\t\t\t表头\n\t\t</th>\n\t</tr>\n\t<tr>\n\t\t<td>\n\t\t\t里面的内容\n\t\t</td>\n\t</tr>\n<table>\n```\n\n属性：\n\n- cellspacing:  设置表格单元格的边距\n- cellpadding: 设置表格的内边距\n- border : 设置表格的边框厚度\n\n## 合并单元格\n\n单元列合并需要用到`colspan`属性，在要跨列的哪一行上设置`colspan`属性，值为要跨的列数。\n\n单元行合并需要用到`rowspan`属性，在要跨列的哪一列上设置`rowspan`属性，值为要跨的行数。\n\n## 表单标签\n\n使用`form`标签。\n\n其中`form`有两个属性：\n\n- action： 值为一个URL，表示表单内容提交到的位置。\n- method： 值为几种提交方式，POST、GET。表示提交的方式。\n\t- get ： 信息在URL中，安全性不高，并且会导致URL过长。\n\t- post:  表单里面的信息在地址栏看不见，对URL长度没有影响。\n\n### 常见的输入框类型\n\n- 输入框\n- 密码框\n- 下拉框\n- 单选框\n- 复选框\n- 提交按钮\n- 上传文件\n- 多行文本\n\n单行输入框：\n\n```HTML\n\t<input type=\"text\">\n```\n\n密码框：\n\n```HTML\n\t<input type=\"password\">\n```\n\n下拉框：\n\n```HTML\n\t<select> // 开始标签\n\t\t<option></option> // 选项标签\n\t\t<option></option>\n\t</select>\n```\n\n单选按钮：\n\n```HTML\n\t<input type=\"radio\" name=\"sex\">\n\t<input type=\"radio\" name=\"sex\">\n```\n\n注意：name属性值相同的为一组。\n\n提交按钮：\n\n```HTML\n\t<input type=\"submit\">\n```\n\n上传文件：\n\n```HTML\n\t<input type=\"file\">\n```\n\n多选框：\n\n```HTML\n\t<input type=\"checkbox\">\n\t<input type=\"checkbox\">\n```\n\n多行文本：\n\n```HTML\n\t<textarea></textarea>\n```\n\n重置按钮：\n\n```HTML\n\t<input type=\"reset\">\n```","slug":"双体web/HTML列表标签","published":1,"updated":"2023-04-03T08:17:51.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmk3008l9kbm62qwdkff","content":"<h1 id=\"列表标签\"><a href=\"#列表标签\" class=\"headerlink\" title=\"列表标签\"></a>列表标签</h1><h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><p>使用<code>&lt;ul&gt;&lt;/ul&gt;</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>四个无序列表。</p>\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>与表格相关的标记</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">标记</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">table</td>\n<td align=\"center\">表标记</td>\n</tr>\n<tr>\n<td align=\"center\">tr</td>\n<td align=\"center\">行标记</td>\n</tr>\n<tr>\n<td align=\"center\">th</td>\n<td align=\"center\">表头标记</td>\n</tr>\n<tr>\n<td align=\"center\">td</td>\n<td align=\"center\">列里面内容标记</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">\t\t\t表头</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">\t\t\t里面的内容</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性：</p>\n<ul>\n<li>cellspacing:  设置表格单元格的边距</li>\n<li>cellpadding: 设置表格的内边距</li>\n<li>border : 设置表格的边框厚度</li>\n</ul>\n<h2 id=\"合并单元格\"><a href=\"#合并单元格\" class=\"headerlink\" title=\"合并单元格\"></a>合并单元格</h2><p>单元列合并需要用到<code>colspan</code>属性，在要跨列的哪一行上设置<code>colspan</code>属性，值为要跨的列数。</p>\n<p>单元行合并需要用到<code>rowspan</code>属性，在要跨列的哪一列上设置<code>rowspan</code>属性，值为要跨的行数。</p>\n<h2 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h2><p>使用<code>form</code>标签。</p>\n<p>其中<code>form</code>有两个属性：</p>\n<ul>\n<li>action： 值为一个URL，表示表单内容提交到的位置。</li>\n<li>method： 值为几种提交方式，POST、GET。表示提交的方式。<ul>\n<li>get ： 信息在URL中，安全性不高，并且会导致URL过长。</li>\n<li>post:  表单里面的信息在地址栏看不见，对URL长度没有影响。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常见的输入框类型\"><a href=\"#常见的输入框类型\" class=\"headerlink\" title=\"常见的输入框类型\"></a>常见的输入框类型</h3><ul>\n<li>输入框</li>\n<li>密码框</li>\n<li>下拉框</li>\n<li>单选框</li>\n<li>复选框</li>\n<li>提交按钮</li>\n<li>上传文件</li>\n<li>多行文本</li>\n</ul>\n<p>单行输入框：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>密码框：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>下拉框：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span> // 开始标签</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span> // 选项标签</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>单选按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sex&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sex&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：name属性值相同的为一组。</p>\n<p>提交按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上传文件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>多选框：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>多行文本：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>重置按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;reset&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"列表标签\"><a href=\"#列表标签\" class=\"headerlink\" title=\"列表标签\"></a>列表标签</h1><h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><p>使用<code>&lt;ul&gt;&lt;/ul&gt;</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>四个无序列表。</p>\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>与表格相关的标记</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">标记</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">table</td>\n<td align=\"center\">表标记</td>\n</tr>\n<tr>\n<td align=\"center\">tr</td>\n<td align=\"center\">行标记</td>\n</tr>\n<tr>\n<td align=\"center\">th</td>\n<td align=\"center\">表头标记</td>\n</tr>\n<tr>\n<td align=\"center\">td</td>\n<td align=\"center\">列里面内容标记</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">\t\t\t表头</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">\t\t\t里面的内容</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性：</p>\n<ul>\n<li>cellspacing:  设置表格单元格的边距</li>\n<li>cellpadding: 设置表格的内边距</li>\n<li>border : 设置表格的边框厚度</li>\n</ul>\n<h2 id=\"合并单元格\"><a href=\"#合并单元格\" class=\"headerlink\" title=\"合并单元格\"></a>合并单元格</h2><p>单元列合并需要用到<code>colspan</code>属性，在要跨列的哪一行上设置<code>colspan</code>属性，值为要跨的列数。</p>\n<p>单元行合并需要用到<code>rowspan</code>属性，在要跨列的哪一列上设置<code>rowspan</code>属性，值为要跨的行数。</p>\n<h2 id=\"表单标签\"><a href=\"#表单标签\" class=\"headerlink\" title=\"表单标签\"></a>表单标签</h2><p>使用<code>form</code>标签。</p>\n<p>其中<code>form</code>有两个属性：</p>\n<ul>\n<li>action： 值为一个URL，表示表单内容提交到的位置。</li>\n<li>method： 值为几种提交方式，POST、GET。表示提交的方式。<ul>\n<li>get ： 信息在URL中，安全性不高，并且会导致URL过长。</li>\n<li>post:  表单里面的信息在地址栏看不见，对URL长度没有影响。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常见的输入框类型\"><a href=\"#常见的输入框类型\" class=\"headerlink\" title=\"常见的输入框类型\"></a>常见的输入框类型</h3><ul>\n<li>输入框</li>\n<li>密码框</li>\n<li>下拉框</li>\n<li>单选框</li>\n<li>复选框</li>\n<li>提交按钮</li>\n<li>上传文件</li>\n<li>多行文本</li>\n</ul>\n<p>单行输入框：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>密码框：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>下拉框：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span> // 开始标签</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span> // 选项标签</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>单选按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sex&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sex&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：name属性值相同的为一组。</p>\n<p>提交按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上传文件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>多选框：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>多行文本：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>重置按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;reset&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"fs中路径动态拼接问题","date":"2022-12-16T16:00:00.000Z","_content":"# fs中路径动态拼接问题\n\n在`node.js`中进行读取或者写入操作的时候，我们都会在方法中传入一个文件的地址参数，之前我们的案例都是使用的相对路径，就像这样`./text.txt`。\n\n虽然在当时的情况下我们可以正确读取或者写入，但是要是node的命令不在当前目录打开呢？\n\n就比如这样：\n\n我们的文件存放在`/node/file/text.txt`，但是node命令却在`/node`目录下打开，此时我们再执行之前的命令，就会发现执行失败，即使在命令行加上文件的相对路径，最后结果还是失败。\n\n这就是使用`fs`模块操作文件的时候，如果提供的操作路径是以./或者../开头的相对路径的时候，就容易出现路径动态拼接错误。\n\n那么有没有什么解决办法呢？\n\n## 解决方法一：使用绝对路径\n\n使用绝对路径就是在地址更换为当前文件在此电脑的完整地址。也就是`C:/......`的样子。\n\n这样在执行命令的时候，就不会出现错误了。  \n但是这样的方法却有着一个致命的缺陷，那就是：移植性大大降低。\n\n我们开发出来的程序总不可能一直都只在你这一台电脑上跑吧，使用绝对路径就会导致在其他电脑上找不到这个地址，就会报错。\n\n所以不推荐这种方法！！\n\n## 第二种方法：`__dirname`\n\n使用方法：就是在之前的相对路径前面加一个`__dirname`\n\n栗子：\n\n```js\nfs.readFile(__dirname+'/test.txt', 'utf-8', function (err, data) {\n    console.log(err);\n    console.log(data);\n})\n```\n\n此时我们将目录切换到上一级之后，使用命令行`node ./node/readFile.js`，加上文件目录，就可以正常读取了。\n\n要是不使用`__dirname`执行此命令的话：就会报错\n\n```\n[Error: ENOENT: no such file or directory, open 'D:\\test.txt'] {\n  errno: -4058,\n  code: 'ENOENT',\n  syscall: 'open',\n  path: 'D:\\\\test.txt'\n}\n```","source":"_posts/node学习/fs中路径动态拼接问题.md","raw":"---\ntitle: fs中路径动态拼接问题\ndate: 2022-12-17\ntags: [前端]\ncategories: [node]\n---\n# fs中路径动态拼接问题\n\n在`node.js`中进行读取或者写入操作的时候，我们都会在方法中传入一个文件的地址参数，之前我们的案例都是使用的相对路径，就像这样`./text.txt`。\n\n虽然在当时的情况下我们可以正确读取或者写入，但是要是node的命令不在当前目录打开呢？\n\n就比如这样：\n\n我们的文件存放在`/node/file/text.txt`，但是node命令却在`/node`目录下打开，此时我们再执行之前的命令，就会发现执行失败，即使在命令行加上文件的相对路径，最后结果还是失败。\n\n这就是使用`fs`模块操作文件的时候，如果提供的操作路径是以./或者../开头的相对路径的时候，就容易出现路径动态拼接错误。\n\n那么有没有什么解决办法呢？\n\n## 解决方法一：使用绝对路径\n\n使用绝对路径就是在地址更换为当前文件在此电脑的完整地址。也就是`C:/......`的样子。\n\n这样在执行命令的时候，就不会出现错误了。  \n但是这样的方法却有着一个致命的缺陷，那就是：移植性大大降低。\n\n我们开发出来的程序总不可能一直都只在你这一台电脑上跑吧，使用绝对路径就会导致在其他电脑上找不到这个地址，就会报错。\n\n所以不推荐这种方法！！\n\n## 第二种方法：`__dirname`\n\n使用方法：就是在之前的相对路径前面加一个`__dirname`\n\n栗子：\n\n```js\nfs.readFile(__dirname+'/test.txt', 'utf-8', function (err, data) {\n    console.log(err);\n    console.log(data);\n})\n```\n\n此时我们将目录切换到上一级之后，使用命令行`node ./node/readFile.js`，加上文件目录，就可以正常读取了。\n\n要是不使用`__dirname`执行此命令的话：就会报错\n\n```\n[Error: ENOENT: no such file or directory, open 'D:\\test.txt'] {\n  errno: -4058,\n  code: 'ENOENT',\n  syscall: 'open',\n  path: 'D:\\\\test.txt'\n}\n```","slug":"node学习/fs中路径动态拼接问题","published":1,"updated":"2023-01-10T02:22:54.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmk5008o9kbmfgiu0mnq","content":"<h1 id=\"fs中路径动态拼接问题\"><a href=\"#fs中路径动态拼接问题\" class=\"headerlink\" title=\"fs中路径动态拼接问题\"></a>fs中路径动态拼接问题</h1><p>在<code>node.js</code>中进行读取或者写入操作的时候，我们都会在方法中传入一个文件的地址参数，之前我们的案例都是使用的相对路径，就像这样<code>./text.txt</code>。</p>\n<p>虽然在当时的情况下我们可以正确读取或者写入，但是要是node的命令不在当前目录打开呢？</p>\n<p>就比如这样：</p>\n<p>我们的文件存放在<code>/node/file/text.txt</code>，但是node命令却在<code>/node</code>目录下打开，此时我们再执行之前的命令，就会发现执行失败，即使在命令行加上文件的相对路径，最后结果还是失败。</p>\n<p>这就是使用<code>fs</code>模块操作文件的时候，如果提供的操作路径是以.&#x2F;或者..&#x2F;开头的相对路径的时候，就容易出现路径动态拼接错误。</p>\n<p>那么有没有什么解决办法呢？</p>\n<h2 id=\"解决方法一：使用绝对路径\"><a href=\"#解决方法一：使用绝对路径\" class=\"headerlink\" title=\"解决方法一：使用绝对路径\"></a>解决方法一：使用绝对路径</h2><p>使用绝对路径就是在地址更换为当前文件在此电脑的完整地址。也就是<code>C:/......</code>的样子。</p>\n<p>这样在执行命令的时候，就不会出现错误了。<br>但是这样的方法却有着一个致命的缺陷，那就是：移植性大大降低。</p>\n<p>我们开发出来的程序总不可能一直都只在你这一台电脑上跑吧，使用绝对路径就会导致在其他电脑上找不到这个地址，就会报错。</p>\n<p>所以不推荐这种方法！！</p>\n<h2 id=\"第二种方法：-dirname\"><a href=\"#第二种方法：-dirname\" class=\"headerlink\" title=\"第二种方法：__dirname\"></a>第二种方法：<code>__dirname</code></h2><p>使用方法：就是在之前的相对路径前面加一个<code>__dirname</code></p>\n<p>栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(__dirname+<span class=\"string\">&#x27;/test.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时我们将目录切换到上一级之后，使用命令行<code>node ./node/readFile.js</code>，加上文件目录，就可以正常读取了。</p>\n<p>要是不使用<code>__dirname</code>执行此命令的话：就会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Error: ENOENT: no such file or directory, open &#x27;D:\\test.txt&#x27;] &#123;</span><br><span class=\"line\">  errno: -4058,</span><br><span class=\"line\">  code: &#x27;ENOENT&#x27;,</span><br><span class=\"line\">  syscall: &#x27;open&#x27;,</span><br><span class=\"line\">  path: &#x27;D:\\\\test.txt&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"fs中路径动态拼接问题\"><a href=\"#fs中路径动态拼接问题\" class=\"headerlink\" title=\"fs中路径动态拼接问题\"></a>fs中路径动态拼接问题</h1><p>在<code>node.js</code>中进行读取或者写入操作的时候，我们都会在方法中传入一个文件的地址参数，之前我们的案例都是使用的相对路径，就像这样<code>./text.txt</code>。</p>\n<p>虽然在当时的情况下我们可以正确读取或者写入，但是要是node的命令不在当前目录打开呢？</p>\n<p>就比如这样：</p>\n<p>我们的文件存放在<code>/node/file/text.txt</code>，但是node命令却在<code>/node</code>目录下打开，此时我们再执行之前的命令，就会发现执行失败，即使在命令行加上文件的相对路径，最后结果还是失败。</p>\n<p>这就是使用<code>fs</code>模块操作文件的时候，如果提供的操作路径是以.&#x2F;或者..&#x2F;开头的相对路径的时候，就容易出现路径动态拼接错误。</p>\n<p>那么有没有什么解决办法呢？</p>\n<h2 id=\"解决方法一：使用绝对路径\"><a href=\"#解决方法一：使用绝对路径\" class=\"headerlink\" title=\"解决方法一：使用绝对路径\"></a>解决方法一：使用绝对路径</h2><p>使用绝对路径就是在地址更换为当前文件在此电脑的完整地址。也就是<code>C:/......</code>的样子。</p>\n<p>这样在执行命令的时候，就不会出现错误了。<br>但是这样的方法却有着一个致命的缺陷，那就是：移植性大大降低。</p>\n<p>我们开发出来的程序总不可能一直都只在你这一台电脑上跑吧，使用绝对路径就会导致在其他电脑上找不到这个地址，就会报错。</p>\n<p>所以不推荐这种方法！！</p>\n<h2 id=\"第二种方法：-dirname\"><a href=\"#第二种方法：-dirname\" class=\"headerlink\" title=\"第二种方法：__dirname\"></a>第二种方法：<code>__dirname</code></h2><p>使用方法：就是在之前的相对路径前面加一个<code>__dirname</code></p>\n<p>栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(__dirname+<span class=\"string\">&#x27;/test.txt&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此时我们将目录切换到上一级之后，使用命令行<code>node ./node/readFile.js</code>，加上文件目录，就可以正常读取了。</p>\n<p>要是不使用<code>__dirname</code>执行此命令的话：就会报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Error: ENOENT: no such file or directory, open &#x27;D:\\test.txt&#x27;] &#123;</span><br><span class=\"line\">  errno: -4058,</span><br><span class=\"line\">  code: &#x27;ENOENT&#x27;,</span><br><span class=\"line\">  syscall: &#x27;open&#x27;,</span><br><span class=\"line\">  path: &#x27;D:\\\\test.txt&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"fs文件系统模块","date":"2022-12-16T16:00:00.000Z","_content":"# fs文件系统模块\n\n## 什么是fs文件系统模块\n\nfs模块是node.js官方提供的、操作文件的模块。\n\n例如：\n\n- fs.readFile():用于读取指定文件的文件内容\n- fs.writeFile()：用于向指定的文件写入内容\n\n引入fs模块：\n\n`const fs = require('fs');`\n\n## 读取指定文件的内容\n\n- fs.readFile()语法：\n\t`fs.readFile(path[,options],callback)`\n\t参数：\n\t\t- path:必选参数，字符串格式，表示文件的路径\n\t\t- options:*可选* 参数，表示以什么编码格式来读取文件\n\t\t- callback:必选参数：文件读取完成之后，通过这个回调函数返回读取的结果（失败：失败信息；成功：读取的结果）\n\n栗子：\n\n首先我先创建一个名为`test.txt`的文档，并且里面的内容是：\n`12341234`\n\n然后我们使用node.js里面的fs模块来读取文件：\n\n```js\n\t// 引入fs模块\n\tconst fs = require('fs');\n\t\n\t// 读取文件\n\tfs.readFile('./test.txt','utf-8',function(err,data){\n\t\tconsole.log(err);// null\n\t\tconsole.log(data);// 12341234\n\t})\n```\n\n我们可以看到在读取文件的时候，后面回调函数里面有两个参数：\n\n1. 第一个参数代表着读取失败的参数，此时我们这里读取成功，所以结果为null\n2. 第二个参数代表着读取成功之后的结果，这里我们读取到文件的内容，所以输出的就是文件的内容。\n\n我们可以根据读取文件回调函数的第一个参数返回的值来判断文件是否读取成功：如果返回的null，代表文件读取成功；否则读取失败。\n\n## 向指定文件写入内容\n\n- fs.writeFile()语法：\n\t`fs.writeFile(file,data[,options],callback);`\n\t参数：\n\t\t- 参数1：必选参数，字符串格式，表示文件的路径\n\t\t- 参数2：必选参数，表示写入的内容\n\t\t- 参数3：*可选* 参数，表示以什么编码格式写入内容\n\t\t- 参数4：必选参数，文件写入后的回调函数\n\n栗子：\n\n```js\n\tconst fs = require('fs');\n\n\tfs.writeFile('text.txt', '海绵宝宝', 'utf-8', function(err) {\n    \tconsole.log(err);// null\n\t})\n```\n\n这段代码执行完毕之后，输出一个`null`，那是不是就表示已经写入成功了呢？\n\n是的，在同级文件夹下，我们可以看到生成了一个新的`text.txt`文件，打开发现正式我们刚才写入的`海绵宝宝`。\n\n那么我们要是再执行一遍代码，只是写入的内容发生改变，那么结果是什么呢？\n\n```js\nfs.writeFile('text.txt', '派大星', 'utf-8', function(err) {\n    \tconsole.log(err);// null\n\t})\n```\n\n这个时候我们再打开`text.txt`文件，发现里面的内容变成了`派大星`，也就是说使用`wirteFile()`会覆盖掉文件原来的内容。\n\n此时，我们同样可以根据写入文件回调函数的参数返回的值来判断文件是否写入成功：如果返回的null，代表文件写入成功；否则写入失败。\n\n##  结尾\n\n通过`node.js`的fs模块，我们就可以实现对文件的读取以及写入了，本文章为我学习node.js的学习笔记，有不足之处望大佬们指点。\n\n\n\n","source":"_posts/node学习/fs文件系统模块.md","raw":"---\ntitle: fs文件系统模块\ndate: 2022-12-17\ntags: [前端]\ncategories: [node]\n---\n# fs文件系统模块\n\n## 什么是fs文件系统模块\n\nfs模块是node.js官方提供的、操作文件的模块。\n\n例如：\n\n- fs.readFile():用于读取指定文件的文件内容\n- fs.writeFile()：用于向指定的文件写入内容\n\n引入fs模块：\n\n`const fs = require('fs');`\n\n## 读取指定文件的内容\n\n- fs.readFile()语法：\n\t`fs.readFile(path[,options],callback)`\n\t参数：\n\t\t- path:必选参数，字符串格式，表示文件的路径\n\t\t- options:*可选* 参数，表示以什么编码格式来读取文件\n\t\t- callback:必选参数：文件读取完成之后，通过这个回调函数返回读取的结果（失败：失败信息；成功：读取的结果）\n\n栗子：\n\n首先我先创建一个名为`test.txt`的文档，并且里面的内容是：\n`12341234`\n\n然后我们使用node.js里面的fs模块来读取文件：\n\n```js\n\t// 引入fs模块\n\tconst fs = require('fs');\n\t\n\t// 读取文件\n\tfs.readFile('./test.txt','utf-8',function(err,data){\n\t\tconsole.log(err);// null\n\t\tconsole.log(data);// 12341234\n\t})\n```\n\n我们可以看到在读取文件的时候，后面回调函数里面有两个参数：\n\n1. 第一个参数代表着读取失败的参数，此时我们这里读取成功，所以结果为null\n2. 第二个参数代表着读取成功之后的结果，这里我们读取到文件的内容，所以输出的就是文件的内容。\n\n我们可以根据读取文件回调函数的第一个参数返回的值来判断文件是否读取成功：如果返回的null，代表文件读取成功；否则读取失败。\n\n## 向指定文件写入内容\n\n- fs.writeFile()语法：\n\t`fs.writeFile(file,data[,options],callback);`\n\t参数：\n\t\t- 参数1：必选参数，字符串格式，表示文件的路径\n\t\t- 参数2：必选参数，表示写入的内容\n\t\t- 参数3：*可选* 参数，表示以什么编码格式写入内容\n\t\t- 参数4：必选参数，文件写入后的回调函数\n\n栗子：\n\n```js\n\tconst fs = require('fs');\n\n\tfs.writeFile('text.txt', '海绵宝宝', 'utf-8', function(err) {\n    \tconsole.log(err);// null\n\t})\n```\n\n这段代码执行完毕之后，输出一个`null`，那是不是就表示已经写入成功了呢？\n\n是的，在同级文件夹下，我们可以看到生成了一个新的`text.txt`文件，打开发现正式我们刚才写入的`海绵宝宝`。\n\n那么我们要是再执行一遍代码，只是写入的内容发生改变，那么结果是什么呢？\n\n```js\nfs.writeFile('text.txt', '派大星', 'utf-8', function(err) {\n    \tconsole.log(err);// null\n\t})\n```\n\n这个时候我们再打开`text.txt`文件，发现里面的内容变成了`派大星`，也就是说使用`wirteFile()`会覆盖掉文件原来的内容。\n\n此时，我们同样可以根据写入文件回调函数的参数返回的值来判断文件是否写入成功：如果返回的null，代表文件写入成功；否则写入失败。\n\n##  结尾\n\n通过`node.js`的fs模块，我们就可以实现对文件的读取以及写入了，本文章为我学习node.js的学习笔记，有不足之处望大佬们指点。\n\n\n\n","slug":"node学习/fs文件系统模块","published":1,"updated":"2023-01-10T02:22:35.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmk9008r9kbm7tnw9vpe","content":"<h1 id=\"fs文件系统模块\"><a href=\"#fs文件系统模块\" class=\"headerlink\" title=\"fs文件系统模块\"></a>fs文件系统模块</h1><h2 id=\"什么是fs文件系统模块\"><a href=\"#什么是fs文件系统模块\" class=\"headerlink\" title=\"什么是fs文件系统模块\"></a>什么是fs文件系统模块</h2><p>fs模块是node.js官方提供的、操作文件的模块。</p>\n<p>例如：</p>\n<ul>\n<li>fs.readFile():用于读取指定文件的文件内容</li>\n<li>fs.writeFile()：用于向指定的文件写入内容</li>\n</ul>\n<p>引入fs模块：</p>\n<p><code>const fs = require(&#39;fs&#39;);</code></p>\n<h2 id=\"读取指定文件的内容\"><a href=\"#读取指定文件的内容\" class=\"headerlink\" title=\"读取指定文件的内容\"></a>读取指定文件的内容</h2><ul>\n<li>fs.readFile()语法：<br>  <code>fs.readFile(path[,options],callback)</code><br>  参数：<br>  - path:必选参数，字符串格式，表示文件的路径<br>  - options:<em>可选</em> 参数，表示以什么编码格式来读取文件<br>  - callback:必选参数：文件读取完成之后，通过这个回调函数返回读取的结果（失败：失败信息；成功：读取的结果）</li>\n</ul>\n<p>栗子：</p>\n<p>首先我先创建一个名为<code>test.txt</code>的文档，并且里面的内容是：<br><code>12341234</code></p>\n<p>然后我们使用node.js里面的fs模块来读取文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入fs模块</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;./test.txt&#x27;</span>,<span class=\"string\">&#x27;utf-8&#x27;</span>,<span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);<span class=\"comment\">// null</span></span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);<span class=\"comment\">// 12341234</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到在读取文件的时候，后面回调函数里面有两个参数：</p>\n<ol>\n<li>第一个参数代表着读取失败的参数，此时我们这里读取成功，所以结果为null</li>\n<li>第二个参数代表着读取成功之后的结果，这里我们读取到文件的内容，所以输出的就是文件的内容。</li>\n</ol>\n<p>我们可以根据读取文件回调函数的第一个参数返回的值来判断文件是否读取成功：如果返回的null，代表文件读取成功；否则读取失败。</p>\n<h2 id=\"向指定文件写入内容\"><a href=\"#向指定文件写入内容\" class=\"headerlink\" title=\"向指定文件写入内容\"></a>向指定文件写入内容</h2><ul>\n<li>fs.writeFile()语法：<br>  <code>fs.writeFile(file,data[,options],callback);</code><br>  参数：<br>  - 参数1：必选参数，字符串格式，表示文件的路径<br>  - 参数2：必选参数，表示写入的内容<br>  - 参数3：<em>可选</em> 参数，表示以什么编码格式写入内容<br>  - 参数4：必选参数，文件写入后的回调函数</li>\n</ul>\n<p>栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">writeFile</span>(<span class=\"string\">&#x27;text.txt&#x27;</span>, <span class=\"string\">&#x27;海绵宝宝&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">   \t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);<span class=\"comment\">// null</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码执行完毕之后，输出一个<code>null</code>，那是不是就表示已经写入成功了呢？</p>\n<p>是的，在同级文件夹下，我们可以看到生成了一个新的<code>text.txt</code>文件，打开发现正式我们刚才写入的<code>海绵宝宝</code>。</p>\n<p>那么我们要是再执行一遍代码，只是写入的内容发生改变，那么结果是什么呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.<span class=\"title function_\">writeFile</span>(<span class=\"string\">&#x27;text.txt&#x27;</span>, <span class=\"string\">&#x27;派大星&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);<span class=\"comment\">// null</span></span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这个时候我们再打开<code>text.txt</code>文件，发现里面的内容变成了<code>派大星</code>，也就是说使用<code>wirteFile()</code>会覆盖掉文件原来的内容。</p>\n<p>此时，我们同样可以根据写入文件回调函数的参数返回的值来判断文件是否写入成功：如果返回的null，代表文件写入成功；否则写入失败。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>通过<code>node.js</code>的fs模块，我们就可以实现对文件的读取以及写入了，本文章为我学习node.js的学习笔记，有不足之处望大佬们指点。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"fs文件系统模块\"><a href=\"#fs文件系统模块\" class=\"headerlink\" title=\"fs文件系统模块\"></a>fs文件系统模块</h1><h2 id=\"什么是fs文件系统模块\"><a href=\"#什么是fs文件系统模块\" class=\"headerlink\" title=\"什么是fs文件系统模块\"></a>什么是fs文件系统模块</h2><p>fs模块是node.js官方提供的、操作文件的模块。</p>\n<p>例如：</p>\n<ul>\n<li>fs.readFile():用于读取指定文件的文件内容</li>\n<li>fs.writeFile()：用于向指定的文件写入内容</li>\n</ul>\n<p>引入fs模块：</p>\n<p><code>const fs = require(&#39;fs&#39;);</code></p>\n<h2 id=\"读取指定文件的内容\"><a href=\"#读取指定文件的内容\" class=\"headerlink\" title=\"读取指定文件的内容\"></a>读取指定文件的内容</h2><ul>\n<li>fs.readFile()语法：<br>  <code>fs.readFile(path[,options],callback)</code><br>  参数：<br>  - path:必选参数，字符串格式，表示文件的路径<br>  - options:<em>可选</em> 参数，表示以什么编码格式来读取文件<br>  - callback:必选参数：文件读取完成之后，通过这个回调函数返回读取的结果（失败：失败信息；成功：读取的结果）</li>\n</ul>\n<p>栗子：</p>\n<p>首先我先创建一个名为<code>test.txt</code>的文档，并且里面的内容是：<br><code>12341234</code></p>\n<p>然后我们使用node.js里面的fs模块来读取文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入fs模块</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(<span class=\"string\">&#x27;./test.txt&#x27;</span>,<span class=\"string\">&#x27;utf-8&#x27;</span>,<span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);<span class=\"comment\">// null</span></span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);<span class=\"comment\">// 12341234</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到在读取文件的时候，后面回调函数里面有两个参数：</p>\n<ol>\n<li>第一个参数代表着读取失败的参数，此时我们这里读取成功，所以结果为null</li>\n<li>第二个参数代表着读取成功之后的结果，这里我们读取到文件的内容，所以输出的就是文件的内容。</li>\n</ol>\n<p>我们可以根据读取文件回调函数的第一个参数返回的值来判断文件是否读取成功：如果返回的null，代表文件读取成功；否则读取失败。</p>\n<h2 id=\"向指定文件写入内容\"><a href=\"#向指定文件写入内容\" class=\"headerlink\" title=\"向指定文件写入内容\"></a>向指定文件写入内容</h2><ul>\n<li>fs.writeFile()语法：<br>  <code>fs.writeFile(file,data[,options],callback);</code><br>  参数：<br>  - 参数1：必选参数，字符串格式，表示文件的路径<br>  - 参数2：必选参数，表示写入的内容<br>  - 参数3：<em>可选</em> 参数，表示以什么编码格式写入内容<br>  - 参数4：必选参数，文件写入后的回调函数</li>\n</ul>\n<p>栗子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">writeFile</span>(<span class=\"string\">&#x27;text.txt&#x27;</span>, <span class=\"string\">&#x27;海绵宝宝&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">   \t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);<span class=\"comment\">// null</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这段代码执行完毕之后，输出一个<code>null</code>，那是不是就表示已经写入成功了呢？</p>\n<p>是的，在同级文件夹下，我们可以看到生成了一个新的<code>text.txt</code>文件，打开发现正式我们刚才写入的<code>海绵宝宝</code>。</p>\n<p>那么我们要是再执行一遍代码，只是写入的内容发生改变，那么结果是什么呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.<span class=\"title function_\">writeFile</span>(<span class=\"string\">&#x27;text.txt&#x27;</span>, <span class=\"string\">&#x27;派大星&#x27;</span>, <span class=\"string\">&#x27;utf-8&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);<span class=\"comment\">// null</span></span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这个时候我们再打开<code>text.txt</code>文件，发现里面的内容变成了<code>派大星</code>，也就是说使用<code>wirteFile()</code>会覆盖掉文件原来的内容。</p>\n<p>此时，我们同样可以根据写入文件回调函数的参数返回的值来判断文件是否写入成功：如果返回的null，代表文件写入成功；否则写入失败。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>通过<code>node.js</code>的fs模块，我们就可以实现对文件的读取以及写入了，本文章为我学习node.js的学习笔记，有不足之处望大佬们指点。</p>\n"},{"title":"1","data":"2023-1-27","_content":"\n# 操作系统\n\n[TOC]\n\n## 1.操作系统的概念\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08bb3bfc50145758d71c496185def9d~tplv-k3u1fbpfcp-watermark.image?)\n\n1. 操作系统负责管理协调硬件、软件等计算机资源的工作\n2. 为上层的应用程序、用户提供简单易用的服务\n3. 操作系统是系统软件，而不是硬件。\n4. 操作系统是计算机系统中最基本的系统软件\n\n****\n\n## 2.操作系统的功能和目标：\n\n补充知识：进程是一个程序的执行过程，执行需要将该程序放到内存当中，才能被CPU处理。\n\n### 2.1作为系统资源的管理者\n\n操作系统实现的功能：\n\n- 处理机（CPU）管理\n- 存储器（运行内存）管理\n- 文件管理\n- 设备管理\n\n操作系统的目标：\n\n- 安全、高效\n\n### 2.2作为用户与计算机硬件之间的接口\n\n- 命令接口：允许用户直接使用\n  - 联机（交互式）命令接口：说一句指令，执行一句指令\n  - 脱机（批处理）命令接口：说一堆指令，再执行一堆指令\n- 程序接口：允许用户通过程序间接使用，由一组系统调用组成（程序接口=系统调用=广义指令）\n- GUI：现代操作系统中最流行的图形用户接口（图形化操作界面）\n\n### 2.3作为最接近硬件的层次\n\n这里操作系统需要提供的功能和目标：实现对硬件及其的拓展\n\n我们通常把覆盖了软件了的称为扩充及其，也就是虚拟机。\n\n****\n\n## 3.操作系统的四个特征：\n\n两个最基本的特征：并发、共享，两者互为存在条件\n\n### 3.1并发\n\n**并发：** 是指两个或者多个事件同一时间间隔发生。这些事件宏观上市同时发生的，但是微观上交替发生的。\n\n**易混淆概念：并行** 并行是指两个或者多个事件在同一时刻发生。\n\n**操作系统的并发性：** 是指计算机系统中同时存在着多个运行的程序，且这些程序都处于已启动运行到运行完毕之间的状态，且宏观上是同时运行的，但是微观上是交替运行的。\n\n### 3.2共享\n\n**共享：** 资源共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用\n\n两种资源共享的方式：\n\n- 互斥共享： 一个时间段内只允许一个进程访问该资源\n- 同时共享：允许一个时间段内多个进程“同时”（宏观）访问该资源，微观上交替访问。\n\n**并发和共享的关系：** 如果失去了并发性，则系统中只有一个程序在允许，则共享性就失去了意义；如果失去了共享性，则系统中的程序都是独立的，不会相互影响，也就失去了并发性。\n\n其余两个特征：\n\n### 3.3虚拟\n\n**虚拟：** 是指把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的。\n\n**虚拟技术：**\n\n- 空分复用技术（比如虚拟储存器技术）\n- 时分复用技术（比如虚拟处理器）\n\n### 3.4异步\n\n**异步：** 是指在多道程勋环境下，允许多个程序并发执行，但是由于资源有限，进程的执行并不是一下到底的，而是走走停停的，这就是进程的异步性。\n\n没有并发就谈不上虚拟和异步，所以并发和共享是操作系统中两个最基本的特征。","source":"_posts/复习笔记/01.md","raw":"---\ntitle: 01\ndata: 2023-1-27\ntags: [计算机]\ncategories: [操作系统]\n---\n\n# 操作系统\n\n[TOC]\n\n## 1.操作系统的概念\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08bb3bfc50145758d71c496185def9d~tplv-k3u1fbpfcp-watermark.image?)\n\n1. 操作系统负责管理协调硬件、软件等计算机资源的工作\n2. 为上层的应用程序、用户提供简单易用的服务\n3. 操作系统是系统软件，而不是硬件。\n4. 操作系统是计算机系统中最基本的系统软件\n\n****\n\n## 2.操作系统的功能和目标：\n\n补充知识：进程是一个程序的执行过程，执行需要将该程序放到内存当中，才能被CPU处理。\n\n### 2.1作为系统资源的管理者\n\n操作系统实现的功能：\n\n- 处理机（CPU）管理\n- 存储器（运行内存）管理\n- 文件管理\n- 设备管理\n\n操作系统的目标：\n\n- 安全、高效\n\n### 2.2作为用户与计算机硬件之间的接口\n\n- 命令接口：允许用户直接使用\n  - 联机（交互式）命令接口：说一句指令，执行一句指令\n  - 脱机（批处理）命令接口：说一堆指令，再执行一堆指令\n- 程序接口：允许用户通过程序间接使用，由一组系统调用组成（程序接口=系统调用=广义指令）\n- GUI：现代操作系统中最流行的图形用户接口（图形化操作界面）\n\n### 2.3作为最接近硬件的层次\n\n这里操作系统需要提供的功能和目标：实现对硬件及其的拓展\n\n我们通常把覆盖了软件了的称为扩充及其，也就是虚拟机。\n\n****\n\n## 3.操作系统的四个特征：\n\n两个最基本的特征：并发、共享，两者互为存在条件\n\n### 3.1并发\n\n**并发：** 是指两个或者多个事件同一时间间隔发生。这些事件宏观上市同时发生的，但是微观上交替发生的。\n\n**易混淆概念：并行** 并行是指两个或者多个事件在同一时刻发生。\n\n**操作系统的并发性：** 是指计算机系统中同时存在着多个运行的程序，且这些程序都处于已启动运行到运行完毕之间的状态，且宏观上是同时运行的，但是微观上是交替运行的。\n\n### 3.2共享\n\n**共享：** 资源共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用\n\n两种资源共享的方式：\n\n- 互斥共享： 一个时间段内只允许一个进程访问该资源\n- 同时共享：允许一个时间段内多个进程“同时”（宏观）访问该资源，微观上交替访问。\n\n**并发和共享的关系：** 如果失去了并发性，则系统中只有一个程序在允许，则共享性就失去了意义；如果失去了共享性，则系统中的程序都是独立的，不会相互影响，也就失去了并发性。\n\n其余两个特征：\n\n### 3.3虚拟\n\n**虚拟：** 是指把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的。\n\n**虚拟技术：**\n\n- 空分复用技术（比如虚拟储存器技术）\n- 时分复用技术（比如虚拟处理器）\n\n### 3.4异步\n\n**异步：** 是指在多道程勋环境下，允许多个程序并发执行，但是由于资源有限，进程的执行并不是一下到底的，而是走走停停的，这就是进程的异步性。\n\n没有并发就谈不上虚拟和异步，所以并发和共享是操作系统中两个最基本的特征。","slug":"复习笔记/01","published":1,"date":"2023-01-27T08:29:39.961Z","updated":"2023-01-27T09:34:09.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkb008v9kbm4845gy8i","content":"<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><p>[TOC]</p>\n<h2 id=\"1-操作系统的概念\"><a href=\"#1-操作系统的概念\" class=\"headerlink\" title=\"1.操作系统的概念\"></a>1.操作系统的概念</h2><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08bb3bfc50145758d71c496185def9d~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ol>\n<li>操作系统负责管理协调硬件、软件等计算机资源的工作</li>\n<li>为上层的应用程序、用户提供简单易用的服务</li>\n<li>操作系统是系统软件，而不是硬件。</li>\n<li>操作系统是计算机系统中最基本的系统软件</li>\n</ol>\n<hr>\n<h2 id=\"2-操作系统的功能和目标：\"><a href=\"#2-操作系统的功能和目标：\" class=\"headerlink\" title=\"2.操作系统的功能和目标：\"></a>2.操作系统的功能和目标：</h2><p>补充知识：进程是一个程序的执行过程，执行需要将该程序放到内存当中，才能被CPU处理。</p>\n<h3 id=\"2-1作为系统资源的管理者\"><a href=\"#2-1作为系统资源的管理者\" class=\"headerlink\" title=\"2.1作为系统资源的管理者\"></a>2.1作为系统资源的管理者</h3><p>操作系统实现的功能：</p>\n<ul>\n<li>处理机（CPU）管理</li>\n<li>存储器（运行内存）管理</li>\n<li>文件管理</li>\n<li>设备管理</li>\n</ul>\n<p>操作系统的目标：</p>\n<ul>\n<li>安全、高效</li>\n</ul>\n<h3 id=\"2-2作为用户与计算机硬件之间的接口\"><a href=\"#2-2作为用户与计算机硬件之间的接口\" class=\"headerlink\" title=\"2.2作为用户与计算机硬件之间的接口\"></a>2.2作为用户与计算机硬件之间的接口</h3><ul>\n<li>命令接口：允许用户直接使用<ul>\n<li>联机（交互式）命令接口：说一句指令，执行一句指令</li>\n<li>脱机（批处理）命令接口：说一堆指令，再执行一堆指令</li>\n</ul>\n</li>\n<li>程序接口：允许用户通过程序间接使用，由一组系统调用组成（程序接口&#x3D;系统调用&#x3D;广义指令）</li>\n<li>GUI：现代操作系统中最流行的图形用户接口（图形化操作界面）</li>\n</ul>\n<h3 id=\"2-3作为最接近硬件的层次\"><a href=\"#2-3作为最接近硬件的层次\" class=\"headerlink\" title=\"2.3作为最接近硬件的层次\"></a>2.3作为最接近硬件的层次</h3><p>这里操作系统需要提供的功能和目标：实现对硬件及其的拓展</p>\n<p>我们通常把覆盖了软件了的称为扩充及其，也就是虚拟机。</p>\n<hr>\n<h2 id=\"3-操作系统的四个特征：\"><a href=\"#3-操作系统的四个特征：\" class=\"headerlink\" title=\"3.操作系统的四个特征：\"></a>3.操作系统的四个特征：</h2><p>两个最基本的特征：并发、共享，两者互为存在条件</p>\n<h3 id=\"3-1并发\"><a href=\"#3-1并发\" class=\"headerlink\" title=\"3.1并发\"></a>3.1并发</h3><p><strong>并发：</strong> 是指两个或者多个事件同一时间间隔发生。这些事件宏观上市同时发生的，但是微观上交替发生的。</p>\n<p><strong>易混淆概念：并行</strong> 并行是指两个或者多个事件在同一时刻发生。</p>\n<p><strong>操作系统的并发性：</strong> 是指计算机系统中同时存在着多个运行的程序，且这些程序都处于已启动运行到运行完毕之间的状态，且宏观上是同时运行的，但是微观上是交替运行的。</p>\n<h3 id=\"3-2共享\"><a href=\"#3-2共享\" class=\"headerlink\" title=\"3.2共享\"></a>3.2共享</h3><p><strong>共享：</strong> 资源共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用</p>\n<p>两种资源共享的方式：</p>\n<ul>\n<li>互斥共享： 一个时间段内只允许一个进程访问该资源</li>\n<li>同时共享：允许一个时间段内多个进程“同时”（宏观）访问该资源，微观上交替访问。</li>\n</ul>\n<p><strong>并发和共享的关系：</strong> 如果失去了并发性，则系统中只有一个程序在允许，则共享性就失去了意义；如果失去了共享性，则系统中的程序都是独立的，不会相互影响，也就失去了并发性。</p>\n<p>其余两个特征：</p>\n<h3 id=\"3-3虚拟\"><a href=\"#3-3虚拟\" class=\"headerlink\" title=\"3.3虚拟\"></a>3.3虚拟</h3><p><strong>虚拟：</strong> 是指把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的。</p>\n<p><strong>虚拟技术：</strong></p>\n<ul>\n<li>空分复用技术（比如虚拟储存器技术）</li>\n<li>时分复用技术（比如虚拟处理器）</li>\n</ul>\n<h3 id=\"3-4异步\"><a href=\"#3-4异步\" class=\"headerlink\" title=\"3.4异步\"></a>3.4异步</h3><p><strong>异步：</strong> 是指在多道程勋环境下，允许多个程序并发执行，但是由于资源有限，进程的执行并不是一下到底的，而是走走停停的，这就是进程的异步性。</p>\n<p>没有并发就谈不上虚拟和异步，所以并发和共享是操作系统中两个最基本的特征。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><p>[TOC]</p>\n<h2 id=\"1-操作系统的概念\"><a href=\"#1-操作系统的概念\" class=\"headerlink\" title=\"1.操作系统的概念\"></a>1.操作系统的概念</h2><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c08bb3bfc50145758d71c496185def9d~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ol>\n<li>操作系统负责管理协调硬件、软件等计算机资源的工作</li>\n<li>为上层的应用程序、用户提供简单易用的服务</li>\n<li>操作系统是系统软件，而不是硬件。</li>\n<li>操作系统是计算机系统中最基本的系统软件</li>\n</ol>\n<hr>\n<h2 id=\"2-操作系统的功能和目标：\"><a href=\"#2-操作系统的功能和目标：\" class=\"headerlink\" title=\"2.操作系统的功能和目标：\"></a>2.操作系统的功能和目标：</h2><p>补充知识：进程是一个程序的执行过程，执行需要将该程序放到内存当中，才能被CPU处理。</p>\n<h3 id=\"2-1作为系统资源的管理者\"><a href=\"#2-1作为系统资源的管理者\" class=\"headerlink\" title=\"2.1作为系统资源的管理者\"></a>2.1作为系统资源的管理者</h3><p>操作系统实现的功能：</p>\n<ul>\n<li>处理机（CPU）管理</li>\n<li>存储器（运行内存）管理</li>\n<li>文件管理</li>\n<li>设备管理</li>\n</ul>\n<p>操作系统的目标：</p>\n<ul>\n<li>安全、高效</li>\n</ul>\n<h3 id=\"2-2作为用户与计算机硬件之间的接口\"><a href=\"#2-2作为用户与计算机硬件之间的接口\" class=\"headerlink\" title=\"2.2作为用户与计算机硬件之间的接口\"></a>2.2作为用户与计算机硬件之间的接口</h3><ul>\n<li>命令接口：允许用户直接使用<ul>\n<li>联机（交互式）命令接口：说一句指令，执行一句指令</li>\n<li>脱机（批处理）命令接口：说一堆指令，再执行一堆指令</li>\n</ul>\n</li>\n<li>程序接口：允许用户通过程序间接使用，由一组系统调用组成（程序接口&#x3D;系统调用&#x3D;广义指令）</li>\n<li>GUI：现代操作系统中最流行的图形用户接口（图形化操作界面）</li>\n</ul>\n<h3 id=\"2-3作为最接近硬件的层次\"><a href=\"#2-3作为最接近硬件的层次\" class=\"headerlink\" title=\"2.3作为最接近硬件的层次\"></a>2.3作为最接近硬件的层次</h3><p>这里操作系统需要提供的功能和目标：实现对硬件及其的拓展</p>\n<p>我们通常把覆盖了软件了的称为扩充及其，也就是虚拟机。</p>\n<hr>\n<h2 id=\"3-操作系统的四个特征：\"><a href=\"#3-操作系统的四个特征：\" class=\"headerlink\" title=\"3.操作系统的四个特征：\"></a>3.操作系统的四个特征：</h2><p>两个最基本的特征：并发、共享，两者互为存在条件</p>\n<h3 id=\"3-1并发\"><a href=\"#3-1并发\" class=\"headerlink\" title=\"3.1并发\"></a>3.1并发</h3><p><strong>并发：</strong> 是指两个或者多个事件同一时间间隔发生。这些事件宏观上市同时发生的，但是微观上交替发生的。</p>\n<p><strong>易混淆概念：并行</strong> 并行是指两个或者多个事件在同一时刻发生。</p>\n<p><strong>操作系统的并发性：</strong> 是指计算机系统中同时存在着多个运行的程序，且这些程序都处于已启动运行到运行完毕之间的状态，且宏观上是同时运行的，但是微观上是交替运行的。</p>\n<h3 id=\"3-2共享\"><a href=\"#3-2共享\" class=\"headerlink\" title=\"3.2共享\"></a>3.2共享</h3><p><strong>共享：</strong> 资源共享，是指系统中的资源可以供内存中多个并发执行的进程共同使用</p>\n<p>两种资源共享的方式：</p>\n<ul>\n<li>互斥共享： 一个时间段内只允许一个进程访问该资源</li>\n<li>同时共享：允许一个时间段内多个进程“同时”（宏观）访问该资源，微观上交替访问。</li>\n</ul>\n<p><strong>并发和共享的关系：</strong> 如果失去了并发性，则系统中只有一个程序在允许，则共享性就失去了意义；如果失去了共享性，则系统中的程序都是独立的，不会相互影响，也就失去了并发性。</p>\n<p>其余两个特征：</p>\n<h3 id=\"3-3虚拟\"><a href=\"#3-3虚拟\" class=\"headerlink\" title=\"3.3虚拟\"></a>3.3虚拟</h3><p><strong>虚拟：</strong> 是指把一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的。</p>\n<p><strong>虚拟技术：</strong></p>\n<ul>\n<li>空分复用技术（比如虚拟储存器技术）</li>\n<li>时分复用技术（比如虚拟处理器）</li>\n</ul>\n<h3 id=\"3-4异步\"><a href=\"#3-4异步\" class=\"headerlink\" title=\"3.4异步\"></a>3.4异步</h3><p><strong>异步：</strong> 是指在多道程勋环境下，允许多个程序并发执行，但是由于资源有限，进程的执行并不是一下到底的，而是走走停停的，这就是进程的异步性。</p>\n<p>没有并发就谈不上虚拟和异步，所以并发和共享是操作系统中两个最基本的特征。</p>\n"},{"title":"什么是path路径模块","date":"2022-12-16T16:00:00.000Z","_content":"# path路径模块\n\n## 什么是path路径模块\n\n`path路径模块`是`node.js`官方提供的用来处理路径的模块。\n\n比如：\n\n- `path.join()`:将多个路径片段拼接成为一个完整的路径片段\n- `path.basename()`:可以从文件的路径字符串里面，将文件的名字解析出来\n\n引入模块：\n\n`const path = require('path');`\n\n## 路径拼接\n\n`path.join()`语法格式：\n\n`path.join([...paths])`:","source":"_posts/node学习/path路径模块.md","raw":"---\ntitle: 什么是path路径模块\ndate: 2022-12-17\ntags: [前端]\ncategories: [node]\n---\n# path路径模块\n\n## 什么是path路径模块\n\n`path路径模块`是`node.js`官方提供的用来处理路径的模块。\n\n比如：\n\n- `path.join()`:将多个路径片段拼接成为一个完整的路径片段\n- `path.basename()`:可以从文件的路径字符串里面，将文件的名字解析出来\n\n引入模块：\n\n`const path = require('path');`\n\n## 路径拼接\n\n`path.join()`语法格式：\n\n`path.join([...paths])`:","slug":"node学习/path路径模块","published":1,"updated":"2023-01-10T02:23:13.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkh008y9kbmbq3xdfme","content":"<h1 id=\"path路径模块\"><a href=\"#path路径模块\" class=\"headerlink\" title=\"path路径模块\"></a>path路径模块</h1><h2 id=\"什么是path路径模块\"><a href=\"#什么是path路径模块\" class=\"headerlink\" title=\"什么是path路径模块\"></a>什么是path路径模块</h2><p><code>path路径模块</code>是<code>node.js</code>官方提供的用来处理路径的模块。</p>\n<p>比如：</p>\n<ul>\n<li><code>path.join()</code>:将多个路径片段拼接成为一个完整的路径片段</li>\n<li><code>path.basename()</code>:可以从文件的路径字符串里面，将文件的名字解析出来</li>\n</ul>\n<p>引入模块：</p>\n<p><code>const path = require(&#39;path&#39;);</code></p>\n<h2 id=\"路径拼接\"><a href=\"#路径拼接\" class=\"headerlink\" title=\"路径拼接\"></a>路径拼接</h2><p><code>path.join()</code>语法格式：</p>\n<p><code>path.join([...paths])</code>:</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"path路径模块\"><a href=\"#path路径模块\" class=\"headerlink\" title=\"path路径模块\"></a>path路径模块</h1><h2 id=\"什么是path路径模块\"><a href=\"#什么是path路径模块\" class=\"headerlink\" title=\"什么是path路径模块\"></a>什么是path路径模块</h2><p><code>path路径模块</code>是<code>node.js</code>官方提供的用来处理路径的模块。</p>\n<p>比如：</p>\n<ul>\n<li><code>path.join()</code>:将多个路径片段拼接成为一个完整的路径片段</li>\n<li><code>path.basename()</code>:可以从文件的路径字符串里面，将文件的名字解析出来</li>\n</ul>\n<p>引入模块：</p>\n<p><code>const path = require(&#39;path&#39;);</code></p>\n<h2 id=\"路径拼接\"><a href=\"#路径拼接\" class=\"headerlink\" title=\"路径拼接\"></a>路径拼接</h2><p><code>path.join()</code>语法格式：</p>\n<p><code>path.join([...paths])</code>:</p>\n"},{"title":"HTML标签的基本使用","date":"2023-03-29T16:00:00.000Z","_content":"\n# HTML标签的基本使用\n\n## 基本标签\n\n### 标题标签\n\n```html\n<h1></h1>\n.\n.\n.\n<h6></h6>\n```\n\n`<h1></h1>`标题最大，`<h6></h6>`字体最小\n\n### 居中标签\n\n将文字放在里面，会在网页中居中，但是不常用了，也不推荐用了，后面会用CSS代替。\n\n```HTML\n<center></center>\n```\n\n### 段落标签\n\n我们在文字放在段落标签中，形成一个段落。\n\n```HTML\n<p></p>\n```\n\n### 水平线标签\n\n```HTML\n<hr/>\n```\n\n这是一个自闭和标签，也就是他只有一个标签，没有闭合标签。在网页上的效果就是形成条水平线。\n\n### 字体标签\n\n```HTML\n<font></font>\n```\n\n里面有一些属性：\n\n- color:设置字体颜色\n- face:设置字体\n- size:设置字体大小\n\n### 换行标签\n\n```HTML\n<br>\n```\n\n这个也是一个自闭和标签，在html中，文档中的换行在html会失效，要实现换行必须使用`<br>`\n\n### 加粗标签\n\n```HTML\n<b></b>\n```\n\n将文字放在这个标签中，字体就会加粗。\n\n### 下划线字体\n\n```HTML\n<u></u>\n```\n\n将字体包含在这个标签中，就可以实现下划线效果。\n\n### 斜体标签\n\n```HTML\n<i></i>\n```\n\n将文字放在里面，可以实现文字的斜体效果。\n\n### 图像标签\n\n```HTML\n<img src=\"路径\">\n```\n\n在img标签中，我们在路径中可以写上图片的路径，比如绝对地址，相对地址，或者URL路径。\n\n图像的替代文字，要是图片不能正确加载，我们使用文字来代替，使用`alt`属性。\n\n```HTML\n<img src=\"./img\" alt=\"图片的描述\">\n```\n\n### 格式文本\n\n```HTML\n<pre></pre>\n```\n\n格式化文本。原样显示，包括里面的一些换行，空格。\n\n### 超链接\n\n- 链接到外部\n- 链接到内部文档（锚点）\n- 电子邮件\n\n**详细介绍：**\n\n- 连接到外部：\n\n```HTML\n<a href=\"URL\" target=\"规定在何处打开链接\"></a>\n```\n\n- 内部链接\n\n要跳转到的地方：\n\n```HTML\n<a name=\"hmbb\"></a>\n```\n\n跳转的按钮：\n\n```HTML\n<a href=\"#hmbb\">点击跳转</a>\n```\n\n## 元素的区分\n\n### 块级元素\n\n独占一行。\n\n### 行内元素\n\n不会独占一行。","source":"_posts/双体web/HTML基本标签的使用.md","raw":"---\ntitle: HTML标签的基本使用\ndate: [2023-3-30]\ntags: [前端]\ncategories: [HTML]\n---\n\n# HTML标签的基本使用\n\n## 基本标签\n\n### 标题标签\n\n```html\n<h1></h1>\n.\n.\n.\n<h6></h6>\n```\n\n`<h1></h1>`标题最大，`<h6></h6>`字体最小\n\n### 居中标签\n\n将文字放在里面，会在网页中居中，但是不常用了，也不推荐用了，后面会用CSS代替。\n\n```HTML\n<center></center>\n```\n\n### 段落标签\n\n我们在文字放在段落标签中，形成一个段落。\n\n```HTML\n<p></p>\n```\n\n### 水平线标签\n\n```HTML\n<hr/>\n```\n\n这是一个自闭和标签，也就是他只有一个标签，没有闭合标签。在网页上的效果就是形成条水平线。\n\n### 字体标签\n\n```HTML\n<font></font>\n```\n\n里面有一些属性：\n\n- color:设置字体颜色\n- face:设置字体\n- size:设置字体大小\n\n### 换行标签\n\n```HTML\n<br>\n```\n\n这个也是一个自闭和标签，在html中，文档中的换行在html会失效，要实现换行必须使用`<br>`\n\n### 加粗标签\n\n```HTML\n<b></b>\n```\n\n将文字放在这个标签中，字体就会加粗。\n\n### 下划线字体\n\n```HTML\n<u></u>\n```\n\n将字体包含在这个标签中，就可以实现下划线效果。\n\n### 斜体标签\n\n```HTML\n<i></i>\n```\n\n将文字放在里面，可以实现文字的斜体效果。\n\n### 图像标签\n\n```HTML\n<img src=\"路径\">\n```\n\n在img标签中，我们在路径中可以写上图片的路径，比如绝对地址，相对地址，或者URL路径。\n\n图像的替代文字，要是图片不能正确加载，我们使用文字来代替，使用`alt`属性。\n\n```HTML\n<img src=\"./img\" alt=\"图片的描述\">\n```\n\n### 格式文本\n\n```HTML\n<pre></pre>\n```\n\n格式化文本。原样显示，包括里面的一些换行，空格。\n\n### 超链接\n\n- 链接到外部\n- 链接到内部文档（锚点）\n- 电子邮件\n\n**详细介绍：**\n\n- 连接到外部：\n\n```HTML\n<a href=\"URL\" target=\"规定在何处打开链接\"></a>\n```\n\n- 内部链接\n\n要跳转到的地方：\n\n```HTML\n<a name=\"hmbb\"></a>\n```\n\n跳转的按钮：\n\n```HTML\n<a href=\"#hmbb\">点击跳转</a>\n```\n\n## 元素的区分\n\n### 块级元素\n\n独占一行。\n\n### 行内元素\n\n不会独占一行。","slug":"双体web/HTML基本标签的使用","published":1,"updated":"2023-03-30T07:26:23.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkk00939kbm5ivn5425","content":"<h1 id=\"HTML标签的基本使用\"><a href=\"#HTML标签的基本使用\" class=\"headerlink\" title=\"HTML标签的基本使用\"></a>HTML标签的基本使用</h1><h2 id=\"基本标签\"><a href=\"#基本标签\" class=\"headerlink\" title=\"基本标签\"></a>基本标签</h2><h3 id=\"标题标签\"><a href=\"#标题标签\" class=\"headerlink\" title=\"标题标签\"></a>标题标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>&lt;h1&gt;&lt;/h1&gt;</code>标题最大，<code>&lt;h6&gt;&lt;/h6&gt;</code>字体最小</p>\n<h3 id=\"居中标签\"><a href=\"#居中标签\" class=\"headerlink\" title=\"居中标签\"></a>居中标签</h3><p>将文字放在里面，会在网页中居中，但是不常用了，也不推荐用了，后面会用CSS代替。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">center</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"段落标签\"><a href=\"#段落标签\" class=\"headerlink\" title=\"段落标签\"></a>段落标签</h3><p>我们在文字放在段落标签中，形成一个段落。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"水平线标签\"><a href=\"#水平线标签\" class=\"headerlink\" title=\"水平线标签\"></a>水平线标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是一个自闭和标签，也就是他只有一个标签，没有闭合标签。在网页上的效果就是形成条水平线。</p>\n<h3 id=\"字体标签\"><a href=\"#字体标签\" class=\"headerlink\" title=\"字体标签\"></a>字体标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">font</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>里面有一些属性：</p>\n<ul>\n<li>color:设置字体颜色</li>\n<li>face:设置字体</li>\n<li>size:设置字体大小</li>\n</ul>\n<h3 id=\"换行标签\"><a href=\"#换行标签\" class=\"headerlink\" title=\"换行标签\"></a>换行标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个也是一个自闭和标签，在html中，文档中的换行在html会失效，要实现换行必须使用<code>&lt;br&gt;</code></p>\n<h3 id=\"加粗标签\"><a href=\"#加粗标签\" class=\"headerlink\" title=\"加粗标签\"></a>加粗标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将文字放在这个标签中，字体就会加粗。</p>\n<h3 id=\"下划线字体\"><a href=\"#下划线字体\" class=\"headerlink\" title=\"下划线字体\"></a>下划线字体</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">u</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">u</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将字体包含在这个标签中，就可以实现下划线效果。</p>\n<h3 id=\"斜体标签\"><a href=\"#斜体标签\" class=\"headerlink\" title=\"斜体标签\"></a>斜体标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将文字放在里面，可以实现文字的斜体效果。</p>\n<h3 id=\"图像标签\"><a href=\"#图像标签\" class=\"headerlink\" title=\"图像标签\"></a>图像标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在img标签中，我们在路径中可以写上图片的路径，比如绝对地址，相对地址，或者URL路径。</p>\n<p>图像的替代文字，要是图片不能正确加载，我们使用文字来代替，使用<code>alt</code>属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./img&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;图片的描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"格式文本\"><a href=\"#格式文本\" class=\"headerlink\" title=\"格式文本\"></a>格式文本</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">pre</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>格式化文本。原样显示，包括里面的一些换行，空格。</p>\n<h3 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h3><ul>\n<li>链接到外部</li>\n<li>链接到内部文档（锚点）</li>\n<li>电子邮件</li>\n</ul>\n<p><strong>详细介绍：</strong></p>\n<ul>\n<li>连接到外部：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;URL&quot;</span> <span class=\"attr\">target</span>=<span class=\"string\">&quot;规定在何处打开链接&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>内部链接</li>\n</ul>\n<p>要跳转到的地方：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hmbb&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>跳转的按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;#hmbb&quot;</span>&gt;</span>点击跳转<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元素的区分\"><a href=\"#元素的区分\" class=\"headerlink\" title=\"元素的区分\"></a>元素的区分</h2><h3 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h3><p>独占一行。</p>\n<h3 id=\"行内元素\"><a href=\"#行内元素\" class=\"headerlink\" title=\"行内元素\"></a>行内元素</h3><p>不会独占一行。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTML标签的基本使用\"><a href=\"#HTML标签的基本使用\" class=\"headerlink\" title=\"HTML标签的基本使用\"></a>HTML标签的基本使用</h1><h2 id=\"基本标签\"><a href=\"#基本标签\" class=\"headerlink\" title=\"基本标签\"></a>基本标签</h2><h3 id=\"标题标签\"><a href=\"#标题标签\" class=\"headerlink\" title=\"标题标签\"></a>标题标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\">.</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>&lt;h1&gt;&lt;/h1&gt;</code>标题最大，<code>&lt;h6&gt;&lt;/h6&gt;</code>字体最小</p>\n<h3 id=\"居中标签\"><a href=\"#居中标签\" class=\"headerlink\" title=\"居中标签\"></a>居中标签</h3><p>将文字放在里面，会在网页中居中，但是不常用了，也不推荐用了，后面会用CSS代替。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">center</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"段落标签\"><a href=\"#段落标签\" class=\"headerlink\" title=\"段落标签\"></a>段落标签</h3><p>我们在文字放在段落标签中，形成一个段落。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"水平线标签\"><a href=\"#水平线标签\" class=\"headerlink\" title=\"水平线标签\"></a>水平线标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hr</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是一个自闭和标签，也就是他只有一个标签，没有闭合标签。在网页上的效果就是形成条水平线。</p>\n<h3 id=\"字体标签\"><a href=\"#字体标签\" class=\"headerlink\" title=\"字体标签\"></a>字体标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">font</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>里面有一些属性：</p>\n<ul>\n<li>color:设置字体颜色</li>\n<li>face:设置字体</li>\n<li>size:设置字体大小</li>\n</ul>\n<h3 id=\"换行标签\"><a href=\"#换行标签\" class=\"headerlink\" title=\"换行标签\"></a>换行标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个也是一个自闭和标签，在html中，文档中的换行在html会失效，要实现换行必须使用<code>&lt;br&gt;</code></p>\n<h3 id=\"加粗标签\"><a href=\"#加粗标签\" class=\"headerlink\" title=\"加粗标签\"></a>加粗标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将文字放在这个标签中，字体就会加粗。</p>\n<h3 id=\"下划线字体\"><a href=\"#下划线字体\" class=\"headerlink\" title=\"下划线字体\"></a>下划线字体</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">u</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">u</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将字体包含在这个标签中，就可以实现下划线效果。</p>\n<h3 id=\"斜体标签\"><a href=\"#斜体标签\" class=\"headerlink\" title=\"斜体标签\"></a>斜体标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">i</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>将文字放在里面，可以实现文字的斜体效果。</p>\n<h3 id=\"图像标签\"><a href=\"#图像标签\" class=\"headerlink\" title=\"图像标签\"></a>图像标签</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在img标签中，我们在路径中可以写上图片的路径，比如绝对地址，相对地址，或者URL路径。</p>\n<p>图像的替代文字，要是图片不能正确加载，我们使用文字来代替，使用<code>alt</code>属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./img&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;图片的描述&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"格式文本\"><a href=\"#格式文本\" class=\"headerlink\" title=\"格式文本\"></a>格式文本</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">pre</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>格式化文本。原样显示，包括里面的一些换行，空格。</p>\n<h3 id=\"超链接\"><a href=\"#超链接\" class=\"headerlink\" title=\"超链接\"></a>超链接</h3><ul>\n<li>链接到外部</li>\n<li>链接到内部文档（锚点）</li>\n<li>电子邮件</li>\n</ul>\n<p><strong>详细介绍：</strong></p>\n<ul>\n<li>连接到外部：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;URL&quot;</span> <span class=\"attr\">target</span>=<span class=\"string\">&quot;规定在何处打开链接&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>内部链接</li>\n</ul>\n<p>要跳转到的地方：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hmbb&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>跳转的按钮：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;#hmbb&quot;</span>&gt;</span>点击跳转<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元素的区分\"><a href=\"#元素的区分\" class=\"headerlink\" title=\"元素的区分\"></a>元素的区分</h2><h3 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h3><p>独占一行。</p>\n<h3 id=\"行内元素\"><a href=\"#行内元素\" class=\"headerlink\" title=\"行内元素\"></a>行内元素</h3><p>不会独占一行。</p>\n"},{"title":"安卓","data":"2023-1-31","_content":"\n# 安卓复习笔记\n\n","source":"_posts/复习笔记/安卓.md","raw":"---\ntitle: 安卓\ndata: 2023-1-31\ntags: [计算机]\ncategories: [安卓]\n---\n\n# 安卓复习笔记\n\n","slug":"复习笔记/安卓","published":1,"date":"2023-01-31T07:20:11.743Z","updated":"2023-01-31T07:21:12.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkl00969kbm44ie9a0g","content":"<h1 id=\"安卓复习笔记\"><a href=\"#安卓复习笔记\" class=\"headerlink\" title=\"安卓复习笔记\"></a>安卓复习笔记</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安卓复习笔记\"><a href=\"#安卓复习笔记\" class=\"headerlink\" title=\"安卓复习笔记\"></a>安卓复习笔记</h1>"},{"title":"require函数","data":"2023-3-5","_content":"\n# require函数\n\n在node.js中，我们经常会导入一些模块，这其中包括我们自己所写的一些模块，也包含一些node的核心模块，比如fs、http等等。\n\n这个时候我们就需要用到require函数了。\n\n既然这是一个函数，我们在使用的时候，就需要在函数名后面加上一对小括号，然后在小括号里面写上我们需要导入的模块的路径。\n\n## 导入node核心模块\n\n在node中，我们可以直接导入node的核心模块，比如fs、http等等。\n\n`const fs = require(\"fs\");`","source":"_posts/node学习/require函数.md","raw":"---\ntitle: require函数\ndata: 2023-3-5\ntags: [前端]\ncategories: [node]\n---\n\n# require函数\n\n在node.js中，我们经常会导入一些模块，这其中包括我们自己所写的一些模块，也包含一些node的核心模块，比如fs、http等等。\n\n这个时候我们就需要用到require函数了。\n\n既然这是一个函数，我们在使用的时候，就需要在函数名后面加上一对小括号，然后在小括号里面写上我们需要导入的模块的路径。\n\n## 导入node核心模块\n\n在node中，我们可以直接导入node的核心模块，比如fs、http等等。\n\n`const fs = require(\"fs\");`","slug":"node学习/require函数","published":1,"date":"2023-03-05T08:57:15.699Z","updated":"2023-03-08T02:10:44.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkm00999kbmg8sc4hhq","content":"<h1 id=\"require函数\"><a href=\"#require函数\" class=\"headerlink\" title=\"require函数\"></a>require函数</h1><p>在node.js中，我们经常会导入一些模块，这其中包括我们自己所写的一些模块，也包含一些node的核心模块，比如fs、http等等。</p>\n<p>这个时候我们就需要用到require函数了。</p>\n<p>既然这是一个函数，我们在使用的时候，就需要在函数名后面加上一对小括号，然后在小括号里面写上我们需要导入的模块的路径。</p>\n<h2 id=\"导入node核心模块\"><a href=\"#导入node核心模块\" class=\"headerlink\" title=\"导入node核心模块\"></a>导入node核心模块</h2><p>在node中，我们可以直接导入node的核心模块，比如fs、http等等。</p>\n<p><code>const fs = require(&quot;fs&quot;);</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"require函数\"><a href=\"#require函数\" class=\"headerlink\" title=\"require函数\"></a>require函数</h1><p>在node.js中，我们经常会导入一些模块，这其中包括我们自己所写的一些模块，也包含一些node的核心模块，比如fs、http等等。</p>\n<p>这个时候我们就需要用到require函数了。</p>\n<p>既然这是一个函数，我们在使用的时候，就需要在函数名后面加上一对小括号，然后在小括号里面写上我们需要导入的模块的路径。</p>\n<h2 id=\"导入node核心模块\"><a href=\"#导入node核心模块\" class=\"headerlink\" title=\"导入node核心模块\"></a>导入node核心模块</h2><p>在node中，我们可以直接导入node的核心模块，比如fs、http等等。</p>\n<p><code>const fs = require(&quot;fs&quot;);</code></p>\n"},{"title":"Java基础","date":"2023-02-28T16:00:00.000Z","_content":"# Java基础\n\n## 方法\n\n方法定义的 完整格式：\n\n```java\n修饰符  返回值类型  方法名称(参数类型 参数名称){\n    方法体\n    返回值\n}\n```\n\n示例：\n\n```java\npublic static int add(int a,int b){\n    return a+b;\n}\n```\n\n定义方法的三要素\n\n- 返回值类型（需要与定义时返回类型一致）\n- 方法名称\n- 参数类型\n\n方法调用的三种调用格式：\n\n- 单独调用\n- 打印调用\n- 赋值调用\n\n示例：\n\n假设方法名称为`add`\n\n- add(1,2);\n- System.out.println(add(1,2));\n- int result = add(1,2);\n\n注意：\n\n当返回值类型为`void`的时候，`return`可以不写，或者谢伟`return;`。\n\n## 数组\n\n一维数组声明格式：\n\n**声明数组**\n\n`type []  var-name`\n\n举例： \n\n<font color=red>int[] x</font>\n\n- 第一种（动态初始化）\n\n利用new来为熟悉型变量分配内存空间\n\n`int[] x = new int[100]`为名为x的数组分配一百个int类型的数据位置。\n\n- 第二种（静态初始化）\n\n`int [] arr = new int[]{数据内容（1,2,3,4）}`\n\n- 第三种  （今天初始化的省略格式）\n\n`int [] = {1,2,3,4,5}`\n\n另外一种定义方式。\n\n`int arr[] = new int[10]`\n\n凡是new的东西，都在堆里面。\n\n在栈里面存的是数组的地址。\n\n### 获取数组的长度\n\n**学前必备：**\n\n属性：对象里面的一些名词，比如学生的身高\n\n方法：对象的一些行为,比如学生吃饭。\n\n使用`.length`（数组的一个属性）。\n\n例子：`arr.length`可以获取到`arr`数组的长度。\n\n## 一些常见的算法\n\n### 冒泡排序\n\n### 数组的增删改查\n\n### Arrays.toString(数组)\n\n这个方法可以将数组以字符串的形式输出。\n\n## 字符串\n\n### 创建以及字符串常量池\n\n**创建方法：**\n\n- 方式一： 不使用new关键字\n\n`String str = \"Hello World\";`\n\n- 方式一：使用new关键字\n\n`String = new String(\"字符串\");`\n\n**字符串池：**\n\n\n\n### 字符串的比较\n\n之前对于基本数据类型，我们可以使用`==`来进行比较，但是对于引用数据类型的时候，我们使用`==`比较的是两个引用类型的地址。如果要比较引用数据类型的值，我们需要使用`equals()`。[同时忽略大小写]\n\n### 字符串的格式化\n\n使用format。\n\n使用方法，format方法需要传入两个参数，第一个参数是格式化的字符串，第二个参数是需要格式化的内容。\n\n```java\nString str = String.format(\"%d年%d月有%d天\",year,mounth,days);\n```\n\n### 字符串常用方法\n\n- 字符串的截取\n\n`str.substring(1,3);`包含头不包含尾。\n\n- 字符串的替换\n\n`str.replace(\"a\",\"b\");`第一个参数  被替换的字符；第二个参数  替换的字符。\n\n返回值为一个新的字符串，原来的字符串不变。\n\n### 字符串的工具类\n\n主要用来拼接字符串\n\n- StringBuffer:线程安全，效率低\n\n作为类成员变量来使用\n\n- Stringbuilder:线程不安全，效率高\n\n作为局部变量来使用\n\n### 字符串的转换\n\n|基本数据类型|对应封装类|\n|:--:|:--:|\n|byte|Byte|\n|short|Short|\n|int|Integer|\n|long|Long|\n|float|Float|\n|double|Double|\n|char|Cahracter|\n|boolean|Boolean|\n\n基本数据类型转字符串：\n\n`String.valueOf(需要转换的数据);`返回一个字符串。\n\n### 传值与传引用\n\n传值不影响外部的变量，传引用操作的是同一个对象。","source":"_posts/javaLearn/java中的方法.md","raw":"---\ntitle: Java基础\ndate: [2023-3-1]\n---\n# Java基础\n\n## 方法\n\n方法定义的 完整格式：\n\n```java\n修饰符  返回值类型  方法名称(参数类型 参数名称){\n    方法体\n    返回值\n}\n```\n\n示例：\n\n```java\npublic static int add(int a,int b){\n    return a+b;\n}\n```\n\n定义方法的三要素\n\n- 返回值类型（需要与定义时返回类型一致）\n- 方法名称\n- 参数类型\n\n方法调用的三种调用格式：\n\n- 单独调用\n- 打印调用\n- 赋值调用\n\n示例：\n\n假设方法名称为`add`\n\n- add(1,2);\n- System.out.println(add(1,2));\n- int result = add(1,2);\n\n注意：\n\n当返回值类型为`void`的时候，`return`可以不写，或者谢伟`return;`。\n\n## 数组\n\n一维数组声明格式：\n\n**声明数组**\n\n`type []  var-name`\n\n举例： \n\n<font color=red>int[] x</font>\n\n- 第一种（动态初始化）\n\n利用new来为熟悉型变量分配内存空间\n\n`int[] x = new int[100]`为名为x的数组分配一百个int类型的数据位置。\n\n- 第二种（静态初始化）\n\n`int [] arr = new int[]{数据内容（1,2,3,4）}`\n\n- 第三种  （今天初始化的省略格式）\n\n`int [] = {1,2,3,4,5}`\n\n另外一种定义方式。\n\n`int arr[] = new int[10]`\n\n凡是new的东西，都在堆里面。\n\n在栈里面存的是数组的地址。\n\n### 获取数组的长度\n\n**学前必备：**\n\n属性：对象里面的一些名词，比如学生的身高\n\n方法：对象的一些行为,比如学生吃饭。\n\n使用`.length`（数组的一个属性）。\n\n例子：`arr.length`可以获取到`arr`数组的长度。\n\n## 一些常见的算法\n\n### 冒泡排序\n\n### 数组的增删改查\n\n### Arrays.toString(数组)\n\n这个方法可以将数组以字符串的形式输出。\n\n## 字符串\n\n### 创建以及字符串常量池\n\n**创建方法：**\n\n- 方式一： 不使用new关键字\n\n`String str = \"Hello World\";`\n\n- 方式一：使用new关键字\n\n`String = new String(\"字符串\");`\n\n**字符串池：**\n\n\n\n### 字符串的比较\n\n之前对于基本数据类型，我们可以使用`==`来进行比较，但是对于引用数据类型的时候，我们使用`==`比较的是两个引用类型的地址。如果要比较引用数据类型的值，我们需要使用`equals()`。[同时忽略大小写]\n\n### 字符串的格式化\n\n使用format。\n\n使用方法，format方法需要传入两个参数，第一个参数是格式化的字符串，第二个参数是需要格式化的内容。\n\n```java\nString str = String.format(\"%d年%d月有%d天\",year,mounth,days);\n```\n\n### 字符串常用方法\n\n- 字符串的截取\n\n`str.substring(1,3);`包含头不包含尾。\n\n- 字符串的替换\n\n`str.replace(\"a\",\"b\");`第一个参数  被替换的字符；第二个参数  替换的字符。\n\n返回值为一个新的字符串，原来的字符串不变。\n\n### 字符串的工具类\n\n主要用来拼接字符串\n\n- StringBuffer:线程安全，效率低\n\n作为类成员变量来使用\n\n- Stringbuilder:线程不安全，效率高\n\n作为局部变量来使用\n\n### 字符串的转换\n\n|基本数据类型|对应封装类|\n|:--:|:--:|\n|byte|Byte|\n|short|Short|\n|int|Integer|\n|long|Long|\n|float|Float|\n|double|Double|\n|char|Cahracter|\n|boolean|Boolean|\n\n基本数据类型转字符串：\n\n`String.valueOf(需要转换的数据);`返回一个字符串。\n\n### 传值与传引用\n\n传值不影响外部的变量，传引用操作的是同一个对象。","slug":"javaLearn/java中的方法","published":1,"updated":"2023-03-16T07:17:45.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkn009d9kbmbf5b3p6g","content":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法定义的 完整格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符  返回值类型  方法名称(参数类型 参数名称)&#123;</span><br><span class=\"line\">    方法体</span><br><span class=\"line\">    返回值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义方法的三要素</p>\n<ul>\n<li>返回值类型（需要与定义时返回类型一致）</li>\n<li>方法名称</li>\n<li>参数类型</li>\n</ul>\n<p>方法调用的三种调用格式：</p>\n<ul>\n<li>单独调用</li>\n<li>打印调用</li>\n<li>赋值调用</li>\n</ul>\n<p>示例：</p>\n<p>假设方法名称为<code>add</code></p>\n<ul>\n<li>add(1,2);</li>\n<li>System.out.println(add(1,2));</li>\n<li>int result &#x3D; add(1,2);</li>\n</ul>\n<p>注意：</p>\n<p>当返回值类型为<code>void</code>的时候，<code>return</code>可以不写，或者谢伟<code>return;</code>。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>一维数组声明格式：</p>\n<p><strong>声明数组</strong></p>\n<p><code>type []  var-name</code></p>\n<p>举例： </p>\n<p><font color=red>int[] x</font></p>\n<ul>\n<li>第一种（动态初始化）</li>\n</ul>\n<p>利用new来为熟悉型变量分配内存空间</p>\n<p><code>int[] x = new int[100]</code>为名为x的数组分配一百个int类型的数据位置。</p>\n<ul>\n<li>第二种（静态初始化）</li>\n</ul>\n<p><code>int [] arr = new int[]&#123;数据内容（1,2,3,4）&#125;</code></p>\n<ul>\n<li>第三种  （今天初始化的省略格式）</li>\n</ul>\n<p><code>int [] = &#123;1,2,3,4,5&#125;</code></p>\n<p>另外一种定义方式。</p>\n<p><code>int arr[] = new int[10]</code></p>\n<p>凡是new的东西，都在堆里面。</p>\n<p>在栈里面存的是数组的地址。</p>\n<h3 id=\"获取数组的长度\"><a href=\"#获取数组的长度\" class=\"headerlink\" title=\"获取数组的长度\"></a>获取数组的长度</h3><p><strong>学前必备：</strong></p>\n<p>属性：对象里面的一些名词，比如学生的身高</p>\n<p>方法：对象的一些行为,比如学生吃饭。</p>\n<p>使用<code>.length</code>（数组的一个属性）。</p>\n<p>例子：<code>arr.length</code>可以获取到<code>arr</code>数组的长度。</p>\n<h2 id=\"一些常见的算法\"><a href=\"#一些常见的算法\" class=\"headerlink\" title=\"一些常见的算法\"></a>一些常见的算法</h2><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><h3 id=\"数组的增删改查\"><a href=\"#数组的增删改查\" class=\"headerlink\" title=\"数组的增删改查\"></a>数组的增删改查</h3><h3 id=\"Arrays-toString-数组\"><a href=\"#Arrays-toString-数组\" class=\"headerlink\" title=\"Arrays.toString(数组)\"></a>Arrays.toString(数组)</h3><p>这个方法可以将数组以字符串的形式输出。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"创建以及字符串常量池\"><a href=\"#创建以及字符串常量池\" class=\"headerlink\" title=\"创建以及字符串常量池\"></a>创建以及字符串常量池</h3><p><strong>创建方法：</strong></p>\n<ul>\n<li>方式一： 不使用new关键字</li>\n</ul>\n<p><code>String str = &quot;Hello World&quot;;</code></p>\n<ul>\n<li>方式一：使用new关键字</li>\n</ul>\n<p><code>String = new String(&quot;字符串&quot;);</code></p>\n<p><strong>字符串池：</strong></p>\n<h3 id=\"字符串的比较\"><a href=\"#字符串的比较\" class=\"headerlink\" title=\"字符串的比较\"></a>字符串的比较</h3><p>之前对于基本数据类型，我们可以使用<code>==</code>来进行比较，但是对于引用数据类型的时候，我们使用<code>==</code>比较的是两个引用类型的地址。如果要比较引用数据类型的值，我们需要使用<code>equals()</code>。[同时忽略大小写]</p>\n<h3 id=\"字符串的格式化\"><a href=\"#字符串的格式化\" class=\"headerlink\" title=\"字符串的格式化\"></a>字符串的格式化</h3><p>使用format。</p>\n<p>使用方法，format方法需要传入两个参数，第一个参数是格式化的字符串，第二个参数是需要格式化的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">&quot;%d年%d月有%d天&quot;</span>,year,mounth,days);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串常用方法\"><a href=\"#字符串常用方法\" class=\"headerlink\" title=\"字符串常用方法\"></a>字符串常用方法</h3><ul>\n<li>字符串的截取</li>\n</ul>\n<p><code>str.substring(1,3);</code>包含头不包含尾。</p>\n<ul>\n<li>字符串的替换</li>\n</ul>\n<p><code>str.replace(&quot;a&quot;,&quot;b&quot;);</code>第一个参数  被替换的字符；第二个参数  替换的字符。</p>\n<p>返回值为一个新的字符串，原来的字符串不变。</p>\n<h3 id=\"字符串的工具类\"><a href=\"#字符串的工具类\" class=\"headerlink\" title=\"字符串的工具类\"></a>字符串的工具类</h3><p>主要用来拼接字符串</p>\n<ul>\n<li>StringBuffer:线程安全，效率低</li>\n</ul>\n<p>作为类成员变量来使用</p>\n<ul>\n<li>Stringbuilder:线程不安全，效率高</li>\n</ul>\n<p>作为局部变量来使用</p>\n<h3 id=\"字符串的转换\"><a href=\"#字符串的转换\" class=\"headerlink\" title=\"字符串的转换\"></a>字符串的转换</h3><table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">对应封装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Cahracter</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n</tbody></table>\n<p>基本数据类型转字符串：</p>\n<p><code>String.valueOf(需要转换的数据);</code>返回一个字符串。</p>\n<h3 id=\"传值与传引用\"><a href=\"#传值与传引用\" class=\"headerlink\" title=\"传值与传引用\"></a>传值与传引用</h3><p>传值不影响外部的变量，传引用操作的是同一个对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java基础\"><a href=\"#Java基础\" class=\"headerlink\" title=\"Java基础\"></a>Java基础</h1><h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法定义的 完整格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符  返回值类型  方法名称(参数类型 参数名称)&#123;</span><br><span class=\"line\">    方法体</span><br><span class=\"line\">    返回值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义方法的三要素</p>\n<ul>\n<li>返回值类型（需要与定义时返回类型一致）</li>\n<li>方法名称</li>\n<li>参数类型</li>\n</ul>\n<p>方法调用的三种调用格式：</p>\n<ul>\n<li>单独调用</li>\n<li>打印调用</li>\n<li>赋值调用</li>\n</ul>\n<p>示例：</p>\n<p>假设方法名称为<code>add</code></p>\n<ul>\n<li>add(1,2);</li>\n<li>System.out.println(add(1,2));</li>\n<li>int result &#x3D; add(1,2);</li>\n</ul>\n<p>注意：</p>\n<p>当返回值类型为<code>void</code>的时候，<code>return</code>可以不写，或者谢伟<code>return;</code>。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>一维数组声明格式：</p>\n<p><strong>声明数组</strong></p>\n<p><code>type []  var-name</code></p>\n<p>举例： </p>\n<p><font color=red>int[] x</font></p>\n<ul>\n<li>第一种（动态初始化）</li>\n</ul>\n<p>利用new来为熟悉型变量分配内存空间</p>\n<p><code>int[] x = new int[100]</code>为名为x的数组分配一百个int类型的数据位置。</p>\n<ul>\n<li>第二种（静态初始化）</li>\n</ul>\n<p><code>int [] arr = new int[]&#123;数据内容（1,2,3,4）&#125;</code></p>\n<ul>\n<li>第三种  （今天初始化的省略格式）</li>\n</ul>\n<p><code>int [] = &#123;1,2,3,4,5&#125;</code></p>\n<p>另外一种定义方式。</p>\n<p><code>int arr[] = new int[10]</code></p>\n<p>凡是new的东西，都在堆里面。</p>\n<p>在栈里面存的是数组的地址。</p>\n<h3 id=\"获取数组的长度\"><a href=\"#获取数组的长度\" class=\"headerlink\" title=\"获取数组的长度\"></a>获取数组的长度</h3><p><strong>学前必备：</strong></p>\n<p>属性：对象里面的一些名词，比如学生的身高</p>\n<p>方法：对象的一些行为,比如学生吃饭。</p>\n<p>使用<code>.length</code>（数组的一个属性）。</p>\n<p>例子：<code>arr.length</code>可以获取到<code>arr</code>数组的长度。</p>\n<h2 id=\"一些常见的算法\"><a href=\"#一些常见的算法\" class=\"headerlink\" title=\"一些常见的算法\"></a>一些常见的算法</h2><h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><h3 id=\"数组的增删改查\"><a href=\"#数组的增删改查\" class=\"headerlink\" title=\"数组的增删改查\"></a>数组的增删改查</h3><h3 id=\"Arrays-toString-数组\"><a href=\"#Arrays-toString-数组\" class=\"headerlink\" title=\"Arrays.toString(数组)\"></a>Arrays.toString(数组)</h3><p>这个方法可以将数组以字符串的形式输出。</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"创建以及字符串常量池\"><a href=\"#创建以及字符串常量池\" class=\"headerlink\" title=\"创建以及字符串常量池\"></a>创建以及字符串常量池</h3><p><strong>创建方法：</strong></p>\n<ul>\n<li>方式一： 不使用new关键字</li>\n</ul>\n<p><code>String str = &quot;Hello World&quot;;</code></p>\n<ul>\n<li>方式一：使用new关键字</li>\n</ul>\n<p><code>String = new String(&quot;字符串&quot;);</code></p>\n<p><strong>字符串池：</strong></p>\n<h3 id=\"字符串的比较\"><a href=\"#字符串的比较\" class=\"headerlink\" title=\"字符串的比较\"></a>字符串的比较</h3><p>之前对于基本数据类型，我们可以使用<code>==</code>来进行比较，但是对于引用数据类型的时候，我们使用<code>==</code>比较的是两个引用类型的地址。如果要比较引用数据类型的值，我们需要使用<code>equals()</code>。[同时忽略大小写]</p>\n<h3 id=\"字符串的格式化\"><a href=\"#字符串的格式化\" class=\"headerlink\" title=\"字符串的格式化\"></a>字符串的格式化</h3><p>使用format。</p>\n<p>使用方法，format方法需要传入两个参数，第一个参数是格式化的字符串，第二个参数是需要格式化的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">&quot;%d年%d月有%d天&quot;</span>,year,mounth,days);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串常用方法\"><a href=\"#字符串常用方法\" class=\"headerlink\" title=\"字符串常用方法\"></a>字符串常用方法</h3><ul>\n<li>字符串的截取</li>\n</ul>\n<p><code>str.substring(1,3);</code>包含头不包含尾。</p>\n<ul>\n<li>字符串的替换</li>\n</ul>\n<p><code>str.replace(&quot;a&quot;,&quot;b&quot;);</code>第一个参数  被替换的字符；第二个参数  替换的字符。</p>\n<p>返回值为一个新的字符串，原来的字符串不变。</p>\n<h3 id=\"字符串的工具类\"><a href=\"#字符串的工具类\" class=\"headerlink\" title=\"字符串的工具类\"></a>字符串的工具类</h3><p>主要用来拼接字符串</p>\n<ul>\n<li>StringBuffer:线程安全，效率低</li>\n</ul>\n<p>作为类成员变量来使用</p>\n<ul>\n<li>Stringbuilder:线程不安全，效率高</li>\n</ul>\n<p>作为局部变量来使用</p>\n<h3 id=\"字符串的转换\"><a href=\"#字符串的转换\" class=\"headerlink\" title=\"字符串的转换\"></a>字符串的转换</h3><table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">对应封装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">byte</td>\n<td align=\"center\">Byte</td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\">Short</td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\">Integer</td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\">Long</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">Float</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">Double</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Cahracter</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n</tbody></table>\n<p>基本数据类型转字符串：</p>\n<p><code>String.valueOf(需要转换的数据);</code>返回一个字符串。</p>\n<h3 id=\"传值与传引用\"><a href=\"#传值与传引用\" class=\"headerlink\" title=\"传值与传引用\"></a>传值与传引用</h3><p>传值不影响外部的变量，传引用操作的是同一个对象。</p>\n"},{"title":"操作系统复习指导（ZML出品）","data":"2023-1-27","_content":"\n# 操作系统复习指导\n[TOC]\n\n## 第一章 操作系统引论\n\n### 1.1操作系统目标、作用\n\n**操作系统目标：**\n\n- 方便性\n  - 通过OS命令操纵计算机，方便用户\n- 有效性\n  - 提高系统资源的利用率\n  - 提高系统吞吐量\n- 可扩充性\n  - OS必须具有很好的可扩充性\n  - 与OS的结构有紧密的联系\n- 开放性\n  - 遵循世界标准规范。特别是开放系统互联OSI\n\n**操作系统作用：**\n\n- 用户与计算机硬件之间的接口\n  - 命令方式（UNIX、DOS命令）\n  - 系统调用方式（API）\n  - GUI方式（Windows、LINUX）\n- 计算机系统资源的管理者\n  - CPU（处理机管理）\n  - 内存（存储器管理）\n  - I/O设备管理\n  - 文件管理\n- 实现对计算机资源的抽象\n  - 裸机：无软件的计算机系统\n  - 虚拟机：覆盖了软件的及其，向用户提供一个对硬件操作的抽象模型\n\n### 1.2操作系统的基本特征\n\n- 并发性\n  - 并发：多个事件在同一时间间隔内发生\n  - 并行：多个事件在同一时刻发生\n  - 并发是并行的子集\n- 共享：系统中的资源可供内存中多个并发执行的进程共同使用\n  - 互斥共享方式（临界资源）\n  - 同时共享方式（非临界资源）\n- 虚拟性：把一个物理实体变为若干个逻辑上的对应物\n  - 时分复用技术：虚拟处理机，虚拟设备\n  - 空分复用技术：虚拟存储器\n- 异步性：并发事件按照各自的速度向前推进，不会因为其他事件的阻塞而等待\n\n### 1.3操作系统的功能\n\n1. 处理机管理功能\n   1. 进程控制：创建进程、撤销（终止）进程、状态转换\n   2. 进程同步：信号量机制\n   3. 进程通信：直接通信、间接通信\n   4. 调度：处理机作业调度、处理机进程调度\n2. 内存管理功能\n   1. 内存分配和回收\n      1. 内存分配\n      2. 内存回收\n   2. 内存保护：\n      1. 确保每个用户程序仅在自己内存空间运行\n      2. 绝不允许用户程序访问操作系统的程序和数据\n   3. 地址映射：\n      1. 逻辑地址转换为物理地址\n   4. 内存扩充（虚拟存储技术）：\n      1. 请求调入功能\n      2. 置换功能\n3. 设备管理功能：\n   1. 完成I/O请求\n   2. 提高CPU和I/O设备的利用率\n4. 文件管理功能：\n   1. 文件存储空间的管理\n   2. 目录管理\n      1. 按名存取\n   3. 文件的读/写管理和保护\n5. 操作系统与用户之间的接口：\n   1. 用户接口：\n      1. 联机用户接口：命令行，说一句指令，执行一句指令\n      2. 脱机用户接口：批处理，说一堆指令，执行一堆指令\n      3. 图形用户接口：GUI\n   2. 程序接口：\n      1. 系统调用：能完成特定功能的子程序\n      2. 库函数\n6. 现代OS的新功能：\n   1. 系统安全：\n      1. 认证技术、密码技术、访问控制技术、反病毒技术\n   2. 网络功能和服务：\n      1. 网络通信、资源管理、应用与操作\n   3. 支持多媒体：\n      1. 接纳控制技术、实时调度、多媒体文件的存储\n\n### 1.4批处理系统、分时系统、实时系统的概念与特点\n\n#### 1.4.1批处理系统\n\n**概念：** 在批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”。然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。\n\n**特点：** \n\n- **多道：** 在内存中同时存放多个作业，一个时刻只有一个作业运行，这些作业共享CPU和外部设备等资源。\n- **成批：** 用户和作业之间没有交互性。用户自己不能干预自己的作业的运行，发现作业错误不能及时改正。\n- 批处理系统的目的是提高系统吞吐量和资源的利用率\n\n#### 1.4.2分时系统\n\n**概念：** 分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。\n\n**特点：**\n\n- 同时性：计算机系统能被多个用户同时使用\n- 独立性：用户和用户之间都是独立操作系统的，在同时操作时并不会发生冲突，破坏，混淆等现象\n- 及时性：系统能以最快的速度将结果显示给用户；\n- **交互作用性**：用户能和电脑进行人机对话。\n\n#### 1.4.3实时系统\n\n**概念：** 实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。\n\n**特点：**\n\n- **高精度计时系统**：计时精度是影响实时性的一个重要因素。在实时应用系统中，经常需要精确确定实时地操作某个设备或执行某个任务，或精确的计算一个时间函数。这些不仅依赖于一些硬件提供的时钟精度，也依赖于实时操作系统实现的高精度计时功能。\n- **多级中断机制**：一个实时应用系统通常需要处理多种外部信息或事件，但处理的紧迫程度有轻重缓急之分。有的必须立即作出反应，有的则可以延后处理。因此，需要建立多级中断嵌套处理机制，以确保对紧迫程度较高的实时事件进行及时响应和处理。\n- **实时调度机制**：实时操作系统不仅要及时响应实时事件中断，同时也要及时调度运行实时任务。但是，处理机调度并不能随心所欲的进行，因为涉及到两个进程之间的切换，只能在确保“安全切换”的时间点上进行，实时调度机制包括两个方面，一是在调度策略和算法上保证优先调度实时任务；二是建立更多“安全切换”时间点，保证及时调度实时任务。\n\n***\n\n## 第二章 进程的描述与控制\n\n### 2.1前趋图\n\n首先了解程序顺序执行：\n\n- 一个较大的程序通常由若干个程序段组成\n- 程序在执行时，必须按照某种先后次序逐个执行，仅当前一个操作执行完毕后，才能执行后续操作\n\n**前趋图：**\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/006a202ce6f34ae6941e80fbe4627086~tplv-k3u1fbpfcp-watermark.image?)\n\n1. 是一个有向无循环图，用于描述进程之间执行的先后顺序。\n2. 节点表示进程或者程序段，有向边表示前趋关系。\n   \n- 程序并发执行：采用多道程序技术，将多个程序同时装入内存，使之并发运行。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/705dbeb3c52645969dbeeff21681b683~tplv-k3u1fbpfcp-watermark.image?)\n\n这时候前趋关系：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6a9e683f5de47dc8ba6795b382d25c4~tplv-k3u1fbpfcp-watermark.image?)\n\n### 2.2进程的概念\n\n- 进程是程序的一次执行\n- 进程是一个程序及其数据在处理机上顺序执行所发生的活动\n- 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n\n### 2.3进程的特征\n\n- **动态性（最基本的特征）**：进程是一个动态的概念，进程的创建、撤销、切换、挂起、唤醒等都是动态的（声明周期）。\n- 并发性：进程是并发执行的，多个进程可以同时在处理机上运行。\n- 独立性：进程是一个独立的单位，拥有自己的地址空间，进程间相互独立，不会相互影响。\n- 异步性：按各自独立的、不可预知的速度向前推进。\n\n### 2.4进程与程序的区别\n\n- **程序是静态的，进程是动态的**\n- 进程是程序的一个实例，是程序的一次执行\n- 程序是进程的代码部分\n- 进程在内存中，程序在外存中\n\n### 2.5进程的三种基本状态以及转换\n\n- **就绪状态**：\n  - 一个较大的程序通常都由若干个程序段组成\n  - 程序在执行时，必须按照某种先后次序逐个执行，仅当迁移操作执行完毕后，才能执行后续操作\n- **执行状态**：已经获得CPU，正在执行的状态\n  - 单处理机：一个进程处于执行状态\n  - 多处理机：多个进程处于执行状态\n- **阻塞状态**\n  - 正在执行的进程由于发生某事件而展示无法继续执行的状态\n  - 典型事件：请求I/O、申请缓冲区、等待子进程结束、等待信号量等\n  - 根据阻塞原因，设置多个阻塞队列，如：I/O阻塞队列、等待子进程结束阻塞队列、等待信号量阻塞队列等\n\n三者的转换：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1d55aa9c4894fc9b524c21ab2deef44~tplv-k3u1fbpfcp-watermark.image?)\n\n***\n\n## 第三章 处理机调度与死锁\n\n### 3.1高、中、低级调度的概念\n\n调度其实就是对处理机进行一个分配。分配的目的是为了让进程尽快的执行完毕，从而提高系统的吞吐量。在处理机调度的时候可以分为三个级别：\n\n- 高级调度（长程调度/作业调度）：\n- 中级调度（中程调度/内存调度）：\n- 低级调度（短程调度/进程调度）：\n\n#### 3.1.1高级调度\n\n作业：是一个比程序更加广泛的一个概念。不仅包含了我们所讲的程序，还有数据，以及还配有一个作业说明书。\n\n- 调度对象：作业\n- 根据某种算法，决定将外存上处于后备队列中的作业调入内存，并为他们创建进程和分配必要的资源。然后将新线程排在就绪队列上等待调度。（把它从外存等待的一个状态取出来变成一个进程）\n- 主要用于多道批处理系统中\n\n#### 3.1.2中级调度\n\n- 调度对象：进程\n- 作用：\n  - 将暂不运行的进程，调至外存等待\n  - 将处于外存上急需运行的进程，调入内存运行\n\n#### 3.1.3低级调度\n\n- 调度对象：进程\n- 根据某种调度算法，决定就绪队列中的哪个进程应获得处理机\n- 应用与多道批处理、分时和实时OS中\n\n#### 3.1.4进程/作业调度的主要任务\n\n**进程/作业调度任务**\n\n- 保存处理机的现场信息\n- 按照某种算法选取进程\n- 把处理机分配给进程\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2af55197e5432babe264c402119374~tplv-k3u1fbpfcp-watermark.image?)\n\n- 排队器：用于将就绪进程插入相应的就绪队列\n- 分派器：用于将选定的进程移除就绪队列\n- 上下文切换器：进行新旧进程之间的上下文切换\n\n### 3.2进程调度算法\n\n- 先来先服务调度算法`FCFS`\n- 短作业优先调度算法`SJF`\n- 优先级调度算法`PR`\n- 高响应比优先调度算法`HRRN`\n\nFCFS、SJF、PR既可以用于作业调度，又可以用于进程调度\n\n#### 3.2.1先来先服务调度算法`FCFS`\n\n按照作业到达的先后顺序来进行调度，哪个作业先来，那就先调度哪个作业。这种调度算法的优点是简单，缺点是不够公平，因为长作业会占用处理机的时间过长，而短作业则会一直等待。\n\n#### 3.2.2短作业优先调度算法`SJF`\n\n`SJF`算法：既可以用于作业，也可以用于进程\n\n- 对作业：从后备队列中选择若干个估计运行时间最短的作业\n- 对进程：关联到每个进程下次运行CPU的区间长度，调度最短的进程\n\n对于进程调度，`SJF`有两种模式\n\n- 非抢占式SJF\n- 抢占式SJF--抢占式发生在有比当前进程剩余时间片更短的进程到达是，当前进程会被抢占。也被叫做最短剩余时间优先调度。\n\n对于一组指定的进程而言，SJF是最优的，因为它给出了最短平均等待时间。\n\n`SJF`比`FCFS`算法有明显改进，但是也有缺点：\n\n- 只能估算进程的运行时间（估值不准确）,所以通常用于作业调度\n- 对于长作业不利\n- 采用SJF算法时，人机无法实现交互\n- 完全未考虑作业的紧迫程度\n\n#### 3.2.3优先级调度算法`PR`\n\n`PR`算法：既可以用于作业，也可以用于进程\n\n基于作业/进程的紧迫程度，由外部赋予作业相应的优先级，调度算法根据优先级进行调度\n\n- 每个进程都有一个优先级，优先级为整数\n- 默认：小的优先级数具有高优先级\n- 目前主流的操作系统调度算法\n\n<font color=\"red\">高响应比优先调度算法是一种优先级调度算法</font>，用于作业调度。\n\n优先级调度算法的类型：\n\n- 非抢占式\n- 抢占式\n\n优先级类型：\n\n- 静态优先级：\n  - 创建进程是确定优先级数（整数），在进程的整个运行期间保持不变\n  - 简单易行，系统开销小\n  - 不够精确，可能会出现优先级低的进程长期没有被调度的情况\n- 动态优先级：\n  - 创建进程时先赋予其一个优先级，然后其值随进程的推进或者等待时间的增加而改变。\n\n优点：\n\n- 实现简单，考虑了进程的紧迫程度\n- 灵活，可以模拟其他算法\n\n存在问题：\n\n- 饥饿：低优先级的进程可能永远的不到执行\n\n解决办法： \n\n- 老化--视进程等待时间的延长提高其优先级数\n\n#### 3.2.4高响应优先比优先调度算法`HRRN`\n\n`HRRN`算法：既可以用于作业，也可以用于进程\n\n- 既考虑作业的等待时间，又考虑作业的运行时间\n- 优先级：优先级=（等待时间+运行时间）/运行时间\n- 响应比：响应比=（等待时间+运行时间）/运行时间=响应时间/运行时间\n- 如果等待时间相同，运行时间越短，类似于SJF\n- 如果运行时间相同，取决于等待时间，类似于FCFS\n- 长作业可以随其等待时间的增加而提高其优先级，从而使其尽快得到调度\n- 缺点：每次调度之前，都需要计算响应比，增加系统开销\n\n### 3.3死锁\n\n#### 3.3.1死锁的概念\n\n<font color=\"red\">死锁：</font>一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组其他进程所持有的资源。\n\n死锁是指多个进程在运行过程中因为争夺资源而造成的一种僵局，当进程处于这种僵持状态的时候，若无外力作业，这些进程将永远不会向前推进。\n\n**计算机中的资源问题：**\n\n- 可重用性资源和可消耗性资源：\n  - 可重用性资源：一次只能分配给一个进程，不允许多个进程共享，遵循：请求资源-->使用资源-->释放资源(大部分资源)\n  - 可消耗性资源：由进程动态创建和消耗（进程间通信的消息）\n- 可抢占性与不可抢占性资源：\n  - 可抢占性资源：某进程在获得这类资源后，该资源可以再被其他进程或者系统抢占，（比如CPU处理机和主存区）\n  - 不可抢占资源：当系统把这类资源分配给某些进程后，再不能强行收回，只能在进程用完之后自行释放，（比如打印机，磁带机）\n\n**死锁原因：**\n\n- 竞争不可抢占性资源引起死锁：\n  - 系统中的不可抢占性资源，由于他们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷入僵局\n- 竞争可消耗性资源引起死锁\n- 进程推进顺序不放引起死锁\n  - 进程推进顺序不当，会使进程在运行过程中，因争夺这些资源而陷入僵局\n\n#### 3.3.2死锁的必要条件\n\n1. 互斥\n   - 一段时间内某资源只能被一个进程占用\n2. 请求和保持\n   - 一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源\n3. 不可抢占\n   - 一个资源只有当持有它的进程使用完毕后才能被其他进程使用\n4. 循环等待\n   - 等待资源的进程之间存在环{p0,p1,p2,...,pn}，其中p0等待p1所占有的资源，p1等待p2所占有的资源，...，pn等待p0所占有的资源\n\n#### 3.3.3预防死锁\n\n破坏死锁的四个必要条件中的一个或者几个\n\n- 互斥：互斥条件是共享资源必须的，不仅不能改变，还应该加以保证\n- 请求和保持：必须保证进程申请资源的时候没有占有其他资源\n  - 要求进程在执行前一次性申请全部的资源，只有没有占有资源是才可以分配资源\n  - 这样做法可能导致资源利用率低，可能出现饥饿现象\n  - 改进：进程只获得运行初期所需的资源后，便开始运行；其后在运行过程中逐步释放已分配的且使用完毕的全部资源，然后在请求新资源。\n- 非抢占：\n  - 如果一个进程的申请没有实现，它要释放所占有的资源\n  - 先占的资源放入进程等待资源列表中\n  - 进程在重新得到旧的资源的时候可以重新开始\n- 循环等待：对所有的资源类型排序，进行线性排序，并赋予不同的序号，要求进程按照递增顺序申请资源\n  - 如何规定每种资源的序号是十分重要的\n  - 限制新类型设备的增加\n  - 作业使用资源的顺序与系统规定的顺序不同\n  - 限制用户简单、自主的编程。\n\n破坏死锁就是破坏死锁的四个必要条件中的一个或者几个\n\n#### 3.3.4避免死锁\n\n死锁避免算法动态检查资源分配状态以确保不会出现循环等待的情况。\n\n**银行家算法：**\n\n针对资源有多个实例，每个进程必须事先声明使用的最大量，当一个进程请求资源，他可能要等待；当一个进程得到所有的资源，他必须在优先的时间释放这些资源。\n\n#### 3.3.5检测死锁与解除\n\n**资源分配图：**\n\n在资源分配图中，找出一个既不阻塞又非独立的进程节点Pi，在顺利的情况下，Pi可以获得所需资源而继续运行，直到运行完毕，再释放其所占的全部资源，这相当于想去Pi的所有请求边和分配边，使之成为一个孤立 的节点。\n\nP1释放资源之后，便可以使P2获得资源继续运行，直到P2完成后又释放出它占有的所有全部资源。\n\n在进行一系列的简化之后，若能消去途中所有的边，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。\n\n***\n\n## 第四章 进程同步\n\n### 4.1临界资源\n\n系统中某些资源一次只允许一个进程使用，我们把这样的资源叫做临界资源或者互斥资源或者共享变量\n\n诸进程之间应该采取互斥的方式，来实现对这种资源的共享。\n\n### 4.2临界区\n\n临界区就是进程中设计临界资源的代码片段。\n\n### 4.3进程同步机制应该遵循的准则\n\n- 空闲让进\n  - 当无进程处于临界区，应允许一个请求进入临界区的进程立即进入自己的临界区\n- 忙则等待\n  - 已有进程处于其临界区，其他试图进入临界区的进程必须等待\n- 有限等待\n  - 等待进入临界区的进程不能'死等'\n- 让权等待\n  - 不能进入临界区的进程，应释放CPU，以便其他进程进入临界区","source":"_posts/复习笔记/操作系统复习指导.md","raw":"---\ntitle: 操作系统复习指导（ZML出品）\ndata: 2023-1-27\ntags: [计算机]\ncategories: [操作系统]\n---\n\n# 操作系统复习指导\n[TOC]\n\n## 第一章 操作系统引论\n\n### 1.1操作系统目标、作用\n\n**操作系统目标：**\n\n- 方便性\n  - 通过OS命令操纵计算机，方便用户\n- 有效性\n  - 提高系统资源的利用率\n  - 提高系统吞吐量\n- 可扩充性\n  - OS必须具有很好的可扩充性\n  - 与OS的结构有紧密的联系\n- 开放性\n  - 遵循世界标准规范。特别是开放系统互联OSI\n\n**操作系统作用：**\n\n- 用户与计算机硬件之间的接口\n  - 命令方式（UNIX、DOS命令）\n  - 系统调用方式（API）\n  - GUI方式（Windows、LINUX）\n- 计算机系统资源的管理者\n  - CPU（处理机管理）\n  - 内存（存储器管理）\n  - I/O设备管理\n  - 文件管理\n- 实现对计算机资源的抽象\n  - 裸机：无软件的计算机系统\n  - 虚拟机：覆盖了软件的及其，向用户提供一个对硬件操作的抽象模型\n\n### 1.2操作系统的基本特征\n\n- 并发性\n  - 并发：多个事件在同一时间间隔内发生\n  - 并行：多个事件在同一时刻发生\n  - 并发是并行的子集\n- 共享：系统中的资源可供内存中多个并发执行的进程共同使用\n  - 互斥共享方式（临界资源）\n  - 同时共享方式（非临界资源）\n- 虚拟性：把一个物理实体变为若干个逻辑上的对应物\n  - 时分复用技术：虚拟处理机，虚拟设备\n  - 空分复用技术：虚拟存储器\n- 异步性：并发事件按照各自的速度向前推进，不会因为其他事件的阻塞而等待\n\n### 1.3操作系统的功能\n\n1. 处理机管理功能\n   1. 进程控制：创建进程、撤销（终止）进程、状态转换\n   2. 进程同步：信号量机制\n   3. 进程通信：直接通信、间接通信\n   4. 调度：处理机作业调度、处理机进程调度\n2. 内存管理功能\n   1. 内存分配和回收\n      1. 内存分配\n      2. 内存回收\n   2. 内存保护：\n      1. 确保每个用户程序仅在自己内存空间运行\n      2. 绝不允许用户程序访问操作系统的程序和数据\n   3. 地址映射：\n      1. 逻辑地址转换为物理地址\n   4. 内存扩充（虚拟存储技术）：\n      1. 请求调入功能\n      2. 置换功能\n3. 设备管理功能：\n   1. 完成I/O请求\n   2. 提高CPU和I/O设备的利用率\n4. 文件管理功能：\n   1. 文件存储空间的管理\n   2. 目录管理\n      1. 按名存取\n   3. 文件的读/写管理和保护\n5. 操作系统与用户之间的接口：\n   1. 用户接口：\n      1. 联机用户接口：命令行，说一句指令，执行一句指令\n      2. 脱机用户接口：批处理，说一堆指令，执行一堆指令\n      3. 图形用户接口：GUI\n   2. 程序接口：\n      1. 系统调用：能完成特定功能的子程序\n      2. 库函数\n6. 现代OS的新功能：\n   1. 系统安全：\n      1. 认证技术、密码技术、访问控制技术、反病毒技术\n   2. 网络功能和服务：\n      1. 网络通信、资源管理、应用与操作\n   3. 支持多媒体：\n      1. 接纳控制技术、实时调度、多媒体文件的存储\n\n### 1.4批处理系统、分时系统、实时系统的概念与特点\n\n#### 1.4.1批处理系统\n\n**概念：** 在批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”。然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。\n\n**特点：** \n\n- **多道：** 在内存中同时存放多个作业，一个时刻只有一个作业运行，这些作业共享CPU和外部设备等资源。\n- **成批：** 用户和作业之间没有交互性。用户自己不能干预自己的作业的运行，发现作业错误不能及时改正。\n- 批处理系统的目的是提高系统吞吐量和资源的利用率\n\n#### 1.4.2分时系统\n\n**概念：** 分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。\n\n**特点：**\n\n- 同时性：计算机系统能被多个用户同时使用\n- 独立性：用户和用户之间都是独立操作系统的，在同时操作时并不会发生冲突，破坏，混淆等现象\n- 及时性：系统能以最快的速度将结果显示给用户；\n- **交互作用性**：用户能和电脑进行人机对话。\n\n#### 1.4.3实时系统\n\n**概念：** 实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。\n\n**特点：**\n\n- **高精度计时系统**：计时精度是影响实时性的一个重要因素。在实时应用系统中，经常需要精确确定实时地操作某个设备或执行某个任务，或精确的计算一个时间函数。这些不仅依赖于一些硬件提供的时钟精度，也依赖于实时操作系统实现的高精度计时功能。\n- **多级中断机制**：一个实时应用系统通常需要处理多种外部信息或事件，但处理的紧迫程度有轻重缓急之分。有的必须立即作出反应，有的则可以延后处理。因此，需要建立多级中断嵌套处理机制，以确保对紧迫程度较高的实时事件进行及时响应和处理。\n- **实时调度机制**：实时操作系统不仅要及时响应实时事件中断，同时也要及时调度运行实时任务。但是，处理机调度并不能随心所欲的进行，因为涉及到两个进程之间的切换，只能在确保“安全切换”的时间点上进行，实时调度机制包括两个方面，一是在调度策略和算法上保证优先调度实时任务；二是建立更多“安全切换”时间点，保证及时调度实时任务。\n\n***\n\n## 第二章 进程的描述与控制\n\n### 2.1前趋图\n\n首先了解程序顺序执行：\n\n- 一个较大的程序通常由若干个程序段组成\n- 程序在执行时，必须按照某种先后次序逐个执行，仅当前一个操作执行完毕后，才能执行后续操作\n\n**前趋图：**\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/006a202ce6f34ae6941e80fbe4627086~tplv-k3u1fbpfcp-watermark.image?)\n\n1. 是一个有向无循环图，用于描述进程之间执行的先后顺序。\n2. 节点表示进程或者程序段，有向边表示前趋关系。\n   \n- 程序并发执行：采用多道程序技术，将多个程序同时装入内存，使之并发运行。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/705dbeb3c52645969dbeeff21681b683~tplv-k3u1fbpfcp-watermark.image?)\n\n这时候前趋关系：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6a9e683f5de47dc8ba6795b382d25c4~tplv-k3u1fbpfcp-watermark.image?)\n\n### 2.2进程的概念\n\n- 进程是程序的一次执行\n- 进程是一个程序及其数据在处理机上顺序执行所发生的活动\n- 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n\n### 2.3进程的特征\n\n- **动态性（最基本的特征）**：进程是一个动态的概念，进程的创建、撤销、切换、挂起、唤醒等都是动态的（声明周期）。\n- 并发性：进程是并发执行的，多个进程可以同时在处理机上运行。\n- 独立性：进程是一个独立的单位，拥有自己的地址空间，进程间相互独立，不会相互影响。\n- 异步性：按各自独立的、不可预知的速度向前推进。\n\n### 2.4进程与程序的区别\n\n- **程序是静态的，进程是动态的**\n- 进程是程序的一个实例，是程序的一次执行\n- 程序是进程的代码部分\n- 进程在内存中，程序在外存中\n\n### 2.5进程的三种基本状态以及转换\n\n- **就绪状态**：\n  - 一个较大的程序通常都由若干个程序段组成\n  - 程序在执行时，必须按照某种先后次序逐个执行，仅当迁移操作执行完毕后，才能执行后续操作\n- **执行状态**：已经获得CPU，正在执行的状态\n  - 单处理机：一个进程处于执行状态\n  - 多处理机：多个进程处于执行状态\n- **阻塞状态**\n  - 正在执行的进程由于发生某事件而展示无法继续执行的状态\n  - 典型事件：请求I/O、申请缓冲区、等待子进程结束、等待信号量等\n  - 根据阻塞原因，设置多个阻塞队列，如：I/O阻塞队列、等待子进程结束阻塞队列、等待信号量阻塞队列等\n\n三者的转换：\n\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1d55aa9c4894fc9b524c21ab2deef44~tplv-k3u1fbpfcp-watermark.image?)\n\n***\n\n## 第三章 处理机调度与死锁\n\n### 3.1高、中、低级调度的概念\n\n调度其实就是对处理机进行一个分配。分配的目的是为了让进程尽快的执行完毕，从而提高系统的吞吐量。在处理机调度的时候可以分为三个级别：\n\n- 高级调度（长程调度/作业调度）：\n- 中级调度（中程调度/内存调度）：\n- 低级调度（短程调度/进程调度）：\n\n#### 3.1.1高级调度\n\n作业：是一个比程序更加广泛的一个概念。不仅包含了我们所讲的程序，还有数据，以及还配有一个作业说明书。\n\n- 调度对象：作业\n- 根据某种算法，决定将外存上处于后备队列中的作业调入内存，并为他们创建进程和分配必要的资源。然后将新线程排在就绪队列上等待调度。（把它从外存等待的一个状态取出来变成一个进程）\n- 主要用于多道批处理系统中\n\n#### 3.1.2中级调度\n\n- 调度对象：进程\n- 作用：\n  - 将暂不运行的进程，调至外存等待\n  - 将处于外存上急需运行的进程，调入内存运行\n\n#### 3.1.3低级调度\n\n- 调度对象：进程\n- 根据某种调度算法，决定就绪队列中的哪个进程应获得处理机\n- 应用与多道批处理、分时和实时OS中\n\n#### 3.1.4进程/作业调度的主要任务\n\n**进程/作业调度任务**\n\n- 保存处理机的现场信息\n- 按照某种算法选取进程\n- 把处理机分配给进程\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2af55197e5432babe264c402119374~tplv-k3u1fbpfcp-watermark.image?)\n\n- 排队器：用于将就绪进程插入相应的就绪队列\n- 分派器：用于将选定的进程移除就绪队列\n- 上下文切换器：进行新旧进程之间的上下文切换\n\n### 3.2进程调度算法\n\n- 先来先服务调度算法`FCFS`\n- 短作业优先调度算法`SJF`\n- 优先级调度算法`PR`\n- 高响应比优先调度算法`HRRN`\n\nFCFS、SJF、PR既可以用于作业调度，又可以用于进程调度\n\n#### 3.2.1先来先服务调度算法`FCFS`\n\n按照作业到达的先后顺序来进行调度，哪个作业先来，那就先调度哪个作业。这种调度算法的优点是简单，缺点是不够公平，因为长作业会占用处理机的时间过长，而短作业则会一直等待。\n\n#### 3.2.2短作业优先调度算法`SJF`\n\n`SJF`算法：既可以用于作业，也可以用于进程\n\n- 对作业：从后备队列中选择若干个估计运行时间最短的作业\n- 对进程：关联到每个进程下次运行CPU的区间长度，调度最短的进程\n\n对于进程调度，`SJF`有两种模式\n\n- 非抢占式SJF\n- 抢占式SJF--抢占式发生在有比当前进程剩余时间片更短的进程到达是，当前进程会被抢占。也被叫做最短剩余时间优先调度。\n\n对于一组指定的进程而言，SJF是最优的，因为它给出了最短平均等待时间。\n\n`SJF`比`FCFS`算法有明显改进，但是也有缺点：\n\n- 只能估算进程的运行时间（估值不准确）,所以通常用于作业调度\n- 对于长作业不利\n- 采用SJF算法时，人机无法实现交互\n- 完全未考虑作业的紧迫程度\n\n#### 3.2.3优先级调度算法`PR`\n\n`PR`算法：既可以用于作业，也可以用于进程\n\n基于作业/进程的紧迫程度，由外部赋予作业相应的优先级，调度算法根据优先级进行调度\n\n- 每个进程都有一个优先级，优先级为整数\n- 默认：小的优先级数具有高优先级\n- 目前主流的操作系统调度算法\n\n<font color=\"red\">高响应比优先调度算法是一种优先级调度算法</font>，用于作业调度。\n\n优先级调度算法的类型：\n\n- 非抢占式\n- 抢占式\n\n优先级类型：\n\n- 静态优先级：\n  - 创建进程是确定优先级数（整数），在进程的整个运行期间保持不变\n  - 简单易行，系统开销小\n  - 不够精确，可能会出现优先级低的进程长期没有被调度的情况\n- 动态优先级：\n  - 创建进程时先赋予其一个优先级，然后其值随进程的推进或者等待时间的增加而改变。\n\n优点：\n\n- 实现简单，考虑了进程的紧迫程度\n- 灵活，可以模拟其他算法\n\n存在问题：\n\n- 饥饿：低优先级的进程可能永远的不到执行\n\n解决办法： \n\n- 老化--视进程等待时间的延长提高其优先级数\n\n#### 3.2.4高响应优先比优先调度算法`HRRN`\n\n`HRRN`算法：既可以用于作业，也可以用于进程\n\n- 既考虑作业的等待时间，又考虑作业的运行时间\n- 优先级：优先级=（等待时间+运行时间）/运行时间\n- 响应比：响应比=（等待时间+运行时间）/运行时间=响应时间/运行时间\n- 如果等待时间相同，运行时间越短，类似于SJF\n- 如果运行时间相同，取决于等待时间，类似于FCFS\n- 长作业可以随其等待时间的增加而提高其优先级，从而使其尽快得到调度\n- 缺点：每次调度之前，都需要计算响应比，增加系统开销\n\n### 3.3死锁\n\n#### 3.3.1死锁的概念\n\n<font color=\"red\">死锁：</font>一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组其他进程所持有的资源。\n\n死锁是指多个进程在运行过程中因为争夺资源而造成的一种僵局，当进程处于这种僵持状态的时候，若无外力作业，这些进程将永远不会向前推进。\n\n**计算机中的资源问题：**\n\n- 可重用性资源和可消耗性资源：\n  - 可重用性资源：一次只能分配给一个进程，不允许多个进程共享，遵循：请求资源-->使用资源-->释放资源(大部分资源)\n  - 可消耗性资源：由进程动态创建和消耗（进程间通信的消息）\n- 可抢占性与不可抢占性资源：\n  - 可抢占性资源：某进程在获得这类资源后，该资源可以再被其他进程或者系统抢占，（比如CPU处理机和主存区）\n  - 不可抢占资源：当系统把这类资源分配给某些进程后，再不能强行收回，只能在进程用完之后自行释放，（比如打印机，磁带机）\n\n**死锁原因：**\n\n- 竞争不可抢占性资源引起死锁：\n  - 系统中的不可抢占性资源，由于他们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷入僵局\n- 竞争可消耗性资源引起死锁\n- 进程推进顺序不放引起死锁\n  - 进程推进顺序不当，会使进程在运行过程中，因争夺这些资源而陷入僵局\n\n#### 3.3.2死锁的必要条件\n\n1. 互斥\n   - 一段时间内某资源只能被一个进程占用\n2. 请求和保持\n   - 一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源\n3. 不可抢占\n   - 一个资源只有当持有它的进程使用完毕后才能被其他进程使用\n4. 循环等待\n   - 等待资源的进程之间存在环{p0,p1,p2,...,pn}，其中p0等待p1所占有的资源，p1等待p2所占有的资源，...，pn等待p0所占有的资源\n\n#### 3.3.3预防死锁\n\n破坏死锁的四个必要条件中的一个或者几个\n\n- 互斥：互斥条件是共享资源必须的，不仅不能改变，还应该加以保证\n- 请求和保持：必须保证进程申请资源的时候没有占有其他资源\n  - 要求进程在执行前一次性申请全部的资源，只有没有占有资源是才可以分配资源\n  - 这样做法可能导致资源利用率低，可能出现饥饿现象\n  - 改进：进程只获得运行初期所需的资源后，便开始运行；其后在运行过程中逐步释放已分配的且使用完毕的全部资源，然后在请求新资源。\n- 非抢占：\n  - 如果一个进程的申请没有实现，它要释放所占有的资源\n  - 先占的资源放入进程等待资源列表中\n  - 进程在重新得到旧的资源的时候可以重新开始\n- 循环等待：对所有的资源类型排序，进行线性排序，并赋予不同的序号，要求进程按照递增顺序申请资源\n  - 如何规定每种资源的序号是十分重要的\n  - 限制新类型设备的增加\n  - 作业使用资源的顺序与系统规定的顺序不同\n  - 限制用户简单、自主的编程。\n\n破坏死锁就是破坏死锁的四个必要条件中的一个或者几个\n\n#### 3.3.4避免死锁\n\n死锁避免算法动态检查资源分配状态以确保不会出现循环等待的情况。\n\n**银行家算法：**\n\n针对资源有多个实例，每个进程必须事先声明使用的最大量，当一个进程请求资源，他可能要等待；当一个进程得到所有的资源，他必须在优先的时间释放这些资源。\n\n#### 3.3.5检测死锁与解除\n\n**资源分配图：**\n\n在资源分配图中，找出一个既不阻塞又非独立的进程节点Pi，在顺利的情况下，Pi可以获得所需资源而继续运行，直到运行完毕，再释放其所占的全部资源，这相当于想去Pi的所有请求边和分配边，使之成为一个孤立 的节点。\n\nP1释放资源之后，便可以使P2获得资源继续运行，直到P2完成后又释放出它占有的所有全部资源。\n\n在进行一系列的简化之后，若能消去途中所有的边，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。\n\n***\n\n## 第四章 进程同步\n\n### 4.1临界资源\n\n系统中某些资源一次只允许一个进程使用，我们把这样的资源叫做临界资源或者互斥资源或者共享变量\n\n诸进程之间应该采取互斥的方式，来实现对这种资源的共享。\n\n### 4.2临界区\n\n临界区就是进程中设计临界资源的代码片段。\n\n### 4.3进程同步机制应该遵循的准则\n\n- 空闲让进\n  - 当无进程处于临界区，应允许一个请求进入临界区的进程立即进入自己的临界区\n- 忙则等待\n  - 已有进程处于其临界区，其他试图进入临界区的进程必须等待\n- 有限等待\n  - 等待进入临界区的进程不能'死等'\n- 让权等待\n  - 不能进入临界区的进程，应释放CPU，以便其他进程进入临界区","slug":"复习笔记/操作系统复习指导","published":1,"date":"2023-01-27T09:44:47.061Z","updated":"2023-01-31T07:19:58.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmko009g9kbm822r29n3","content":"<h1 id=\"操作系统复习指导\"><a href=\"#操作系统复习指导\" class=\"headerlink\" title=\"操作系统复习指导\"></a>操作系统复习指导</h1><p>[TOC]</p>\n<h2 id=\"第一章-操作系统引论\"><a href=\"#第一章-操作系统引论\" class=\"headerlink\" title=\"第一章 操作系统引论\"></a>第一章 操作系统引论</h2><h3 id=\"1-1操作系统目标、作用\"><a href=\"#1-1操作系统目标、作用\" class=\"headerlink\" title=\"1.1操作系统目标、作用\"></a>1.1操作系统目标、作用</h3><p><strong>操作系统目标：</strong></p>\n<ul>\n<li>方便性<ul>\n<li>通过OS命令操纵计算机，方便用户</li>\n</ul>\n</li>\n<li>有效性<ul>\n<li>提高系统资源的利用率</li>\n<li>提高系统吞吐量</li>\n</ul>\n</li>\n<li>可扩充性<ul>\n<li>OS必须具有很好的可扩充性</li>\n<li>与OS的结构有紧密的联系</li>\n</ul>\n</li>\n<li>开放性<ul>\n<li>遵循世界标准规范。特别是开放系统互联OSI</li>\n</ul>\n</li>\n</ul>\n<p><strong>操作系统作用：</strong></p>\n<ul>\n<li>用户与计算机硬件之间的接口<ul>\n<li>命令方式（UNIX、DOS命令）</li>\n<li>系统调用方式（API）</li>\n<li>GUI方式（Windows、LINUX）</li>\n</ul>\n</li>\n<li>计算机系统资源的管理者<ul>\n<li>CPU（处理机管理）</li>\n<li>内存（存储器管理）</li>\n<li>I&#x2F;O设备管理</li>\n<li>文件管理</li>\n</ul>\n</li>\n<li>实现对计算机资源的抽象<ul>\n<li>裸机：无软件的计算机系统</li>\n<li>虚拟机：覆盖了软件的及其，向用户提供一个对硬件操作的抽象模型</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2操作系统的基本特征\"><a href=\"#1-2操作系统的基本特征\" class=\"headerlink\" title=\"1.2操作系统的基本特征\"></a>1.2操作系统的基本特征</h3><ul>\n<li>并发性<ul>\n<li>并发：多个事件在同一时间间隔内发生</li>\n<li>并行：多个事件在同一时刻发生</li>\n<li>并发是并行的子集</li>\n</ul>\n</li>\n<li>共享：系统中的资源可供内存中多个并发执行的进程共同使用<ul>\n<li>互斥共享方式（临界资源）</li>\n<li>同时共享方式（非临界资源）</li>\n</ul>\n</li>\n<li>虚拟性：把一个物理实体变为若干个逻辑上的对应物<ul>\n<li>时分复用技术：虚拟处理机，虚拟设备</li>\n<li>空分复用技术：虚拟存储器</li>\n</ul>\n</li>\n<li>异步性：并发事件按照各自的速度向前推进，不会因为其他事件的阻塞而等待</li>\n</ul>\n<h3 id=\"1-3操作系统的功能\"><a href=\"#1-3操作系统的功能\" class=\"headerlink\" title=\"1.3操作系统的功能\"></a>1.3操作系统的功能</h3><ol>\n<li>处理机管理功能<ol>\n<li>进程控制：创建进程、撤销（终止）进程、状态转换</li>\n<li>进程同步：信号量机制</li>\n<li>进程通信：直接通信、间接通信</li>\n<li>调度：处理机作业调度、处理机进程调度</li>\n</ol>\n</li>\n<li>内存管理功能<ol>\n<li>内存分配和回收<ol>\n<li>内存分配</li>\n<li>内存回收</li>\n</ol>\n</li>\n<li>内存保护：<ol>\n<li>确保每个用户程序仅在自己内存空间运行</li>\n<li>绝不允许用户程序访问操作系统的程序和数据</li>\n</ol>\n</li>\n<li>地址映射：<ol>\n<li>逻辑地址转换为物理地址</li>\n</ol>\n</li>\n<li>内存扩充（虚拟存储技术）：<ol>\n<li>请求调入功能</li>\n<li>置换功能</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>设备管理功能：<ol>\n<li>完成I&#x2F;O请求</li>\n<li>提高CPU和I&#x2F;O设备的利用率</li>\n</ol>\n</li>\n<li>文件管理功能：<ol>\n<li>文件存储空间的管理</li>\n<li>目录管理<ol>\n<li>按名存取</li>\n</ol>\n</li>\n<li>文件的读&#x2F;写管理和保护</li>\n</ol>\n</li>\n<li>操作系统与用户之间的接口：<ol>\n<li>用户接口：<ol>\n<li>联机用户接口：命令行，说一句指令，执行一句指令</li>\n<li>脱机用户接口：批处理，说一堆指令，执行一堆指令</li>\n<li>图形用户接口：GUI</li>\n</ol>\n</li>\n<li>程序接口：<ol>\n<li>系统调用：能完成特定功能的子程序</li>\n<li>库函数</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>现代OS的新功能：<ol>\n<li>系统安全：<ol>\n<li>认证技术、密码技术、访问控制技术、反病毒技术</li>\n</ol>\n</li>\n<li>网络功能和服务：<ol>\n<li>网络通信、资源管理、应用与操作</li>\n</ol>\n</li>\n<li>支持多媒体：<ol>\n<li>接纳控制技术、实时调度、多媒体文件的存储</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"1-4批处理系统、分时系统、实时系统的概念与特点\"><a href=\"#1-4批处理系统、分时系统、实时系统的概念与特点\" class=\"headerlink\" title=\"1.4批处理系统、分时系统、实时系统的概念与特点\"></a>1.4批处理系统、分时系统、实时系统的概念与特点</h3><h4 id=\"1-4-1批处理系统\"><a href=\"#1-4-1批处理系统\" class=\"headerlink\" title=\"1.4.1批处理系统\"></a>1.4.1批处理系统</h4><p><strong>概念：</strong> 在批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”。然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</p>\n<p><strong>特点：</strong> </p>\n<ul>\n<li><strong>多道：</strong> 在内存中同时存放多个作业，一个时刻只有一个作业运行，这些作业共享CPU和外部设备等资源。</li>\n<li><strong>成批：</strong> 用户和作业之间没有交互性。用户自己不能干预自己的作业的运行，发现作业错误不能及时改正。</li>\n<li>批处理系统的目的是提高系统吞吐量和资源的利用率</li>\n</ul>\n<h4 id=\"1-4-2分时系统\"><a href=\"#1-4-2分时系统\" class=\"headerlink\" title=\"1.4.2分时系统\"></a>1.4.2分时系统</h4><p><strong>概念：</strong> 分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>同时性：计算机系统能被多个用户同时使用</li>\n<li>独立性：用户和用户之间都是独立操作系统的，在同时操作时并不会发生冲突，破坏，混淆等现象</li>\n<li>及时性：系统能以最快的速度将结果显示给用户；</li>\n<li><strong>交互作用性</strong>：用户能和电脑进行人机对话。</li>\n</ul>\n<h4 id=\"1-4-3实时系统\"><a href=\"#1-4-3实时系统\" class=\"headerlink\" title=\"1.4.3实时系统\"></a>1.4.3实时系统</h4><p><strong>概念：</strong> 实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li><strong>高精度计时系统</strong>：计时精度是影响实时性的一个重要因素。在实时应用系统中，经常需要精确确定实时地操作某个设备或执行某个任务，或精确的计算一个时间函数。这些不仅依赖于一些硬件提供的时钟精度，也依赖于实时操作系统实现的高精度计时功能。</li>\n<li><strong>多级中断机制</strong>：一个实时应用系统通常需要处理多种外部信息或事件，但处理的紧迫程度有轻重缓急之分。有的必须立即作出反应，有的则可以延后处理。因此，需要建立多级中断嵌套处理机制，以确保对紧迫程度较高的实时事件进行及时响应和处理。</li>\n<li><strong>实时调度机制</strong>：实时操作系统不仅要及时响应实时事件中断，同时也要及时调度运行实时任务。但是，处理机调度并不能随心所欲的进行，因为涉及到两个进程之间的切换，只能在确保“安全切换”的时间点上进行，实时调度机制包括两个方面，一是在调度策略和算法上保证优先调度实时任务；二是建立更多“安全切换”时间点，保证及时调度实时任务。</li>\n</ul>\n<hr>\n<h2 id=\"第二章-进程的描述与控制\"><a href=\"#第二章-进程的描述与控制\" class=\"headerlink\" title=\"第二章 进程的描述与控制\"></a>第二章 进程的描述与控制</h2><h3 id=\"2-1前趋图\"><a href=\"#2-1前趋图\" class=\"headerlink\" title=\"2.1前趋图\"></a>2.1前趋图</h3><p>首先了解程序顺序执行：</p>\n<ul>\n<li>一个较大的程序通常由若干个程序段组成</li>\n<li>程序在执行时，必须按照某种先后次序逐个执行，仅当前一个操作执行完毕后，才能执行后续操作</li>\n</ul>\n<p><strong>前趋图：</strong></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/006a202ce6f34ae6941e80fbe4627086~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ol>\n<li>是一个有向无循环图，用于描述进程之间执行的先后顺序。</li>\n<li>节点表示进程或者程序段，有向边表示前趋关系。</li>\n</ol>\n<ul>\n<li>程序并发执行：采用多道程序技术，将多个程序同时装入内存，使之并发运行。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/705dbeb3c52645969dbeeff21681b683~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>这时候前趋关系：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6a9e683f5de47dc8ba6795b382d25c4~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"2-2进程的概念\"><a href=\"#2-2进程的概念\" class=\"headerlink\" title=\"2.2进程的概念\"></a>2.2进程的概念</h3><ul>\n<li>进程是程序的一次执行</li>\n<li>进程是一个程序及其数据在处理机上顺序执行所发生的活动</li>\n<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>\n</ul>\n<h3 id=\"2-3进程的特征\"><a href=\"#2-3进程的特征\" class=\"headerlink\" title=\"2.3进程的特征\"></a>2.3进程的特征</h3><ul>\n<li><strong>动态性（最基本的特征）</strong>：进程是一个动态的概念，进程的创建、撤销、切换、挂起、唤醒等都是动态的（声明周期）。</li>\n<li>并发性：进程是并发执行的，多个进程可以同时在处理机上运行。</li>\n<li>独立性：进程是一个独立的单位，拥有自己的地址空间，进程间相互独立，不会相互影响。</li>\n<li>异步性：按各自独立的、不可预知的速度向前推进。</li>\n</ul>\n<h3 id=\"2-4进程与程序的区别\"><a href=\"#2-4进程与程序的区别\" class=\"headerlink\" title=\"2.4进程与程序的区别\"></a>2.4进程与程序的区别</h3><ul>\n<li><strong>程序是静态的，进程是动态的</strong></li>\n<li>进程是程序的一个实例，是程序的一次执行</li>\n<li>程序是进程的代码部分</li>\n<li>进程在内存中，程序在外存中</li>\n</ul>\n<h3 id=\"2-5进程的三种基本状态以及转换\"><a href=\"#2-5进程的三种基本状态以及转换\" class=\"headerlink\" title=\"2.5进程的三种基本状态以及转换\"></a>2.5进程的三种基本状态以及转换</h3><ul>\n<li><strong>就绪状态</strong>：<ul>\n<li>一个较大的程序通常都由若干个程序段组成</li>\n<li>程序在执行时，必须按照某种先后次序逐个执行，仅当迁移操作执行完毕后，才能执行后续操作</li>\n</ul>\n</li>\n<li><strong>执行状态</strong>：已经获得CPU，正在执行的状态<ul>\n<li>单处理机：一个进程处于执行状态</li>\n<li>多处理机：多个进程处于执行状态</li>\n</ul>\n</li>\n<li><strong>阻塞状态</strong><ul>\n<li>正在执行的进程由于发生某事件而展示无法继续执行的状态</li>\n<li>典型事件：请求I&#x2F;O、申请缓冲区、等待子进程结束、等待信号量等</li>\n<li>根据阻塞原因，设置多个阻塞队列，如：I&#x2F;O阻塞队列、等待子进程结束阻塞队列、等待信号量阻塞队列等</li>\n</ul>\n</li>\n</ul>\n<p>三者的转换：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1d55aa9c4894fc9b524c21ab2deef44~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<hr>\n<h2 id=\"第三章-处理机调度与死锁\"><a href=\"#第三章-处理机调度与死锁\" class=\"headerlink\" title=\"第三章 处理机调度与死锁\"></a>第三章 处理机调度与死锁</h2><h3 id=\"3-1高、中、低级调度的概念\"><a href=\"#3-1高、中、低级调度的概念\" class=\"headerlink\" title=\"3.1高、中、低级调度的概念\"></a>3.1高、中、低级调度的概念</h3><p>调度其实就是对处理机进行一个分配。分配的目的是为了让进程尽快的执行完毕，从而提高系统的吞吐量。在处理机调度的时候可以分为三个级别：</p>\n<ul>\n<li>高级调度（长程调度&#x2F;作业调度）：</li>\n<li>中级调度（中程调度&#x2F;内存调度）：</li>\n<li>低级调度（短程调度&#x2F;进程调度）：</li>\n</ul>\n<h4 id=\"3-1-1高级调度\"><a href=\"#3-1-1高级调度\" class=\"headerlink\" title=\"3.1.1高级调度\"></a>3.1.1高级调度</h4><p>作业：是一个比程序更加广泛的一个概念。不仅包含了我们所讲的程序，还有数据，以及还配有一个作业说明书。</p>\n<ul>\n<li>调度对象：作业</li>\n<li>根据某种算法，决定将外存上处于后备队列中的作业调入内存，并为他们创建进程和分配必要的资源。然后将新线程排在就绪队列上等待调度。（把它从外存等待的一个状态取出来变成一个进程）</li>\n<li>主要用于多道批处理系统中</li>\n</ul>\n<h4 id=\"3-1-2中级调度\"><a href=\"#3-1-2中级调度\" class=\"headerlink\" title=\"3.1.2中级调度\"></a>3.1.2中级调度</h4><ul>\n<li>调度对象：进程</li>\n<li>作用：<ul>\n<li>将暂不运行的进程，调至外存等待</li>\n<li>将处于外存上急需运行的进程，调入内存运行</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-1-3低级调度\"><a href=\"#3-1-3低级调度\" class=\"headerlink\" title=\"3.1.3低级调度\"></a>3.1.3低级调度</h4><ul>\n<li>调度对象：进程</li>\n<li>根据某种调度算法，决定就绪队列中的哪个进程应获得处理机</li>\n<li>应用与多道批处理、分时和实时OS中</li>\n</ul>\n<h4 id=\"3-1-4进程-x2F-作业调度的主要任务\"><a href=\"#3-1-4进程-x2F-作业调度的主要任务\" class=\"headerlink\" title=\"3.1.4进程&#x2F;作业调度的主要任务\"></a>3.1.4进程&#x2F;作业调度的主要任务</h4><p><strong>进程&#x2F;作业调度任务</strong></p>\n<ul>\n<li>保存处理机的现场信息</li>\n<li>按照某种算法选取进程</li>\n<li>把处理机分配给进程</li>\n</ul>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2af55197e5432babe264c402119374~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>排队器：用于将就绪进程插入相应的就绪队列</li>\n<li>分派器：用于将选定的进程移除就绪队列</li>\n<li>上下文切换器：进行新旧进程之间的上下文切换</li>\n</ul>\n<h3 id=\"3-2进程调度算法\"><a href=\"#3-2进程调度算法\" class=\"headerlink\" title=\"3.2进程调度算法\"></a>3.2进程调度算法</h3><ul>\n<li>先来先服务调度算法<code>FCFS</code></li>\n<li>短作业优先调度算法<code>SJF</code></li>\n<li>优先级调度算法<code>PR</code></li>\n<li>高响应比优先调度算法<code>HRRN</code></li>\n</ul>\n<p>FCFS、SJF、PR既可以用于作业调度，又可以用于进程调度</p>\n<h4 id=\"3-2-1先来先服务调度算法FCFS\"><a href=\"#3-2-1先来先服务调度算法FCFS\" class=\"headerlink\" title=\"3.2.1先来先服务调度算法FCFS\"></a>3.2.1先来先服务调度算法<code>FCFS</code></h4><p>按照作业到达的先后顺序来进行调度，哪个作业先来，那就先调度哪个作业。这种调度算法的优点是简单，缺点是不够公平，因为长作业会占用处理机的时间过长，而短作业则会一直等待。</p>\n<h4 id=\"3-2-2短作业优先调度算法SJF\"><a href=\"#3-2-2短作业优先调度算法SJF\" class=\"headerlink\" title=\"3.2.2短作业优先调度算法SJF\"></a>3.2.2短作业优先调度算法<code>SJF</code></h4><p><code>SJF</code>算法：既可以用于作业，也可以用于进程</p>\n<ul>\n<li>对作业：从后备队列中选择若干个估计运行时间最短的作业</li>\n<li>对进程：关联到每个进程下次运行CPU的区间长度，调度最短的进程</li>\n</ul>\n<p>对于进程调度，<code>SJF</code>有两种模式</p>\n<ul>\n<li>非抢占式SJF</li>\n<li>抢占式SJF–抢占式发生在有比当前进程剩余时间片更短的进程到达是，当前进程会被抢占。也被叫做最短剩余时间优先调度。</li>\n</ul>\n<p>对于一组指定的进程而言，SJF是最优的，因为它给出了最短平均等待时间。</p>\n<p><code>SJF</code>比<code>FCFS</code>算法有明显改进，但是也有缺点：</p>\n<ul>\n<li>只能估算进程的运行时间（估值不准确）,所以通常用于作业调度</li>\n<li>对于长作业不利</li>\n<li>采用SJF算法时，人机无法实现交互</li>\n<li>完全未考虑作业的紧迫程度</li>\n</ul>\n<h4 id=\"3-2-3优先级调度算法PR\"><a href=\"#3-2-3优先级调度算法PR\" class=\"headerlink\" title=\"3.2.3优先级调度算法PR\"></a>3.2.3优先级调度算法<code>PR</code></h4><p><code>PR</code>算法：既可以用于作业，也可以用于进程</p>\n<p>基于作业&#x2F;进程的紧迫程度，由外部赋予作业相应的优先级，调度算法根据优先级进行调度</p>\n<ul>\n<li>每个进程都有一个优先级，优先级为整数</li>\n<li>默认：小的优先级数具有高优先级</li>\n<li>目前主流的操作系统调度算法</li>\n</ul>\n<p><font color=\"red\">高响应比优先调度算法是一种优先级调度算法</font>，用于作业调度。</p>\n<p>优先级调度算法的类型：</p>\n<ul>\n<li>非抢占式</li>\n<li>抢占式</li>\n</ul>\n<p>优先级类型：</p>\n<ul>\n<li>静态优先级：<ul>\n<li>创建进程是确定优先级数（整数），在进程的整个运行期间保持不变</li>\n<li>简单易行，系统开销小</li>\n<li>不够精确，可能会出现优先级低的进程长期没有被调度的情况</li>\n</ul>\n</li>\n<li>动态优先级：<ul>\n<li>创建进程时先赋予其一个优先级，然后其值随进程的推进或者等待时间的增加而改变。</li>\n</ul>\n</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>实现简单，考虑了进程的紧迫程度</li>\n<li>灵活，可以模拟其他算法</li>\n</ul>\n<p>存在问题：</p>\n<ul>\n<li>饥饿：低优先级的进程可能永远的不到执行</li>\n</ul>\n<p>解决办法： </p>\n<ul>\n<li>老化–视进程等待时间的延长提高其优先级数</li>\n</ul>\n<h4 id=\"3-2-4高响应优先比优先调度算法HRRN\"><a href=\"#3-2-4高响应优先比优先调度算法HRRN\" class=\"headerlink\" title=\"3.2.4高响应优先比优先调度算法HRRN\"></a>3.2.4高响应优先比优先调度算法<code>HRRN</code></h4><p><code>HRRN</code>算法：既可以用于作业，也可以用于进程</p>\n<ul>\n<li>既考虑作业的等待时间，又考虑作业的运行时间</li>\n<li>优先级：优先级&#x3D;（等待时间+运行时间）&#x2F;运行时间</li>\n<li>响应比：响应比&#x3D;（等待时间+运行时间）&#x2F;运行时间&#x3D;响应时间&#x2F;运行时间</li>\n<li>如果等待时间相同，运行时间越短，类似于SJF</li>\n<li>如果运行时间相同，取决于等待时间，类似于FCFS</li>\n<li>长作业可以随其等待时间的增加而提高其优先级，从而使其尽快得到调度</li>\n<li>缺点：每次调度之前，都需要计算响应比，增加系统开销</li>\n</ul>\n<h3 id=\"3-3死锁\"><a href=\"#3-3死锁\" class=\"headerlink\" title=\"3.3死锁\"></a>3.3死锁</h3><h4 id=\"3-3-1死锁的概念\"><a href=\"#3-3-1死锁的概念\" class=\"headerlink\" title=\"3.3.1死锁的概念\"></a>3.3.1死锁的概念</h4><p><font color=\"red\">死锁：</font>一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组其他进程所持有的资源。</p>\n<p>死锁是指多个进程在运行过程中因为争夺资源而造成的一种僵局，当进程处于这种僵持状态的时候，若无外力作业，这些进程将永远不会向前推进。</p>\n<p><strong>计算机中的资源问题：</strong></p>\n<ul>\n<li>可重用性资源和可消耗性资源：<ul>\n<li>可重用性资源：一次只能分配给一个进程，不允许多个进程共享，遵循：请求资源–&gt;使用资源–&gt;释放资源(大部分资源)</li>\n<li>可消耗性资源：由进程动态创建和消耗（进程间通信的消息）</li>\n</ul>\n</li>\n<li>可抢占性与不可抢占性资源：<ul>\n<li>可抢占性资源：某进程在获得这类资源后，该资源可以再被其他进程或者系统抢占，（比如CPU处理机和主存区）</li>\n<li>不可抢占资源：当系统把这类资源分配给某些进程后，再不能强行收回，只能在进程用完之后自行释放，（比如打印机，磁带机）</li>\n</ul>\n</li>\n</ul>\n<p><strong>死锁原因：</strong></p>\n<ul>\n<li>竞争不可抢占性资源引起死锁：<ul>\n<li>系统中的不可抢占性资源，由于他们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷入僵局</li>\n</ul>\n</li>\n<li>竞争可消耗性资源引起死锁</li>\n<li>进程推进顺序不放引起死锁<ul>\n<li>进程推进顺序不当，会使进程在运行过程中，因争夺这些资源而陷入僵局</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-3-2死锁的必要条件\"><a href=\"#3-3-2死锁的必要条件\" class=\"headerlink\" title=\"3.3.2死锁的必要条件\"></a>3.3.2死锁的必要条件</h4><ol>\n<li>互斥<ul>\n<li>一段时间内某资源只能被一个进程占用</li>\n</ul>\n</li>\n<li>请求和保持<ul>\n<li>一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源</li>\n</ul>\n</li>\n<li>不可抢占<ul>\n<li>一个资源只有当持有它的进程使用完毕后才能被其他进程使用</li>\n</ul>\n</li>\n<li>循环等待<ul>\n<li>等待资源的进程之间存在环{p0,p1,p2,…,pn}，其中p0等待p1所占有的资源，p1等待p2所占有的资源，…，pn等待p0所占有的资源</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-3-3预防死锁\"><a href=\"#3-3-3预防死锁\" class=\"headerlink\" title=\"3.3.3预防死锁\"></a>3.3.3预防死锁</h4><p>破坏死锁的四个必要条件中的一个或者几个</p>\n<ul>\n<li>互斥：互斥条件是共享资源必须的，不仅不能改变，还应该加以保证</li>\n<li>请求和保持：必须保证进程申请资源的时候没有占有其他资源<ul>\n<li>要求进程在执行前一次性申请全部的资源，只有没有占有资源是才可以分配资源</li>\n<li>这样做法可能导致资源利用率低，可能出现饥饿现象</li>\n<li>改进：进程只获得运行初期所需的资源后，便开始运行；其后在运行过程中逐步释放已分配的且使用完毕的全部资源，然后在请求新资源。</li>\n</ul>\n</li>\n<li>非抢占：<ul>\n<li>如果一个进程的申请没有实现，它要释放所占有的资源</li>\n<li>先占的资源放入进程等待资源列表中</li>\n<li>进程在重新得到旧的资源的时候可以重新开始</li>\n</ul>\n</li>\n<li>循环等待：对所有的资源类型排序，进行线性排序，并赋予不同的序号，要求进程按照递增顺序申请资源<ul>\n<li>如何规定每种资源的序号是十分重要的</li>\n<li>限制新类型设备的增加</li>\n<li>作业使用资源的顺序与系统规定的顺序不同</li>\n<li>限制用户简单、自主的编程。</li>\n</ul>\n</li>\n</ul>\n<p>破坏死锁就是破坏死锁的四个必要条件中的一个或者几个</p>\n<h4 id=\"3-3-4避免死锁\"><a href=\"#3-3-4避免死锁\" class=\"headerlink\" title=\"3.3.4避免死锁\"></a>3.3.4避免死锁</h4><p>死锁避免算法动态检查资源分配状态以确保不会出现循环等待的情况。</p>\n<p><strong>银行家算法：</strong></p>\n<p>针对资源有多个实例，每个进程必须事先声明使用的最大量，当一个进程请求资源，他可能要等待；当一个进程得到所有的资源，他必须在优先的时间释放这些资源。</p>\n<h4 id=\"3-3-5检测死锁与解除\"><a href=\"#3-3-5检测死锁与解除\" class=\"headerlink\" title=\"3.3.5检测死锁与解除\"></a>3.3.5检测死锁与解除</h4><p><strong>资源分配图：</strong></p>\n<p>在资源分配图中，找出一个既不阻塞又非独立的进程节点Pi，在顺利的情况下，Pi可以获得所需资源而继续运行，直到运行完毕，再释放其所占的全部资源，这相当于想去Pi的所有请求边和分配边，使之成为一个孤立 的节点。</p>\n<p>P1释放资源之后，便可以使P2获得资源继续运行，直到P2完成后又释放出它占有的所有全部资源。</p>\n<p>在进行一系列的简化之后，若能消去途中所有的边，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。</p>\n<hr>\n<h2 id=\"第四章-进程同步\"><a href=\"#第四章-进程同步\" class=\"headerlink\" title=\"第四章 进程同步\"></a>第四章 进程同步</h2><h3 id=\"4-1临界资源\"><a href=\"#4-1临界资源\" class=\"headerlink\" title=\"4.1临界资源\"></a>4.1临界资源</h3><p>系统中某些资源一次只允许一个进程使用，我们把这样的资源叫做临界资源或者互斥资源或者共享变量</p>\n<p>诸进程之间应该采取互斥的方式，来实现对这种资源的共享。</p>\n<h3 id=\"4-2临界区\"><a href=\"#4-2临界区\" class=\"headerlink\" title=\"4.2临界区\"></a>4.2临界区</h3><p>临界区就是进程中设计临界资源的代码片段。</p>\n<h3 id=\"4-3进程同步机制应该遵循的准则\"><a href=\"#4-3进程同步机制应该遵循的准则\" class=\"headerlink\" title=\"4.3进程同步机制应该遵循的准则\"></a>4.3进程同步机制应该遵循的准则</h3><ul>\n<li>空闲让进<ul>\n<li>当无进程处于临界区，应允许一个请求进入临界区的进程立即进入自己的临界区</li>\n</ul>\n</li>\n<li>忙则等待<ul>\n<li>已有进程处于其临界区，其他试图进入临界区的进程必须等待</li>\n</ul>\n</li>\n<li>有限等待<ul>\n<li>等待进入临界区的进程不能’死等’</li>\n</ul>\n</li>\n<li>让权等待<ul>\n<li>不能进入临界区的进程，应释放CPU，以便其他进程进入临界区</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"操作系统复习指导\"><a href=\"#操作系统复习指导\" class=\"headerlink\" title=\"操作系统复习指导\"></a>操作系统复习指导</h1><p>[TOC]</p>\n<h2 id=\"第一章-操作系统引论\"><a href=\"#第一章-操作系统引论\" class=\"headerlink\" title=\"第一章 操作系统引论\"></a>第一章 操作系统引论</h2><h3 id=\"1-1操作系统目标、作用\"><a href=\"#1-1操作系统目标、作用\" class=\"headerlink\" title=\"1.1操作系统目标、作用\"></a>1.1操作系统目标、作用</h3><p><strong>操作系统目标：</strong></p>\n<ul>\n<li>方便性<ul>\n<li>通过OS命令操纵计算机，方便用户</li>\n</ul>\n</li>\n<li>有效性<ul>\n<li>提高系统资源的利用率</li>\n<li>提高系统吞吐量</li>\n</ul>\n</li>\n<li>可扩充性<ul>\n<li>OS必须具有很好的可扩充性</li>\n<li>与OS的结构有紧密的联系</li>\n</ul>\n</li>\n<li>开放性<ul>\n<li>遵循世界标准规范。特别是开放系统互联OSI</li>\n</ul>\n</li>\n</ul>\n<p><strong>操作系统作用：</strong></p>\n<ul>\n<li>用户与计算机硬件之间的接口<ul>\n<li>命令方式（UNIX、DOS命令）</li>\n<li>系统调用方式（API）</li>\n<li>GUI方式（Windows、LINUX）</li>\n</ul>\n</li>\n<li>计算机系统资源的管理者<ul>\n<li>CPU（处理机管理）</li>\n<li>内存（存储器管理）</li>\n<li>I&#x2F;O设备管理</li>\n<li>文件管理</li>\n</ul>\n</li>\n<li>实现对计算机资源的抽象<ul>\n<li>裸机：无软件的计算机系统</li>\n<li>虚拟机：覆盖了软件的及其，向用户提供一个对硬件操作的抽象模型</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2操作系统的基本特征\"><a href=\"#1-2操作系统的基本特征\" class=\"headerlink\" title=\"1.2操作系统的基本特征\"></a>1.2操作系统的基本特征</h3><ul>\n<li>并发性<ul>\n<li>并发：多个事件在同一时间间隔内发生</li>\n<li>并行：多个事件在同一时刻发生</li>\n<li>并发是并行的子集</li>\n</ul>\n</li>\n<li>共享：系统中的资源可供内存中多个并发执行的进程共同使用<ul>\n<li>互斥共享方式（临界资源）</li>\n<li>同时共享方式（非临界资源）</li>\n</ul>\n</li>\n<li>虚拟性：把一个物理实体变为若干个逻辑上的对应物<ul>\n<li>时分复用技术：虚拟处理机，虚拟设备</li>\n<li>空分复用技术：虚拟存储器</li>\n</ul>\n</li>\n<li>异步性：并发事件按照各自的速度向前推进，不会因为其他事件的阻塞而等待</li>\n</ul>\n<h3 id=\"1-3操作系统的功能\"><a href=\"#1-3操作系统的功能\" class=\"headerlink\" title=\"1.3操作系统的功能\"></a>1.3操作系统的功能</h3><ol>\n<li>处理机管理功能<ol>\n<li>进程控制：创建进程、撤销（终止）进程、状态转换</li>\n<li>进程同步：信号量机制</li>\n<li>进程通信：直接通信、间接通信</li>\n<li>调度：处理机作业调度、处理机进程调度</li>\n</ol>\n</li>\n<li>内存管理功能<ol>\n<li>内存分配和回收<ol>\n<li>内存分配</li>\n<li>内存回收</li>\n</ol>\n</li>\n<li>内存保护：<ol>\n<li>确保每个用户程序仅在自己内存空间运行</li>\n<li>绝不允许用户程序访问操作系统的程序和数据</li>\n</ol>\n</li>\n<li>地址映射：<ol>\n<li>逻辑地址转换为物理地址</li>\n</ol>\n</li>\n<li>内存扩充（虚拟存储技术）：<ol>\n<li>请求调入功能</li>\n<li>置换功能</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>设备管理功能：<ol>\n<li>完成I&#x2F;O请求</li>\n<li>提高CPU和I&#x2F;O设备的利用率</li>\n</ol>\n</li>\n<li>文件管理功能：<ol>\n<li>文件存储空间的管理</li>\n<li>目录管理<ol>\n<li>按名存取</li>\n</ol>\n</li>\n<li>文件的读&#x2F;写管理和保护</li>\n</ol>\n</li>\n<li>操作系统与用户之间的接口：<ol>\n<li>用户接口：<ol>\n<li>联机用户接口：命令行，说一句指令，执行一句指令</li>\n<li>脱机用户接口：批处理，说一堆指令，执行一堆指令</li>\n<li>图形用户接口：GUI</li>\n</ol>\n</li>\n<li>程序接口：<ol>\n<li>系统调用：能完成特定功能的子程序</li>\n<li>库函数</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>现代OS的新功能：<ol>\n<li>系统安全：<ol>\n<li>认证技术、密码技术、访问控制技术、反病毒技术</li>\n</ol>\n</li>\n<li>网络功能和服务：<ol>\n<li>网络通信、资源管理、应用与操作</li>\n</ol>\n</li>\n<li>支持多媒体：<ol>\n<li>接纳控制技术、实时调度、多媒体文件的存储</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"1-4批处理系统、分时系统、实时系统的概念与特点\"><a href=\"#1-4批处理系统、分时系统、实时系统的概念与特点\" class=\"headerlink\" title=\"1.4批处理系统、分时系统、实时系统的概念与特点\"></a>1.4批处理系统、分时系统、实时系统的概念与特点</h3><h4 id=\"1-4-1批处理系统\"><a href=\"#1-4-1批处理系统\" class=\"headerlink\" title=\"1.4.1批处理系统\"></a>1.4.1批处理系统</h4><p><strong>概念：</strong> 在批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”。然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</p>\n<p><strong>特点：</strong> </p>\n<ul>\n<li><strong>多道：</strong> 在内存中同时存放多个作业，一个时刻只有一个作业运行，这些作业共享CPU和外部设备等资源。</li>\n<li><strong>成批：</strong> 用户和作业之间没有交互性。用户自己不能干预自己的作业的运行，发现作业错误不能及时改正。</li>\n<li>批处理系统的目的是提高系统吞吐量和资源的利用率</li>\n</ul>\n<h4 id=\"1-4-2分时系统\"><a href=\"#1-4-2分时系统\" class=\"headerlink\" title=\"1.4.2分时系统\"></a>1.4.2分时系统</h4><p><strong>概念：</strong> 分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li>同时性：计算机系统能被多个用户同时使用</li>\n<li>独立性：用户和用户之间都是独立操作系统的，在同时操作时并不会发生冲突，破坏，混淆等现象</li>\n<li>及时性：系统能以最快的速度将结果显示给用户；</li>\n<li><strong>交互作用性</strong>：用户能和电脑进行人机对话。</li>\n</ul>\n<h4 id=\"1-4-3实时系统\"><a href=\"#1-4-3实时系统\" class=\"headerlink\" title=\"1.4.3实时系统\"></a>1.4.3实时系统</h4><p><strong>概念：</strong> 实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致的运行。</p>\n<p><strong>特点：</strong></p>\n<ul>\n<li><strong>高精度计时系统</strong>：计时精度是影响实时性的一个重要因素。在实时应用系统中，经常需要精确确定实时地操作某个设备或执行某个任务，或精确的计算一个时间函数。这些不仅依赖于一些硬件提供的时钟精度，也依赖于实时操作系统实现的高精度计时功能。</li>\n<li><strong>多级中断机制</strong>：一个实时应用系统通常需要处理多种外部信息或事件，但处理的紧迫程度有轻重缓急之分。有的必须立即作出反应，有的则可以延后处理。因此，需要建立多级中断嵌套处理机制，以确保对紧迫程度较高的实时事件进行及时响应和处理。</li>\n<li><strong>实时调度机制</strong>：实时操作系统不仅要及时响应实时事件中断，同时也要及时调度运行实时任务。但是，处理机调度并不能随心所欲的进行，因为涉及到两个进程之间的切换，只能在确保“安全切换”的时间点上进行，实时调度机制包括两个方面，一是在调度策略和算法上保证优先调度实时任务；二是建立更多“安全切换”时间点，保证及时调度实时任务。</li>\n</ul>\n<hr>\n<h2 id=\"第二章-进程的描述与控制\"><a href=\"#第二章-进程的描述与控制\" class=\"headerlink\" title=\"第二章 进程的描述与控制\"></a>第二章 进程的描述与控制</h2><h3 id=\"2-1前趋图\"><a href=\"#2-1前趋图\" class=\"headerlink\" title=\"2.1前趋图\"></a>2.1前趋图</h3><p>首先了解程序顺序执行：</p>\n<ul>\n<li>一个较大的程序通常由若干个程序段组成</li>\n<li>程序在执行时，必须按照某种先后次序逐个执行，仅当前一个操作执行完毕后，才能执行后续操作</li>\n</ul>\n<p><strong>前趋图：</strong></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/006a202ce6f34ae6941e80fbe4627086~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ol>\n<li>是一个有向无循环图，用于描述进程之间执行的先后顺序。</li>\n<li>节点表示进程或者程序段，有向边表示前趋关系。</li>\n</ol>\n<ul>\n<li>程序并发执行：采用多道程序技术，将多个程序同时装入内存，使之并发运行。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/705dbeb3c52645969dbeeff21681b683~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>这时候前趋关系：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6a9e683f5de47dc8ba6795b382d25c4~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"2-2进程的概念\"><a href=\"#2-2进程的概念\" class=\"headerlink\" title=\"2.2进程的概念\"></a>2.2进程的概念</h3><ul>\n<li>进程是程序的一次执行</li>\n<li>进程是一个程序及其数据在处理机上顺序执行所发生的活动</li>\n<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>\n</ul>\n<h3 id=\"2-3进程的特征\"><a href=\"#2-3进程的特征\" class=\"headerlink\" title=\"2.3进程的特征\"></a>2.3进程的特征</h3><ul>\n<li><strong>动态性（最基本的特征）</strong>：进程是一个动态的概念，进程的创建、撤销、切换、挂起、唤醒等都是动态的（声明周期）。</li>\n<li>并发性：进程是并发执行的，多个进程可以同时在处理机上运行。</li>\n<li>独立性：进程是一个独立的单位，拥有自己的地址空间，进程间相互独立，不会相互影响。</li>\n<li>异步性：按各自独立的、不可预知的速度向前推进。</li>\n</ul>\n<h3 id=\"2-4进程与程序的区别\"><a href=\"#2-4进程与程序的区别\" class=\"headerlink\" title=\"2.4进程与程序的区别\"></a>2.4进程与程序的区别</h3><ul>\n<li><strong>程序是静态的，进程是动态的</strong></li>\n<li>进程是程序的一个实例，是程序的一次执行</li>\n<li>程序是进程的代码部分</li>\n<li>进程在内存中，程序在外存中</li>\n</ul>\n<h3 id=\"2-5进程的三种基本状态以及转换\"><a href=\"#2-5进程的三种基本状态以及转换\" class=\"headerlink\" title=\"2.5进程的三种基本状态以及转换\"></a>2.5进程的三种基本状态以及转换</h3><ul>\n<li><strong>就绪状态</strong>：<ul>\n<li>一个较大的程序通常都由若干个程序段组成</li>\n<li>程序在执行时，必须按照某种先后次序逐个执行，仅当迁移操作执行完毕后，才能执行后续操作</li>\n</ul>\n</li>\n<li><strong>执行状态</strong>：已经获得CPU，正在执行的状态<ul>\n<li>单处理机：一个进程处于执行状态</li>\n<li>多处理机：多个进程处于执行状态</li>\n</ul>\n</li>\n<li><strong>阻塞状态</strong><ul>\n<li>正在执行的进程由于发生某事件而展示无法继续执行的状态</li>\n<li>典型事件：请求I&#x2F;O、申请缓冲区、等待子进程结束、等待信号量等</li>\n<li>根据阻塞原因，设置多个阻塞队列，如：I&#x2F;O阻塞队列、等待子进程结束阻塞队列、等待信号量阻塞队列等</li>\n</ul>\n</li>\n</ul>\n<p>三者的转换：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1d55aa9c4894fc9b524c21ab2deef44~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<hr>\n<h2 id=\"第三章-处理机调度与死锁\"><a href=\"#第三章-处理机调度与死锁\" class=\"headerlink\" title=\"第三章 处理机调度与死锁\"></a>第三章 处理机调度与死锁</h2><h3 id=\"3-1高、中、低级调度的概念\"><a href=\"#3-1高、中、低级调度的概念\" class=\"headerlink\" title=\"3.1高、中、低级调度的概念\"></a>3.1高、中、低级调度的概念</h3><p>调度其实就是对处理机进行一个分配。分配的目的是为了让进程尽快的执行完毕，从而提高系统的吞吐量。在处理机调度的时候可以分为三个级别：</p>\n<ul>\n<li>高级调度（长程调度&#x2F;作业调度）：</li>\n<li>中级调度（中程调度&#x2F;内存调度）：</li>\n<li>低级调度（短程调度&#x2F;进程调度）：</li>\n</ul>\n<h4 id=\"3-1-1高级调度\"><a href=\"#3-1-1高级调度\" class=\"headerlink\" title=\"3.1.1高级调度\"></a>3.1.1高级调度</h4><p>作业：是一个比程序更加广泛的一个概念。不仅包含了我们所讲的程序，还有数据，以及还配有一个作业说明书。</p>\n<ul>\n<li>调度对象：作业</li>\n<li>根据某种算法，决定将外存上处于后备队列中的作业调入内存，并为他们创建进程和分配必要的资源。然后将新线程排在就绪队列上等待调度。（把它从外存等待的一个状态取出来变成一个进程）</li>\n<li>主要用于多道批处理系统中</li>\n</ul>\n<h4 id=\"3-1-2中级调度\"><a href=\"#3-1-2中级调度\" class=\"headerlink\" title=\"3.1.2中级调度\"></a>3.1.2中级调度</h4><ul>\n<li>调度对象：进程</li>\n<li>作用：<ul>\n<li>将暂不运行的进程，调至外存等待</li>\n<li>将处于外存上急需运行的进程，调入内存运行</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-1-3低级调度\"><a href=\"#3-1-3低级调度\" class=\"headerlink\" title=\"3.1.3低级调度\"></a>3.1.3低级调度</h4><ul>\n<li>调度对象：进程</li>\n<li>根据某种调度算法，决定就绪队列中的哪个进程应获得处理机</li>\n<li>应用与多道批处理、分时和实时OS中</li>\n</ul>\n<h4 id=\"3-1-4进程-x2F-作业调度的主要任务\"><a href=\"#3-1-4进程-x2F-作业调度的主要任务\" class=\"headerlink\" title=\"3.1.4进程&#x2F;作业调度的主要任务\"></a>3.1.4进程&#x2F;作业调度的主要任务</h4><p><strong>进程&#x2F;作业调度任务</strong></p>\n<ul>\n<li>保存处理机的现场信息</li>\n<li>按照某种算法选取进程</li>\n<li>把处理机分配给进程</li>\n</ul>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2af55197e5432babe264c402119374~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<ul>\n<li>排队器：用于将就绪进程插入相应的就绪队列</li>\n<li>分派器：用于将选定的进程移除就绪队列</li>\n<li>上下文切换器：进行新旧进程之间的上下文切换</li>\n</ul>\n<h3 id=\"3-2进程调度算法\"><a href=\"#3-2进程调度算法\" class=\"headerlink\" title=\"3.2进程调度算法\"></a>3.2进程调度算法</h3><ul>\n<li>先来先服务调度算法<code>FCFS</code></li>\n<li>短作业优先调度算法<code>SJF</code></li>\n<li>优先级调度算法<code>PR</code></li>\n<li>高响应比优先调度算法<code>HRRN</code></li>\n</ul>\n<p>FCFS、SJF、PR既可以用于作业调度，又可以用于进程调度</p>\n<h4 id=\"3-2-1先来先服务调度算法FCFS\"><a href=\"#3-2-1先来先服务调度算法FCFS\" class=\"headerlink\" title=\"3.2.1先来先服务调度算法FCFS\"></a>3.2.1先来先服务调度算法<code>FCFS</code></h4><p>按照作业到达的先后顺序来进行调度，哪个作业先来，那就先调度哪个作业。这种调度算法的优点是简单，缺点是不够公平，因为长作业会占用处理机的时间过长，而短作业则会一直等待。</p>\n<h4 id=\"3-2-2短作业优先调度算法SJF\"><a href=\"#3-2-2短作业优先调度算法SJF\" class=\"headerlink\" title=\"3.2.2短作业优先调度算法SJF\"></a>3.2.2短作业优先调度算法<code>SJF</code></h4><p><code>SJF</code>算法：既可以用于作业，也可以用于进程</p>\n<ul>\n<li>对作业：从后备队列中选择若干个估计运行时间最短的作业</li>\n<li>对进程：关联到每个进程下次运行CPU的区间长度，调度最短的进程</li>\n</ul>\n<p>对于进程调度，<code>SJF</code>有两种模式</p>\n<ul>\n<li>非抢占式SJF</li>\n<li>抢占式SJF–抢占式发生在有比当前进程剩余时间片更短的进程到达是，当前进程会被抢占。也被叫做最短剩余时间优先调度。</li>\n</ul>\n<p>对于一组指定的进程而言，SJF是最优的，因为它给出了最短平均等待时间。</p>\n<p><code>SJF</code>比<code>FCFS</code>算法有明显改进，但是也有缺点：</p>\n<ul>\n<li>只能估算进程的运行时间（估值不准确）,所以通常用于作业调度</li>\n<li>对于长作业不利</li>\n<li>采用SJF算法时，人机无法实现交互</li>\n<li>完全未考虑作业的紧迫程度</li>\n</ul>\n<h4 id=\"3-2-3优先级调度算法PR\"><a href=\"#3-2-3优先级调度算法PR\" class=\"headerlink\" title=\"3.2.3优先级调度算法PR\"></a>3.2.3优先级调度算法<code>PR</code></h4><p><code>PR</code>算法：既可以用于作业，也可以用于进程</p>\n<p>基于作业&#x2F;进程的紧迫程度，由外部赋予作业相应的优先级，调度算法根据优先级进行调度</p>\n<ul>\n<li>每个进程都有一个优先级，优先级为整数</li>\n<li>默认：小的优先级数具有高优先级</li>\n<li>目前主流的操作系统调度算法</li>\n</ul>\n<p><font color=\"red\">高响应比优先调度算法是一种优先级调度算法</font>，用于作业调度。</p>\n<p>优先级调度算法的类型：</p>\n<ul>\n<li>非抢占式</li>\n<li>抢占式</li>\n</ul>\n<p>优先级类型：</p>\n<ul>\n<li>静态优先级：<ul>\n<li>创建进程是确定优先级数（整数），在进程的整个运行期间保持不变</li>\n<li>简单易行，系统开销小</li>\n<li>不够精确，可能会出现优先级低的进程长期没有被调度的情况</li>\n</ul>\n</li>\n<li>动态优先级：<ul>\n<li>创建进程时先赋予其一个优先级，然后其值随进程的推进或者等待时间的增加而改变。</li>\n</ul>\n</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>实现简单，考虑了进程的紧迫程度</li>\n<li>灵活，可以模拟其他算法</li>\n</ul>\n<p>存在问题：</p>\n<ul>\n<li>饥饿：低优先级的进程可能永远的不到执行</li>\n</ul>\n<p>解决办法： </p>\n<ul>\n<li>老化–视进程等待时间的延长提高其优先级数</li>\n</ul>\n<h4 id=\"3-2-4高响应优先比优先调度算法HRRN\"><a href=\"#3-2-4高响应优先比优先调度算法HRRN\" class=\"headerlink\" title=\"3.2.4高响应优先比优先调度算法HRRN\"></a>3.2.4高响应优先比优先调度算法<code>HRRN</code></h4><p><code>HRRN</code>算法：既可以用于作业，也可以用于进程</p>\n<ul>\n<li>既考虑作业的等待时间，又考虑作业的运行时间</li>\n<li>优先级：优先级&#x3D;（等待时间+运行时间）&#x2F;运行时间</li>\n<li>响应比：响应比&#x3D;（等待时间+运行时间）&#x2F;运行时间&#x3D;响应时间&#x2F;运行时间</li>\n<li>如果等待时间相同，运行时间越短，类似于SJF</li>\n<li>如果运行时间相同，取决于等待时间，类似于FCFS</li>\n<li>长作业可以随其等待时间的增加而提高其优先级，从而使其尽快得到调度</li>\n<li>缺点：每次调度之前，都需要计算响应比，增加系统开销</li>\n</ul>\n<h3 id=\"3-3死锁\"><a href=\"#3-3死锁\" class=\"headerlink\" title=\"3.3死锁\"></a>3.3死锁</h3><h4 id=\"3-3-1死锁的概念\"><a href=\"#3-3-1死锁的概念\" class=\"headerlink\" title=\"3.3.1死锁的概念\"></a>3.3.1死锁的概念</h4><p><font color=\"red\">死锁：</font>一组等待的进程，其中每一个进程都持有资源，并且等待着由这个组其他进程所持有的资源。</p>\n<p>死锁是指多个进程在运行过程中因为争夺资源而造成的一种僵局，当进程处于这种僵持状态的时候，若无外力作业，这些进程将永远不会向前推进。</p>\n<p><strong>计算机中的资源问题：</strong></p>\n<ul>\n<li>可重用性资源和可消耗性资源：<ul>\n<li>可重用性资源：一次只能分配给一个进程，不允许多个进程共享，遵循：请求资源–&gt;使用资源–&gt;释放资源(大部分资源)</li>\n<li>可消耗性资源：由进程动态创建和消耗（进程间通信的消息）</li>\n</ul>\n</li>\n<li>可抢占性与不可抢占性资源：<ul>\n<li>可抢占性资源：某进程在获得这类资源后，该资源可以再被其他进程或者系统抢占，（比如CPU处理机和主存区）</li>\n<li>不可抢占资源：当系统把这类资源分配给某些进程后，再不能强行收回，只能在进程用完之后自行释放，（比如打印机，磁带机）</li>\n</ul>\n</li>\n</ul>\n<p><strong>死锁原因：</strong></p>\n<ul>\n<li>竞争不可抢占性资源引起死锁：<ul>\n<li>系统中的不可抢占性资源，由于他们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷入僵局</li>\n</ul>\n</li>\n<li>竞争可消耗性资源引起死锁</li>\n<li>进程推进顺序不放引起死锁<ul>\n<li>进程推进顺序不当，会使进程在运行过程中，因争夺这些资源而陷入僵局</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-3-2死锁的必要条件\"><a href=\"#3-3-2死锁的必要条件\" class=\"headerlink\" title=\"3.3.2死锁的必要条件\"></a>3.3.2死锁的必要条件</h4><ol>\n<li>互斥<ul>\n<li>一段时间内某资源只能被一个进程占用</li>\n</ul>\n</li>\n<li>请求和保持<ul>\n<li>一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源</li>\n</ul>\n</li>\n<li>不可抢占<ul>\n<li>一个资源只有当持有它的进程使用完毕后才能被其他进程使用</li>\n</ul>\n</li>\n<li>循环等待<ul>\n<li>等待资源的进程之间存在环{p0,p1,p2,…,pn}，其中p0等待p1所占有的资源，p1等待p2所占有的资源，…，pn等待p0所占有的资源</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-3-3预防死锁\"><a href=\"#3-3-3预防死锁\" class=\"headerlink\" title=\"3.3.3预防死锁\"></a>3.3.3预防死锁</h4><p>破坏死锁的四个必要条件中的一个或者几个</p>\n<ul>\n<li>互斥：互斥条件是共享资源必须的，不仅不能改变，还应该加以保证</li>\n<li>请求和保持：必须保证进程申请资源的时候没有占有其他资源<ul>\n<li>要求进程在执行前一次性申请全部的资源，只有没有占有资源是才可以分配资源</li>\n<li>这样做法可能导致资源利用率低，可能出现饥饿现象</li>\n<li>改进：进程只获得运行初期所需的资源后，便开始运行；其后在运行过程中逐步释放已分配的且使用完毕的全部资源，然后在请求新资源。</li>\n</ul>\n</li>\n<li>非抢占：<ul>\n<li>如果一个进程的申请没有实现，它要释放所占有的资源</li>\n<li>先占的资源放入进程等待资源列表中</li>\n<li>进程在重新得到旧的资源的时候可以重新开始</li>\n</ul>\n</li>\n<li>循环等待：对所有的资源类型排序，进行线性排序，并赋予不同的序号，要求进程按照递增顺序申请资源<ul>\n<li>如何规定每种资源的序号是十分重要的</li>\n<li>限制新类型设备的增加</li>\n<li>作业使用资源的顺序与系统规定的顺序不同</li>\n<li>限制用户简单、自主的编程。</li>\n</ul>\n</li>\n</ul>\n<p>破坏死锁就是破坏死锁的四个必要条件中的一个或者几个</p>\n<h4 id=\"3-3-4避免死锁\"><a href=\"#3-3-4避免死锁\" class=\"headerlink\" title=\"3.3.4避免死锁\"></a>3.3.4避免死锁</h4><p>死锁避免算法动态检查资源分配状态以确保不会出现循环等待的情况。</p>\n<p><strong>银行家算法：</strong></p>\n<p>针对资源有多个实例，每个进程必须事先声明使用的最大量，当一个进程请求资源，他可能要等待；当一个进程得到所有的资源，他必须在优先的时间释放这些资源。</p>\n<h4 id=\"3-3-5检测死锁与解除\"><a href=\"#3-3-5检测死锁与解除\" class=\"headerlink\" title=\"3.3.5检测死锁与解除\"></a>3.3.5检测死锁与解除</h4><p><strong>资源分配图：</strong></p>\n<p>在资源分配图中，找出一个既不阻塞又非独立的进程节点Pi，在顺利的情况下，Pi可以获得所需资源而继续运行，直到运行完毕，再释放其所占的全部资源，这相当于想去Pi的所有请求边和分配边，使之成为一个孤立 的节点。</p>\n<p>P1释放资源之后，便可以使P2获得资源继续运行，直到P2完成后又释放出它占有的所有全部资源。</p>\n<p>在进行一系列的简化之后，若能消去途中所有的边，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完全简化的。</p>\n<hr>\n<h2 id=\"第四章-进程同步\"><a href=\"#第四章-进程同步\" class=\"headerlink\" title=\"第四章 进程同步\"></a>第四章 进程同步</h2><h3 id=\"4-1临界资源\"><a href=\"#4-1临界资源\" class=\"headerlink\" title=\"4.1临界资源\"></a>4.1临界资源</h3><p>系统中某些资源一次只允许一个进程使用，我们把这样的资源叫做临界资源或者互斥资源或者共享变量</p>\n<p>诸进程之间应该采取互斥的方式，来实现对这种资源的共享。</p>\n<h3 id=\"4-2临界区\"><a href=\"#4-2临界区\" class=\"headerlink\" title=\"4.2临界区\"></a>4.2临界区</h3><p>临界区就是进程中设计临界资源的代码片段。</p>\n<h3 id=\"4-3进程同步机制应该遵循的准则\"><a href=\"#4-3进程同步机制应该遵循的准则\" class=\"headerlink\" title=\"4.3进程同步机制应该遵循的准则\"></a>4.3进程同步机制应该遵循的准则</h3><ul>\n<li>空闲让进<ul>\n<li>当无进程处于临界区，应允许一个请求进入临界区的进程立即进入自己的临界区</li>\n</ul>\n</li>\n<li>忙则等待<ul>\n<li>已有进程处于其临界区，其他试图进入临界区的进程必须等待</li>\n</ul>\n</li>\n<li>有限等待<ul>\n<li>等待进入临界区的进程不能’死等’</li>\n</ul>\n</li>\n<li>让权等待<ul>\n<li>不能进入临界区的进程，应释放CPU，以便其他进程进入临界区</li>\n</ul>\n</li>\n</ul>\n"},{"title":"static关键字","date":"2023-01-03T16:00:00.000Z","_content":"# static关键字\n\nstatic 表示静态，是java当中的一个修饰符，可以修饰成员方法，成员变量。\n\n## static修饰成员变量\n\n被static修饰的成员变量叫做静态变量\n\n- 特点\n\n\t- 被该类所有的实例化对象所共享\n\t- 不属于对象，属于类\n\t- 随着类的加载而加载，优先于对象存在\n\t\n- 调用方式\n\n\t- 类名调用（推荐）\n\t- 对象名调用\n\n静态变量时随着类的加载而加载的，是优于对象出现的\n\n也就是说使用static修饰的变量，可以在实例化对象之前使用\n\n静态变量在堆内存中，只有一份，哪个实例化对象需要该变量，直接去拿就可以，而不需要在每一个实例化对象中都定义一次。\n\n如何判断一个变量是否需要使用static修饰：  \n就看这个变量是否需要被多个实例化对象同时使用同一个值，也就是是否需要被多个实例化对象所共享。\n\t\n## static修饰成员方法\n\n被static修饰的成员方法被叫做静态方法\n\n- 特点\n\t- 多用在测试类和工具当中\n\t- JavaBean类很少会用\n\n- 调用方式\n\t- 类名调用（推荐）\n\t- 对象名调用\n\n### 什么是工具类\n\n- JavaBean类： 描述一类事物的类。比如：Student Teacher Dog\n- 测试类：用来检查其他类是否书写正确，带有main方法，是程序的入口\n- 工具类： 不是用来描述一类事物的，而是帮助我们做一些事情的类\n\n#### 工具类的规则：\n\n1. 类名见名知意\n2. 私有化构造方法\n\n## static的注意事项\n\n- 静态方法只能访问静态比那里和静态方法\n- 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法\n- 静态方法中没有this关键字的\n\n**总结：**\n\n静态方法中，只能访问静态\n\n 非静态方法可以访问所有\n\n 静态方法中没有this关键字","source":"_posts/javaLearn/static关键字.md","raw":"---\ntitle: static关键字\ndate: 2023-1-4\ntags: [后端]\ncategories: [Java]\n---\n# static关键字\n\nstatic 表示静态，是java当中的一个修饰符，可以修饰成员方法，成员变量。\n\n## static修饰成员变量\n\n被static修饰的成员变量叫做静态变量\n\n- 特点\n\n\t- 被该类所有的实例化对象所共享\n\t- 不属于对象，属于类\n\t- 随着类的加载而加载，优先于对象存在\n\t\n- 调用方式\n\n\t- 类名调用（推荐）\n\t- 对象名调用\n\n静态变量时随着类的加载而加载的，是优于对象出现的\n\n也就是说使用static修饰的变量，可以在实例化对象之前使用\n\n静态变量在堆内存中，只有一份，哪个实例化对象需要该变量，直接去拿就可以，而不需要在每一个实例化对象中都定义一次。\n\n如何判断一个变量是否需要使用static修饰：  \n就看这个变量是否需要被多个实例化对象同时使用同一个值，也就是是否需要被多个实例化对象所共享。\n\t\n## static修饰成员方法\n\n被static修饰的成员方法被叫做静态方法\n\n- 特点\n\t- 多用在测试类和工具当中\n\t- JavaBean类很少会用\n\n- 调用方式\n\t- 类名调用（推荐）\n\t- 对象名调用\n\n### 什么是工具类\n\n- JavaBean类： 描述一类事物的类。比如：Student Teacher Dog\n- 测试类：用来检查其他类是否书写正确，带有main方法，是程序的入口\n- 工具类： 不是用来描述一类事物的，而是帮助我们做一些事情的类\n\n#### 工具类的规则：\n\n1. 类名见名知意\n2. 私有化构造方法\n\n## static的注意事项\n\n- 静态方法只能访问静态比那里和静态方法\n- 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法\n- 静态方法中没有this关键字的\n\n**总结：**\n\n静态方法中，只能访问静态\n\n 非静态方法可以访问所有\n\n 静态方法中没有this关键字","slug":"javaLearn/static关键字","published":1,"updated":"2023-03-08T03:16:18.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkp009j9kbm6eld93vh","content":"<h1 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h1><p>static 表示静态，是java当中的一个修饰符，可以修饰成员方法，成员变量。</p>\n<h2 id=\"static修饰成员变量\"><a href=\"#static修饰成员变量\" class=\"headerlink\" title=\"static修饰成员变量\"></a>static修饰成员变量</h2><p>被static修饰的成员变量叫做静态变量</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li>被该类所有的实例化对象所共享</li>\n<li>不属于对象，属于类</li>\n<li>随着类的加载而加载，优先于对象存在</li>\n</ul>\n</li>\n<li><p>调用方式</p>\n<ul>\n<li>类名调用（推荐）</li>\n<li>对象名调用</li>\n</ul>\n</li>\n</ul>\n<p>静态变量时随着类的加载而加载的，是优于对象出现的</p>\n<p>也就是说使用static修饰的变量，可以在实例化对象之前使用</p>\n<p>静态变量在堆内存中，只有一份，哪个实例化对象需要该变量，直接去拿就可以，而不需要在每一个实例化对象中都定义一次。</p>\n<p>如何判断一个变量是否需要使用static修饰：<br>就看这个变量是否需要被多个实例化对象同时使用同一个值，也就是是否需要被多个实例化对象所共享。</p>\n<h2 id=\"static修饰成员方法\"><a href=\"#static修饰成员方法\" class=\"headerlink\" title=\"static修饰成员方法\"></a>static修饰成员方法</h2><p>被static修饰的成员方法被叫做静态方法</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li>多用在测试类和工具当中</li>\n<li>JavaBean类很少会用</li>\n</ul>\n</li>\n<li><p>调用方式</p>\n<ul>\n<li>类名调用（推荐）</li>\n<li>对象名调用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是工具类\"><a href=\"#什么是工具类\" class=\"headerlink\" title=\"什么是工具类\"></a>什么是工具类</h3><ul>\n<li>JavaBean类： 描述一类事物的类。比如：Student Teacher Dog</li>\n<li>测试类：用来检查其他类是否书写正确，带有main方法，是程序的入口</li>\n<li>工具类： 不是用来描述一类事物的，而是帮助我们做一些事情的类</li>\n</ul>\n<h4 id=\"工具类的规则：\"><a href=\"#工具类的规则：\" class=\"headerlink\" title=\"工具类的规则：\"></a>工具类的规则：</h4><ol>\n<li>类名见名知意</li>\n<li>私有化构造方法</li>\n</ol>\n<h2 id=\"static的注意事项\"><a href=\"#static的注意事项\" class=\"headerlink\" title=\"static的注意事项\"></a>static的注意事项</h2><ul>\n<li>静态方法只能访问静态比那里和静态方法</li>\n<li>非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法</li>\n<li>静态方法中没有this关键字的</li>\n</ul>\n<p><strong>总结：</strong></p>\n<p>静态方法中，只能访问静态</p>\n<p> 非静态方法可以访问所有</p>\n<p> 静态方法中没有this关键字</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"static关键字\"><a href=\"#static关键字\" class=\"headerlink\" title=\"static关键字\"></a>static关键字</h1><p>static 表示静态，是java当中的一个修饰符，可以修饰成员方法，成员变量。</p>\n<h2 id=\"static修饰成员变量\"><a href=\"#static修饰成员变量\" class=\"headerlink\" title=\"static修饰成员变量\"></a>static修饰成员变量</h2><p>被static修饰的成员变量叫做静态变量</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li>被该类所有的实例化对象所共享</li>\n<li>不属于对象，属于类</li>\n<li>随着类的加载而加载，优先于对象存在</li>\n</ul>\n</li>\n<li><p>调用方式</p>\n<ul>\n<li>类名调用（推荐）</li>\n<li>对象名调用</li>\n</ul>\n</li>\n</ul>\n<p>静态变量时随着类的加载而加载的，是优于对象出现的</p>\n<p>也就是说使用static修饰的变量，可以在实例化对象之前使用</p>\n<p>静态变量在堆内存中，只有一份，哪个实例化对象需要该变量，直接去拿就可以，而不需要在每一个实例化对象中都定义一次。</p>\n<p>如何判断一个变量是否需要使用static修饰：<br>就看这个变量是否需要被多个实例化对象同时使用同一个值，也就是是否需要被多个实例化对象所共享。</p>\n<h2 id=\"static修饰成员方法\"><a href=\"#static修饰成员方法\" class=\"headerlink\" title=\"static修饰成员方法\"></a>static修饰成员方法</h2><p>被static修饰的成员方法被叫做静态方法</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li>多用在测试类和工具当中</li>\n<li>JavaBean类很少会用</li>\n</ul>\n</li>\n<li><p>调用方式</p>\n<ul>\n<li>类名调用（推荐）</li>\n<li>对象名调用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是工具类\"><a href=\"#什么是工具类\" class=\"headerlink\" title=\"什么是工具类\"></a>什么是工具类</h3><ul>\n<li>JavaBean类： 描述一类事物的类。比如：Student Teacher Dog</li>\n<li>测试类：用来检查其他类是否书写正确，带有main方法，是程序的入口</li>\n<li>工具类： 不是用来描述一类事物的，而是帮助我们做一些事情的类</li>\n</ul>\n<h4 id=\"工具类的规则：\"><a href=\"#工具类的规则：\" class=\"headerlink\" title=\"工具类的规则：\"></a>工具类的规则：</h4><ol>\n<li>类名见名知意</li>\n<li>私有化构造方法</li>\n</ol>\n<h2 id=\"static的注意事项\"><a href=\"#static的注意事项\" class=\"headerlink\" title=\"static的注意事项\"></a>static的注意事项</h2><ul>\n<li>静态方法只能访问静态比那里和静态方法</li>\n<li>非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法</li>\n<li>静态方法中没有this关键字的</li>\n</ul>\n<p><strong>总结：</strong></p>\n<p>静态方法中，只能访问静态</p>\n<p> 非静态方法可以访问所有</p>\n<p> 静态方法中没有this关键字</p>\n"},{"title":"内部类","date":"2023-01-09T16:00:00.000Z","_content":"# 内部类\n[TOC]\n\n## 什么是内部类\n\n类的五大成员：\n\n\t属性、方法、构造方法、代码块、内部类\n\n在一个类的里面，再定义一个类，这个类就是内部类。\n\n例子：在A类里面定义一个B类，这个B类就被成为内部类\n\n内部类访问的特点：\n\n- 内部类可以直接访问外部类的成员，包括私有。\n- 外部类要访问内部类的成员，必须创建对象。\n\n用到内部类的地方：\n- B类表示A类的一部分，且B类单独存在没有意义。\n\n## 内部类分类\n\n1. 成员内部类\n2. 静态内部类\n3. 局部内部类\n4. **匿名内部类**\n\n## 成员内部类\n\n写在成员位置，属于外部类的成员。\n\n 成员内部类可以被一些修饰符所修饰，比如：private、默认、protected 、public 、static 等\n\n 在成员内部类里面JDK16之前不能定义静态变量，JDk16之后才可以定义静态变量。\n\n ### 获取成员内部类对象\n\n 方法一：\n \t在外部类中编写方法，对外提供内部类对象（当内部类使用private修饰时）\n\n```java\npublic Inner getInstance(){\n\treturn new Inner();\n}\n```\n\n方法二：\n \t直接创建格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;\n \t`Outer.Inner oi = new Outer().new Inner();`\n\n### 成员内部类获取外部类的成员变量\n\n代码：\n\n```java\npublic class Outer {\n    private int a = 10;\n\n    class Inner {\n        private int a = 20;\n\n        public void show() {\n            int a = 30;\n            System.out.println(Outer.this.a);//10\n            System.out.println(this.a);// 20\n            System.out.println(a);// 30\n        }\n    }\n}\n```\n\n## 静态内部类\n\n静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要在静态内部类里面创建外部类的对象，通过外部类对象访问外部类的非静态变量和方法。\n\n- 创建静态内部类对象格式： 外部类名.内部类名 对象名 = new 外部类名.内部类名();\n- 调用非静态方法的格式：先创建对象，用对象调用\n- 调用静态方法的格式：外部类名.内部类名.方法名();\n\n## 局部内部类\n\n1. 将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量\n2. 外接是无法直接使用的，需要在方法内部创建对象并使用\n3. 该类可以直接访问外部类的成员，也可以访问方法内的局部变量\n\n```java\npublic class JuBu {\n    public void show() {\n        // 局部内部类\n        class Inner {\n            public void method() {\n                System.out.println(\"局部变量里面的方法\");\n            }\n\n            public static void method1() {\n                System.out.println(\"局部变量里面的静态方法\");\n            }\n        }\n\n        // 外接无法直接使用 Inner\n        // 可以创建一个局部内部类对象\n        Inner i = new Inner();\n        i.method();\n        .method1();\n    }\n}\n\n```\n\n## 匿名内部类\n\n匿名内部类的本质就是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置。\n\n格式：\n\n```java\nnew 类名或者接口名(){\n\t重写方法;\n};\n```\n\n三部分：\n- 继承\\实现\n- 方法重写\n- 创建对象\n\n真正的匿名内部类是`()`后面花括号里面的内容，如果`new`关键字后面是类，那么就是继承关系；如果`new`关键字后面是接口，那么就是实现关系。\n\n既然继承\\实现了一个父类\\接口，那么里面的所有抽象方法就必须重写。\n\n通过`new`关键字创建一个对象，这个对象是匿名内部类的对象。\n\n内部类作用：\n\n当在多态情况下，需要传入一个父类的子类，就可以使用内部类继承父类作为参数传递进方法。\n\n```java\npublic static void method(Animal a){\n\ta.eat();// 编译看左边，运行看右边\n}\n\nmethod(\n\tnew Animal (){\n\t\tpublic void eat(){\n\t\t\t\tSystem.out.println(\"吃东西\");\n\t\t}\n\t}\n);\n```","source":"_posts/javaLearn/内部类.md","raw":"---\ntitle: 内部类\ndate: 2023-1-10\ntags: [后端]\ncategories: [Java]\n---\n# 内部类\n[TOC]\n\n## 什么是内部类\n\n类的五大成员：\n\n\t属性、方法、构造方法、代码块、内部类\n\n在一个类的里面，再定义一个类，这个类就是内部类。\n\n例子：在A类里面定义一个B类，这个B类就被成为内部类\n\n内部类访问的特点：\n\n- 内部类可以直接访问外部类的成员，包括私有。\n- 外部类要访问内部类的成员，必须创建对象。\n\n用到内部类的地方：\n- B类表示A类的一部分，且B类单独存在没有意义。\n\n## 内部类分类\n\n1. 成员内部类\n2. 静态内部类\n3. 局部内部类\n4. **匿名内部类**\n\n## 成员内部类\n\n写在成员位置，属于外部类的成员。\n\n 成员内部类可以被一些修饰符所修饰，比如：private、默认、protected 、public 、static 等\n\n 在成员内部类里面JDK16之前不能定义静态变量，JDk16之后才可以定义静态变量。\n\n ### 获取成员内部类对象\n\n 方法一：\n \t在外部类中编写方法，对外提供内部类对象（当内部类使用private修饰时）\n\n```java\npublic Inner getInstance(){\n\treturn new Inner();\n}\n```\n\n方法二：\n \t直接创建格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;\n \t`Outer.Inner oi = new Outer().new Inner();`\n\n### 成员内部类获取外部类的成员变量\n\n代码：\n\n```java\npublic class Outer {\n    private int a = 10;\n\n    class Inner {\n        private int a = 20;\n\n        public void show() {\n            int a = 30;\n            System.out.println(Outer.this.a);//10\n            System.out.println(this.a);// 20\n            System.out.println(a);// 30\n        }\n    }\n}\n```\n\n## 静态内部类\n\n静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要在静态内部类里面创建外部类的对象，通过外部类对象访问外部类的非静态变量和方法。\n\n- 创建静态内部类对象格式： 外部类名.内部类名 对象名 = new 外部类名.内部类名();\n- 调用非静态方法的格式：先创建对象，用对象调用\n- 调用静态方法的格式：外部类名.内部类名.方法名();\n\n## 局部内部类\n\n1. 将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量\n2. 外接是无法直接使用的，需要在方法内部创建对象并使用\n3. 该类可以直接访问外部类的成员，也可以访问方法内的局部变量\n\n```java\npublic class JuBu {\n    public void show() {\n        // 局部内部类\n        class Inner {\n            public void method() {\n                System.out.println(\"局部变量里面的方法\");\n            }\n\n            public static void method1() {\n                System.out.println(\"局部变量里面的静态方法\");\n            }\n        }\n\n        // 外接无法直接使用 Inner\n        // 可以创建一个局部内部类对象\n        Inner i = new Inner();\n        i.method();\n        .method1();\n    }\n}\n\n```\n\n## 匿名内部类\n\n匿名内部类的本质就是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置。\n\n格式：\n\n```java\nnew 类名或者接口名(){\n\t重写方法;\n};\n```\n\n三部分：\n- 继承\\实现\n- 方法重写\n- 创建对象\n\n真正的匿名内部类是`()`后面花括号里面的内容，如果`new`关键字后面是类，那么就是继承关系；如果`new`关键字后面是接口，那么就是实现关系。\n\n既然继承\\实现了一个父类\\接口，那么里面的所有抽象方法就必须重写。\n\n通过`new`关键字创建一个对象，这个对象是匿名内部类的对象。\n\n内部类作用：\n\n当在多态情况下，需要传入一个父类的子类，就可以使用内部类继承父类作为参数传递进方法。\n\n```java\npublic static void method(Animal a){\n\ta.eat();// 编译看左边，运行看右边\n}\n\nmethod(\n\tnew Animal (){\n\t\tpublic void eat(){\n\t\t\t\tSystem.out.println(\"吃东西\");\n\t\t}\n\t}\n);\n```","slug":"javaLearn/内部类","published":1,"updated":"2023-01-10T06:59:37.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkq009m9kbm519q6l0s","content":"<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><p>[TOC]</p>\n<h2 id=\"什么是内部类\"><a href=\"#什么是内部类\" class=\"headerlink\" title=\"什么是内部类\"></a>什么是内部类</h2><p>类的五大成员：</p>\n<pre><code>属性、方法、构造方法、代码块、内部类\n</code></pre>\n<p>在一个类的里面，再定义一个类，这个类就是内部类。</p>\n<p>例子：在A类里面定义一个B类，这个B类就被成为内部类</p>\n<p>内部类访问的特点：</p>\n<ul>\n<li>内部类可以直接访问外部类的成员，包括私有。</li>\n<li>外部类要访问内部类的成员，必须创建对象。</li>\n</ul>\n<p>用到内部类的地方：</p>\n<ul>\n<li>B类表示A类的一部分，且B类单独存在没有意义。</li>\n</ul>\n<h2 id=\"内部类分类\"><a href=\"#内部类分类\" class=\"headerlink\" title=\"内部类分类\"></a>内部类分类</h2><ol>\n<li>成员内部类</li>\n<li>静态内部类</li>\n<li>局部内部类</li>\n<li><strong>匿名内部类</strong></li>\n</ol>\n<h2 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p>\n<p> 成员内部类可以被一些修饰符所修饰，比如：private、默认、protected 、public 、static 等</p>\n<p> 在成员内部类里面JDK16之前不能定义静态变量，JDk16之后才可以定义静态变量。</p>\n<h3 id=\"获取成员内部类对象\"><a href=\"#获取成员内部类对象\" class=\"headerlink\" title=\"获取成员内部类对象\"></a>获取成员内部类对象</h3><p> 方法一：<br>     在外部类中编写方法，对外提供内部类对象（当内部类使用private修饰时）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Inner <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：<br>     直接创建格式：外部类名.内部类名 对象名 &#x3D; 外部类对象.内部类对象;<br>     <code>Outer.Inner oi = new Outer().new Inner();</code></p>\n<h3 id=\"成员内部类获取外部类的成员变量\"><a href=\"#成员内部类获取外部类的成员变量\" class=\"headerlink\" title=\"成员内部类获取外部类的成员变量\"></a>成员内部类获取外部类的成员变量</h3><p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">30</span>;</span><br><span class=\"line\">            System.out.println(Outer.<span class=\"built_in\">this</span>.a);<span class=\"comment\">//10</span></span><br><span class=\"line\">            System.out.println(<span class=\"built_in\">this</span>.a);<span class=\"comment\">// 20</span></span><br><span class=\"line\">            System.out.println(a);<span class=\"comment\">// 30</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><p>静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要在静态内部类里面创建外部类的对象，通过外部类对象访问外部类的非静态变量和方法。</p>\n<ul>\n<li>创建静态内部类对象格式： 外部类名.内部类名 对象名 &#x3D; new 外部类名.内部类名();</li>\n<li>调用非静态方法的格式：先创建对象，用对象调用</li>\n<li>调用静态方法的格式：外部类名.内部类名.方法名();</li>\n</ul>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><ol>\n<li>将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量</li>\n<li>外接是无法直接使用的，需要在方法内部创建对象并使用</li>\n<li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JuBu</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 局部内部类</span></span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;局部变量里面的方法&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;局部变量里面的静态方法&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 外接无法直接使用 Inner</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以创建一个局部内部类对象</span></span><br><span class=\"line\">        <span class=\"type\">Inner</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">        i.method();</span><br><span class=\"line\">        .method1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>匿名内部类的本质就是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置。</p>\n<p>格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类名或者接口名()&#123;</span><br><span class=\"line\">\t重写方法;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>三部分：</p>\n<ul>\n<li>继承\\实现</li>\n<li>方法重写</li>\n<li>创建对象</li>\n</ul>\n<p>真正的匿名内部类是<code>()</code>后面花括号里面的内容，如果<code>new</code>关键字后面是类，那么就是继承关系；如果<code>new</code>关键字后面是接口，那么就是实现关系。</p>\n<p>既然继承\\实现了一个父类\\接口，那么里面的所有抽象方法就必须重写。</p>\n<p>通过<code>new</code>关键字创建一个对象，这个对象是匿名内部类的对象。</p>\n<p>内部类作用：</p>\n<p>当在多态情况下，需要传入一个父类的子类，就可以使用内部类继承父类作为参数传递进方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">(Animal a)</span>&#123;</span><br><span class=\"line\">\ta.eat();<span class=\"comment\">// 编译看左边，运行看右边</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">method(</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span> ()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;吃东西&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><p>[TOC]</p>\n<h2 id=\"什么是内部类\"><a href=\"#什么是内部类\" class=\"headerlink\" title=\"什么是内部类\"></a>什么是内部类</h2><p>类的五大成员：</p>\n<pre><code>属性、方法、构造方法、代码块、内部类\n</code></pre>\n<p>在一个类的里面，再定义一个类，这个类就是内部类。</p>\n<p>例子：在A类里面定义一个B类，这个B类就被成为内部类</p>\n<p>内部类访问的特点：</p>\n<ul>\n<li>内部类可以直接访问外部类的成员，包括私有。</li>\n<li>外部类要访问内部类的成员，必须创建对象。</li>\n</ul>\n<p>用到内部类的地方：</p>\n<ul>\n<li>B类表示A类的一部分，且B类单独存在没有意义。</li>\n</ul>\n<h2 id=\"内部类分类\"><a href=\"#内部类分类\" class=\"headerlink\" title=\"内部类分类\"></a>内部类分类</h2><ol>\n<li>成员内部类</li>\n<li>静态内部类</li>\n<li>局部内部类</li>\n<li><strong>匿名内部类</strong></li>\n</ol>\n<h2 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p>\n<p> 成员内部类可以被一些修饰符所修饰，比如：private、默认、protected 、public 、static 等</p>\n<p> 在成员内部类里面JDK16之前不能定义静态变量，JDk16之后才可以定义静态变量。</p>\n<h3 id=\"获取成员内部类对象\"><a href=\"#获取成员内部类对象\" class=\"headerlink\" title=\"获取成员内部类对象\"></a>获取成员内部类对象</h3><p> 方法一：<br>     在外部类中编写方法，对外提供内部类对象（当内部类使用private修饰时）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Inner <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：<br>     直接创建格式：外部类名.内部类名 对象名 &#x3D; 外部类对象.内部类对象;<br>     <code>Outer.Inner oi = new Outer().new Inner();</code></p>\n<h3 id=\"成员内部类获取外部类的成员变量\"><a href=\"#成员内部类获取外部类的成员变量\" class=\"headerlink\" title=\"成员内部类获取外部类的成员变量\"></a>成员内部类获取外部类的成员变量</h3><p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">30</span>;</span><br><span class=\"line\">            System.out.println(Outer.<span class=\"built_in\">this</span>.a);<span class=\"comment\">//10</span></span><br><span class=\"line\">            System.out.println(<span class=\"built_in\">this</span>.a);<span class=\"comment\">// 20</span></span><br><span class=\"line\">            System.out.println(a);<span class=\"comment\">// 30</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><p>静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要在静态内部类里面创建外部类的对象，通过外部类对象访问外部类的非静态变量和方法。</p>\n<ul>\n<li>创建静态内部类对象格式： 外部类名.内部类名 对象名 &#x3D; new 外部类名.内部类名();</li>\n<li>调用非静态方法的格式：先创建对象，用对象调用</li>\n<li>调用静态方法的格式：外部类名.内部类名.方法名();</li>\n</ul>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><ol>\n<li>将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量</li>\n<li>外接是无法直接使用的，需要在方法内部创建对象并使用</li>\n<li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JuBu</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 局部内部类</span></span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;局部变量里面的方法&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;局部变量里面的静态方法&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 外接无法直接使用 Inner</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以创建一个局部内部类对象</span></span><br><span class=\"line\">        <span class=\"type\">Inner</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">        i.method();</span><br><span class=\"line\">        .method1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>匿名内部类的本质就是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置。</p>\n<p>格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类名或者接口名()&#123;</span><br><span class=\"line\">\t重写方法;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>三部分：</p>\n<ul>\n<li>继承\\实现</li>\n<li>方法重写</li>\n<li>创建对象</li>\n</ul>\n<p>真正的匿名内部类是<code>()</code>后面花括号里面的内容，如果<code>new</code>关键字后面是类，那么就是继承关系；如果<code>new</code>关键字后面是接口，那么就是实现关系。</p>\n<p>既然继承\\实现了一个父类\\接口，那么里面的所有抽象方法就必须重写。</p>\n<p>通过<code>new</code>关键字创建一个对象，这个对象是匿名内部类的对象。</p>\n<p>内部类作用：</p>\n<p>当在多态情况下，需要传入一个父类的子类，就可以使用内部类继承父类作为参数传递进方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">(Animal a)</span>&#123;</span><br><span class=\"line\">\ta.eat();<span class=\"comment\">// 编译看左边，运行看右边</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">method(</span><br><span class=\"line\">\t<span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span> ()&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;吃东西&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>"},{"title":"包和final与权限修饰符","date":"2023-01-06T16:00:00.000Z","_content":"# 包和final与权限修饰符\n[TOC]\n\n## 包\n\n包就是文件夹，用来管理各种不同的`java`类，方便后期代码维护。\n\n- **<font color=red>包名的规则：</font>**公司域名反写+包的作用，需要全部英文小写，见名知意。\n- **<font color = red>使用其他类的规则：</font>**\n\t- 使用同一个包中的类时，不需要导包\n\t- 使用`java.lang`包中的类时，不需要导包\n\t- 其他情况都需要导包\n\t- 如果同时使用两个包中同名类，需要用全类名\n\n## final\n\n 最终的，不可以被改变的\n\nfinal可以修饰方法，类，变量。\n\n- 修饰方法的时候：表明该方法是最终方法，不能被重写（不能被继承）\n- 修饰类的时候：表明该类是最终类，不能被继承\n- 修饰变量的时候：这时候这个变量叫做常量，只能被赋值一次\n\n在实际开发当中，常量一般作为系统的配置信息，方便维护，提高可读性。\n\n常量的命名规范：\n\n- 单个单词：全部大写\n- 多个单词：全部大写，单词之间用下划线隔开\n\n细节：\n\n- final修饰变量是基本数据类型的时候，里面存储的数据值不能发生改变。\n- final修饰变量是引用类型的时候，变量存储的地址值是不能发生改变的，但是对象内部的数据可以发生改变。\n\n## 权限修饰符\n\n- 权限修饰符：使用来控制一个成员能够被访问范围的。\n\n- 可以修饰成员变量、方法、构造方法、内部类\n\n**<font color=red>权限修饰符分类：</font>**\n\n权限修饰符有四种，范围由小到大：<font color = red>private < 空着不写 < protected < public</font>\n\n修饰符作用范围：\n|  修饰符   | 同一个类中 | 同一个包中其他类 | 不同包下的子类 | 不同包下的无关类 |\n| :-------: | :--------: | :--------------: | :------------: | :--------------: |\n|  private  |     √      |                  |                |                  |\n| 空着不写  |     √      |        √         |                |                  |\n| protected |     √      |        √         |       √        |                  |\n|  public   |     √      |        √         |       √        |        √         |","source":"_posts/javaLearn/包、final与修饰符.md","raw":"---\ntitle: 包和final与权限修饰符\ndate: 2023-1-7\ntags: [后端]\ncategories: [Java]\n---\n# 包和final与权限修饰符\n[TOC]\n\n## 包\n\n包就是文件夹，用来管理各种不同的`java`类，方便后期代码维护。\n\n- **<font color=red>包名的规则：</font>**公司域名反写+包的作用，需要全部英文小写，见名知意。\n- **<font color = red>使用其他类的规则：</font>**\n\t- 使用同一个包中的类时，不需要导包\n\t- 使用`java.lang`包中的类时，不需要导包\n\t- 其他情况都需要导包\n\t- 如果同时使用两个包中同名类，需要用全类名\n\n## final\n\n 最终的，不可以被改变的\n\nfinal可以修饰方法，类，变量。\n\n- 修饰方法的时候：表明该方法是最终方法，不能被重写（不能被继承）\n- 修饰类的时候：表明该类是最终类，不能被继承\n- 修饰变量的时候：这时候这个变量叫做常量，只能被赋值一次\n\n在实际开发当中，常量一般作为系统的配置信息，方便维护，提高可读性。\n\n常量的命名规范：\n\n- 单个单词：全部大写\n- 多个单词：全部大写，单词之间用下划线隔开\n\n细节：\n\n- final修饰变量是基本数据类型的时候，里面存储的数据值不能发生改变。\n- final修饰变量是引用类型的时候，变量存储的地址值是不能发生改变的，但是对象内部的数据可以发生改变。\n\n## 权限修饰符\n\n- 权限修饰符：使用来控制一个成员能够被访问范围的。\n\n- 可以修饰成员变量、方法、构造方法、内部类\n\n**<font color=red>权限修饰符分类：</font>**\n\n权限修饰符有四种，范围由小到大：<font color = red>private < 空着不写 < protected < public</font>\n\n修饰符作用范围：\n|  修饰符   | 同一个类中 | 同一个包中其他类 | 不同包下的子类 | 不同包下的无关类 |\n| :-------: | :--------: | :--------------: | :------------: | :--------------: |\n|  private  |     √      |                  |                |                  |\n| 空着不写  |     √      |        √         |                |                  |\n| protected |     √      |        √         |       √        |                  |\n|  public   |     √      |        √         |       √        |        √         |","slug":"javaLearn/包、final与修饰符","published":1,"updated":"2023-01-10T02:24:07.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkr009p9kbmcauegth7","content":"<h1 id=\"包和final与权限修饰符\"><a href=\"#包和final与权限修饰符\" class=\"headerlink\" title=\"包和final与权限修饰符\"></a>包和final与权限修饰符</h1><p>[TOC]</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>包就是文件夹，用来管理各种不同的<code>java</code>类，方便后期代码维护。</p>\n<ul>\n<li>**<font color=red>包名的规则：</font>**公司域名反写+包的作用，需要全部英文小写，见名知意。</li>\n<li><strong><font color = red>使用其他类的规则：</font></strong><ul>\n<li>使用同一个包中的类时，不需要导包</li>\n<li>使用<code>java.lang</code>包中的类时，不需要导包</li>\n<li>其他情况都需要导包</li>\n<li>如果同时使用两个包中同名类，需要用全类名</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h2><p> 最终的，不可以被改变的</p>\n<p>final可以修饰方法，类，变量。</p>\n<ul>\n<li>修饰方法的时候：表明该方法是最终方法，不能被重写（不能被继承）</li>\n<li>修饰类的时候：表明该类是最终类，不能被继承</li>\n<li>修饰变量的时候：这时候这个变量叫做常量，只能被赋值一次</li>\n</ul>\n<p>在实际开发当中，常量一般作为系统的配置信息，方便维护，提高可读性。</p>\n<p>常量的命名规范：</p>\n<ul>\n<li>单个单词：全部大写</li>\n<li>多个单词：全部大写，单词之间用下划线隔开</li>\n</ul>\n<p>细节：</p>\n<ul>\n<li>final修饰变量是基本数据类型的时候，里面存储的数据值不能发生改变。</li>\n<li>final修饰变量是引用类型的时候，变量存储的地址值是不能发生改变的，但是对象内部的数据可以发生改变。</li>\n</ul>\n<h2 id=\"权限修饰符\"><a href=\"#权限修饰符\" class=\"headerlink\" title=\"权限修饰符\"></a>权限修饰符</h2><ul>\n<li><p>权限修饰符：使用来控制一个成员能够被访问范围的。</p>\n</li>\n<li><p>可以修饰成员变量、方法、构造方法、内部类</p>\n</li>\n</ul>\n<p><strong><font color=red>权限修饰符分类：</font></strong></p>\n<p>权限修饰符有四种，范围由小到大：<font color = red>private &lt; 空着不写 &lt; protected &lt; public</font></p>\n<p>修饰符作用范围：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"center\">同一个类中</th>\n<th align=\"center\">同一个包中其他类</th>\n<th align=\"center\">不同包下的子类</th>\n<th align=\"center\">不同包下的无关类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">private</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">空着不写</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">protected</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">public</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"包和final与权限修饰符\"><a href=\"#包和final与权限修饰符\" class=\"headerlink\" title=\"包和final与权限修饰符\"></a>包和final与权限修饰符</h1><p>[TOC]</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>包就是文件夹，用来管理各种不同的<code>java</code>类，方便后期代码维护。</p>\n<ul>\n<li>**<font color=red>包名的规则：</font>**公司域名反写+包的作用，需要全部英文小写，见名知意。</li>\n<li><strong><font color = red>使用其他类的规则：</font></strong><ul>\n<li>使用同一个包中的类时，不需要导包</li>\n<li>使用<code>java.lang</code>包中的类时，不需要导包</li>\n<li>其他情况都需要导包</li>\n<li>如果同时使用两个包中同名类，需要用全类名</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h2><p> 最终的，不可以被改变的</p>\n<p>final可以修饰方法，类，变量。</p>\n<ul>\n<li>修饰方法的时候：表明该方法是最终方法，不能被重写（不能被继承）</li>\n<li>修饰类的时候：表明该类是最终类，不能被继承</li>\n<li>修饰变量的时候：这时候这个变量叫做常量，只能被赋值一次</li>\n</ul>\n<p>在实际开发当中，常量一般作为系统的配置信息，方便维护，提高可读性。</p>\n<p>常量的命名规范：</p>\n<ul>\n<li>单个单词：全部大写</li>\n<li>多个单词：全部大写，单词之间用下划线隔开</li>\n</ul>\n<p>细节：</p>\n<ul>\n<li>final修饰变量是基本数据类型的时候，里面存储的数据值不能发生改变。</li>\n<li>final修饰变量是引用类型的时候，变量存储的地址值是不能发生改变的，但是对象内部的数据可以发生改变。</li>\n</ul>\n<h2 id=\"权限修饰符\"><a href=\"#权限修饰符\" class=\"headerlink\" title=\"权限修饰符\"></a>权限修饰符</h2><ul>\n<li><p>权限修饰符：使用来控制一个成员能够被访问范围的。</p>\n</li>\n<li><p>可以修饰成员变量、方法、构造方法、内部类</p>\n</li>\n</ul>\n<p><strong><font color=red>权限修饰符分类：</font></strong></p>\n<p>权限修饰符有四种，范围由小到大：<font color = red>private &lt; 空着不写 &lt; protected &lt; public</font></p>\n<p>修饰符作用范围：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">修饰符</th>\n<th align=\"center\">同一个类中</th>\n<th align=\"center\">同一个包中其他类</th>\n<th align=\"center\">不同包下的子类</th>\n<th align=\"center\">不同包下的无关类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">private</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">空着不写</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">protected</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">public</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n</tbody></table>\n"},{"_content":"# 组织行为学\n\n## 第一章\n\n### 组织行为学研究的内容\n\n研究组织中人的心理和行为规律（个体行为、群里行为、组织行为）\n\n### 管理的功能\n\n开发员工的潜能、提高员工的满意度和幸福感、提高领导水平、组织变革和组织发展的推动力。\n\n## 第二章\n\n### 大五大人格模型\n\n- 开放性（openness）：具有想象、审美、情感丰富、求异、创造、智慧等特质。\n- 责任心（conscientiousness）：显示胜任、公正、条理、尽职、成就、自律、谨慎、克制等特点。\n- 外倾性（extraversion）：表现出热情、社交、果断、活跃、冒险、乐观等特质。\n- 宜人性（agreeableness）：具有信任、利他、直率、依从、谦虚、移情等特质。\n- 神经质性（neuroticism）：难以平衡焦虑、敌对、压抑、自我意识、冲动、脆弱等情绪的特质，即不具有保持情绪稳定的能力。\n\n### MBTI人格理论\n\n四个维度：\n\n- 倾向将心理能量集中在外部世界还是内部世界的角度（内向型、外向型）\n- 如何获取信息的角度（感觉型、直觉型）\n- 如何处理信息和做出决策的角度（思考型、情感型）\n- 对待外部世界的方式（判断型、知觉型）\n\n### 智力多元论\n`47页第二段，不能吧智力当做听说读写看，文化智力那些重点看后面2个理论`\n留空......\n\n## 第三章\n\n### 态度的概念\n\n- 是一种内在的心理倾向\n- 态度总是指向特定的对象\n- 态度具有一定的稳定性和持久性\n- 态度是一个复杂的结构\n\n### 态度的三种成分（态度的结构）\n\n- 认知成分\n- 情感成分\n- 行为成分\n\n如果这个三个成分保持协调一致，那么态度稳定\n\n### 认知的失调理论\n\n个体认识到自己态度之间或者态度与行为之间存在矛盾，这就是认知失调。\n\n## 第四章\n\n### 动机理论\n\n","source":"_posts/复习笔记/组织行为学.md","raw":"# 组织行为学\n\n## 第一章\n\n### 组织行为学研究的内容\n\n研究组织中人的心理和行为规律（个体行为、群里行为、组织行为）\n\n### 管理的功能\n\n开发员工的潜能、提高员工的满意度和幸福感、提高领导水平、组织变革和组织发展的推动力。\n\n## 第二章\n\n### 大五大人格模型\n\n- 开放性（openness）：具有想象、审美、情感丰富、求异、创造、智慧等特质。\n- 责任心（conscientiousness）：显示胜任、公正、条理、尽职、成就、自律、谨慎、克制等特点。\n- 外倾性（extraversion）：表现出热情、社交、果断、活跃、冒险、乐观等特质。\n- 宜人性（agreeableness）：具有信任、利他、直率、依从、谦虚、移情等特质。\n- 神经质性（neuroticism）：难以平衡焦虑、敌对、压抑、自我意识、冲动、脆弱等情绪的特质，即不具有保持情绪稳定的能力。\n\n### MBTI人格理论\n\n四个维度：\n\n- 倾向将心理能量集中在外部世界还是内部世界的角度（内向型、外向型）\n- 如何获取信息的角度（感觉型、直觉型）\n- 如何处理信息和做出决策的角度（思考型、情感型）\n- 对待外部世界的方式（判断型、知觉型）\n\n### 智力多元论\n`47页第二段，不能吧智力当做听说读写看，文化智力那些重点看后面2个理论`\n留空......\n\n## 第三章\n\n### 态度的概念\n\n- 是一种内在的心理倾向\n- 态度总是指向特定的对象\n- 态度具有一定的稳定性和持久性\n- 态度是一个复杂的结构\n\n### 态度的三种成分（态度的结构）\n\n- 认知成分\n- 情感成分\n- 行为成分\n\n如果这个三个成分保持协调一致，那么态度稳定\n\n### 认知的失调理论\n\n个体认识到自己态度之间或者态度与行为之间存在矛盾，这就是认知失调。\n\n## 第四章\n\n### 动机理论\n\n","slug":"复习笔记/组织行为学","published":1,"date":"2023-02-02T02:48:03.153Z","updated":"2023-02-02T04:35:55.448Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmks009s9kbm7q2n76uj","content":"<h1 id=\"组织行为学\"><a href=\"#组织行为学\" class=\"headerlink\" title=\"组织行为学\"></a>组织行为学</h1><h2 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h2><h3 id=\"组织行为学研究的内容\"><a href=\"#组织行为学研究的内容\" class=\"headerlink\" title=\"组织行为学研究的内容\"></a>组织行为学研究的内容</h3><p>研究组织中人的心理和行为规律（个体行为、群里行为、组织行为）</p>\n<h3 id=\"管理的功能\"><a href=\"#管理的功能\" class=\"headerlink\" title=\"管理的功能\"></a>管理的功能</h3><p>开发员工的潜能、提高员工的满意度和幸福感、提高领导水平、组织变革和组织发展的推动力。</p>\n<h2 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h2><h3 id=\"大五大人格模型\"><a href=\"#大五大人格模型\" class=\"headerlink\" title=\"大五大人格模型\"></a>大五大人格模型</h3><ul>\n<li>开放性（openness）：具有想象、审美、情感丰富、求异、创造、智慧等特质。</li>\n<li>责任心（conscientiousness）：显示胜任、公正、条理、尽职、成就、自律、谨慎、克制等特点。</li>\n<li>外倾性（extraversion）：表现出热情、社交、果断、活跃、冒险、乐观等特质。</li>\n<li>宜人性（agreeableness）：具有信任、利他、直率、依从、谦虚、移情等特质。</li>\n<li>神经质性（neuroticism）：难以平衡焦虑、敌对、压抑、自我意识、冲动、脆弱等情绪的特质，即不具有保持情绪稳定的能力。</li>\n</ul>\n<h3 id=\"MBTI人格理论\"><a href=\"#MBTI人格理论\" class=\"headerlink\" title=\"MBTI人格理论\"></a>MBTI人格理论</h3><p>四个维度：</p>\n<ul>\n<li>倾向将心理能量集中在外部世界还是内部世界的角度（内向型、外向型）</li>\n<li>如何获取信息的角度（感觉型、直觉型）</li>\n<li>如何处理信息和做出决策的角度（思考型、情感型）</li>\n<li>对待外部世界的方式（判断型、知觉型）</li>\n</ul>\n<h3 id=\"智力多元论\"><a href=\"#智力多元论\" class=\"headerlink\" title=\"智力多元论\"></a>智力多元论</h3><p><code>47页第二段，不能吧智力当做听说读写看，文化智力那些重点看后面2个理论</code><br>留空……</p>\n<h2 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h2><h3 id=\"态度的概念\"><a href=\"#态度的概念\" class=\"headerlink\" title=\"态度的概念\"></a>态度的概念</h3><ul>\n<li>是一种内在的心理倾向</li>\n<li>态度总是指向特定的对象</li>\n<li>态度具有一定的稳定性和持久性</li>\n<li>态度是一个复杂的结构</li>\n</ul>\n<h3 id=\"态度的三种成分（态度的结构）\"><a href=\"#态度的三种成分（态度的结构）\" class=\"headerlink\" title=\"态度的三种成分（态度的结构）\"></a>态度的三种成分（态度的结构）</h3><ul>\n<li>认知成分</li>\n<li>情感成分</li>\n<li>行为成分</li>\n</ul>\n<p>如果这个三个成分保持协调一致，那么态度稳定</p>\n<h3 id=\"认知的失调理论\"><a href=\"#认知的失调理论\" class=\"headerlink\" title=\"认知的失调理论\"></a>认知的失调理论</h3><p>个体认识到自己态度之间或者态度与行为之间存在矛盾，这就是认知失调。</p>\n<h2 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h2><h3 id=\"动机理论\"><a href=\"#动机理论\" class=\"headerlink\" title=\"动机理论\"></a>动机理论</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"组织行为学\"><a href=\"#组织行为学\" class=\"headerlink\" title=\"组织行为学\"></a>组织行为学</h1><h2 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h2><h3 id=\"组织行为学研究的内容\"><a href=\"#组织行为学研究的内容\" class=\"headerlink\" title=\"组织行为学研究的内容\"></a>组织行为学研究的内容</h3><p>研究组织中人的心理和行为规律（个体行为、群里行为、组织行为）</p>\n<h3 id=\"管理的功能\"><a href=\"#管理的功能\" class=\"headerlink\" title=\"管理的功能\"></a>管理的功能</h3><p>开发员工的潜能、提高员工的满意度和幸福感、提高领导水平、组织变革和组织发展的推动力。</p>\n<h2 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h2><h3 id=\"大五大人格模型\"><a href=\"#大五大人格模型\" class=\"headerlink\" title=\"大五大人格模型\"></a>大五大人格模型</h3><ul>\n<li>开放性（openness）：具有想象、审美、情感丰富、求异、创造、智慧等特质。</li>\n<li>责任心（conscientiousness）：显示胜任、公正、条理、尽职、成就、自律、谨慎、克制等特点。</li>\n<li>外倾性（extraversion）：表现出热情、社交、果断、活跃、冒险、乐观等特质。</li>\n<li>宜人性（agreeableness）：具有信任、利他、直率、依从、谦虚、移情等特质。</li>\n<li>神经质性（neuroticism）：难以平衡焦虑、敌对、压抑、自我意识、冲动、脆弱等情绪的特质，即不具有保持情绪稳定的能力。</li>\n</ul>\n<h3 id=\"MBTI人格理论\"><a href=\"#MBTI人格理论\" class=\"headerlink\" title=\"MBTI人格理论\"></a>MBTI人格理论</h3><p>四个维度：</p>\n<ul>\n<li>倾向将心理能量集中在外部世界还是内部世界的角度（内向型、外向型）</li>\n<li>如何获取信息的角度（感觉型、直觉型）</li>\n<li>如何处理信息和做出决策的角度（思考型、情感型）</li>\n<li>对待外部世界的方式（判断型、知觉型）</li>\n</ul>\n<h3 id=\"智力多元论\"><a href=\"#智力多元论\" class=\"headerlink\" title=\"智力多元论\"></a>智力多元论</h3><p><code>47页第二段，不能吧智力当做听说读写看，文化智力那些重点看后面2个理论</code><br>留空……</p>\n<h2 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h2><h3 id=\"态度的概念\"><a href=\"#态度的概念\" class=\"headerlink\" title=\"态度的概念\"></a>态度的概念</h3><ul>\n<li>是一种内在的心理倾向</li>\n<li>态度总是指向特定的对象</li>\n<li>态度具有一定的稳定性和持久性</li>\n<li>态度是一个复杂的结构</li>\n</ul>\n<h3 id=\"态度的三种成分（态度的结构）\"><a href=\"#态度的三种成分（态度的结构）\" class=\"headerlink\" title=\"态度的三种成分（态度的结构）\"></a>态度的三种成分（态度的结构）</h3><ul>\n<li>认知成分</li>\n<li>情感成分</li>\n<li>行为成分</li>\n</ul>\n<p>如果这个三个成分保持协调一致，那么态度稳定</p>\n<h3 id=\"认知的失调理论\"><a href=\"#认知的失调理论\" class=\"headerlink\" title=\"认知的失调理论\"></a>认知的失调理论</h3><p>个体认识到自己态度之间或者态度与行为之间存在矛盾，这就是认知失调。</p>\n<h2 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h2><h3 id=\"动机理论\"><a href=\"#动机理论\" class=\"headerlink\" title=\"动机理论\"></a>动机理论</h3>"},{"title":"多态","date":"2023-01-06T16:00:00.000Z","_content":"# 多态\n[TOC]\n## 什么是多态\n\n多态就是同类型的对象，表现出不同的形态\n\n## 多态的表现形式\n\n父类类型 对象名称 = 子类对象;\n\n## 多态的前提\n\n- 有继承关系\n- 有父类引用指向子类对象 Fu f = new Zi()\n- 需要有方法的重写\n\n## 多态好处\n\n使用父类类型作为参数，可以接受所有子类对象。\n\n## 多态调用成员特点\n\n- 变量调用：编译看左边，运行也看左边\n\t- 编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有编译失败\n\t- 运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值\n- 方法调用：编译看左边，运行看右边\n\t- 编译看左边：javac编译代码的时候，会看左边的父类有没有这个方法，如果有，编译成功，否则编译失败\n\t- 运行看右边：java运行代码的时候，实际上运行的是子类中的方法\n\n造成这样结果的原因是：\n\n- 成员变量：在子类对象中，会把父类的成员变量也继承下来。父：name --> 子：name\n- 成员方法：如果子类对方法进行了重写，那么在虚方法表中就会把父类的方法进行覆盖。\n\n## 多态的优势以及弊端\n\n### 优势\n\n- 在多态形式下，右边对象可以实现解耦合，便于扩展和维护\n- 定义方法的时候，使用父类型作为参数，可以接受所有子类对象，体现多态的扩展与便利\n\n### 弊端\n\n- 在多态模式下，不能调用子类特有的功能\n\t- 这是因为在编译的时候，会先去看父类有没有这个方法，如果没有直接报错。\n\t\n\t- 解决方案：变回子类类型就可以了\n\t\n\t    就比如：Dog d = (Dog) a;","source":"_posts/javaLearn/多态.md","raw":"---\ntitle: 多态\ndate: 2023-1-7\ntags: [后端]\ncategories: [Java]\n---\n# 多态\n[TOC]\n## 什么是多态\n\n多态就是同类型的对象，表现出不同的形态\n\n## 多态的表现形式\n\n父类类型 对象名称 = 子类对象;\n\n## 多态的前提\n\n- 有继承关系\n- 有父类引用指向子类对象 Fu f = new Zi()\n- 需要有方法的重写\n\n## 多态好处\n\n使用父类类型作为参数，可以接受所有子类对象。\n\n## 多态调用成员特点\n\n- 变量调用：编译看左边，运行也看左边\n\t- 编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有编译失败\n\t- 运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值\n- 方法调用：编译看左边，运行看右边\n\t- 编译看左边：javac编译代码的时候，会看左边的父类有没有这个方法，如果有，编译成功，否则编译失败\n\t- 运行看右边：java运行代码的时候，实际上运行的是子类中的方法\n\n造成这样结果的原因是：\n\n- 成员变量：在子类对象中，会把父类的成员变量也继承下来。父：name --> 子：name\n- 成员方法：如果子类对方法进行了重写，那么在虚方法表中就会把父类的方法进行覆盖。\n\n## 多态的优势以及弊端\n\n### 优势\n\n- 在多态形式下，右边对象可以实现解耦合，便于扩展和维护\n- 定义方法的时候，使用父类型作为参数，可以接受所有子类对象，体现多态的扩展与便利\n\n### 弊端\n\n- 在多态模式下，不能调用子类特有的功能\n\t- 这是因为在编译的时候，会先去看父类有没有这个方法，如果没有直接报错。\n\t\n\t- 解决方案：变回子类类型就可以了\n\t\n\t    就比如：Dog d = (Dog) a;","slug":"javaLearn/多态","published":1,"updated":"2023-01-10T02:24:46.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkt009v9kbm9zjp381u","content":"<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p>[TOC]</p>\n<h2 id=\"什么是多态\"><a href=\"#什么是多态\" class=\"headerlink\" title=\"什么是多态\"></a>什么是多态</h2><p>多态就是同类型的对象，表现出不同的形态</p>\n<h2 id=\"多态的表现形式\"><a href=\"#多态的表现形式\" class=\"headerlink\" title=\"多态的表现形式\"></a>多态的表现形式</h2><p>父类类型 对象名称 &#x3D; 子类对象;</p>\n<h2 id=\"多态的前提\"><a href=\"#多态的前提\" class=\"headerlink\" title=\"多态的前提\"></a>多态的前提</h2><ul>\n<li>有继承关系</li>\n<li>有父类引用指向子类对象 Fu f &#x3D; new Zi()</li>\n<li>需要有方法的重写</li>\n</ul>\n<h2 id=\"多态好处\"><a href=\"#多态好处\" class=\"headerlink\" title=\"多态好处\"></a>多态好处</h2><p>使用父类类型作为参数，可以接受所有子类对象。</p>\n<h2 id=\"多态调用成员特点\"><a href=\"#多态调用成员特点\" class=\"headerlink\" title=\"多态调用成员特点\"></a>多态调用成员特点</h2><ul>\n<li>变量调用：编译看左边，运行也看左边<ul>\n<li>编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有编译失败</li>\n<li>运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值</li>\n</ul>\n</li>\n<li>方法调用：编译看左边，运行看右边<ul>\n<li>编译看左边：javac编译代码的时候，会看左边的父类有没有这个方法，如果有，编译成功，否则编译失败</li>\n<li>运行看右边：java运行代码的时候，实际上运行的是子类中的方法</li>\n</ul>\n</li>\n</ul>\n<p>造成这样结果的原因是：</p>\n<ul>\n<li>成员变量：在子类对象中，会把父类的成员变量也继承下来。父：name –&gt; 子：name</li>\n<li>成员方法：如果子类对方法进行了重写，那么在虚方法表中就会把父类的方法进行覆盖。</li>\n</ul>\n<h2 id=\"多态的优势以及弊端\"><a href=\"#多态的优势以及弊端\" class=\"headerlink\" title=\"多态的优势以及弊端\"></a>多态的优势以及弊端</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ul>\n<li>在多态形式下，右边对象可以实现解耦合，便于扩展和维护</li>\n<li>定义方法的时候，使用父类型作为参数，可以接受所有子类对象，体现多态的扩展与便利</li>\n</ul>\n<h3 id=\"弊端\"><a href=\"#弊端\" class=\"headerlink\" title=\"弊端\"></a>弊端</h3><ul>\n<li>在多态模式下，不能调用子类特有的功能<ul>\n<li><p>这是因为在编译的时候，会先去看父类有没有这个方法，如果没有直接报错。</p>\n</li>\n<li><p>解决方案：变回子类类型就可以了</p>\n<p>  就比如：Dog d &#x3D; (Dog) a;</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p>[TOC]</p>\n<h2 id=\"什么是多态\"><a href=\"#什么是多态\" class=\"headerlink\" title=\"什么是多态\"></a>什么是多态</h2><p>多态就是同类型的对象，表现出不同的形态</p>\n<h2 id=\"多态的表现形式\"><a href=\"#多态的表现形式\" class=\"headerlink\" title=\"多态的表现形式\"></a>多态的表现形式</h2><p>父类类型 对象名称 &#x3D; 子类对象;</p>\n<h2 id=\"多态的前提\"><a href=\"#多态的前提\" class=\"headerlink\" title=\"多态的前提\"></a>多态的前提</h2><ul>\n<li>有继承关系</li>\n<li>有父类引用指向子类对象 Fu f &#x3D; new Zi()</li>\n<li>需要有方法的重写</li>\n</ul>\n<h2 id=\"多态好处\"><a href=\"#多态好处\" class=\"headerlink\" title=\"多态好处\"></a>多态好处</h2><p>使用父类类型作为参数，可以接受所有子类对象。</p>\n<h2 id=\"多态调用成员特点\"><a href=\"#多态调用成员特点\" class=\"headerlink\" title=\"多态调用成员特点\"></a>多态调用成员特点</h2><ul>\n<li>变量调用：编译看左边，运行也看左边<ul>\n<li>编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有编译失败</li>\n<li>运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值</li>\n</ul>\n</li>\n<li>方法调用：编译看左边，运行看右边<ul>\n<li>编译看左边：javac编译代码的时候，会看左边的父类有没有这个方法，如果有，编译成功，否则编译失败</li>\n<li>运行看右边：java运行代码的时候，实际上运行的是子类中的方法</li>\n</ul>\n</li>\n</ul>\n<p>造成这样结果的原因是：</p>\n<ul>\n<li>成员变量：在子类对象中，会把父类的成员变量也继承下来。父：name –&gt; 子：name</li>\n<li>成员方法：如果子类对方法进行了重写，那么在虚方法表中就会把父类的方法进行覆盖。</li>\n</ul>\n<h2 id=\"多态的优势以及弊端\"><a href=\"#多态的优势以及弊端\" class=\"headerlink\" title=\"多态的优势以及弊端\"></a>多态的优势以及弊端</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ul>\n<li>在多态形式下，右边对象可以实现解耦合，便于扩展和维护</li>\n<li>定义方法的时候，使用父类型作为参数，可以接受所有子类对象，体现多态的扩展与便利</li>\n</ul>\n<h3 id=\"弊端\"><a href=\"#弊端\" class=\"headerlink\" title=\"弊端\"></a>弊端</h3><ul>\n<li>在多态模式下，不能调用子类特有的功能<ul>\n<li><p>这是因为在编译的时候，会先去看父类有没有这个方法，如果没有直接报错。</p>\n</li>\n<li><p>解决方案：变回子类类型就可以了</p>\n<p>  就比如：Dog d &#x3D; (Dog) a;</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"java中的封装","date":"2023-03-12T16:00:00.000Z","_content":"\n[TOC]\n\n# 封装\n\n不对外暴露过多的细节。\n\n实现方法：\n\n- 使用范围修饰符\n- 对象之间的交互都通过方法调用进行\n\n范围修饰符：\n\n- 类的访问控制\n\t- public 和package(默认)\n\n||同类|同一包中类|子类|其他包中类|\n|:--:|:--:|:--:|:--:|:--:|\n|public|√|√|√|√|\n|protected|√|√|√||\n|无修饰符|√|√|||\n|private|√|||\n\n## 封装一个属性\n\n- 第一步: 将属性的修饰符设置为`private`。\n\n- 第二步：为这些属性设置相应的`get`与`set`方法。","source":"_posts/javaLearn/封装..md","raw":"---\ntitle: java中的封装\ndate: [2023-3-13]\ntags: [java]\ncategories: [后端]\n---\n\n[TOC]\n\n# 封装\n\n不对外暴露过多的细节。\n\n实现方法：\n\n- 使用范围修饰符\n- 对象之间的交互都通过方法调用进行\n\n范围修饰符：\n\n- 类的访问控制\n\t- public 和package(默认)\n\n||同类|同一包中类|子类|其他包中类|\n|:--:|:--:|:--:|:--:|:--:|\n|public|√|√|√|√|\n|protected|√|√|√||\n|无修饰符|√|√|||\n|private|√|||\n\n## 封装一个属性\n\n- 第一步: 将属性的修饰符设置为`private`。\n\n- 第二步：为这些属性设置相应的`get`与`set`方法。","slug":"javaLearn/封装.","published":1,"updated":"2023-03-16T07:15:05.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmku009y9kbmhe4r1w9c","content":"<p>[TOC]</p>\n<h1 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h1><p>不对外暴露过多的细节。</p>\n<p>实现方法：</p>\n<ul>\n<li>使用范围修饰符</li>\n<li>对象之间的交互都通过方法调用进行</li>\n</ul>\n<p>范围修饰符：</p>\n<ul>\n<li>类的访问控制<ul>\n<li>public 和package(默认)</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">同类</th>\n<th align=\"center\">同一包中类</th>\n<th align=\"center\">子类</th>\n<th align=\"center\">其他包中类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">protected</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">无修饰符</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">private</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"封装一个属性\"><a href=\"#封装一个属性\" class=\"headerlink\" title=\"封装一个属性\"></a>封装一个属性</h2><ul>\n<li><p>第一步: 将属性的修饰符设置为<code>private</code>。</p>\n</li>\n<li><p>第二步：为这些属性设置相应的<code>get</code>与<code>set</code>方法。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h1><p>不对外暴露过多的细节。</p>\n<p>实现方法：</p>\n<ul>\n<li>使用范围修饰符</li>\n<li>对象之间的交互都通过方法调用进行</li>\n</ul>\n<p>范围修饰符：</p>\n<ul>\n<li>类的访问控制<ul>\n<li>public 和package(默认)</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">同类</th>\n<th align=\"center\">同一包中类</th>\n<th align=\"center\">子类</th>\n<th align=\"center\">其他包中类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">public</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n</tr>\n<tr>\n<td align=\"center\">protected</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">无修饰符</td>\n<td align=\"center\">√</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">private</td>\n<td align=\"center\">√</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"封装一个属性\"><a href=\"#封装一个属性\" class=\"headerlink\" title=\"封装一个属性\"></a>封装一个属性</h2><ul>\n<li><p>第一步: 将属性的修饰符设置为<code>private</code>。</p>\n</li>\n<li><p>第二步：为这些属性设置相应的<code>get</code>与<code>set</code>方法。</p>\n</li>\n</ul>\n"},{"title":"Java中的异常","date":"2023-03-14T16:00:00.000Z","_content":"[TOC]\n# Java中的异常\n\n在编写代码的时候我们经常会遇到一些报错，这些报错java就用一个对象包裹起来。这就是异常。\n\n在java运行的时候，遇到异常直接停止运行，并且提示报错信息。\n\n## 异常的体系结构\n\n所有的异常类型都是Throwable的子类。\n\n异常又大致分为两种：\n\n- error:系统错误，比较严重，无法恢复\n- Exception:用户程序可以捕捉的异常\n\t- 预期异常：必须要去处理，否则编译不通过\n\t- 运行时异常：可以不去捕获\n\n## 使用环境分类\n\n### 想让程序终止 throw\n\n### 不想让程序终止\n\n#### 1.自己处理：try catch finally\n\n#### 2.给别人处理 throws\n\n## Throws关键字\n\n方法可以通过throws关键字告诉调用者方法执行过程中可能会抛出哪些异常。","source":"_posts/javaLearn/异常.md","raw":"---\ntitle:  Java中的异常\ndate: [2023-3-15]\ntags: [后端]\ncategories: [Java]\n---\n[TOC]\n# Java中的异常\n\n在编写代码的时候我们经常会遇到一些报错，这些报错java就用一个对象包裹起来。这就是异常。\n\n在java运行的时候，遇到异常直接停止运行，并且提示报错信息。\n\n## 异常的体系结构\n\n所有的异常类型都是Throwable的子类。\n\n异常又大致分为两种：\n\n- error:系统错误，比较严重，无法恢复\n- Exception:用户程序可以捕捉的异常\n\t- 预期异常：必须要去处理，否则编译不通过\n\t- 运行时异常：可以不去捕获\n\n## 使用环境分类\n\n### 想让程序终止 throw\n\n### 不想让程序终止\n\n#### 1.自己处理：try catch finally\n\n#### 2.给别人处理 throws\n\n## Throws关键字\n\n方法可以通过throws关键字告诉调用者方法执行过程中可能会抛出哪些异常。","slug":"javaLearn/异常","published":1,"updated":"2023-03-16T07:14:52.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkv00a19kbm68gk9iag","content":"<p>[TOC]</p>\n<h1 id=\"Java中的异常\"><a href=\"#Java中的异常\" class=\"headerlink\" title=\"Java中的异常\"></a>Java中的异常</h1><p>在编写代码的时候我们经常会遇到一些报错，这些报错java就用一个对象包裹起来。这就是异常。</p>\n<p>在java运行的时候，遇到异常直接停止运行，并且提示报错信息。</p>\n<h2 id=\"异常的体系结构\"><a href=\"#异常的体系结构\" class=\"headerlink\" title=\"异常的体系结构\"></a>异常的体系结构</h2><p>所有的异常类型都是Throwable的子类。</p>\n<p>异常又大致分为两种：</p>\n<ul>\n<li>error:系统错误，比较严重，无法恢复</li>\n<li>Exception:用户程序可以捕捉的异常<ul>\n<li>预期异常：必须要去处理，否则编译不通过</li>\n<li>运行时异常：可以不去捕获</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"使用环境分类\"><a href=\"#使用环境分类\" class=\"headerlink\" title=\"使用环境分类\"></a>使用环境分类</h2><h3 id=\"想让程序终止-throw\"><a href=\"#想让程序终止-throw\" class=\"headerlink\" title=\"想让程序终止 throw\"></a>想让程序终止 throw</h3><h3 id=\"不想让程序终止\"><a href=\"#不想让程序终止\" class=\"headerlink\" title=\"不想让程序终止\"></a>不想让程序终止</h3><h4 id=\"1-自己处理：try-catch-finally\"><a href=\"#1-自己处理：try-catch-finally\" class=\"headerlink\" title=\"1.自己处理：try catch finally\"></a>1.自己处理：try catch finally</h4><h4 id=\"2-给别人处理-throws\"><a href=\"#2-给别人处理-throws\" class=\"headerlink\" title=\"2.给别人处理 throws\"></a>2.给别人处理 throws</h4><h2 id=\"Throws关键字\"><a href=\"#Throws关键字\" class=\"headerlink\" title=\"Throws关键字\"></a>Throws关键字</h2><p>方法可以通过throws关键字告诉调用者方法执行过程中可能会抛出哪些异常。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"Java中的异常\"><a href=\"#Java中的异常\" class=\"headerlink\" title=\"Java中的异常\"></a>Java中的异常</h1><p>在编写代码的时候我们经常会遇到一些报错，这些报错java就用一个对象包裹起来。这就是异常。</p>\n<p>在java运行的时候，遇到异常直接停止运行，并且提示报错信息。</p>\n<h2 id=\"异常的体系结构\"><a href=\"#异常的体系结构\" class=\"headerlink\" title=\"异常的体系结构\"></a>异常的体系结构</h2><p>所有的异常类型都是Throwable的子类。</p>\n<p>异常又大致分为两种：</p>\n<ul>\n<li>error:系统错误，比较严重，无法恢复</li>\n<li>Exception:用户程序可以捕捉的异常<ul>\n<li>预期异常：必须要去处理，否则编译不通过</li>\n<li>运行时异常：可以不去捕获</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"使用环境分类\"><a href=\"#使用环境分类\" class=\"headerlink\" title=\"使用环境分类\"></a>使用环境分类</h2><h3 id=\"想让程序终止-throw\"><a href=\"#想让程序终止-throw\" class=\"headerlink\" title=\"想让程序终止 throw\"></a>想让程序终止 throw</h3><h3 id=\"不想让程序终止\"><a href=\"#不想让程序终止\" class=\"headerlink\" title=\"不想让程序终止\"></a>不想让程序终止</h3><h4 id=\"1-自己处理：try-catch-finally\"><a href=\"#1-自己处理：try-catch-finally\" class=\"headerlink\" title=\"1.自己处理：try catch finally\"></a>1.自己处理：try catch finally</h4><h4 id=\"2-给别人处理-throws\"><a href=\"#2-给别人处理-throws\" class=\"headerlink\" title=\"2.给别人处理 throws\"></a>2.给别人处理 throws</h4><h2 id=\"Throws关键字\"><a href=\"#Throws关键字\" class=\"headerlink\" title=\"Throws关键字\"></a>Throws关键字</h2><p>方法可以通过throws关键字告诉调用者方法执行过程中可能会抛出哪些异常。</p>\n"},{"title":"常用API-Math","date":"2023-01-09T16:00:00.000Z","_content":"\n# 常用API-Math\n\nMath类的常用方法：\n|方法名|说明|\n|:--:|:--:|\n|abs()|返回绝对值|\n|ceil()|向上取整|\n|floor()|向下取整|\n|round()|四舍五入|\n|max(int a,int b)|返回较大值|\n|pow(double a,double b)|返回a的b次幂|\n|random()|返回double类型随机数[0.0~1.0)|\n\n绝对值：\n\n`abs(-88); // 88`\n`abs(99) // 99`\n\n向上取整：向数轴正数方向取整\n\n`ceil(-1.8); // -1`\n`ceil(1.2) // 2`\n\n向下取整：向数轴负数方向取整\n\n`floor(-2.3)  // -3`\n`floor(2.6) // 2`","source":"_posts/javaLearn/常用API-Math.md","raw":"---\ntitle: 常用API-Math\ndate: 2023-1-10\ntags: [后端]\ncategories: [Java]\n---\n\n# 常用API-Math\n\nMath类的常用方法：\n|方法名|说明|\n|:--:|:--:|\n|abs()|返回绝对值|\n|ceil()|向上取整|\n|floor()|向下取整|\n|round()|四舍五入|\n|max(int a,int b)|返回较大值|\n|pow(double a,double b)|返回a的b次幂|\n|random()|返回double类型随机数[0.0~1.0)|\n\n绝对值：\n\n`abs(-88); // 88`\n`abs(99) // 99`\n\n向上取整：向数轴正数方向取整\n\n`ceil(-1.8); // -1`\n`ceil(1.2) // 2`\n\n向下取整：向数轴负数方向取整\n\n`floor(-2.3)  // -3`\n`floor(2.6) // 2`","slug":"javaLearn/常用API-Math","published":1,"updated":"2023-01-10T08:21:25.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkw00a59kbm1uxb45ob","content":"<h1 id=\"常用API-Math\"><a href=\"#常用API-Math\" class=\"headerlink\" title=\"常用API-Math\"></a>常用API-Math</h1><p>Math类的常用方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">abs()</td>\n<td align=\"center\">返回绝对值</td>\n</tr>\n<tr>\n<td align=\"center\">ceil()</td>\n<td align=\"center\">向上取整</td>\n</tr>\n<tr>\n<td align=\"center\">floor()</td>\n<td align=\"center\">向下取整</td>\n</tr>\n<tr>\n<td align=\"center\">round()</td>\n<td align=\"center\">四舍五入</td>\n</tr>\n<tr>\n<td align=\"center\">max(int a,int b)</td>\n<td align=\"center\">返回较大值</td>\n</tr>\n<tr>\n<td align=\"center\">pow(double a,double b)</td>\n<td align=\"center\">返回a的b次幂</td>\n</tr>\n<tr>\n<td align=\"center\">random()</td>\n<td align=\"center\">返回double类型随机数[0.0~1.0)</td>\n</tr>\n</tbody></table>\n<p>绝对值：</p>\n<p><code>abs(-88); // 88</code><br><code>abs(99) // 99</code></p>\n<p>向上取整：向数轴正数方向取整</p>\n<p><code>ceil(-1.8); // -1</code><br><code>ceil(1.2) // 2</code></p>\n<p>向下取整：向数轴负数方向取整</p>\n<p><code>floor(-2.3)  // -3</code><br><code>floor(2.6) // 2</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用API-Math\"><a href=\"#常用API-Math\" class=\"headerlink\" title=\"常用API-Math\"></a>常用API-Math</h1><p>Math类的常用方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法名</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">abs()</td>\n<td align=\"center\">返回绝对值</td>\n</tr>\n<tr>\n<td align=\"center\">ceil()</td>\n<td align=\"center\">向上取整</td>\n</tr>\n<tr>\n<td align=\"center\">floor()</td>\n<td align=\"center\">向下取整</td>\n</tr>\n<tr>\n<td align=\"center\">round()</td>\n<td align=\"center\">四舍五入</td>\n</tr>\n<tr>\n<td align=\"center\">max(int a,int b)</td>\n<td align=\"center\">返回较大值</td>\n</tr>\n<tr>\n<td align=\"center\">pow(double a,double b)</td>\n<td align=\"center\">返回a的b次幂</td>\n</tr>\n<tr>\n<td align=\"center\">random()</td>\n<td align=\"center\">返回double类型随机数[0.0~1.0)</td>\n</tr>\n</tbody></table>\n<p>绝对值：</p>\n<p><code>abs(-88); // 88</code><br><code>abs(99) // 99</code></p>\n<p>向上取整：向数轴正数方向取整</p>\n<p><code>ceil(-1.8); // -1</code><br><code>ceil(1.2) // 2</code></p>\n<p>向下取整：向数轴负数方向取整</p>\n<p><code>floor(-2.3)  // -3</code><br><code>floor(2.6) // 2</code></p>\n"},{"title":"接口","date":"2023-01-07T16:00:00.000Z","_content":"# 接口\n[TOC]\n\n接口就是一种规则，对行为的一种抽象。\n\n## 接口的定义与使用\n\n- 接口使用关键字`interface`来定义\n\tpublic <font color = red>interface</font> 接口名{}\n- 接口不能实例化\n- 接口和类之间是实现关系，通过implements关键字表示\n\tpublic class 类名 <font color = red>implements</font> 接口名{}\n- 接口的子类（实现类）\n\t- 要么重写接口中所有的抽象方法\n\t- 要么是抽象类\n\n**注意1：**接口和类的实现关系，可以单实现，也可以多实现。\n\tpublic class 类名 implements 接口名1,接口名2{}\n**注意2：**实现类还可以在继承一个类的同时实现多个接口。\n\tpublic class 类名 extends  父类 implements 接口名1,接口名2{}\n\n------------------\n## 接口的细节\n\n### 接口中成员变量的特点\n\n- 成员变量\n\t只能是常量\n\t默认修饰符 :  **public** static  final\n- 构造方法：  没有\n- 成员方法：\n\t只能是抽象方法\n\t默认修饰符： public  abstract\n- JDK7以前： 接口中可以定义有方法体的方法\n- JDK8的新特性：接口中可以定义有方法体的方法\n- JDK9的新特性： 接口中可以定义私有方法\n\n### 接口与类之间的关系\n\n- 类和类的关系\n\t- 继承关系，只能单继承，不能多继承，但是可以多层继承\n- 类和接口的关系\n\t- 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n- 接口和接口的关系\n\t-  继承关系，可以单继承，也可以多继承\n\n## 接口拓展\n\n### JDK8以后接口新增的方法\n\n- 允许在接口中定义默认方法，需要使用default关键字修饰。\n\t<font color= skyblue>作用：解决接口升级问题</font>\n\t\n\n接口中<font color=red>默认方法</font>的定义格式：\n- 格式： public <font color=red>default</font> 返回值类型 方法名 (参数列表){}\n- 范例： public <font color=red>default</font> void show(){}\n\n接口中默认方法的<font color=red>注意事项</font>：\n- 默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字\n- public可以省略，default不可以省略\n- 如果实现了多个接口，多个接口中存在相同名字的默认方法，那么子类必须对该方法进行重写","source":"_posts/javaLearn/接口.md","raw":"---\ntitle: 接口\ndate: 2023-1-8\ntags: [后端]\ncategories: [Java]\n---\n# 接口\n[TOC]\n\n接口就是一种规则，对行为的一种抽象。\n\n## 接口的定义与使用\n\n- 接口使用关键字`interface`来定义\n\tpublic <font color = red>interface</font> 接口名{}\n- 接口不能实例化\n- 接口和类之间是实现关系，通过implements关键字表示\n\tpublic class 类名 <font color = red>implements</font> 接口名{}\n- 接口的子类（实现类）\n\t- 要么重写接口中所有的抽象方法\n\t- 要么是抽象类\n\n**注意1：**接口和类的实现关系，可以单实现，也可以多实现。\n\tpublic class 类名 implements 接口名1,接口名2{}\n**注意2：**实现类还可以在继承一个类的同时实现多个接口。\n\tpublic class 类名 extends  父类 implements 接口名1,接口名2{}\n\n------------------\n## 接口的细节\n\n### 接口中成员变量的特点\n\n- 成员变量\n\t只能是常量\n\t默认修饰符 :  **public** static  final\n- 构造方法：  没有\n- 成员方法：\n\t只能是抽象方法\n\t默认修饰符： public  abstract\n- JDK7以前： 接口中可以定义有方法体的方法\n- JDK8的新特性：接口中可以定义有方法体的方法\n- JDK9的新特性： 接口中可以定义私有方法\n\n### 接口与类之间的关系\n\n- 类和类的关系\n\t- 继承关系，只能单继承，不能多继承，但是可以多层继承\n- 类和接口的关系\n\t- 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n- 接口和接口的关系\n\t-  继承关系，可以单继承，也可以多继承\n\n## 接口拓展\n\n### JDK8以后接口新增的方法\n\n- 允许在接口中定义默认方法，需要使用default关键字修饰。\n\t<font color= skyblue>作用：解决接口升级问题</font>\n\t\n\n接口中<font color=red>默认方法</font>的定义格式：\n- 格式： public <font color=red>default</font> 返回值类型 方法名 (参数列表){}\n- 范例： public <font color=red>default</font> void show(){}\n\n接口中默认方法的<font color=red>注意事项</font>：\n- 默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字\n- public可以省略，default不可以省略\n- 如果实现了多个接口，多个接口中存在相同名字的默认方法，那么子类必须对该方法进行重写","slug":"javaLearn/接口","published":1,"updated":"2023-01-10T02:25:40.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkw00a89kbm986j6yfy","content":"<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><p>[TOC]</p>\n<p>接口就是一种规则，对行为的一种抽象。</p>\n<h2 id=\"接口的定义与使用\"><a href=\"#接口的定义与使用\" class=\"headerlink\" title=\"接口的定义与使用\"></a>接口的定义与使用</h2><ul>\n<li>接口使用关键字<code>interface</code>来定义<br>  public <font color = red>interface</font> 接口名{}</li>\n<li>接口不能实例化</li>\n<li>接口和类之间是实现关系，通过implements关键字表示<br>  public class 类名 <font color = red>implements</font> 接口名{}</li>\n<li>接口的子类（实现类）<ul>\n<li>要么重写接口中所有的抽象方法</li>\n<li>要么是抽象类</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意1：</strong>接口和类的实现关系，可以单实现，也可以多实现。<br>    public class 类名 implements 接口名1,接口名2{}<br><strong>注意2：</strong>实现类还可以在继承一个类的同时实现多个接口。<br>    public class 类名 extends  父类 implements 接口名1,接口名2{}</p>\n<hr>\n<h2 id=\"接口的细节\"><a href=\"#接口的细节\" class=\"headerlink\" title=\"接口的细节\"></a>接口的细节</h2><h3 id=\"接口中成员变量的特点\"><a href=\"#接口中成员变量的特点\" class=\"headerlink\" title=\"接口中成员变量的特点\"></a>接口中成员变量的特点</h3><ul>\n<li>成员变量<br>  只能是常量<br>  默认修饰符 :  <strong>public</strong> static  final</li>\n<li>构造方法：  没有</li>\n<li>成员方法：<br>  只能是抽象方法<br>  默认修饰符： public  abstract</li>\n<li>JDK7以前： 接口中可以定义有方法体的方法</li>\n<li>JDK8的新特性：接口中可以定义有方法体的方法</li>\n<li>JDK9的新特性： 接口中可以定义私有方法</li>\n</ul>\n<h3 id=\"接口与类之间的关系\"><a href=\"#接口与类之间的关系\" class=\"headerlink\" title=\"接口与类之间的关系\"></a>接口与类之间的关系</h3><ul>\n<li>类和类的关系<ul>\n<li>继承关系，只能单继承，不能多继承，但是可以多层继承</li>\n</ul>\n</li>\n<li>类和接口的关系<ul>\n<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>\n</ul>\n</li>\n<li>接口和接口的关系<ul>\n<li>继承关系，可以单继承，也可以多继承</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"接口拓展\"><a href=\"#接口拓展\" class=\"headerlink\" title=\"接口拓展\"></a>接口拓展</h2><h3 id=\"JDK8以后接口新增的方法\"><a href=\"#JDK8以后接口新增的方法\" class=\"headerlink\" title=\"JDK8以后接口新增的方法\"></a>JDK8以后接口新增的方法</h3><ul>\n<li>允许在接口中定义默认方法，需要使用default关键字修饰。<br>  <font color= skyblue>作用：解决接口升级问题</font></li>\n</ul>\n<p>接口中<font color=red>默认方法</font>的定义格式：</p>\n<ul>\n<li>格式： public <font color=red>default</font> 返回值类型 方法名 (参数列表){}</li>\n<li>范例： public <font color=red>default</font> void show(){}</li>\n</ul>\n<p>接口中默认方法的<font color=red>注意事项</font>：</p>\n<ul>\n<li>默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字</li>\n<li>public可以省略，default不可以省略</li>\n<li>如果实现了多个接口，多个接口中存在相同名字的默认方法，那么子类必须对该方法进行重写</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><p>[TOC]</p>\n<p>接口就是一种规则，对行为的一种抽象。</p>\n<h2 id=\"接口的定义与使用\"><a href=\"#接口的定义与使用\" class=\"headerlink\" title=\"接口的定义与使用\"></a>接口的定义与使用</h2><ul>\n<li>接口使用关键字<code>interface</code>来定义<br>  public <font color = red>interface</font> 接口名{}</li>\n<li>接口不能实例化</li>\n<li>接口和类之间是实现关系，通过implements关键字表示<br>  public class 类名 <font color = red>implements</font> 接口名{}</li>\n<li>接口的子类（实现类）<ul>\n<li>要么重写接口中所有的抽象方法</li>\n<li>要么是抽象类</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意1：</strong>接口和类的实现关系，可以单实现，也可以多实现。<br>    public class 类名 implements 接口名1,接口名2{}<br><strong>注意2：</strong>实现类还可以在继承一个类的同时实现多个接口。<br>    public class 类名 extends  父类 implements 接口名1,接口名2{}</p>\n<hr>\n<h2 id=\"接口的细节\"><a href=\"#接口的细节\" class=\"headerlink\" title=\"接口的细节\"></a>接口的细节</h2><h3 id=\"接口中成员变量的特点\"><a href=\"#接口中成员变量的特点\" class=\"headerlink\" title=\"接口中成员变量的特点\"></a>接口中成员变量的特点</h3><ul>\n<li>成员变量<br>  只能是常量<br>  默认修饰符 :  <strong>public</strong> static  final</li>\n<li>构造方法：  没有</li>\n<li>成员方法：<br>  只能是抽象方法<br>  默认修饰符： public  abstract</li>\n<li>JDK7以前： 接口中可以定义有方法体的方法</li>\n<li>JDK8的新特性：接口中可以定义有方法体的方法</li>\n<li>JDK9的新特性： 接口中可以定义私有方法</li>\n</ul>\n<h3 id=\"接口与类之间的关系\"><a href=\"#接口与类之间的关系\" class=\"headerlink\" title=\"接口与类之间的关系\"></a>接口与类之间的关系</h3><ul>\n<li>类和类的关系<ul>\n<li>继承关系，只能单继承，不能多继承，但是可以多层继承</li>\n</ul>\n</li>\n<li>类和接口的关系<ul>\n<li>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</li>\n</ul>\n</li>\n<li>接口和接口的关系<ul>\n<li>继承关系，可以单继承，也可以多继承</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"接口拓展\"><a href=\"#接口拓展\" class=\"headerlink\" title=\"接口拓展\"></a>接口拓展</h2><h3 id=\"JDK8以后接口新增的方法\"><a href=\"#JDK8以后接口新增的方法\" class=\"headerlink\" title=\"JDK8以后接口新增的方法\"></a>JDK8以后接口新增的方法</h3><ul>\n<li>允许在接口中定义默认方法，需要使用default关键字修饰。<br>  <font color= skyblue>作用：解决接口升级问题</font></li>\n</ul>\n<p>接口中<font color=red>默认方法</font>的定义格式：</p>\n<ul>\n<li>格式： public <font color=red>default</font> 返回值类型 方法名 (参数列表){}</li>\n<li>范例： public <font color=red>default</font> void show(){}</li>\n</ul>\n<p>接口中默认方法的<font color=red>注意事项</font>：</p>\n<ul>\n<li>默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字</li>\n<li>public可以省略，default不可以省略</li>\n<li>如果实现了多个接口，多个接口中存在相同名字的默认方法，那么子类必须对该方法进行重写</li>\n</ul>\n"},{"title":"抽象类与抽象方法","date":"2023-01-06T16:00:00.000Z","_content":"# 抽象类与抽象方法\n\n[TOC]\n## 定义\n\n- 抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。那么该方法就可以定义抽象方法。\n- 抽象类：如果一个类中存在抽象方法，那么该类<font color=red>必须声明为抽象类</font>。\n## 抽象类与抽象方法的定义格式\n\n- 抽象方法的定义格式：\n\t- public abstract 返回值类型 方法名(参数列表);\n- 抽象类的定义格式：\n\t- public abstract class 类名{}\n\t\n**抽象类和抽象方法的注意事项：**\n- 抽象类不能实例化\n- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n- 可以有构造方法\n- 抽象类的子类：\n\t- 要么重写抽象类中的所有抽象方法\n\t- 要么是抽象类\n## 抽象方法的定义格式\n\n## 子类继承抽象类之后，如何重写抽象方法","source":"_posts/javaLearn/抽象类与抽象方法.md","raw":"---\ntitle: 抽象类与抽象方法\ndate: 2023-1-7\ntags: [后端]\ncategories: [Java]\n---\n# 抽象类与抽象方法\n\n[TOC]\n## 定义\n\n- 抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。那么该方法就可以定义抽象方法。\n- 抽象类：如果一个类中存在抽象方法，那么该类<font color=red>必须声明为抽象类</font>。\n## 抽象类与抽象方法的定义格式\n\n- 抽象方法的定义格式：\n\t- public abstract 返回值类型 方法名(参数列表);\n- 抽象类的定义格式：\n\t- public abstract class 类名{}\n\t\n**抽象类和抽象方法的注意事项：**\n- 抽象类不能实例化\n- 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n- 可以有构造方法\n- 抽象类的子类：\n\t- 要么重写抽象类中的所有抽象方法\n\t- 要么是抽象类\n## 抽象方法的定义格式\n\n## 子类继承抽象类之后，如何重写抽象方法","slug":"javaLearn/抽象类与抽象方法","published":1,"updated":"2023-01-10T02:24:23.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmkx00ab9kbmfl4gdixr","content":"<h1 id=\"抽象类与抽象方法\"><a href=\"#抽象类与抽象方法\" class=\"headerlink\" title=\"抽象类与抽象方法\"></a>抽象类与抽象方法</h1><p>[TOC]</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li>抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。那么该方法就可以定义抽象方法。</li>\n<li>抽象类：如果一个类中存在抽象方法，那么该类<font color=red>必须声明为抽象类</font>。</li>\n</ul>\n<h2 id=\"抽象类与抽象方法的定义格式\"><a href=\"#抽象类与抽象方法的定义格式\" class=\"headerlink\" title=\"抽象类与抽象方法的定义格式\"></a>抽象类与抽象方法的定义格式</h2><ul>\n<li>抽象方法的定义格式：<ul>\n<li>public abstract 返回值类型 方法名(参数列表);</li>\n</ul>\n</li>\n<li>抽象类的定义格式：<ul>\n<li>public abstract class 类名{}</li>\n</ul>\n</li>\n</ul>\n<p><strong>抽象类和抽象方法的注意事项：</strong></p>\n<ul>\n<li>抽象类不能实例化</li>\n<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>\n<li>可以有构造方法</li>\n<li>抽象类的子类：<ul>\n<li>要么重写抽象类中的所有抽象方法</li>\n<li>要么是抽象类</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象方法的定义格式\"><a href=\"#抽象方法的定义格式\" class=\"headerlink\" title=\"抽象方法的定义格式\"></a>抽象方法的定义格式</h2><h2 id=\"子类继承抽象类之后，如何重写抽象方法\"><a href=\"#子类继承抽象类之后，如何重写抽象方法\" class=\"headerlink\" title=\"子类继承抽象类之后，如何重写抽象方法\"></a>子类继承抽象类之后，如何重写抽象方法</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"抽象类与抽象方法\"><a href=\"#抽象类与抽象方法\" class=\"headerlink\" title=\"抽象类与抽象方法\"></a>抽象类与抽象方法</h1><p>[TOC]</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li>抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以，在父类中不能确定具体的方法体。那么该方法就可以定义抽象方法。</li>\n<li>抽象类：如果一个类中存在抽象方法，那么该类<font color=red>必须声明为抽象类</font>。</li>\n</ul>\n<h2 id=\"抽象类与抽象方法的定义格式\"><a href=\"#抽象类与抽象方法的定义格式\" class=\"headerlink\" title=\"抽象类与抽象方法的定义格式\"></a>抽象类与抽象方法的定义格式</h2><ul>\n<li>抽象方法的定义格式：<ul>\n<li>public abstract 返回值类型 方法名(参数列表);</li>\n</ul>\n</li>\n<li>抽象类的定义格式：<ul>\n<li>public abstract class 类名{}</li>\n</ul>\n</li>\n</ul>\n<p><strong>抽象类和抽象方法的注意事项：</strong></p>\n<ul>\n<li>抽象类不能实例化</li>\n<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>\n<li>可以有构造方法</li>\n<li>抽象类的子类：<ul>\n<li>要么重写抽象类中的所有抽象方法</li>\n<li>要么是抽象类</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"抽象方法的定义格式\"><a href=\"#抽象方法的定义格式\" class=\"headerlink\" title=\"抽象方法的定义格式\"></a>抽象方法的定义格式</h2><h2 id=\"子类继承抽象类之后，如何重写抽象方法\"><a href=\"#子类继承抽象类之后，如何重写抽象方法\" class=\"headerlink\" title=\"子类继承抽象类之后，如何重写抽象方法\"></a>子类继承抽象类之后，如何重写抽象方法</h2>"},{"title":"java中的类和对象","date":"2023-03-07T16:00:00.000Z","_content":"\n[TOC]\n\n# 类和对象\n\n## 什么是类\n\n类是对事物的抽象。类描述了下面两种事物：\n\n- 属性（比如人的年龄）\n- 行为（方法）\n\n属性一般用名词来描述，行为一般用动词或者动宾短语来描述。\n\n### 类的具体实例\n\n类中的属性，有自己独立的取值\n\n类中的行为是外部对自己进行操作的接口（方法）\n\n**小知识补充：**\n\n- 成员变量：类中的属性\n- 成员方法：类中的行为\n- 局部变量：方法中的变量\n\n### 类的成员\n\n- 变量\n\n    - 静态变量\n    - 动态变量\n\n- 方法\n\n    - 静态方法\n    - 动态方法\n\n**静态变量：**\n\n类的所有实例共享一个拷贝\n\n也就是说静态变量是类的所有实例共享的，而不是每个实例都有一个拷贝。这样就可以节约内存。\n\n**静态方法：**\n\n- 与类本身相关的行为，与类的具体实例无关\n- 方法内部不能直接访问实例变量或者实例方法\n\n### 方法重载（OverLoading）\n\n**规则：**\n\n- 方法名相同\n- 参数列表不同（参数类型不同，参数个数不同，参数顺序不同）\n\n重载的方法根据传入的参数，来确定执行哪一个方法。\n\n## 构造方法\n\n**规则：**\n\n-  方法名和类名相同（区分大小写）\n-  声明中没有返回值类型（连void都没有）\n-  可以有参数列表（可有可无）\n\n## this关键字\n\nthis指向当前对象的引用。\n\n- 实例方法或者构造方法使用this来访问其他实例成员\n- 构造方法重载，在一个构造方法中调用这个构造方法。\n\t- 必须位于构造方法第一句","source":"_posts/javaLearn/类和对象.md","raw":"---\ntitle: java中的类和对象\ndate: [2023-3-8]\ntags: [后端]\ncategories: [Java]\n---\n\n[TOC]\n\n# 类和对象\n\n## 什么是类\n\n类是对事物的抽象。类描述了下面两种事物：\n\n- 属性（比如人的年龄）\n- 行为（方法）\n\n属性一般用名词来描述，行为一般用动词或者动宾短语来描述。\n\n### 类的具体实例\n\n类中的属性，有自己独立的取值\n\n类中的行为是外部对自己进行操作的接口（方法）\n\n**小知识补充：**\n\n- 成员变量：类中的属性\n- 成员方法：类中的行为\n- 局部变量：方法中的变量\n\n### 类的成员\n\n- 变量\n\n    - 静态变量\n    - 动态变量\n\n- 方法\n\n    - 静态方法\n    - 动态方法\n\n**静态变量：**\n\n类的所有实例共享一个拷贝\n\n也就是说静态变量是类的所有实例共享的，而不是每个实例都有一个拷贝。这样就可以节约内存。\n\n**静态方法：**\n\n- 与类本身相关的行为，与类的具体实例无关\n- 方法内部不能直接访问实例变量或者实例方法\n\n### 方法重载（OverLoading）\n\n**规则：**\n\n- 方法名相同\n- 参数列表不同（参数类型不同，参数个数不同，参数顺序不同）\n\n重载的方法根据传入的参数，来确定执行哪一个方法。\n\n## 构造方法\n\n**规则：**\n\n-  方法名和类名相同（区分大小写）\n-  声明中没有返回值类型（连void都没有）\n-  可以有参数列表（可有可无）\n\n## this关键字\n\nthis指向当前对象的引用。\n\n- 实例方法或者构造方法使用this来访问其他实例成员\n- 构造方法重载，在一个构造方法中调用这个构造方法。\n\t- 必须位于构造方法第一句","slug":"javaLearn/类和对象","published":1,"updated":"2023-03-16T07:17:56.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmky00ae9kbm18lraylx","content":"<p>[TOC]</p>\n<h1 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h1><h2 id=\"什么是类\"><a href=\"#什么是类\" class=\"headerlink\" title=\"什么是类\"></a>什么是类</h2><p>类是对事物的抽象。类描述了下面两种事物：</p>\n<ul>\n<li>属性（比如人的年龄）</li>\n<li>行为（方法）</li>\n</ul>\n<p>属性一般用名词来描述，行为一般用动词或者动宾短语来描述。</p>\n<h3 id=\"类的具体实例\"><a href=\"#类的具体实例\" class=\"headerlink\" title=\"类的具体实例\"></a>类的具体实例</h3><p>类中的属性，有自己独立的取值</p>\n<p>类中的行为是外部对自己进行操作的接口（方法）</p>\n<p><strong>小知识补充：</strong></p>\n<ul>\n<li>成员变量：类中的属性</li>\n<li>成员方法：类中的行为</li>\n<li>局部变量：方法中的变量</li>\n</ul>\n<h3 id=\"类的成员\"><a href=\"#类的成员\" class=\"headerlink\" title=\"类的成员\"></a>类的成员</h3><ul>\n<li><p>变量</p>\n<ul>\n<li>静态变量</li>\n<li>动态变量</li>\n</ul>\n</li>\n<li><p>方法</p>\n<ul>\n<li>静态方法</li>\n<li>动态方法</li>\n</ul>\n</li>\n</ul>\n<p><strong>静态变量：</strong></p>\n<p>类的所有实例共享一个拷贝</p>\n<p>也就是说静态变量是类的所有实例共享的，而不是每个实例都有一个拷贝。这样就可以节约内存。</p>\n<p><strong>静态方法：</strong></p>\n<ul>\n<li>与类本身相关的行为，与类的具体实例无关</li>\n<li>方法内部不能直接访问实例变量或者实例方法</li>\n</ul>\n<h3 id=\"方法重载（OverLoading）\"><a href=\"#方法重载（OverLoading）\" class=\"headerlink\" title=\"方法重载（OverLoading）\"></a>方法重载（OverLoading）</h3><p><strong>规则：</strong></p>\n<ul>\n<li>方法名相同</li>\n<li>参数列表不同（参数类型不同，参数个数不同，参数顺序不同）</li>\n</ul>\n<p>重载的方法根据传入的参数，来确定执行哪一个方法。</p>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p><strong>规则：</strong></p>\n<ul>\n<li>方法名和类名相同（区分大小写）</li>\n<li>声明中没有返回值类型（连void都没有）</li>\n<li>可以有参数列表（可有可无）</li>\n</ul>\n<h2 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h2><p>this指向当前对象的引用。</p>\n<ul>\n<li>实例方法或者构造方法使用this来访问其他实例成员</li>\n<li>构造方法重载，在一个构造方法中调用这个构造方法。<ul>\n<li>必须位于构造方法第一句</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"类和对象\"><a href=\"#类和对象\" class=\"headerlink\" title=\"类和对象\"></a>类和对象</h1><h2 id=\"什么是类\"><a href=\"#什么是类\" class=\"headerlink\" title=\"什么是类\"></a>什么是类</h2><p>类是对事物的抽象。类描述了下面两种事物：</p>\n<ul>\n<li>属性（比如人的年龄）</li>\n<li>行为（方法）</li>\n</ul>\n<p>属性一般用名词来描述，行为一般用动词或者动宾短语来描述。</p>\n<h3 id=\"类的具体实例\"><a href=\"#类的具体实例\" class=\"headerlink\" title=\"类的具体实例\"></a>类的具体实例</h3><p>类中的属性，有自己独立的取值</p>\n<p>类中的行为是外部对自己进行操作的接口（方法）</p>\n<p><strong>小知识补充：</strong></p>\n<ul>\n<li>成员变量：类中的属性</li>\n<li>成员方法：类中的行为</li>\n<li>局部变量：方法中的变量</li>\n</ul>\n<h3 id=\"类的成员\"><a href=\"#类的成员\" class=\"headerlink\" title=\"类的成员\"></a>类的成员</h3><ul>\n<li><p>变量</p>\n<ul>\n<li>静态变量</li>\n<li>动态变量</li>\n</ul>\n</li>\n<li><p>方法</p>\n<ul>\n<li>静态方法</li>\n<li>动态方法</li>\n</ul>\n</li>\n</ul>\n<p><strong>静态变量：</strong></p>\n<p>类的所有实例共享一个拷贝</p>\n<p>也就是说静态变量是类的所有实例共享的，而不是每个实例都有一个拷贝。这样就可以节约内存。</p>\n<p><strong>静态方法：</strong></p>\n<ul>\n<li>与类本身相关的行为，与类的具体实例无关</li>\n<li>方法内部不能直接访问实例变量或者实例方法</li>\n</ul>\n<h3 id=\"方法重载（OverLoading）\"><a href=\"#方法重载（OverLoading）\" class=\"headerlink\" title=\"方法重载（OverLoading）\"></a>方法重载（OverLoading）</h3><p><strong>规则：</strong></p>\n<ul>\n<li>方法名相同</li>\n<li>参数列表不同（参数类型不同，参数个数不同，参数顺序不同）</li>\n</ul>\n<p>重载的方法根据传入的参数，来确定执行哪一个方法。</p>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p><strong>规则：</strong></p>\n<ul>\n<li>方法名和类名相同（区分大小写）</li>\n<li>声明中没有返回值类型（连void都没有）</li>\n<li>可以有参数列表（可有可无）</li>\n</ul>\n<h2 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a>this关键字</h2><p>this指向当前对象的引用。</p>\n<ul>\n<li>实例方法或者构造方法使用this来访问其他实例成员</li>\n<li>构造方法重载，在一个构造方法中调用这个构造方法。<ul>\n<li>必须位于构造方法第一句</li>\n</ul>\n</li>\n</ul>\n"},{"title":"HTTP基础|[青训营笔记]","data":"2023-1-25","_content":"\n# HTTP基础\n\n[TOC]\n\n## 1.初识HTTP\n\nHTTP是一种超文本传输协议。它的特点有：\n\n- 是一种应用层协议，基于TCP协议\n- HTTP协议包括两个部分：请求  响应\n- HTTP是一个简单可扩展的协议\n- HTTP是一个无状态的协议\n\nHTTP中请求的一些方法：\n|  方法   |                                描述                                |\n| :-----: | :----------------------------------------------------------------: |\n|   GET   |   请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据    |\n|  POST   | 用于将实体提交到指定的资源，通常导致在服务器上的状态变化或者副作用 |\n|   PUT   |              用请求有效载荷替换目标资源的所有当前标识              |\n| DELETE  |                           删除指定的资源                           |\n|  HEAD   |         请求一个与GET请求的响应相同的响应，但是没有响应体          |\n| CONNECT |               建立一个到由目标资源标识的服务器的隧道               |\n| OPTIONS |                     用于描述目标资源的通信选项                     |\n|  TRACE  |              沿着到目标资源的路径执行一个消息环回测试              |\n|  PATCH  |                       用于对资源应用部分修改                       |\n\n安全的方法：也就是不会修改服务器数据的方法。  \n比如：GET  HEAD  OPTIONS \n\n### HTTP的状态码\n\n状态码一般是三位数：\n\n- 1XX：1开头的状态码，表示请求已经接收，正在处理（指示信息）\n- 2XX：2开头的状态码，表示请求已经被成功接收、理解、接受（成功）\n- 3XX：3开头的状态码：要完成请求必须进行更进一步的操作（重定向）\n- 4XX：4开头的状态码：请求有语法错误或者请求无法实现（客户端错误）\n- 5XX：5开头的状态码，服务器未能实现合法的请求（服务器错误）\n\n### HTTP常用的请求头\n\n|      请求头       |                                         描述                                          |\n| :---------------: | :-----------------------------------------------------------------------------------: |\n|      Accept       |          接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）           |\n|   Content-Type    |                             客户端发送出去实体内容的类型                              |\n|   Cache-Control   |                       指定请求和响应遵循的缓存机制，如no-cache                        |\n| If-Modified-Since |          对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内          |\n|      EXpires      |                缓存控制，这个时间内不会请求，直接使用缓存，服务端时间                 |\n|      Max-age      |              代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存               |\n|   If-None-Match   |                 对于服务端ETag，用来匹配文件内容是否改变（非常精确）                  |\n|      Cookie       |                           有cookie并且同域访问时会自动带上                            |\n|      Referer      | 该页面的来源URL（使用与所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段） |\n|      Origin       |         最初的请求是从哪里发起的（只会精确到端口），Origin比Referer更尊重隐私         |\n|    User-Agent     |                        用户客户端的一些必要信息，比如UA头部等                         |\n\n### HTTP常用的响应头\n\n|           响应头            |                             描述                             |\n| :-------------------------: | :----------------------------------------------------------: |\n|        Content-Type         |                  服务端返回的实体内容的类型                  |\n|        Cache-Control        |           指定请求和响应遵循的缓存机制，如no-cache           |\n|        Last-Modified        |                    请求资源的自后修改时间                    |\n|           Expires           |        应该在什么时候认为文档已经过期，从而不再缓存它        |\n|           Max-age           |   客户端的本地资源应该缓存多少秒，开启Cache-Control才有效    |\n|            ETag             |           资源的特定版本的标识符，ETags类似于指纹            |\n|         Set-Cookie          | 设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端 |\n|           Server            |                     服务器的一些相关信息                     |\n| Access-Control-Allow-Origin |           服务器端允许的请求Origin头部（比如：*）            |\n\n### HTTP中的缓存\n\n前面我们提到HTTP的请求头以及响应头，都有缓存这个选项。\n\n现在我们就来聊聊HTTP中的缓存，在这里缓存分为两种：\n\n- 强缓存\n- 协商缓存\n\n两者的区别就是：强缓存浏览器会看本地有没有缓存，有的话，浏览器直接拿来用；协商缓存呢，浏览器看到本地有缓存，但是不会马上拿来用，会先给服务端那边确认一下，确认成功之后才可以使用。\n\n强缓存里面的一些配置：\n\n- Expires：时间戳\n- Cache-Control：\n  - 可缓存性：\n    - no-cache:协商缓存验证\n    - no-store：不使用任何缓存\n  - 到期：\n    - max-age：单位是秒，存储的最大周期，性对于请求时间\n  - 重新验证/重新加载\n    - must-revalidate：一旦资源过期，遭成功向原始服务器验证之前，不能使用\n\n协商缓存的一些配置：\n\n- ETag/If-None-Match:资源的特定版本的标识符，类似指纹\n- Last-Modified/If-Modified-Since:最后修改时间\n\n### Cookie\n\nset-Cookie-response字段\n\n|                              |                                                                                                                  |\n| :--------------------------: | :--------------------------------------------------------------------------------------------------------------: |\n|          Name=value          |                                               各种cookie的名称和值                                               |\n|         Expires=Date         |                                Cookie的有效期，缺省时Cookie仅在浏览器关闭之前有效                                |\n|          Path=Path           |                                  限制指定Cookie的发送范围的文件目录，默认为当前                                  |\n|        Domain=domain         |                                 限制cookie生效的域名，默认为创建cookie的服务域名                                 |\n|            secure            |                                      仅在HTTPS安全链接时，才可以发送Cookie                                       |\n|           HttpOnly           |                                           JavaScript脚本无法获得Cookie                                           |\n| SameSite=[None\\|Strict\\|Lax] | None:同站、跨站请求都可以发送；Strict：仅在同站发送；允许与顶级导航一起发送，并将第三方网站发起的GET请求一起发送 |\n\n## HTTP的应用场景\n\n### 静态资源\n\n为了让用户更快的拿到静态资源，我们有一种静态资源部署方案：缓存+CDN+文件名hash\n\n### 跨域问题\n\n- CORS\n- 代理服务器\n  - 同源策略是浏览器的安全策略，不是HTTP的\n- Iframe\n  - 很多不方便的地方","source":"_posts/青训营笔记/HTTP.md","raw":"---\ntitle: HTTP基础|[青训营笔记]\ndata: 2023-1-25\ntags: [前端]\ncategories: [青训营]\n---\n\n# HTTP基础\n\n[TOC]\n\n## 1.初识HTTP\n\nHTTP是一种超文本传输协议。它的特点有：\n\n- 是一种应用层协议，基于TCP协议\n- HTTP协议包括两个部分：请求  响应\n- HTTP是一个简单可扩展的协议\n- HTTP是一个无状态的协议\n\nHTTP中请求的一些方法：\n|  方法   |                                描述                                |\n| :-----: | :----------------------------------------------------------------: |\n|   GET   |   请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据    |\n|  POST   | 用于将实体提交到指定的资源，通常导致在服务器上的状态变化或者副作用 |\n|   PUT   |              用请求有效载荷替换目标资源的所有当前标识              |\n| DELETE  |                           删除指定的资源                           |\n|  HEAD   |         请求一个与GET请求的响应相同的响应，但是没有响应体          |\n| CONNECT |               建立一个到由目标资源标识的服务器的隧道               |\n| OPTIONS |                     用于描述目标资源的通信选项                     |\n|  TRACE  |              沿着到目标资源的路径执行一个消息环回测试              |\n|  PATCH  |                       用于对资源应用部分修改                       |\n\n安全的方法：也就是不会修改服务器数据的方法。  \n比如：GET  HEAD  OPTIONS \n\n### HTTP的状态码\n\n状态码一般是三位数：\n\n- 1XX：1开头的状态码，表示请求已经接收，正在处理（指示信息）\n- 2XX：2开头的状态码，表示请求已经被成功接收、理解、接受（成功）\n- 3XX：3开头的状态码：要完成请求必须进行更进一步的操作（重定向）\n- 4XX：4开头的状态码：请求有语法错误或者请求无法实现（客户端错误）\n- 5XX：5开头的状态码，服务器未能实现合法的请求（服务器错误）\n\n### HTTP常用的请求头\n\n|      请求头       |                                         描述                                          |\n| :---------------: | :-----------------------------------------------------------------------------------: |\n|      Accept       |          接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）           |\n|   Content-Type    |                             客户端发送出去实体内容的类型                              |\n|   Cache-Control   |                       指定请求和响应遵循的缓存机制，如no-cache                        |\n| If-Modified-Since |          对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内          |\n|      EXpires      |                缓存控制，这个时间内不会请求，直接使用缓存，服务端时间                 |\n|      Max-age      |              代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存               |\n|   If-None-Match   |                 对于服务端ETag，用来匹配文件内容是否改变（非常精确）                  |\n|      Cookie       |                           有cookie并且同域访问时会自动带上                            |\n|      Referer      | 该页面的来源URL（使用与所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段） |\n|      Origin       |         最初的请求是从哪里发起的（只会精确到端口），Origin比Referer更尊重隐私         |\n|    User-Agent     |                        用户客户端的一些必要信息，比如UA头部等                         |\n\n### HTTP常用的响应头\n\n|           响应头            |                             描述                             |\n| :-------------------------: | :----------------------------------------------------------: |\n|        Content-Type         |                  服务端返回的实体内容的类型                  |\n|        Cache-Control        |           指定请求和响应遵循的缓存机制，如no-cache           |\n|        Last-Modified        |                    请求资源的自后修改时间                    |\n|           Expires           |        应该在什么时候认为文档已经过期，从而不再缓存它        |\n|           Max-age           |   客户端的本地资源应该缓存多少秒，开启Cache-Control才有效    |\n|            ETag             |           资源的特定版本的标识符，ETags类似于指纹            |\n|         Set-Cookie          | 设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端 |\n|           Server            |                     服务器的一些相关信息                     |\n| Access-Control-Allow-Origin |           服务器端允许的请求Origin头部（比如：*）            |\n\n### HTTP中的缓存\n\n前面我们提到HTTP的请求头以及响应头，都有缓存这个选项。\n\n现在我们就来聊聊HTTP中的缓存，在这里缓存分为两种：\n\n- 强缓存\n- 协商缓存\n\n两者的区别就是：强缓存浏览器会看本地有没有缓存，有的话，浏览器直接拿来用；协商缓存呢，浏览器看到本地有缓存，但是不会马上拿来用，会先给服务端那边确认一下，确认成功之后才可以使用。\n\n强缓存里面的一些配置：\n\n- Expires：时间戳\n- Cache-Control：\n  - 可缓存性：\n    - no-cache:协商缓存验证\n    - no-store：不使用任何缓存\n  - 到期：\n    - max-age：单位是秒，存储的最大周期，性对于请求时间\n  - 重新验证/重新加载\n    - must-revalidate：一旦资源过期，遭成功向原始服务器验证之前，不能使用\n\n协商缓存的一些配置：\n\n- ETag/If-None-Match:资源的特定版本的标识符，类似指纹\n- Last-Modified/If-Modified-Since:最后修改时间\n\n### Cookie\n\nset-Cookie-response字段\n\n|                              |                                                                                                                  |\n| :--------------------------: | :--------------------------------------------------------------------------------------------------------------: |\n|          Name=value          |                                               各种cookie的名称和值                                               |\n|         Expires=Date         |                                Cookie的有效期，缺省时Cookie仅在浏览器关闭之前有效                                |\n|          Path=Path           |                                  限制指定Cookie的发送范围的文件目录，默认为当前                                  |\n|        Domain=domain         |                                 限制cookie生效的域名，默认为创建cookie的服务域名                                 |\n|            secure            |                                      仅在HTTPS安全链接时，才可以发送Cookie                                       |\n|           HttpOnly           |                                           JavaScript脚本无法获得Cookie                                           |\n| SameSite=[None\\|Strict\\|Lax] | None:同站、跨站请求都可以发送；Strict：仅在同站发送；允许与顶级导航一起发送，并将第三方网站发起的GET请求一起发送 |\n\n## HTTP的应用场景\n\n### 静态资源\n\n为了让用户更快的拿到静态资源，我们有一种静态资源部署方案：缓存+CDN+文件名hash\n\n### 跨域问题\n\n- CORS\n- 代理服务器\n  - 同源策略是浏览器的安全策略，不是HTTP的\n- Iframe\n  - 很多不方便的地方","slug":"青训营笔记/HTTP","published":1,"date":"2023-01-24T11:03:01.429Z","updated":"2023-01-25T03:16:24.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml000ah9kbm8pj08sv0","content":"<h1 id=\"HTTP基础\"><a href=\"#HTTP基础\" class=\"headerlink\" title=\"HTTP基础\"></a>HTTP基础</h1><p>[TOC]</p>\n<h2 id=\"1-初识HTTP\"><a href=\"#1-初识HTTP\" class=\"headerlink\" title=\"1.初识HTTP\"></a>1.初识HTTP</h2><p>HTTP是一种超文本传输协议。它的特点有：</p>\n<ul>\n<li>是一种应用层协议，基于TCP协议</li>\n<li>HTTP协议包括两个部分：请求  响应</li>\n<li>HTTP是一个简单可扩展的协议</li>\n<li>HTTP是一个无状态的协议</li>\n</ul>\n<p>HTTP中请求的一些方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">GET</td>\n<td align=\"center\">请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据</td>\n</tr>\n<tr>\n<td align=\"center\">POST</td>\n<td align=\"center\">用于将实体提交到指定的资源，通常导致在服务器上的状态变化或者副作用</td>\n</tr>\n<tr>\n<td align=\"center\">PUT</td>\n<td align=\"center\">用请求有效载荷替换目标资源的所有当前标识</td>\n</tr>\n<tr>\n<td align=\"center\">DELETE</td>\n<td align=\"center\">删除指定的资源</td>\n</tr>\n<tr>\n<td align=\"center\">HEAD</td>\n<td align=\"center\">请求一个与GET请求的响应相同的响应，但是没有响应体</td>\n</tr>\n<tr>\n<td align=\"center\">CONNECT</td>\n<td align=\"center\">建立一个到由目标资源标识的服务器的隧道</td>\n</tr>\n<tr>\n<td align=\"center\">OPTIONS</td>\n<td align=\"center\">用于描述目标资源的通信选项</td>\n</tr>\n<tr>\n<td align=\"center\">TRACE</td>\n<td align=\"center\">沿着到目标资源的路径执行一个消息环回测试</td>\n</tr>\n<tr>\n<td align=\"center\">PATCH</td>\n<td align=\"center\">用于对资源应用部分修改</td>\n</tr>\n</tbody></table>\n<p>安全的方法：也就是不会修改服务器数据的方法。<br>比如：GET  HEAD  OPTIONS </p>\n<h3 id=\"HTTP的状态码\"><a href=\"#HTTP的状态码\" class=\"headerlink\" title=\"HTTP的状态码\"></a>HTTP的状态码</h3><p>状态码一般是三位数：</p>\n<ul>\n<li>1XX：1开头的状态码，表示请求已经接收，正在处理（指示信息）</li>\n<li>2XX：2开头的状态码，表示请求已经被成功接收、理解、接受（成功）</li>\n<li>3XX：3开头的状态码：要完成请求必须进行更进一步的操作（重定向）</li>\n<li>4XX：4开头的状态码：请求有语法错误或者请求无法实现（客户端错误）</li>\n<li>5XX：5开头的状态码，服务器未能实现合法的请求（服务器错误）</li>\n</ul>\n<h3 id=\"HTTP常用的请求头\"><a href=\"#HTTP常用的请求头\" class=\"headerlink\" title=\"HTTP常用的请求头\"></a>HTTP常用的请求头</h3><table>\n<thead>\n<tr>\n<th align=\"center\">请求头</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Accept</td>\n<td align=\"center\">接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）</td>\n</tr>\n<tr>\n<td align=\"center\">Content-Type</td>\n<td align=\"center\">客户端发送出去实体内容的类型</td>\n</tr>\n<tr>\n<td align=\"center\">Cache-Control</td>\n<td align=\"center\">指定请求和响应遵循的缓存机制，如no-cache</td>\n</tr>\n<tr>\n<td align=\"center\">If-Modified-Since</td>\n<td align=\"center\">对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内</td>\n</tr>\n<tr>\n<td align=\"center\">EXpires</td>\n<td align=\"center\">缓存控制，这个时间内不会请求，直接使用缓存，服务端时间</td>\n</tr>\n<tr>\n<td align=\"center\">Max-age</td>\n<td align=\"center\">代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存</td>\n</tr>\n<tr>\n<td align=\"center\">If-None-Match</td>\n<td align=\"center\">对于服务端ETag，用来匹配文件内容是否改变（非常精确）</td>\n</tr>\n<tr>\n<td align=\"center\">Cookie</td>\n<td align=\"center\">有cookie并且同域访问时会自动带上</td>\n</tr>\n<tr>\n<td align=\"center\">Referer</td>\n<td align=\"center\">该页面的来源URL（使用与所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段）</td>\n</tr>\n<tr>\n<td align=\"center\">Origin</td>\n<td align=\"center\">最初的请求是从哪里发起的（只会精确到端口），Origin比Referer更尊重隐私</td>\n</tr>\n<tr>\n<td align=\"center\">User-Agent</td>\n<td align=\"center\">用户客户端的一些必要信息，比如UA头部等</td>\n</tr>\n</tbody></table>\n<h3 id=\"HTTP常用的响应头\"><a href=\"#HTTP常用的响应头\" class=\"headerlink\" title=\"HTTP常用的响应头\"></a>HTTP常用的响应头</h3><table>\n<thead>\n<tr>\n<th align=\"center\">响应头</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Content-Type</td>\n<td align=\"center\">服务端返回的实体内容的类型</td>\n</tr>\n<tr>\n<td align=\"center\">Cache-Control</td>\n<td align=\"center\">指定请求和响应遵循的缓存机制，如no-cache</td>\n</tr>\n<tr>\n<td align=\"center\">Last-Modified</td>\n<td align=\"center\">请求资源的自后修改时间</td>\n</tr>\n<tr>\n<td align=\"center\">Expires</td>\n<td align=\"center\">应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td align=\"center\">Max-age</td>\n<td align=\"center\">客户端的本地资源应该缓存多少秒，开启Cache-Control才有效</td>\n</tr>\n<tr>\n<td align=\"center\">ETag</td>\n<td align=\"center\">资源的特定版本的标识符，ETags类似于指纹</td>\n</tr>\n<tr>\n<td align=\"center\">Set-Cookie</td>\n<td align=\"center\">设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</td>\n</tr>\n<tr>\n<td align=\"center\">Server</td>\n<td align=\"center\">服务器的一些相关信息</td>\n</tr>\n<tr>\n<td align=\"center\">Access-Control-Allow-Origin</td>\n<td align=\"center\">服务器端允许的请求Origin头部（比如：*）</td>\n</tr>\n</tbody></table>\n<h3 id=\"HTTP中的缓存\"><a href=\"#HTTP中的缓存\" class=\"headerlink\" title=\"HTTP中的缓存\"></a>HTTP中的缓存</h3><p>前面我们提到HTTP的请求头以及响应头，都有缓存这个选项。</p>\n<p>现在我们就来聊聊HTTP中的缓存，在这里缓存分为两种：</p>\n<ul>\n<li>强缓存</li>\n<li>协商缓存</li>\n</ul>\n<p>两者的区别就是：强缓存浏览器会看本地有没有缓存，有的话，浏览器直接拿来用；协商缓存呢，浏览器看到本地有缓存，但是不会马上拿来用，会先给服务端那边确认一下，确认成功之后才可以使用。</p>\n<p>强缓存里面的一些配置：</p>\n<ul>\n<li>Expires：时间戳</li>\n<li>Cache-Control：<ul>\n<li>可缓存性：<ul>\n<li>no-cache:协商缓存验证</li>\n<li>no-store：不使用任何缓存</li>\n</ul>\n</li>\n<li>到期：<ul>\n<li>max-age：单位是秒，存储的最大周期，性对于请求时间</li>\n</ul>\n</li>\n<li>重新验证&#x2F;重新加载<ul>\n<li>must-revalidate：一旦资源过期，遭成功向原始服务器验证之前，不能使用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>协商缓存的一些配置：</p>\n<ul>\n<li>ETag&#x2F;If-None-Match:资源的特定版本的标识符，类似指纹</li>\n<li>Last-Modified&#x2F;If-Modified-Since:最后修改时间</li>\n</ul>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>set-Cookie-response字段</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Name&#x3D;value</td>\n<td align=\"center\">各种cookie的名称和值</td>\n</tr>\n<tr>\n<td align=\"center\">Expires&#x3D;Date</td>\n<td align=\"center\">Cookie的有效期，缺省时Cookie仅在浏览器关闭之前有效</td>\n</tr>\n<tr>\n<td align=\"center\">Path&#x3D;Path</td>\n<td align=\"center\">限制指定Cookie的发送范围的文件目录，默认为当前</td>\n</tr>\n<tr>\n<td align=\"center\">Domain&#x3D;domain</td>\n<td align=\"center\">限制cookie生效的域名，默认为创建cookie的服务域名</td>\n</tr>\n<tr>\n<td align=\"center\">secure</td>\n<td align=\"center\">仅在HTTPS安全链接时，才可以发送Cookie</td>\n</tr>\n<tr>\n<td align=\"center\">HttpOnly</td>\n<td align=\"center\">JavaScript脚本无法获得Cookie</td>\n</tr>\n<tr>\n<td align=\"center\">SameSite&#x3D;[None|Strict|Lax]</td>\n<td align=\"center\">None:同站、跨站请求都可以发送；Strict：仅在同站发送；允许与顶级导航一起发送，并将第三方网站发起的GET请求一起发送</td>\n</tr>\n</tbody></table>\n<h2 id=\"HTTP的应用场景\"><a href=\"#HTTP的应用场景\" class=\"headerlink\" title=\"HTTP的应用场景\"></a>HTTP的应用场景</h2><h3 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h3><p>为了让用户更快的拿到静态资源，我们有一种静态资源部署方案：缓存+CDN+文件名hash</p>\n<h3 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h3><ul>\n<li>CORS</li>\n<li>代理服务器<ul>\n<li>同源策略是浏览器的安全策略，不是HTTP的</li>\n</ul>\n</li>\n<li>Iframe<ul>\n<li>很多不方便的地方</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTTP基础\"><a href=\"#HTTP基础\" class=\"headerlink\" title=\"HTTP基础\"></a>HTTP基础</h1><p>[TOC]</p>\n<h2 id=\"1-初识HTTP\"><a href=\"#1-初识HTTP\" class=\"headerlink\" title=\"1.初识HTTP\"></a>1.初识HTTP</h2><p>HTTP是一种超文本传输协议。它的特点有：</p>\n<ul>\n<li>是一种应用层协议，基于TCP协议</li>\n<li>HTTP协议包括两个部分：请求  响应</li>\n<li>HTTP是一个简单可扩展的协议</li>\n<li>HTTP是一个无状态的协议</li>\n</ul>\n<p>HTTP中请求的一些方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">方法</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">GET</td>\n<td align=\"center\">请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据</td>\n</tr>\n<tr>\n<td align=\"center\">POST</td>\n<td align=\"center\">用于将实体提交到指定的资源，通常导致在服务器上的状态变化或者副作用</td>\n</tr>\n<tr>\n<td align=\"center\">PUT</td>\n<td align=\"center\">用请求有效载荷替换目标资源的所有当前标识</td>\n</tr>\n<tr>\n<td align=\"center\">DELETE</td>\n<td align=\"center\">删除指定的资源</td>\n</tr>\n<tr>\n<td align=\"center\">HEAD</td>\n<td align=\"center\">请求一个与GET请求的响应相同的响应，但是没有响应体</td>\n</tr>\n<tr>\n<td align=\"center\">CONNECT</td>\n<td align=\"center\">建立一个到由目标资源标识的服务器的隧道</td>\n</tr>\n<tr>\n<td align=\"center\">OPTIONS</td>\n<td align=\"center\">用于描述目标资源的通信选项</td>\n</tr>\n<tr>\n<td align=\"center\">TRACE</td>\n<td align=\"center\">沿着到目标资源的路径执行一个消息环回测试</td>\n</tr>\n<tr>\n<td align=\"center\">PATCH</td>\n<td align=\"center\">用于对资源应用部分修改</td>\n</tr>\n</tbody></table>\n<p>安全的方法：也就是不会修改服务器数据的方法。<br>比如：GET  HEAD  OPTIONS </p>\n<h3 id=\"HTTP的状态码\"><a href=\"#HTTP的状态码\" class=\"headerlink\" title=\"HTTP的状态码\"></a>HTTP的状态码</h3><p>状态码一般是三位数：</p>\n<ul>\n<li>1XX：1开头的状态码，表示请求已经接收，正在处理（指示信息）</li>\n<li>2XX：2开头的状态码，表示请求已经被成功接收、理解、接受（成功）</li>\n<li>3XX：3开头的状态码：要完成请求必须进行更进一步的操作（重定向）</li>\n<li>4XX：4开头的状态码：请求有语法错误或者请求无法实现（客户端错误）</li>\n<li>5XX：5开头的状态码，服务器未能实现合法的请求（服务器错误）</li>\n</ul>\n<h3 id=\"HTTP常用的请求头\"><a href=\"#HTTP常用的请求头\" class=\"headerlink\" title=\"HTTP常用的请求头\"></a>HTTP常用的请求头</h3><table>\n<thead>\n<tr>\n<th align=\"center\">请求头</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Accept</td>\n<td align=\"center\">接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）</td>\n</tr>\n<tr>\n<td align=\"center\">Content-Type</td>\n<td align=\"center\">客户端发送出去实体内容的类型</td>\n</tr>\n<tr>\n<td align=\"center\">Cache-Control</td>\n<td align=\"center\">指定请求和响应遵循的缓存机制，如no-cache</td>\n</tr>\n<tr>\n<td align=\"center\">If-Modified-Since</td>\n<td align=\"center\">对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内</td>\n</tr>\n<tr>\n<td align=\"center\">EXpires</td>\n<td align=\"center\">缓存控制，这个时间内不会请求，直接使用缓存，服务端时间</td>\n</tr>\n<tr>\n<td align=\"center\">Max-age</td>\n<td align=\"center\">代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存</td>\n</tr>\n<tr>\n<td align=\"center\">If-None-Match</td>\n<td align=\"center\">对于服务端ETag，用来匹配文件内容是否改变（非常精确）</td>\n</tr>\n<tr>\n<td align=\"center\">Cookie</td>\n<td align=\"center\">有cookie并且同域访问时会自动带上</td>\n</tr>\n<tr>\n<td align=\"center\">Referer</td>\n<td align=\"center\">该页面的来源URL（使用与所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段）</td>\n</tr>\n<tr>\n<td align=\"center\">Origin</td>\n<td align=\"center\">最初的请求是从哪里发起的（只会精确到端口），Origin比Referer更尊重隐私</td>\n</tr>\n<tr>\n<td align=\"center\">User-Agent</td>\n<td align=\"center\">用户客户端的一些必要信息，比如UA头部等</td>\n</tr>\n</tbody></table>\n<h3 id=\"HTTP常用的响应头\"><a href=\"#HTTP常用的响应头\" class=\"headerlink\" title=\"HTTP常用的响应头\"></a>HTTP常用的响应头</h3><table>\n<thead>\n<tr>\n<th align=\"center\">响应头</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Content-Type</td>\n<td align=\"center\">服务端返回的实体内容的类型</td>\n</tr>\n<tr>\n<td align=\"center\">Cache-Control</td>\n<td align=\"center\">指定请求和响应遵循的缓存机制，如no-cache</td>\n</tr>\n<tr>\n<td align=\"center\">Last-Modified</td>\n<td align=\"center\">请求资源的自后修改时间</td>\n</tr>\n<tr>\n<td align=\"center\">Expires</td>\n<td align=\"center\">应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td align=\"center\">Max-age</td>\n<td align=\"center\">客户端的本地资源应该缓存多少秒，开启Cache-Control才有效</td>\n</tr>\n<tr>\n<td align=\"center\">ETag</td>\n<td align=\"center\">资源的特定版本的标识符，ETags类似于指纹</td>\n</tr>\n<tr>\n<td align=\"center\">Set-Cookie</td>\n<td align=\"center\">设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</td>\n</tr>\n<tr>\n<td align=\"center\">Server</td>\n<td align=\"center\">服务器的一些相关信息</td>\n</tr>\n<tr>\n<td align=\"center\">Access-Control-Allow-Origin</td>\n<td align=\"center\">服务器端允许的请求Origin头部（比如：*）</td>\n</tr>\n</tbody></table>\n<h3 id=\"HTTP中的缓存\"><a href=\"#HTTP中的缓存\" class=\"headerlink\" title=\"HTTP中的缓存\"></a>HTTP中的缓存</h3><p>前面我们提到HTTP的请求头以及响应头，都有缓存这个选项。</p>\n<p>现在我们就来聊聊HTTP中的缓存，在这里缓存分为两种：</p>\n<ul>\n<li>强缓存</li>\n<li>协商缓存</li>\n</ul>\n<p>两者的区别就是：强缓存浏览器会看本地有没有缓存，有的话，浏览器直接拿来用；协商缓存呢，浏览器看到本地有缓存，但是不会马上拿来用，会先给服务端那边确认一下，确认成功之后才可以使用。</p>\n<p>强缓存里面的一些配置：</p>\n<ul>\n<li>Expires：时间戳</li>\n<li>Cache-Control：<ul>\n<li>可缓存性：<ul>\n<li>no-cache:协商缓存验证</li>\n<li>no-store：不使用任何缓存</li>\n</ul>\n</li>\n<li>到期：<ul>\n<li>max-age：单位是秒，存储的最大周期，性对于请求时间</li>\n</ul>\n</li>\n<li>重新验证&#x2F;重新加载<ul>\n<li>must-revalidate：一旦资源过期，遭成功向原始服务器验证之前，不能使用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>协商缓存的一些配置：</p>\n<ul>\n<li>ETag&#x2F;If-None-Match:资源的特定版本的标识符，类似指纹</li>\n<li>Last-Modified&#x2F;If-Modified-Since:最后修改时间</li>\n</ul>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><p>set-Cookie-response字段</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Name&#x3D;value</td>\n<td align=\"center\">各种cookie的名称和值</td>\n</tr>\n<tr>\n<td align=\"center\">Expires&#x3D;Date</td>\n<td align=\"center\">Cookie的有效期，缺省时Cookie仅在浏览器关闭之前有效</td>\n</tr>\n<tr>\n<td align=\"center\">Path&#x3D;Path</td>\n<td align=\"center\">限制指定Cookie的发送范围的文件目录，默认为当前</td>\n</tr>\n<tr>\n<td align=\"center\">Domain&#x3D;domain</td>\n<td align=\"center\">限制cookie生效的域名，默认为创建cookie的服务域名</td>\n</tr>\n<tr>\n<td align=\"center\">secure</td>\n<td align=\"center\">仅在HTTPS安全链接时，才可以发送Cookie</td>\n</tr>\n<tr>\n<td align=\"center\">HttpOnly</td>\n<td align=\"center\">JavaScript脚本无法获得Cookie</td>\n</tr>\n<tr>\n<td align=\"center\">SameSite&#x3D;[None|Strict|Lax]</td>\n<td align=\"center\">None:同站、跨站请求都可以发送；Strict：仅在同站发送；允许与顶级导航一起发送，并将第三方网站发起的GET请求一起发送</td>\n</tr>\n</tbody></table>\n<h2 id=\"HTTP的应用场景\"><a href=\"#HTTP的应用场景\" class=\"headerlink\" title=\"HTTP的应用场景\"></a>HTTP的应用场景</h2><h3 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h3><p>为了让用户更快的拿到静态资源，我们有一种静态资源部署方案：缓存+CDN+文件名hash</p>\n<h3 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h3><ul>\n<li>CORS</li>\n<li>代理服务器<ul>\n<li>同源策略是浏览器的安全策略，不是HTTP的</li>\n</ul>\n</li>\n<li>Iframe<ul>\n<li>很多不方便的地方</li>\n</ul>\n</li>\n</ul>\n"},{"title":"继承","date":"2023-01-05T16:00:00.000Z","_content":"# 继承\n[TOC]\n\n面向对象三大特征：封装、继承、多态\n\n1. 封装：对象代表什么，就得封装对应的数据，并且提供数据对应的行为\n\n## 继承\n\n在java当中，提供了一个关键字：extends ，使用这个关键字可以让一个类与另一个类建立起继承关系。\n\n栗子：\n\n```java\n\tpublic class Student extendes Person{};\n```\n\n上面的代码中：Student称为子类（派生类），Person称为父类（基类或者超类）。\n\n使用继承的好处：\n\n- 可以把多个子类中重复的代码抽取到父类当中，提高了代码的复用性\n- 子类可以在父类的基础上，增加其他的功能，使得子类更加强大。\n\n## 自己设计\n\n**什么时候会用到继承：**当类与类之间，存在相同（共性）的内容，并且满足子类是父类其中的一种是，就可以考虑使用继承。\n\n比如：\n\n| 学生  | 老师  |\n| :---: | :---: |\n| 姓名  | 姓名  |\n| 年龄  | 年龄  |\n| 性别  | 性别  |\n| 学习  | 教书  |\n\n可以看到学生和老师都有姓名、年龄、性别这几个属性。那么就可以把这几个属性提取出来，放到父类里面。\n\n## 继承中的特点\n\n**一句话概括：**java只支持单继承，不支持多继承，但是支持多层继承\n\n- 单继承：一个子类只能继承一个父类（一个儿子只能有一个父亲）\n- 不支持多继承：子类不能同时继承多个父类（一个儿子不同同时有多个父亲）\n- 多层继承：子类A可以继承父类B，父类B可以继承父类C，父类C是子类A的间接父类\n\njava中有一个类是所有类的祖宗：Object。java中的每一个类都直接或者间接继承于Object。\n\n**注意：**子类只能访问父类中非私有的成员。\n\n## 继承可以继承父类中哪些内容\n\n父类中会有以下三种东西：\n\n1. 构造方法\n2. 成员变量\n3. 成员方法\n\n根据其中是否私有，可以继承的情况分下面几类：\n\n|          | 非私有是否能继承 | 私有是否能继承 |\n| :------: | :--------------: | :------------: |\n| 构造方法 |       不能       |      不能      |\n| 成员变量 |        能        |       能       |\n| 成员方法 |        //        |       //       |\n\n其中成员方法：只有能够添加到虚方法表中的方法才能被继承。也就是说除了private、final、static修饰的方法，都可以被继承。\n\n## 继承中成员变量访问特点\n\n**就近原则：谁离我近，我就用谁**\n\n例子：\n```java\npublic class Fu(){\n\tString name = \"Fu\";\n}\n\npublic class Zi extends Fu(){\n\tString name = \"Zi\";\n\tpublic void ziShow(){\n\t\tString name = \"ziShow\";\n\t\tSystem.out.println(name);  // \"ziShow\"（从局部位置开始往上找）\n\t\tSystem.out.println(this.name);  // \"Zi\"（从本类成员位置开始往上找）\n\t\tSystem.out.println(super.name);  // \"Fu\"（从父类成员位置开始往上找）\n\t}\n}\n```\n先在局部位置找，本类成员位置找，父类成员位置找，逐级往上。\n\n## 继承中成员方法的访问特点\n\n**直接调用满足就近原则：**谁离我近，我就用谁\n\n### super关键字\n\n用来显示访问父类成员或者构造方法。\n\nsuper调用：直接访问父类。\n\n可以使用`supper.父类方法`来调用父类的方法；可以使用`super.父类属性`来调用父类的属性。\n\n调用父类的构造方法：\n\n在子类中使用够惨构造方法，在方法里面使用`super(父类的参数)`。\n\n例子：\n```java\npublic static void main(String[] args){\n\tStudent s = new Student();\n\ts.lunch(); \n\t// 吃饭\n\t// 喝水\n}\n\nclass Person{\n\tpublic void eat(){\n\t\tSystem.out.println(\"吃饭\");\n\t}\n\t\n\tpublic void drink(){\n\t\tSystem.out.println(\"喝水\");\n\t}\n}\n\nclass Student extends Perdson{\n\tpublic void lunch(){\n\t\teat();\n\t\tdrink();\n\t}\n}\n```\n\n同样的如果调用方法时，前面加了super，那么就会直接去调用父类的方法。  \n前面加了this，就会调用本类的方法。\n\n### 方法的重写\n\n当父类的方法不能满足子类现在的需求时，就需要进行方法的重写。\n\n**书写格式：**\n\n在继承体系中，子类出现了和父类一模一样的方法声明，我们就称子类的这个方法是重写的方法。\n\n- @Override  重写注解\n\t1. @Override 是放在重写后的方法上，用来校验子类重写是语法是否正确。\n\t2. 加上注解之后如果有红色的波浪线，表示语法错误。\n\t3. <font color=red>建议重写方法都加@Override注解，代码安全优雅</font>\n\n如果在子类重写了方法，那么这个方法就会覆盖掉父类的方法。\n\n**方法重写注意事项与要求**\n\n1. 重写方法的名称、形参列表必须与父类当中的一致。\n2. 子类重写父类方法时，访问权限子类必须大于等于父类。（空着不写 < protected < public）\n3. 子类重写父类方法时，返回值类型子类必须小于等于父类。（了解）\n\t比如： 父类为animal  子类为cat和dog:那么子类返回的范围就不能不animal还大\n4. <font color=red>重写的方法尽量与父类保持一致</font>\n5. 只有添加到虚方法表的方法才能被重写。\n\n**方法重写的本质：**\n\n覆盖虚方法表中的方法\n\n## 继承中构造方法的特点\n\n- 父类中的构造方法不会被子类继承\n- 子类当中所有的构造方法都会先默认访问父类中的无参构造，再执行自己。\n\t为什么呢？\n\t\t- 因为子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据\n\t\t- <font color=red>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化</font>\n\t\t怎么调用父类构造方法?\n\t\t- 子类构造方法的第一行语句默认都是：super()，不写它也在，并且必须在第一行。\n\t\t- <font color=red>如果想调用父类有参构造，必须手动写super进行调用</font>\n\n## this,super总结\n\n- this可以理解为一个变量，里面存着当前方法调用者的地址值。\n- super表示父类的存储空间\n\n| 关键字 |            访问成员变量            |                访问成员方法                |           访问构造方法            |\n| :----: | :--------------------------------: | :----------------------------------------: | :-------------------------------: |\n|  this  | this.成员变量    访问本类成员变量  |   this.成员方法(...)   访问本类成员方法    |     this(...)    访问本类方法     |\n| super  | super.成员变量    访问父类成员变量 | super.成员方法(...)     访问父类的成员方法 | super(...)     访问父类的构造方法 |","source":"_posts/javaLearn/继承.md","raw":"---\ntitle: 继承\ndate: 2023-1-6\ntags: [后端]\ncategories: [Java]\n---\n# 继承\n[TOC]\n\n面向对象三大特征：封装、继承、多态\n\n1. 封装：对象代表什么，就得封装对应的数据，并且提供数据对应的行为\n\n## 继承\n\n在java当中，提供了一个关键字：extends ，使用这个关键字可以让一个类与另一个类建立起继承关系。\n\n栗子：\n\n```java\n\tpublic class Student extendes Person{};\n```\n\n上面的代码中：Student称为子类（派生类），Person称为父类（基类或者超类）。\n\n使用继承的好处：\n\n- 可以把多个子类中重复的代码抽取到父类当中，提高了代码的复用性\n- 子类可以在父类的基础上，增加其他的功能，使得子类更加强大。\n\n## 自己设计\n\n**什么时候会用到继承：**当类与类之间，存在相同（共性）的内容，并且满足子类是父类其中的一种是，就可以考虑使用继承。\n\n比如：\n\n| 学生  | 老师  |\n| :---: | :---: |\n| 姓名  | 姓名  |\n| 年龄  | 年龄  |\n| 性别  | 性别  |\n| 学习  | 教书  |\n\n可以看到学生和老师都有姓名、年龄、性别这几个属性。那么就可以把这几个属性提取出来，放到父类里面。\n\n## 继承中的特点\n\n**一句话概括：**java只支持单继承，不支持多继承，但是支持多层继承\n\n- 单继承：一个子类只能继承一个父类（一个儿子只能有一个父亲）\n- 不支持多继承：子类不能同时继承多个父类（一个儿子不同同时有多个父亲）\n- 多层继承：子类A可以继承父类B，父类B可以继承父类C，父类C是子类A的间接父类\n\njava中有一个类是所有类的祖宗：Object。java中的每一个类都直接或者间接继承于Object。\n\n**注意：**子类只能访问父类中非私有的成员。\n\n## 继承可以继承父类中哪些内容\n\n父类中会有以下三种东西：\n\n1. 构造方法\n2. 成员变量\n3. 成员方法\n\n根据其中是否私有，可以继承的情况分下面几类：\n\n|          | 非私有是否能继承 | 私有是否能继承 |\n| :------: | :--------------: | :------------: |\n| 构造方法 |       不能       |      不能      |\n| 成员变量 |        能        |       能       |\n| 成员方法 |        //        |       //       |\n\n其中成员方法：只有能够添加到虚方法表中的方法才能被继承。也就是说除了private、final、static修饰的方法，都可以被继承。\n\n## 继承中成员变量访问特点\n\n**就近原则：谁离我近，我就用谁**\n\n例子：\n```java\npublic class Fu(){\n\tString name = \"Fu\";\n}\n\npublic class Zi extends Fu(){\n\tString name = \"Zi\";\n\tpublic void ziShow(){\n\t\tString name = \"ziShow\";\n\t\tSystem.out.println(name);  // \"ziShow\"（从局部位置开始往上找）\n\t\tSystem.out.println(this.name);  // \"Zi\"（从本类成员位置开始往上找）\n\t\tSystem.out.println(super.name);  // \"Fu\"（从父类成员位置开始往上找）\n\t}\n}\n```\n先在局部位置找，本类成员位置找，父类成员位置找，逐级往上。\n\n## 继承中成员方法的访问特点\n\n**直接调用满足就近原则：**谁离我近，我就用谁\n\n### super关键字\n\n用来显示访问父类成员或者构造方法。\n\nsuper调用：直接访问父类。\n\n可以使用`supper.父类方法`来调用父类的方法；可以使用`super.父类属性`来调用父类的属性。\n\n调用父类的构造方法：\n\n在子类中使用够惨构造方法，在方法里面使用`super(父类的参数)`。\n\n例子：\n```java\npublic static void main(String[] args){\n\tStudent s = new Student();\n\ts.lunch(); \n\t// 吃饭\n\t// 喝水\n}\n\nclass Person{\n\tpublic void eat(){\n\t\tSystem.out.println(\"吃饭\");\n\t}\n\t\n\tpublic void drink(){\n\t\tSystem.out.println(\"喝水\");\n\t}\n}\n\nclass Student extends Perdson{\n\tpublic void lunch(){\n\t\teat();\n\t\tdrink();\n\t}\n}\n```\n\n同样的如果调用方法时，前面加了super，那么就会直接去调用父类的方法。  \n前面加了this，就会调用本类的方法。\n\n### 方法的重写\n\n当父类的方法不能满足子类现在的需求时，就需要进行方法的重写。\n\n**书写格式：**\n\n在继承体系中，子类出现了和父类一模一样的方法声明，我们就称子类的这个方法是重写的方法。\n\n- @Override  重写注解\n\t1. @Override 是放在重写后的方法上，用来校验子类重写是语法是否正确。\n\t2. 加上注解之后如果有红色的波浪线，表示语法错误。\n\t3. <font color=red>建议重写方法都加@Override注解，代码安全优雅</font>\n\n如果在子类重写了方法，那么这个方法就会覆盖掉父类的方法。\n\n**方法重写注意事项与要求**\n\n1. 重写方法的名称、形参列表必须与父类当中的一致。\n2. 子类重写父类方法时，访问权限子类必须大于等于父类。（空着不写 < protected < public）\n3. 子类重写父类方法时，返回值类型子类必须小于等于父类。（了解）\n\t比如： 父类为animal  子类为cat和dog:那么子类返回的范围就不能不animal还大\n4. <font color=red>重写的方法尽量与父类保持一致</font>\n5. 只有添加到虚方法表的方法才能被重写。\n\n**方法重写的本质：**\n\n覆盖虚方法表中的方法\n\n## 继承中构造方法的特点\n\n- 父类中的构造方法不会被子类继承\n- 子类当中所有的构造方法都会先默认访问父类中的无参构造，再执行自己。\n\t为什么呢？\n\t\t- 因为子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据\n\t\t- <font color=red>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化</font>\n\t\t怎么调用父类构造方法?\n\t\t- 子类构造方法的第一行语句默认都是：super()，不写它也在，并且必须在第一行。\n\t\t- <font color=red>如果想调用父类有参构造，必须手动写super进行调用</font>\n\n## this,super总结\n\n- this可以理解为一个变量，里面存着当前方法调用者的地址值。\n- super表示父类的存储空间\n\n| 关键字 |            访问成员变量            |                访问成员方法                |           访问构造方法            |\n| :----: | :--------------------------------: | :----------------------------------------: | :-------------------------------: |\n|  this  | this.成员变量    访问本类成员变量  |   this.成员方法(...)   访问本类成员方法    |     this(...)    访问本类方法     |\n| super  | super.成员变量    访问父类成员变量 | super.成员方法(...)     访问父类的成员方法 | super(...)     访问父类的构造方法 |","slug":"javaLearn/继承","published":1,"updated":"2023-03-14T03:22:00.191Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml200ak9kbmf6u57dqp","content":"<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>[TOC]</p>\n<p>面向对象三大特征：封装、继承、多态</p>\n<ol>\n<li>封装：对象代表什么，就得封装对应的数据，并且提供数据对应的行为</li>\n</ol>\n<h2 id=\"继承-1\"><a href=\"#继承-1\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在java当中，提供了一个关键字：extends ，使用这个关键字可以让一个类与另一个类建立起继承关系。</p>\n<p>栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> extendes Person&#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中：Student称为子类（派生类），Person称为父类（基类或者超类）。</p>\n<p>使用继承的好处：</p>\n<ul>\n<li>可以把多个子类中重复的代码抽取到父类当中，提高了代码的复用性</li>\n<li>子类可以在父类的基础上，增加其他的功能，使得子类更加强大。</li>\n</ul>\n<h2 id=\"自己设计\"><a href=\"#自己设计\" class=\"headerlink\" title=\"自己设计\"></a>自己设计</h2><p><strong>什么时候会用到继承：</strong>当类与类之间，存在相同（共性）的内容，并且满足子类是父类其中的一种是，就可以考虑使用继承。</p>\n<p>比如：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">学生</th>\n<th align=\"center\">老师</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">姓名</td>\n<td align=\"center\">姓名</td>\n</tr>\n<tr>\n<td align=\"center\">年龄</td>\n<td align=\"center\">年龄</td>\n</tr>\n<tr>\n<td align=\"center\">性别</td>\n<td align=\"center\">性别</td>\n</tr>\n<tr>\n<td align=\"center\">学习</td>\n<td align=\"center\">教书</td>\n</tr>\n</tbody></table>\n<p>可以看到学生和老师都有姓名、年龄、性别这几个属性。那么就可以把这几个属性提取出来，放到父类里面。</p>\n<h2 id=\"继承中的特点\"><a href=\"#继承中的特点\" class=\"headerlink\" title=\"继承中的特点\"></a>继承中的特点</h2><p><strong>一句话概括：</strong>java只支持单继承，不支持多继承，但是支持多层继承</p>\n<ul>\n<li>单继承：一个子类只能继承一个父类（一个儿子只能有一个父亲）</li>\n<li>不支持多继承：子类不能同时继承多个父类（一个儿子不同同时有多个父亲）</li>\n<li>多层继承：子类A可以继承父类B，父类B可以继承父类C，父类C是子类A的间接父类</li>\n</ul>\n<p>java中有一个类是所有类的祖宗：Object。java中的每一个类都直接或者间接继承于Object。</p>\n<p><strong>注意：</strong>子类只能访问父类中非私有的成员。</p>\n<h2 id=\"继承可以继承父类中哪些内容\"><a href=\"#继承可以继承父类中哪些内容\" class=\"headerlink\" title=\"继承可以继承父类中哪些内容\"></a>继承可以继承父类中哪些内容</h2><p>父类中会有以下三种东西：</p>\n<ol>\n<li>构造方法</li>\n<li>成员变量</li>\n<li>成员方法</li>\n</ol>\n<p>根据其中是否私有，可以继承的情况分下面几类：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">非私有是否能继承</th>\n<th align=\"center\">私有是否能继承</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">构造方法</td>\n<td align=\"center\">不能</td>\n<td align=\"center\">不能</td>\n</tr>\n<tr>\n<td align=\"center\">成员变量</td>\n<td align=\"center\">能</td>\n<td align=\"center\">能</td>\n</tr>\n<tr>\n<td align=\"center\">成员方法</td>\n<td align=\"center\">&#x2F;&#x2F;</td>\n<td align=\"center\">&#x2F;&#x2F;</td>\n</tr>\n</tbody></table>\n<p>其中成员方法：只有能够添加到虚方法表中的方法才能被继承。也就是说除了private、final、static修饰的方法，都可以被继承。</p>\n<h2 id=\"继承中成员变量访问特点\"><a href=\"#继承中成员变量访问特点\" class=\"headerlink\" title=\"继承中成员变量访问特点\"></a>继承中成员变量访问特点</h2><p><strong>就近原则：谁离我近，我就用谁</strong></p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Fu</span>()&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Fu&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Zi</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Fu</span>()&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Zi&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ziShow</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ziShow&quot;</span>;</span><br><span class=\"line\">\t\tSystem.out.println(name);  <span class=\"comment\">// &quot;ziShow&quot;（从局部位置开始往上找）</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"built_in\">this</span>.name);  <span class=\"comment\">// &quot;Zi&quot;（从本类成员位置开始往上找）</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"built_in\">super</span>.name);  <span class=\"comment\">// &quot;Fu&quot;（从父类成员位置开始往上找）</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先在局部位置找，本类成员位置找，父类成员位置找，逐级往上。</p>\n<h2 id=\"继承中成员方法的访问特点\"><a href=\"#继承中成员方法的访问特点\" class=\"headerlink\" title=\"继承中成员方法的访问特点\"></a>继承中成员方法的访问特点</h2><p><strong>直接调用满足就近原则：</strong>谁离我近，我就用谁</p>\n<h3 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h3><p>用来显示访问父类成员或者构造方法。</p>\n<p>super调用：直接访问父类。</p>\n<p>可以使用<code>supper.父类方法</code>来调用父类的方法；可以使用<code>super.父类属性</code>来调用父类的属性。</p>\n<p>调用父类的构造方法：</p>\n<p>在子类中使用够惨构造方法，在方法里面使用<code>super(父类的参数)</code>。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">Student</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br><span class=\"line\">\ts.lunch(); </span><br><span class=\"line\">\t<span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">\t<span class=\"comment\">// 喝水</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;吃饭&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">drink</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;喝水&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Perdson</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lunch</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\teat();</span><br><span class=\"line\">\t\tdrink();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的如果调用方法时，前面加了super，那么就会直接去调用父类的方法。<br>前面加了this，就会调用本类的方法。</p>\n<h3 id=\"方法的重写\"><a href=\"#方法的重写\" class=\"headerlink\" title=\"方法的重写\"></a>方法的重写</h3><p>当父类的方法不能满足子类现在的需求时，就需要进行方法的重写。</p>\n<p><strong>书写格式：</strong></p>\n<p>在继承体系中，子类出现了和父类一模一样的方法声明，我们就称子类的这个方法是重写的方法。</p>\n<ul>\n<li>@Override  重写注解<ol>\n<li>@Override 是放在重写后的方法上，用来校验子类重写是语法是否正确。</li>\n<li>加上注解之后如果有红色的波浪线，表示语法错误。</li>\n<li><font color=red>建议重写方法都加@Override注解，代码安全优雅</font></li>\n</ol>\n</li>\n</ul>\n<p>如果在子类重写了方法，那么这个方法就会覆盖掉父类的方法。</p>\n<p><strong>方法重写注意事项与要求</strong></p>\n<ol>\n<li>重写方法的名称、形参列表必须与父类当中的一致。</li>\n<li>子类重写父类方法时，访问权限子类必须大于等于父类。（空着不写 &lt; protected &lt; public）</li>\n<li>子类重写父类方法时，返回值类型子类必须小于等于父类。（了解）<br> 比如： 父类为animal  子类为cat和dog:那么子类返回的范围就不能不animal还大</li>\n<li><font color=red>重写的方法尽量与父类保持一致</font></li>\n<li>只有添加到虚方法表的方法才能被重写。</li>\n</ol>\n<p><strong>方法重写的本质：</strong></p>\n<p>覆盖虚方法表中的方法</p>\n<h2 id=\"继承中构造方法的特点\"><a href=\"#继承中构造方法的特点\" class=\"headerlink\" title=\"继承中构造方法的特点\"></a>继承中构造方法的特点</h2><ul>\n<li>父类中的构造方法不会被子类继承</li>\n<li>子类当中所有的构造方法都会先默认访问父类中的无参构造，再执行自己。<br>  为什么呢？<br>  - 因为子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据<br>  - <font color=red>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化</font><br>  怎么调用父类构造方法?<br>  - 子类构造方法的第一行语句默认都是：super()，不写它也在，并且必须在第一行。<br>  - <font color=red>如果想调用父类有参构造，必须手动写super进行调用</font></li>\n</ul>\n<h2 id=\"this-super总结\"><a href=\"#this-super总结\" class=\"headerlink\" title=\"this,super总结\"></a>this,super总结</h2><ul>\n<li>this可以理解为一个变量，里面存着当前方法调用者的地址值。</li>\n<li>super表示父类的存储空间</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">关键字</th>\n<th align=\"center\">访问成员变量</th>\n<th align=\"center\">访问成员方法</th>\n<th align=\"center\">访问构造方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">this</td>\n<td align=\"center\">this.成员变量    访问本类成员变量</td>\n<td align=\"center\">this.成员方法(…)   访问本类成员方法</td>\n<td align=\"center\">this(…)    访问本类方法</td>\n</tr>\n<tr>\n<td align=\"center\">super</td>\n<td align=\"center\">super.成员变量    访问父类成员变量</td>\n<td align=\"center\">super.成员方法(…)     访问父类的成员方法</td>\n<td align=\"center\">super(…)     访问父类的构造方法</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>[TOC]</p>\n<p>面向对象三大特征：封装、继承、多态</p>\n<ol>\n<li>封装：对象代表什么，就得封装对应的数据，并且提供数据对应的行为</li>\n</ol>\n<h2 id=\"继承-1\"><a href=\"#继承-1\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在java当中，提供了一个关键字：extends ，使用这个关键字可以让一个类与另一个类建立起继承关系。</p>\n<p>栗子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> extendes Person&#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中：Student称为子类（派生类），Person称为父类（基类或者超类）。</p>\n<p>使用继承的好处：</p>\n<ul>\n<li>可以把多个子类中重复的代码抽取到父类当中，提高了代码的复用性</li>\n<li>子类可以在父类的基础上，增加其他的功能，使得子类更加强大。</li>\n</ul>\n<h2 id=\"自己设计\"><a href=\"#自己设计\" class=\"headerlink\" title=\"自己设计\"></a>自己设计</h2><p><strong>什么时候会用到继承：</strong>当类与类之间，存在相同（共性）的内容，并且满足子类是父类其中的一种是，就可以考虑使用继承。</p>\n<p>比如：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">学生</th>\n<th align=\"center\">老师</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">姓名</td>\n<td align=\"center\">姓名</td>\n</tr>\n<tr>\n<td align=\"center\">年龄</td>\n<td align=\"center\">年龄</td>\n</tr>\n<tr>\n<td align=\"center\">性别</td>\n<td align=\"center\">性别</td>\n</tr>\n<tr>\n<td align=\"center\">学习</td>\n<td align=\"center\">教书</td>\n</tr>\n</tbody></table>\n<p>可以看到学生和老师都有姓名、年龄、性别这几个属性。那么就可以把这几个属性提取出来，放到父类里面。</p>\n<h2 id=\"继承中的特点\"><a href=\"#继承中的特点\" class=\"headerlink\" title=\"继承中的特点\"></a>继承中的特点</h2><p><strong>一句话概括：</strong>java只支持单继承，不支持多继承，但是支持多层继承</p>\n<ul>\n<li>单继承：一个子类只能继承一个父类（一个儿子只能有一个父亲）</li>\n<li>不支持多继承：子类不能同时继承多个父类（一个儿子不同同时有多个父亲）</li>\n<li>多层继承：子类A可以继承父类B，父类B可以继承父类C，父类C是子类A的间接父类</li>\n</ul>\n<p>java中有一个类是所有类的祖宗：Object。java中的每一个类都直接或者间接继承于Object。</p>\n<p><strong>注意：</strong>子类只能访问父类中非私有的成员。</p>\n<h2 id=\"继承可以继承父类中哪些内容\"><a href=\"#继承可以继承父类中哪些内容\" class=\"headerlink\" title=\"继承可以继承父类中哪些内容\"></a>继承可以继承父类中哪些内容</h2><p>父类中会有以下三种东西：</p>\n<ol>\n<li>构造方法</li>\n<li>成员变量</li>\n<li>成员方法</li>\n</ol>\n<p>根据其中是否私有，可以继承的情况分下面几类：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">非私有是否能继承</th>\n<th align=\"center\">私有是否能继承</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">构造方法</td>\n<td align=\"center\">不能</td>\n<td align=\"center\">不能</td>\n</tr>\n<tr>\n<td align=\"center\">成员变量</td>\n<td align=\"center\">能</td>\n<td align=\"center\">能</td>\n</tr>\n<tr>\n<td align=\"center\">成员方法</td>\n<td align=\"center\">&#x2F;&#x2F;</td>\n<td align=\"center\">&#x2F;&#x2F;</td>\n</tr>\n</tbody></table>\n<p>其中成员方法：只有能够添加到虚方法表中的方法才能被继承。也就是说除了private、final、static修饰的方法，都可以被继承。</p>\n<h2 id=\"继承中成员变量访问特点\"><a href=\"#继承中成员变量访问特点\" class=\"headerlink\" title=\"继承中成员变量访问特点\"></a>继承中成员变量访问特点</h2><p><strong>就近原则：谁离我近，我就用谁</strong></p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Fu</span>()&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Fu&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Zi</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Fu</span>()&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Zi&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ziShow</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ziShow&quot;</span>;</span><br><span class=\"line\">\t\tSystem.out.println(name);  <span class=\"comment\">// &quot;ziShow&quot;（从局部位置开始往上找）</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"built_in\">this</span>.name);  <span class=\"comment\">// &quot;Zi&quot;（从本类成员位置开始往上找）</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"built_in\">super</span>.name);  <span class=\"comment\">// &quot;Fu&quot;（从父类成员位置开始往上找）</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先在局部位置找，本类成员位置找，父类成员位置找，逐级往上。</p>\n<h2 id=\"继承中成员方法的访问特点\"><a href=\"#继承中成员方法的访问特点\" class=\"headerlink\" title=\"继承中成员方法的访问特点\"></a>继承中成员方法的访问特点</h2><p><strong>直接调用满足就近原则：</strong>谁离我近，我就用谁</p>\n<h3 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h3><p>用来显示访问父类成员或者构造方法。</p>\n<p>super调用：直接访问父类。</p>\n<p>可以使用<code>supper.父类方法</code>来调用父类的方法；可以使用<code>super.父类属性</code>来调用父类的属性。</p>\n<p>调用父类的构造方法：</p>\n<p>在子类中使用够惨构造方法，在方法里面使用<code>super(父类的参数)</code>。</p>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">Student</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>();</span><br><span class=\"line\">\ts.lunch(); </span><br><span class=\"line\">\t<span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">\t<span class=\"comment\">// 喝水</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;吃饭&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">drink</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;喝水&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Perdson</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lunch</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\teat();</span><br><span class=\"line\">\t\tdrink();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的如果调用方法时，前面加了super，那么就会直接去调用父类的方法。<br>前面加了this，就会调用本类的方法。</p>\n<h3 id=\"方法的重写\"><a href=\"#方法的重写\" class=\"headerlink\" title=\"方法的重写\"></a>方法的重写</h3><p>当父类的方法不能满足子类现在的需求时，就需要进行方法的重写。</p>\n<p><strong>书写格式：</strong></p>\n<p>在继承体系中，子类出现了和父类一模一样的方法声明，我们就称子类的这个方法是重写的方法。</p>\n<ul>\n<li>@Override  重写注解<ol>\n<li>@Override 是放在重写后的方法上，用来校验子类重写是语法是否正确。</li>\n<li>加上注解之后如果有红色的波浪线，表示语法错误。</li>\n<li><font color=red>建议重写方法都加@Override注解，代码安全优雅</font></li>\n</ol>\n</li>\n</ul>\n<p>如果在子类重写了方法，那么这个方法就会覆盖掉父类的方法。</p>\n<p><strong>方法重写注意事项与要求</strong></p>\n<ol>\n<li>重写方法的名称、形参列表必须与父类当中的一致。</li>\n<li>子类重写父类方法时，访问权限子类必须大于等于父类。（空着不写 &lt; protected &lt; public）</li>\n<li>子类重写父类方法时，返回值类型子类必须小于等于父类。（了解）<br> 比如： 父类为animal  子类为cat和dog:那么子类返回的范围就不能不animal还大</li>\n<li><font color=red>重写的方法尽量与父类保持一致</font></li>\n<li>只有添加到虚方法表的方法才能被重写。</li>\n</ol>\n<p><strong>方法重写的本质：</strong></p>\n<p>覆盖虚方法表中的方法</p>\n<h2 id=\"继承中构造方法的特点\"><a href=\"#继承中构造方法的特点\" class=\"headerlink\" title=\"继承中构造方法的特点\"></a>继承中构造方法的特点</h2><ul>\n<li>父类中的构造方法不会被子类继承</li>\n<li>子类当中所有的构造方法都会先默认访问父类中的无参构造，再执行自己。<br>  为什么呢？<br>  - 因为子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据<br>  - <font color=red>子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化</font><br>  怎么调用父类构造方法?<br>  - 子类构造方法的第一行语句默认都是：super()，不写它也在，并且必须在第一行。<br>  - <font color=red>如果想调用父类有参构造，必须手动写super进行调用</font></li>\n</ul>\n<h2 id=\"this-super总结\"><a href=\"#this-super总结\" class=\"headerlink\" title=\"this,super总结\"></a>this,super总结</h2><ul>\n<li>this可以理解为一个变量，里面存着当前方法调用者的地址值。</li>\n<li>super表示父类的存储空间</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">关键字</th>\n<th align=\"center\">访问成员变量</th>\n<th align=\"center\">访问成员方法</th>\n<th align=\"center\">访问构造方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">this</td>\n<td align=\"center\">this.成员变量    访问本类成员变量</td>\n<td align=\"center\">this.成员方法(…)   访问本类成员方法</td>\n<td align=\"center\">this(…)    访问本类方法</td>\n</tr>\n<tr>\n<td align=\"center\">super</td>\n<td align=\"center\">super.成员变量    访问父类成员变量</td>\n<td align=\"center\">super.成员方法(…)     访问父类的成员方法</td>\n<td align=\"center\">super(…)     访问父类的构造方法</td>\n</tr>\n</tbody></table>\n"},{"title":"面向对象编程","date":"2023-03-09T16:00:00.000Z","_content":"\n# 面向对象编程\n\n核心概念：\n\n- 类\n- 对象\n- 方法\n- 消息\n- 封装\n- 继承\n- 多态\n\n","source":"_posts/javaLearn/面向对象编程.md","raw":"---\ntitle: 面向对象编程\ndate: [2023-3-10]\ntags: [后端]\ncategories: [Java]\n---\n\n# 面向对象编程\n\n核心概念：\n\n- 类\n- 对象\n- 方法\n- 消息\n- 封装\n- 继承\n- 多态\n\n","slug":"javaLearn/面向对象编程","published":1,"updated":"2023-03-16T07:15:21.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml400ao9kbm6vj4f1ez","content":"<h1 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h1><p>核心概念：</p>\n<ul>\n<li>类</li>\n<li>对象</li>\n<li>方法</li>\n<li>消息</li>\n<li>封装</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h1><p>核心概念：</p>\n<ul>\n<li>类</li>\n<li>对象</li>\n<li>方法</li>\n<li>消息</li>\n<li>封装</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n"},{"title":"前端与HTML","date":"2023-01-14T16:00:00.000Z","_content":"\n# 笔记1\n[TOC]\n\n本节课主要学习什么是前端，以及一些HTML的基本知识。\n\n## 什么是前端\n\n前端三件套中的`HTML`，`CSS`，`javascript`。这三个部分构成了前端的基础。HTML主要负责网页所呈现的内容还有网页的结构，比如网页的导航栏或者里面的内容是什么。\n\n导航栏：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d3ee3fef764979ad5efdb0c0df3b51~tplv-k3u1fbpfcp-watermark.image?)\n\ncss中负责的就是网页一些元素的样式，比如某个内容在网页的位置，大小，以及颜色等等。通过css使得我们的网页更加美观。\n\nJavaScript中负责的就是网页的一些行为，比如用户点击了网页的某个按钮，网页就会做出相应的行为。（表单提交按钮，网页提交表单）\n\n当然这些技术只是前端的基础（基石）。随着前端的不断发展，前端的生态不断完善，前端的任务也不再是简单呈现页面给用户做一些简单的交互。前端越来越庞大，随之也出现了很多技术，比如js的库：`jQuery`，还有一些前端框架：`Vue`，`react`等等。\n\n## HTML\n\nHTML就是一种超文本链接语言，那什么是超文本链接语言呢？\n\n就是通过一系列的标签，就文本内容呈现在页面上。\n\n比如要呈现一个一级标题：`<h1>我是以及标题</h1>`，在标签里面，又会有一些属性。比如`img`标签：`<img src = \"图片路径\">`，其中这个`src`就是img标签的一个属性，代表这个路片的路径；src等号后面的就是图片的属性值。\n\n一个完整的html结构应该是这样的。\n\n```html\n<!DOCTYPE html>\n\n\n\t<head>\n    \t<meta charset=\"UTF-8\">\n    \t<title>青训营</title>\n\t</head>\n\n\t<body>\n    \n\t</body>\n\n\n</html>\n```\n\n我们可以看到在html中，所有的标签，都被一个html标签所包裹着，我们从上往下看：\n\n首先是`<head>`标签，这个标签里面存放的是一些在网页里面不需要呈现给用户的但是网页又需要的东西。就比如网页的编格式`<meta charset=\"UTF-8\">`，这里我们设置网页的编码格式为UTF-8,还有网页的标题，`<title>青训营</title>`网页的标题就是我们在浏览器顶部状态栏里面看见的标题。\n\n### HTML中的标题标签\n\n在HTML中标签从一级到六级，字体一级最大最粗，然后依次变小。\n\n例子：\n\n```html\n<h1>我是一级标题</h1>\n    <h2>我是二级标题</h2>\n    <h3>我是三级标题</h3>\n    <h4>我是四级标题</h4>\n    <p>我是普通文本</p>\n    <h5>我是五级标题</h5>\n    <h6>我是六级标题</h6>\n```\n\n效果图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f8c2ce1eb34c0e9004bdc573d2c623~tplv-k3u1fbpfcp-watermark.image?)\n\n### HTML中列表标签\n\n在HTML中关于列表的标签有三类：有序列表，无序列表，还有一种列表类似key:value形式。\n\n- 有序列表：父标签为`<ol></ol>`,子标签为：`<li></li>`,一个有序列表只能有一个父标签，可以有多个子标签。最后呈现的效果会在子标签前面根据字标签出现的顺序（从上往下），一次添加上1,2,3,4的序号。\n- 无序列表：父标签为`<ul></ul>`,子标签为：`<li></li>`,一个有序列表只能有一个父标签，可以有多个子标签。最后呈现的效果会在子标签前面加上一个小黑点。\n- 最后一种类似于key:value的标签：我们下面用代码演示。\n\n```html\n<p>有序列表</p>\n    <ol>\n        <li>第一个</li>\n        <li>第二个</li>\n    </ol>\n    <p>无序列表</p>\n    <ul>\n        <li>第一个</li>\n        <li>第二个</li>\n    </ul>\n    <p>第三种列表</p>\n    <dl>\n        <dt>第一个</dt>\n        <dd>qq</dd>\n        <dd>ww</dd>\n        <dt>第二个</dt>\n        <dd>ee</dd>\n        <dd>rr</dd>\n    </dl>\n```\n\n运行结果：\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b8ed83c9594009a47532b08d746078~tplv-k3u1fbpfcp-watermark.image?)\n\n\n我们可以看到第三种标签：`<dl>`是父标签，然后下面有`<dt>`与`<dd>`标签。然后`<dt>`标签又是`<dd>`标签的标题。\n\n### HTML中的链接标签\n\n在HTML中链接我们使用`<a>`标签。\n\n`<a href = \"链接地址\" target = \"打开方式\">`\n\n## 标签语义化\n\n在实际的开发过程中，将标签语义化可以更利于SEO，然后对于阅读这个代码的人也更加容易理解。\n\n在HTML5中常用的语义化标签有这些：\n\n- 页面头部：`<header></header>\n- 导航栏：`<nav></nav>`\n- 主体部分： `<main></main>`\n- 内容部分：`<article></article>`\n- 侧边栏: `<aside></aside>`\n- 页面底部： `<footer></footer>`\n\n这些语义化标签与正常的HTML标签用法是一样的。\n\n## 总结\n\n在HTML中，我们负责的是页面的内容以及结果，而不是页面的样式，我们要把网页的三部分（结构、样式、行为）给分开，这样更加利于后面的维护。","source":"_posts/青训营笔记/前端与HTML.md","raw":"---\ntitle: 前端与HTML\ndate: 2023-01-15\ntags: [前端]\ncategories: [青训营]\n---\n\n# 笔记1\n[TOC]\n\n本节课主要学习什么是前端，以及一些HTML的基本知识。\n\n## 什么是前端\n\n前端三件套中的`HTML`，`CSS`，`javascript`。这三个部分构成了前端的基础。HTML主要负责网页所呈现的内容还有网页的结构，比如网页的导航栏或者里面的内容是什么。\n\n导航栏：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d3ee3fef764979ad5efdb0c0df3b51~tplv-k3u1fbpfcp-watermark.image?)\n\ncss中负责的就是网页一些元素的样式，比如某个内容在网页的位置，大小，以及颜色等等。通过css使得我们的网页更加美观。\n\nJavaScript中负责的就是网页的一些行为，比如用户点击了网页的某个按钮，网页就会做出相应的行为。（表单提交按钮，网页提交表单）\n\n当然这些技术只是前端的基础（基石）。随着前端的不断发展，前端的生态不断完善，前端的任务也不再是简单呈现页面给用户做一些简单的交互。前端越来越庞大，随之也出现了很多技术，比如js的库：`jQuery`，还有一些前端框架：`Vue`，`react`等等。\n\n## HTML\n\nHTML就是一种超文本链接语言，那什么是超文本链接语言呢？\n\n就是通过一系列的标签，就文本内容呈现在页面上。\n\n比如要呈现一个一级标题：`<h1>我是以及标题</h1>`，在标签里面，又会有一些属性。比如`img`标签：`<img src = \"图片路径\">`，其中这个`src`就是img标签的一个属性，代表这个路片的路径；src等号后面的就是图片的属性值。\n\n一个完整的html结构应该是这样的。\n\n```html\n<!DOCTYPE html>\n\n\n\t<head>\n    \t<meta charset=\"UTF-8\">\n    \t<title>青训营</title>\n\t</head>\n\n\t<body>\n    \n\t</body>\n\n\n</html>\n```\n\n我们可以看到在html中，所有的标签，都被一个html标签所包裹着，我们从上往下看：\n\n首先是`<head>`标签，这个标签里面存放的是一些在网页里面不需要呈现给用户的但是网页又需要的东西。就比如网页的编格式`<meta charset=\"UTF-8\">`，这里我们设置网页的编码格式为UTF-8,还有网页的标题，`<title>青训营</title>`网页的标题就是我们在浏览器顶部状态栏里面看见的标题。\n\n### HTML中的标题标签\n\n在HTML中标签从一级到六级，字体一级最大最粗，然后依次变小。\n\n例子：\n\n```html\n<h1>我是一级标题</h1>\n    <h2>我是二级标题</h2>\n    <h3>我是三级标题</h3>\n    <h4>我是四级标题</h4>\n    <p>我是普通文本</p>\n    <h5>我是五级标题</h5>\n    <h6>我是六级标题</h6>\n```\n\n效果图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f8c2ce1eb34c0e9004bdc573d2c623~tplv-k3u1fbpfcp-watermark.image?)\n\n### HTML中列表标签\n\n在HTML中关于列表的标签有三类：有序列表，无序列表，还有一种列表类似key:value形式。\n\n- 有序列表：父标签为`<ol></ol>`,子标签为：`<li></li>`,一个有序列表只能有一个父标签，可以有多个子标签。最后呈现的效果会在子标签前面根据字标签出现的顺序（从上往下），一次添加上1,2,3,4的序号。\n- 无序列表：父标签为`<ul></ul>`,子标签为：`<li></li>`,一个有序列表只能有一个父标签，可以有多个子标签。最后呈现的效果会在子标签前面加上一个小黑点。\n- 最后一种类似于key:value的标签：我们下面用代码演示。\n\n```html\n<p>有序列表</p>\n    <ol>\n        <li>第一个</li>\n        <li>第二个</li>\n    </ol>\n    <p>无序列表</p>\n    <ul>\n        <li>第一个</li>\n        <li>第二个</li>\n    </ul>\n    <p>第三种列表</p>\n    <dl>\n        <dt>第一个</dt>\n        <dd>qq</dd>\n        <dd>ww</dd>\n        <dt>第二个</dt>\n        <dd>ee</dd>\n        <dd>rr</dd>\n    </dl>\n```\n\n运行结果：\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b8ed83c9594009a47532b08d746078~tplv-k3u1fbpfcp-watermark.image?)\n\n\n我们可以看到第三种标签：`<dl>`是父标签，然后下面有`<dt>`与`<dd>`标签。然后`<dt>`标签又是`<dd>`标签的标题。\n\n### HTML中的链接标签\n\n在HTML中链接我们使用`<a>`标签。\n\n`<a href = \"链接地址\" target = \"打开方式\">`\n\n## 标签语义化\n\n在实际的开发过程中，将标签语义化可以更利于SEO，然后对于阅读这个代码的人也更加容易理解。\n\n在HTML5中常用的语义化标签有这些：\n\n- 页面头部：`<header></header>\n- 导航栏：`<nav></nav>`\n- 主体部分： `<main></main>`\n- 内容部分：`<article></article>`\n- 侧边栏: `<aside></aside>`\n- 页面底部： `<footer></footer>`\n\n这些语义化标签与正常的HTML标签用法是一样的。\n\n## 总结\n\n在HTML中，我们负责的是页面的内容以及结果，而不是页面的样式，我们要把网页的三部分（结构、样式、行为）给分开，这样更加利于后面的维护。","slug":"青训营笔记/前端与HTML","published":1,"updated":"2023-01-20T13:37:53.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml500ar9kbmb4gl9xke","content":"<h1 id=\"笔记1\"><a href=\"#笔记1\" class=\"headerlink\" title=\"笔记1\"></a>笔记1</h1><p>[TOC]</p>\n<p>本节课主要学习什么是前端，以及一些HTML的基本知识。</p>\n<h2 id=\"什么是前端\"><a href=\"#什么是前端\" class=\"headerlink\" title=\"什么是前端\"></a>什么是前端</h2><p>前端三件套中的<code>HTML</code>，<code>CSS</code>，<code>javascript</code>。这三个部分构成了前端的基础。HTML主要负责网页所呈现的内容还有网页的结构，比如网页的导航栏或者里面的内容是什么。</p>\n<p>导航栏：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d3ee3fef764979ad5efdb0c0df3b51~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>css中负责的就是网页一些元素的样式，比如某个内容在网页的位置，大小，以及颜色等等。通过css使得我们的网页更加美观。</p>\n<p>JavaScript中负责的就是网页的一些行为，比如用户点击了网页的某个按钮，网页就会做出相应的行为。（表单提交按钮，网页提交表单）</p>\n<p>当然这些技术只是前端的基础（基石）。随着前端的不断发展，前端的生态不断完善，前端的任务也不再是简单呈现页面给用户做一些简单的交互。前端越来越庞大，随之也出现了很多技术，比如js的库：<code>jQuery</code>，还有一些前端框架：<code>Vue</code>，<code>react</code>等等。</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p>HTML就是一种超文本链接语言，那什么是超文本链接语言呢？</p>\n<p>就是通过一系列的标签，就文本内容呈现在页面上。</p>\n<p>比如要呈现一个一级标题：<code>&lt;h1&gt;我是以及标题&lt;/h1&gt;</code>，在标签里面，又会有一些属性。比如<code>img</code>标签：<code>&lt;img src = &quot;图片路径&quot;&gt;</code>，其中这个<code>src</code>就是img标签的一个属性，代表这个路片的路径；src等号后面的就是图片的属性值。</p>\n<p>一个完整的html结构应该是这样的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>青训营<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到在html中，所有的标签，都被一个html标签所包裹着，我们从上往下看：</p>\n<p>首先是<code>&lt;head&gt;</code>标签，这个标签里面存放的是一些在网页里面不需要呈现给用户的但是网页又需要的东西。就比如网页的编格式<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>，这里我们设置网页的编码格式为UTF-8,还有网页的标题，<code>&lt;title&gt;青训营&lt;/title&gt;</code>网页的标题就是我们在浏览器顶部状态栏里面看见的标题。</p>\n<h3 id=\"HTML中的标题标签\"><a href=\"#HTML中的标题标签\" class=\"headerlink\" title=\"HTML中的标题标签\"></a>HTML中的标题标签</h3><p>在HTML中标签从一级到六级，字体一级最大最粗，然后依次变小。</p>\n<p>例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是一级标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是二级标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>我是三级标题<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h4</span>&gt;</span>我是四级标题<span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是普通文本<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>我是五级标题<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>我是六级标题<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>效果图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f8c2ce1eb34c0e9004bdc573d2c623~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"HTML中列表标签\"><a href=\"#HTML中列表标签\" class=\"headerlink\" title=\"HTML中列表标签\"></a>HTML中列表标签</h3><p>在HTML中关于列表的标签有三类：有序列表，无序列表，还有一种列表类似key:value形式。</p>\n<ul>\n<li>有序列表：父标签为<code>&lt;ol&gt;&lt;/ol&gt;</code>,子标签为：<code>&lt;li&gt;&lt;/li&gt;</code>,一个有序列表只能有一个父标签，可以有多个子标签。最后呈现的效果会在子标签前面根据字标签出现的顺序（从上往下），一次添加上1,2,3,4的序号。</li>\n<li>无序列表：父标签为<code>&lt;ul&gt;&lt;/ul&gt;</code>,子标签为：<code>&lt;li&gt;&lt;/li&gt;</code>,一个有序列表只能有一个父标签，可以有多个子标签。最后呈现的效果会在子标签前面加上一个小黑点。</li>\n<li>最后一种类似于key:value的标签：我们下面用代码演示。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>有序列表<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>第一个<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>第二个<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>无序列表<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>第一个<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>第二个<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>第三种列表<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dl</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>第一个<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>qq<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>ww<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>第二个<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>ee<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>rr<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b8ed83c9594009a47532b08d746078~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>我们可以看到第三种标签：<code>&lt;dl&gt;</code>是父标签，然后下面有<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code>标签。然后<code>&lt;dt&gt;</code>标签又是<code>&lt;dd&gt;</code>标签的标题。</p>\n<h3 id=\"HTML中的链接标签\"><a href=\"#HTML中的链接标签\" class=\"headerlink\" title=\"HTML中的链接标签\"></a>HTML中的链接标签</h3><p>在HTML中链接我们使用<code>&lt;a&gt;</code>标签。</p>\n<p><code>&lt;a href = &quot;链接地址&quot; target = &quot;打开方式&quot;&gt;</code></p>\n<h2 id=\"标签语义化\"><a href=\"#标签语义化\" class=\"headerlink\" title=\"标签语义化\"></a>标签语义化</h2><p>在实际的开发过程中，将标签语义化可以更利于SEO，然后对于阅读这个代码的人也更加容易理解。</p>\n<p>在HTML5中常用的语义化标签有这些：</p>\n<ul>\n<li>页面头部：&#96;<header></header></li>\n<li>导航栏：<code>&lt;nav&gt;&lt;/nav&gt;</code></li>\n<li>主体部分： <code>&lt;main&gt;&lt;/main&gt;</code></li>\n<li>内容部分：<code>&lt;article&gt;&lt;/article&gt;</code></li>\n<li>侧边栏: <code>&lt;aside&gt;&lt;/aside&gt;</code></li>\n<li>页面底部： <code>&lt;footer&gt;&lt;/footer&gt;</code></li>\n</ul>\n<p>这些语义化标签与正常的HTML标签用法是一样的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在HTML中，我们负责的是页面的内容以及结果，而不是页面的样式，我们要把网页的三部分（结构、样式、行为）给分开，这样更加利于后面的维护。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"笔记1\"><a href=\"#笔记1\" class=\"headerlink\" title=\"笔记1\"></a>笔记1</h1><p>[TOC]</p>\n<p>本节课主要学习什么是前端，以及一些HTML的基本知识。</p>\n<h2 id=\"什么是前端\"><a href=\"#什么是前端\" class=\"headerlink\" title=\"什么是前端\"></a>什么是前端</h2><p>前端三件套中的<code>HTML</code>，<code>CSS</code>，<code>javascript</code>。这三个部分构成了前端的基础。HTML主要负责网页所呈现的内容还有网页的结构，比如网页的导航栏或者里面的内容是什么。</p>\n<p>导航栏：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d3ee3fef764979ad5efdb0c0df3b51~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>css中负责的就是网页一些元素的样式，比如某个内容在网页的位置，大小，以及颜色等等。通过css使得我们的网页更加美观。</p>\n<p>JavaScript中负责的就是网页的一些行为，比如用户点击了网页的某个按钮，网页就会做出相应的行为。（表单提交按钮，网页提交表单）</p>\n<p>当然这些技术只是前端的基础（基石）。随着前端的不断发展，前端的生态不断完善，前端的任务也不再是简单呈现页面给用户做一些简单的交互。前端越来越庞大，随之也出现了很多技术，比如js的库：<code>jQuery</code>，还有一些前端框架：<code>Vue</code>，<code>react</code>等等。</p>\n<h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><p>HTML就是一种超文本链接语言，那什么是超文本链接语言呢？</p>\n<p>就是通过一系列的标签，就文本内容呈现在页面上。</p>\n<p>比如要呈现一个一级标题：<code>&lt;h1&gt;我是以及标题&lt;/h1&gt;</code>，在标签里面，又会有一些属性。比如<code>img</code>标签：<code>&lt;img src = &quot;图片路径&quot;&gt;</code>，其中这个<code>src</code>就是img标签的一个属性，代表这个路片的路径；src等号后面的就是图片的属性值。</p>\n<p>一个完整的html结构应该是这样的。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>青训营<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到在html中，所有的标签，都被一个html标签所包裹着，我们从上往下看：</p>\n<p>首先是<code>&lt;head&gt;</code>标签，这个标签里面存放的是一些在网页里面不需要呈现给用户的但是网页又需要的东西。就比如网页的编格式<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>，这里我们设置网页的编码格式为UTF-8,还有网页的标题，<code>&lt;title&gt;青训营&lt;/title&gt;</code>网页的标题就是我们在浏览器顶部状态栏里面看见的标题。</p>\n<h3 id=\"HTML中的标题标签\"><a href=\"#HTML中的标题标签\" class=\"headerlink\" title=\"HTML中的标题标签\"></a>HTML中的标题标签</h3><p>在HTML中标签从一级到六级，字体一级最大最粗，然后依次变小。</p>\n<p>例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是一级标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>我是二级标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>我是三级标题<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h4</span>&gt;</span>我是四级标题<span class=\"tag\">&lt;/<span class=\"name\">h4</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>我是普通文本<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span>我是五级标题<span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>我是六级标题<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>效果图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f8c2ce1eb34c0e9004bdc573d2c623~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3 id=\"HTML中列表标签\"><a href=\"#HTML中列表标签\" class=\"headerlink\" title=\"HTML中列表标签\"></a>HTML中列表标签</h3><p>在HTML中关于列表的标签有三类：有序列表，无序列表，还有一种列表类似key:value形式。</p>\n<ul>\n<li>有序列表：父标签为<code>&lt;ol&gt;&lt;/ol&gt;</code>,子标签为：<code>&lt;li&gt;&lt;/li&gt;</code>,一个有序列表只能有一个父标签，可以有多个子标签。最后呈现的效果会在子标签前面根据字标签出现的顺序（从上往下），一次添加上1,2,3,4的序号。</li>\n<li>无序列表：父标签为<code>&lt;ul&gt;&lt;/ul&gt;</code>,子标签为：<code>&lt;li&gt;&lt;/li&gt;</code>,一个有序列表只能有一个父标签，可以有多个子标签。最后呈现的效果会在子标签前面加上一个小黑点。</li>\n<li>最后一种类似于key:value的标签：我们下面用代码演示。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>有序列表<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>第一个<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>第二个<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>无序列表<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>第一个<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>第二个<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>第三种列表<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dl</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>第一个<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>qq<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>ww<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dt</span>&gt;</span>第二个<span class=\"tag\">&lt;/<span class=\"name\">dt</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>ee<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dd</span>&gt;</span>rr<span class=\"tag\">&lt;/<span class=\"name\">dd</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行结果：<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b8ed83c9594009a47532b08d746078~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>我们可以看到第三种标签：<code>&lt;dl&gt;</code>是父标签，然后下面有<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code>标签。然后<code>&lt;dt&gt;</code>标签又是<code>&lt;dd&gt;</code>标签的标题。</p>\n<h3 id=\"HTML中的链接标签\"><a href=\"#HTML中的链接标签\" class=\"headerlink\" title=\"HTML中的链接标签\"></a>HTML中的链接标签</h3><p>在HTML中链接我们使用<code>&lt;a&gt;</code>标签。</p>\n<p><code>&lt;a href = &quot;链接地址&quot; target = &quot;打开方式&quot;&gt;</code></p>\n<h2 id=\"标签语义化\"><a href=\"#标签语义化\" class=\"headerlink\" title=\"标签语义化\"></a>标签语义化</h2><p>在实际的开发过程中，将标签语义化可以更利于SEO，然后对于阅读这个代码的人也更加容易理解。</p>\n<p>在HTML5中常用的语义化标签有这些：</p>\n<ul>\n<li>页面头部：&#96;<header></header></li>\n<li>导航栏：<code>&lt;nav&gt;&lt;/nav&gt;</code></li>\n<li>主体部分： <code>&lt;main&gt;&lt;/main&gt;</code></li>\n<li>内容部分：<code>&lt;article&gt;&lt;/article&gt;</code></li>\n<li>侧边栏: <code>&lt;aside&gt;&lt;/aside&gt;</code></li>\n<li>页面底部： <code>&lt;footer&gt;&lt;/footer&gt;</code></li>\n</ul>\n<p>这些语义化标签与正常的HTML标签用法是一样的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在HTML中，我们负责的是页面的内容以及结果，而不是页面的样式，我们要把网页的三部分（结构、样式、行为）给分开，这样更加利于后面的维护。</p>\n"},{"title":"TS基本语法","date":"2023-01-28T16:00:00.000Z","_content":"\n# TS基本语法\n\n## 基础数据类型\n\n给一个变量定义类型的时候，我们经常在变量名的后面加上一个\":\",再加上类型的一个名称。\n\n例如：\n\n```ts\nlet str:string = 'string';\nlet num:number = 12;\nlet isTrue:boolean = true;\nlet n:null = null;\nlet un:undefined = undefined;\n```\n\n## 对象数据类型\n\n在对象数据类型里面，ts可以定义一个接口，然后定义一个对象来实现这个接口。在接口里面，我们可以定义对象的一些属性，以及属性的类型。并且可以对一些属性进行限制，比如只能读，或者只能写。\n\n```ts\ninterface test{\n    // 只读属性\n    readonly name:string;\n    // 一般属性\n    age:number;\n    sex:'man'|'woman';\n    // 可选属性\n    hobby?:string;\n    // 任意属性\n    [key:string]:any;\n}\n```\n\n在上面的代码中，我们写了一个接口，里面我们设置了一些属性：\n\n- name是一个只读属性，只能在创建的时候赋值，之后不能修改。（readonly修饰）\n- age,sex是一般属性，可以在创建的时候赋值，也可以在之后修改。\n  - 其中sex我们在接口时就规定了它的值只有那几个，如果赋值为其他的，就会报错。\n- hobby:是一个可选属性，可以在创建的时候赋值，也可以在之后修改，但是可以不赋值。（可选属性就是在冒号前面加上一个?）\n- 任意属性：我们可以在接口中定义一个任意属性，这个属性的值可以是任意类型，但是我们必须要定义一个任意属性，这样才能保证我们的接口可以有任意的属性。\n  - 其中key代表对象的属性名，string代表属性名的类型，any代表属性值的类型（这里的any代表任意类型）。\n\n**注意：**\n\n当我们定义了任意属性的时候，那么其余属性的值的类型必须是任意属性类型的子类型。否则就会报错。\n\n```ts\ninterface test{\n    // 一般属性\n    age:number;\n    // 任意属性\n    [key:string]:string;\n}\n\nconst user: test={\n    age:18,\n    address:'重庆',\n}\n// Property 'age' of type 'number' is not assignable to 'string' index type 'string'.\n\n```\n这里因为我们定义了任意属性的值的类型是string，而age的值是number，所以就会报错。\n\n## 函数数据类型\n\n在ts里面我们给函数定义类型的时候，我们可以有两种方式：\n\n1. 在函数定义的时候就定义类型\n2. 在函数的参数里面定义类型\n\n就像这样：\n\n这是一个普通的函数：\n\n```js\nfunction add(x,y){\n    return x+y;\n}\n```\n这是我们js中定一个函数，如果我们想要给函数定义类型，我们可以这样：\n\n- 第一种方法，在函数定义的时候，就定义类型\n\n```ts\ninterface Iadd{\n    (x:number,y:number):number;\n}\nconst add:Iadd = (x,y) => x=y;\n```\n\n- 第二种方法，在函数的参数里面定义类型\n\n```ts\nconst add = (x:number,y:number):number => x=y;\n```","source":"_posts/青训营笔记/TS基本语法.md","raw":"---\ntitle: TS基本语法\ndate: 2023-1-29\ntags: [前端]\ncategories: [青训营]\n---\n\n# TS基本语法\n\n## 基础数据类型\n\n给一个变量定义类型的时候，我们经常在变量名的后面加上一个\":\",再加上类型的一个名称。\n\n例如：\n\n```ts\nlet str:string = 'string';\nlet num:number = 12;\nlet isTrue:boolean = true;\nlet n:null = null;\nlet un:undefined = undefined;\n```\n\n## 对象数据类型\n\n在对象数据类型里面，ts可以定义一个接口，然后定义一个对象来实现这个接口。在接口里面，我们可以定义对象的一些属性，以及属性的类型。并且可以对一些属性进行限制，比如只能读，或者只能写。\n\n```ts\ninterface test{\n    // 只读属性\n    readonly name:string;\n    // 一般属性\n    age:number;\n    sex:'man'|'woman';\n    // 可选属性\n    hobby?:string;\n    // 任意属性\n    [key:string]:any;\n}\n```\n\n在上面的代码中，我们写了一个接口，里面我们设置了一些属性：\n\n- name是一个只读属性，只能在创建的时候赋值，之后不能修改。（readonly修饰）\n- age,sex是一般属性，可以在创建的时候赋值，也可以在之后修改。\n  - 其中sex我们在接口时就规定了它的值只有那几个，如果赋值为其他的，就会报错。\n- hobby:是一个可选属性，可以在创建的时候赋值，也可以在之后修改，但是可以不赋值。（可选属性就是在冒号前面加上一个?）\n- 任意属性：我们可以在接口中定义一个任意属性，这个属性的值可以是任意类型，但是我们必须要定义一个任意属性，这样才能保证我们的接口可以有任意的属性。\n  - 其中key代表对象的属性名，string代表属性名的类型，any代表属性值的类型（这里的any代表任意类型）。\n\n**注意：**\n\n当我们定义了任意属性的时候，那么其余属性的值的类型必须是任意属性类型的子类型。否则就会报错。\n\n```ts\ninterface test{\n    // 一般属性\n    age:number;\n    // 任意属性\n    [key:string]:string;\n}\n\nconst user: test={\n    age:18,\n    address:'重庆',\n}\n// Property 'age' of type 'number' is not assignable to 'string' index type 'string'.\n\n```\n这里因为我们定义了任意属性的值的类型是string，而age的值是number，所以就会报错。\n\n## 函数数据类型\n\n在ts里面我们给函数定义类型的时候，我们可以有两种方式：\n\n1. 在函数定义的时候就定义类型\n2. 在函数的参数里面定义类型\n\n就像这样：\n\n这是一个普通的函数：\n\n```js\nfunction add(x,y){\n    return x+y;\n}\n```\n这是我们js中定一个函数，如果我们想要给函数定义类型，我们可以这样：\n\n- 第一种方法，在函数定义的时候，就定义类型\n\n```ts\ninterface Iadd{\n    (x:number,y:number):number;\n}\nconst add:Iadd = (x,y) => x=y;\n```\n\n- 第二种方法，在函数的参数里面定义类型\n\n```ts\nconst add = (x:number,y:number):number => x=y;\n```","slug":"青训营笔记/TS基本语法","published":1,"updated":"2023-01-29T11:33:30.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml600au9kbm97ru6a3n","content":"<h1 id=\"TS基本语法\"><a href=\"#TS基本语法\" class=\"headerlink\" title=\"TS基本语法\"></a>TS基本语法</h1><h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><p>给一个变量定义类型的时候，我们经常在变量名的后面加上一个”:”,再加上类型的一个名称。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str</span>:<span class=\"built_in\">string</span> = <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">num</span>:<span class=\"built_in\">number</span> = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">isTrue</span>:<span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">n</span>:<span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">un</span>:<span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象数据类型\"><a href=\"#对象数据类型\" class=\"headerlink\" title=\"对象数据类型\"></a>对象数据类型</h2><p>在对象数据类型里面，ts可以定义一个接口，然后定义一个对象来实现这个接口。在接口里面，我们可以定义对象的一些属性，以及属性的类型。并且可以对一些属性进行限制，比如只能读，或者只能写。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> test&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只读属性</span></span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 一般属性</span></span><br><span class=\"line\">    <span class=\"attr\">age</span>:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">sex</span>:<span class=\"string\">&#x27;man&#x27;</span>|<span class=\"string\">&#x27;woman&#x27;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 可选属性</span></span><br><span class=\"line\">    hobby?:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 任意属性</span></span><br><span class=\"line\">    [<span class=\"attr\">key</span>:<span class=\"built_in\">string</span>]:<span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们写了一个接口，里面我们设置了一些属性：</p>\n<ul>\n<li>name是一个只读属性，只能在创建的时候赋值，之后不能修改。（readonly修饰）</li>\n<li>age,sex是一般属性，可以在创建的时候赋值，也可以在之后修改。<ul>\n<li>其中sex我们在接口时就规定了它的值只有那几个，如果赋值为其他的，就会报错。</li>\n</ul>\n</li>\n<li>hobby:是一个可选属性，可以在创建的时候赋值，也可以在之后修改，但是可以不赋值。（可选属性就是在冒号前面加上一个?）</li>\n<li>任意属性：我们可以在接口中定义一个任意属性，这个属性的值可以是任意类型，但是我们必须要定义一个任意属性，这样才能保证我们的接口可以有任意的属性。<ul>\n<li>其中key代表对象的属性名，string代表属性名的类型，any代表属性值的类型（这里的any代表任意类型）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>当我们定义了任意属性的时候，那么其余属性的值的类型必须是任意属性类型的子类型。否则就会报错。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> test&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一般属性</span></span><br><span class=\"line\">    <span class=\"attr\">age</span>:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 任意属性</span></span><br><span class=\"line\">    [<span class=\"attr\">key</span>:<span class=\"built_in\">string</span>]:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">user</span>: test=&#123;</span><br><span class=\"line\">    <span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">    <span class=\"attr\">address</span>:<span class=\"string\">&#x27;重庆&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string&#x27;.</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里因为我们定义了任意属性的值的类型是string，而age的值是number，所以就会报错。</p>\n<h2 id=\"函数数据类型\"><a href=\"#函数数据类型\" class=\"headerlink\" title=\"函数数据类型\"></a>函数数据类型</h2><p>在ts里面我们给函数定义类型的时候，我们可以有两种方式：</p>\n<ol>\n<li>在函数定义的时候就定义类型</li>\n<li>在函数的参数里面定义类型</li>\n</ol>\n<p>就像这样：</p>\n<p>这是一个普通的函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">x,y</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是我们js中定一个函数，如果我们想要给函数定义类型，我们可以这样：</p>\n<ul>\n<li>第一种方法，在函数定义的时候，就定义类型</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iadd</span>&#123;</span><br><span class=\"line\">    (<span class=\"attr\">x</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">y</span>:<span class=\"built_in\">number</span>):<span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">add</span>:<span class=\"title class_\">Iadd</span> = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> x=y;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种方法，在函数的参数里面定义类型</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = (<span class=\"attr\">x</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">y</span>:<span class=\"built_in\">number</span>):<span class=\"function\"><span class=\"params\">number</span> =&gt;</span> x=y;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TS基本语法\"><a href=\"#TS基本语法\" class=\"headerlink\" title=\"TS基本语法\"></a>TS基本语法</h1><h2 id=\"基础数据类型\"><a href=\"#基础数据类型\" class=\"headerlink\" title=\"基础数据类型\"></a>基础数据类型</h2><p>给一个变量定义类型的时候，我们经常在变量名的后面加上一个”:”,再加上类型的一个名称。</p>\n<p>例如：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">str</span>:<span class=\"built_in\">string</span> = <span class=\"string\">&#x27;string&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">num</span>:<span class=\"built_in\">number</span> = <span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">isTrue</span>:<span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">n</span>:<span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">un</span>:<span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象数据类型\"><a href=\"#对象数据类型\" class=\"headerlink\" title=\"对象数据类型\"></a>对象数据类型</h2><p>在对象数据类型里面，ts可以定义一个接口，然后定义一个对象来实现这个接口。在接口里面，我们可以定义对象的一些属性，以及属性的类型。并且可以对一些属性进行限制，比如只能读，或者只能写。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> test&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只读属性</span></span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 一般属性</span></span><br><span class=\"line\">    <span class=\"attr\">age</span>:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"attr\">sex</span>:<span class=\"string\">&#x27;man&#x27;</span>|<span class=\"string\">&#x27;woman&#x27;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 可选属性</span></span><br><span class=\"line\">    hobby?:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 任意属性</span></span><br><span class=\"line\">    [<span class=\"attr\">key</span>:<span class=\"built_in\">string</span>]:<span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们写了一个接口，里面我们设置了一些属性：</p>\n<ul>\n<li>name是一个只读属性，只能在创建的时候赋值，之后不能修改。（readonly修饰）</li>\n<li>age,sex是一般属性，可以在创建的时候赋值，也可以在之后修改。<ul>\n<li>其中sex我们在接口时就规定了它的值只有那几个，如果赋值为其他的，就会报错。</li>\n</ul>\n</li>\n<li>hobby:是一个可选属性，可以在创建的时候赋值，也可以在之后修改，但是可以不赋值。（可选属性就是在冒号前面加上一个?）</li>\n<li>任意属性：我们可以在接口中定义一个任意属性，这个属性的值可以是任意类型，但是我们必须要定义一个任意属性，这样才能保证我们的接口可以有任意的属性。<ul>\n<li>其中key代表对象的属性名，string代表属性名的类型，any代表属性值的类型（这里的any代表任意类型）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>当我们定义了任意属性的时候，那么其余属性的值的类型必须是任意属性类型的子类型。否则就会报错。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> test&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一般属性</span></span><br><span class=\"line\">    <span class=\"attr\">age</span>:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 任意属性</span></span><br><span class=\"line\">    [<span class=\"attr\">key</span>:<span class=\"built_in\">string</span>]:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">user</span>: test=&#123;</span><br><span class=\"line\">    <span class=\"attr\">age</span>:<span class=\"number\">18</span>,</span><br><span class=\"line\">    <span class=\"attr\">address</span>:<span class=\"string\">&#x27;重庆&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string&#x27;.</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里因为我们定义了任意属性的值的类型是string，而age的值是number，所以就会报错。</p>\n<h2 id=\"函数数据类型\"><a href=\"#函数数据类型\" class=\"headerlink\" title=\"函数数据类型\"></a>函数数据类型</h2><p>在ts里面我们给函数定义类型的时候，我们可以有两种方式：</p>\n<ol>\n<li>在函数定义的时候就定义类型</li>\n<li>在函数的参数里面定义类型</li>\n</ol>\n<p>就像这样：</p>\n<p>这是一个普通的函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">x,y</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是我们js中定一个函数，如果我们想要给函数定义类型，我们可以这样：</p>\n<ul>\n<li>第一种方法，在函数定义的时候，就定义类型</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Iadd</span>&#123;</span><br><span class=\"line\">    (<span class=\"attr\">x</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">y</span>:<span class=\"built_in\">number</span>):<span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"attr\">add</span>:<span class=\"title class_\">Iadd</span> = <span class=\"function\">(<span class=\"params\">x,y</span>) =&gt;</span> x=y;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种方法，在函数的参数里面定义类型</li>\n</ul>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = (<span class=\"attr\">x</span>:<span class=\"built_in\">number</span>,<span class=\"attr\">y</span>:<span class=\"built_in\">number</span>):<span class=\"function\"><span class=\"params\">number</span> =&gt;</span> x=y;</span><br></pre></td></tr></table></figure>"},{"title":"青训营-我的名片|[青训营-码上掘金]","data":"2023-2-12","_content":"# 青训营-我的名片|[青训营-码上掘金]\n\n**当青训营遇上码上掘金**\n\n先上一个效果预览图：\n\n![我的名片.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ec82a65c7b8426dbeb41279ec4e3412~tplv-k3u1fbpfcp-watermark.image?)\n\n可以看到主题部分是一个方框，然后我们做了圆角处理，并且在边框上面有一个流水灯的效果，然后在方框正中间，我们写上自己的一些信息。\n\n## 1. 代码实现\n\n首先我们来实现一个方框，这里我们设置方框的宽高的方式是利用padding来实现的，我们先给整个body设置宽高为100vh,和100vw,然后我们给这个盒子设置一个padding，这样我们就可以的到一个盒子。\n\n```css\nbody{\n    /* 居中 */\n    display:flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    /* min-height: 100vh; */\n    width: 100vw;\n    height: 100vh;\n    background-color: #000;\n\n    \n}\n.main{\n    overflow: hidden;\n    padding: 30vmin 20vmin;\n    background-color: rgb(10, 3, 16);\n    /* 文字居中 */\n    text-align: center;\n    /* 文字字体 */\n    font-size: 2vmin;\n    color:#0FF;\n    /* 圆角边框 */\n    border-radius:5vmin;\n    z-index: 0;\n    position: relative;\n}\n```\n\n在上面的代码中，我们通过flex布局，将盒子垂直居中，并且在背景设置了一个颜色，我们顺便设置了一下文字的位置，大小等等。并且通过border-radius设置了圆角，这样使得方框看起来更加圆润。\n\n## 边框厚度的实现\n\n这个时候我们并不能看到边框，这是为什么呢，因为我们没有设置边框的宽度，通常我们通过border来设置边框的一些参数，但是我们这里不使用这个方法，因为我们需要的是一个流水灯的效果，所以我们需要一个动态的边框，这个时候我们就需要用到伪元素了。\n\n首先就是before伪元素，我们通过这个一个伪元素，制造出一个很大的盒子，然后将这个盒子的颜色改为一种射灯状的状态，我们可以通过`background-image: conic-gradient(transparent,#0FF,transparent 40%);`来实现这个射灯状的效果，然后我们再设置一个动画，让这个盒子在中心旋转起来，这样就可以实现一个流水灯的效果了。\n\n```css\n.main::before{\n    content: \"\";\n    width: 200%;\n    height: 200%;\n    background-color: rgb(48, 48, 48);\n    z-index: -2;\n    position: absolute;\n    left: -50%;\n    top: -50%;\n    background-image: conic-gradient(transparent,#0FF,transparent 40%);\n    animation: rotate 5s linear infinite;\n}\n@keyframes rotate {\n    100%{transform:rotate(360deg);}\n}\n```\n\n## 遮住大盒子多与的部分\n\n在现在我们的效果中，前面伪元素的盒子太大了，此时我们需要将多余的部分遮住，这个时候我们就需要用到after伪元素了，我们通过这个伪元素，将多余的部分遮住。\n\n```css\n.main::after{\n    content: \"\";\n    /* width: 18vmin;\n    height: 28vmin; */\n    inset: 1vmin;\n    background-color: #000;\n    border-radius: 4vmin;\n    position: absolute;\n    z-index:-1;\n}\n```\n\n可以看到我们在我们给这两个伪元素设置了一个z-index,这是为了防止层级错误，导致效果不能实现。\n\n## 2.总结\n\n通过这个小案例，我们可以学习到一些css的新知识，比如伪元素，伪类，以及一些新的css属性，比如conic-gradient，以及一些新的css单位，比如vmin，vmax等等。","source":"_posts/青训营笔记/青训营码上掘金.md","raw":"---\ntitle: 青训营-我的名片|[青训营-码上掘金]\ndata: 2023-2-12\ntags: [前端]\ncategories: [青训营]\n---\n# 青训营-我的名片|[青训营-码上掘金]\n\n**当青训营遇上码上掘金**\n\n先上一个效果预览图：\n\n![我的名片.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ec82a65c7b8426dbeb41279ec4e3412~tplv-k3u1fbpfcp-watermark.image?)\n\n可以看到主题部分是一个方框，然后我们做了圆角处理，并且在边框上面有一个流水灯的效果，然后在方框正中间，我们写上自己的一些信息。\n\n## 1. 代码实现\n\n首先我们来实现一个方框，这里我们设置方框的宽高的方式是利用padding来实现的，我们先给整个body设置宽高为100vh,和100vw,然后我们给这个盒子设置一个padding，这样我们就可以的到一个盒子。\n\n```css\nbody{\n    /* 居中 */\n    display:flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    /* min-height: 100vh; */\n    width: 100vw;\n    height: 100vh;\n    background-color: #000;\n\n    \n}\n.main{\n    overflow: hidden;\n    padding: 30vmin 20vmin;\n    background-color: rgb(10, 3, 16);\n    /* 文字居中 */\n    text-align: center;\n    /* 文字字体 */\n    font-size: 2vmin;\n    color:#0FF;\n    /* 圆角边框 */\n    border-radius:5vmin;\n    z-index: 0;\n    position: relative;\n}\n```\n\n在上面的代码中，我们通过flex布局，将盒子垂直居中，并且在背景设置了一个颜色，我们顺便设置了一下文字的位置，大小等等。并且通过border-radius设置了圆角，这样使得方框看起来更加圆润。\n\n## 边框厚度的实现\n\n这个时候我们并不能看到边框，这是为什么呢，因为我们没有设置边框的宽度，通常我们通过border来设置边框的一些参数，但是我们这里不使用这个方法，因为我们需要的是一个流水灯的效果，所以我们需要一个动态的边框，这个时候我们就需要用到伪元素了。\n\n首先就是before伪元素，我们通过这个一个伪元素，制造出一个很大的盒子，然后将这个盒子的颜色改为一种射灯状的状态，我们可以通过`background-image: conic-gradient(transparent,#0FF,transparent 40%);`来实现这个射灯状的效果，然后我们再设置一个动画，让这个盒子在中心旋转起来，这样就可以实现一个流水灯的效果了。\n\n```css\n.main::before{\n    content: \"\";\n    width: 200%;\n    height: 200%;\n    background-color: rgb(48, 48, 48);\n    z-index: -2;\n    position: absolute;\n    left: -50%;\n    top: -50%;\n    background-image: conic-gradient(transparent,#0FF,transparent 40%);\n    animation: rotate 5s linear infinite;\n}\n@keyframes rotate {\n    100%{transform:rotate(360deg);}\n}\n```\n\n## 遮住大盒子多与的部分\n\n在现在我们的效果中，前面伪元素的盒子太大了，此时我们需要将多余的部分遮住，这个时候我们就需要用到after伪元素了，我们通过这个伪元素，将多余的部分遮住。\n\n```css\n.main::after{\n    content: \"\";\n    /* width: 18vmin;\n    height: 28vmin; */\n    inset: 1vmin;\n    background-color: #000;\n    border-radius: 4vmin;\n    position: absolute;\n    z-index:-1;\n}\n```\n\n可以看到我们在我们给这两个伪元素设置了一个z-index,这是为了防止层级错误，导致效果不能实现。\n\n## 2.总结\n\n通过这个小案例，我们可以学习到一些css的新知识，比如伪元素，伪类，以及一些新的css属性，比如conic-gradient，以及一些新的css单位，比如vmin，vmax等等。","slug":"青训营笔记/青训营码上掘金","published":1,"date":"2023-02-12T12:51:11.536Z","updated":"2023-02-12T13:48:25.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml600ax9kbmfy2n7u7i","content":"<h1 id=\"青训营-我的名片-青训营-码上掘金\"><a href=\"#青训营-我的名片-青训营-码上掘金\" class=\"headerlink\" title=\"青训营-我的名片|[青训营-码上掘金]\"></a>青训营-我的名片|[青训营-码上掘金]</h1><p><strong>当青训营遇上码上掘金</strong></p>\n<p>先上一个效果预览图：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ec82a65c7b8426dbeb41279ec4e3412~tplv-k3u1fbpfcp-watermark.image\" alt=\"我的名片.gif\"></p>\n<p>可以看到主题部分是一个方框，然后我们做了圆角处理，并且在边框上面有一个流水灯的效果，然后在方框正中间，我们写上自己的一些信息。</p>\n<h2 id=\"1-代码实现\"><a href=\"#1-代码实现\" class=\"headerlink\" title=\"1. 代码实现\"></a>1. 代码实现</h2><p>首先我们来实现一个方框，这里我们设置方框的宽高的方式是利用padding来实现的，我们先给整个body设置宽高为100vh,和100vw,然后我们给这个盒子设置一个padding，这样我们就可以的到一个盒子。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">display</span>:flex;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">    <span class=\"comment\">/* min-height: 100vh; */</span></span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">30vmin</span> <span class=\"number\">20vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">10</span>, <span class=\"number\">3</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 文字居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"comment\">/* 文字字体 */</span></span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">2vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#0FF</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 圆角边框 */</span></span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">5vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们通过flex布局，将盒子垂直居中，并且在背景设置了一个颜色，我们顺便设置了一下文字的位置，大小等等。并且通过border-radius设置了圆角，这样使得方框看起来更加圆润。</p>\n<h2 id=\"边框厚度的实现\"><a href=\"#边框厚度的实现\" class=\"headerlink\" title=\"边框厚度的实现\"></a>边框厚度的实现</h2><p>这个时候我们并不能看到边框，这是为什么呢，因为我们没有设置边框的宽度，通常我们通过border来设置边框的一些参数，但是我们这里不使用这个方法，因为我们需要的是一个流水灯的效果，所以我们需要一个动态的边框，这个时候我们就需要用到伪元素了。</p>\n<p>首先就是before伪元素，我们通过这个一个伪元素，制造出一个很大的盒子，然后将这个盒子的颜色改为一种射灯状的状态，我们可以通过<code>background-image: conic-gradient(transparent,#0FF,transparent 40%);</code>来实现这个射灯状的效果，然后我们再设置一个动画，让这个盒子在中心旋转起来，这样就可以实现一个流水灯的效果了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span><span class=\"selector-pseudo\">::before</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">48</span>, <span class=\"number\">48</span>, <span class=\"number\">48</span>);</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: -<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: -<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: -<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">conic-gradient</span>(transparent,<span class=\"number\">#0FF</span>,transparent <span class=\"number\">40%</span>);</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: rotate <span class=\"number\">5s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> rotate &#123;</span><br><span class=\"line\">    <span class=\"number\">100%</span>&#123;<span class=\"attribute\">transform</span>:<span class=\"built_in\">rotate</span>(<span class=\"number\">360deg</span>);&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"遮住大盒子多与的部分\"><a href=\"#遮住大盒子多与的部分\" class=\"headerlink\" title=\"遮住大盒子多与的部分\"></a>遮住大盒子多与的部分</h2><p>在现在我们的效果中，前面伪元素的盒子太大了，此时我们需要将多余的部分遮住，这个时候我们就需要用到after伪元素了，我们通过这个伪元素，将多余的部分遮住。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span><span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* width: 18vmin;</span></span><br><span class=\"line\"><span class=\"comment\">    height: 28vmin; */</span></span><br><span class=\"line\">    inset: <span class=\"number\">1vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">4vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>:-<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们在我们给这两个伪元素设置了一个z-index,这是为了防止层级错误，导致效果不能实现。</p>\n<h2 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2.总结\"></a>2.总结</h2><p>通过这个小案例，我们可以学习到一些css的新知识，比如伪元素，伪类，以及一些新的css属性，比如conic-gradient，以及一些新的css单位，比如vmin，vmax等等。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"青训营-我的名片-青训营-码上掘金\"><a href=\"#青训营-我的名片-青训营-码上掘金\" class=\"headerlink\" title=\"青训营-我的名片|[青训营-码上掘金]\"></a>青训营-我的名片|[青训营-码上掘金]</h1><p><strong>当青训营遇上码上掘金</strong></p>\n<p>先上一个效果预览图：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ec82a65c7b8426dbeb41279ec4e3412~tplv-k3u1fbpfcp-watermark.image\" alt=\"我的名片.gif\"></p>\n<p>可以看到主题部分是一个方框，然后我们做了圆角处理，并且在边框上面有一个流水灯的效果，然后在方框正中间，我们写上自己的一些信息。</p>\n<h2 id=\"1-代码实现\"><a href=\"#1-代码实现\" class=\"headerlink\" title=\"1. 代码实现\"></a>1. 代码实现</h2><p>首先我们来实现一个方框，这里我们设置方框的宽高的方式是利用padding来实现的，我们先给整个body设置宽高为100vh,和100vw,然后我们给这个盒子设置一个padding，这样我们就可以的到一个盒子。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">display</span>:flex;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">    <span class=\"comment\">/* min-height: 100vh; */</span></span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.main</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">30vmin</span> <span class=\"number\">20vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">10</span>, <span class=\"number\">3</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 文字居中 */</span></span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;</span><br><span class=\"line\">    <span class=\"comment\">/* 文字字体 */</span></span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">2vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#0FF</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 圆角边框 */</span></span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">5vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，我们通过flex布局，将盒子垂直居中，并且在背景设置了一个颜色，我们顺便设置了一下文字的位置，大小等等。并且通过border-radius设置了圆角，这样使得方框看起来更加圆润。</p>\n<h2 id=\"边框厚度的实现\"><a href=\"#边框厚度的实现\" class=\"headerlink\" title=\"边框厚度的实现\"></a>边框厚度的实现</h2><p>这个时候我们并不能看到边框，这是为什么呢，因为我们没有设置边框的宽度，通常我们通过border来设置边框的一些参数，但是我们这里不使用这个方法，因为我们需要的是一个流水灯的效果，所以我们需要一个动态的边框，这个时候我们就需要用到伪元素了。</p>\n<p>首先就是before伪元素，我们通过这个一个伪元素，制造出一个很大的盒子，然后将这个盒子的颜色改为一种射灯状的状态，我们可以通过<code>background-image: conic-gradient(transparent,#0FF,transparent 40%);</code>来实现这个射灯状的效果，然后我们再设置一个动画，让这个盒子在中心旋转起来，这样就可以实现一个流水灯的效果了。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span><span class=\"selector-pseudo\">::before</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">48</span>, <span class=\"number\">48</span>, <span class=\"number\">48</span>);</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: -<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: -<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: -<span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">conic-gradient</span>(transparent,<span class=\"number\">#0FF</span>,transparent <span class=\"number\">40%</span>);</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: rotate <span class=\"number\">5s</span> linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> rotate &#123;</span><br><span class=\"line\">    <span class=\"number\">100%</span>&#123;<span class=\"attribute\">transform</span>:<span class=\"built_in\">rotate</span>(<span class=\"number\">360deg</span>);&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"遮住大盒子多与的部分\"><a href=\"#遮住大盒子多与的部分\" class=\"headerlink\" title=\"遮住大盒子多与的部分\"></a>遮住大盒子多与的部分</h2><p>在现在我们的效果中，前面伪元素的盒子太大了，此时我们需要将多余的部分遮住，这个时候我们就需要用到after伪元素了，我们通过这个伪元素，将多余的部分遮住。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.main</span><span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* width: 18vmin;</span></span><br><span class=\"line\"><span class=\"comment\">    height: 28vmin; */</span></span><br><span class=\"line\">    inset: <span class=\"number\">1vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">4vmin</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>:-<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们在我们给这两个伪元素设置了一个z-index,这是为了防止层级错误，导致效果不能实现。</p>\n<h2 id=\"2-总结\"><a href=\"#2-总结\" class=\"headerlink\" title=\"2.总结\"></a>2.总结</h2><p>通过这个小案例，我们可以学习到一些css的新知识，比如伪元素，伪类，以及一些新的css属性，比如conic-gradient，以及一些新的css单位，比如vmin，vmax等等。</p>\n"},{"title":"E-R图","date":"2023-03-20T16:00:00.000Z","categroies":["数据库"],"_content":"\n# E-R图\n\n## 关系表\n\n联系的属性以及两个实体的主标识形成关系表\n\n关系表的主键为两个实体主标识的组合。\n\n### 一对多的关系时可以不引入关系表。\n\n将多方的实体转换为关系表，然后将少的那一方的主标识放进来。\n\n多方表的外键是非多方实体的主标识。\n\n### 一对一的关系不必引入关系表\n\n## 范式\n\n设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\n\n### 范式出现的目的\n\n为了消除数据的冗余。\n\n### 1NF第一范式\n\n表中没有多值字段以及组合字段。\n\n### 2NF第二范式\n\n不存在非关键字段（不是主标识的都是非关键字段）对任一候选关键字段（约等于主标识）的部分的函数依赖。\n\n### 3NF第三范式\n\n- 没有关键字段传递依赖主键。\n- 非关键字段只依赖主键。","source":"_posts/javaLearn/数据库/E-R图.md","raw":"---\ntitle: E-R图\ndate: [2023-3-21]\ntags: [后端]\ncategroies: [数据库]\n---\n\n# E-R图\n\n## 关系表\n\n联系的属性以及两个实体的主标识形成关系表\n\n关系表的主键为两个实体主标识的组合。\n\n### 一对多的关系时可以不引入关系表。\n\n将多方的实体转换为关系表，然后将少的那一方的主标识放进来。\n\n多方表的外键是非多方实体的主标识。\n\n### 一对一的关系不必引入关系表\n\n## 范式\n\n设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\n\n### 范式出现的目的\n\n为了消除数据的冗余。\n\n### 1NF第一范式\n\n表中没有多值字段以及组合字段。\n\n### 2NF第二范式\n\n不存在非关键字段（不是主标识的都是非关键字段）对任一候选关键字段（约等于主标识）的部分的函数依赖。\n\n### 3NF第三范式\n\n- 没有关键字段传递依赖主键。\n- 非关键字段只依赖主键。","slug":"javaLearn/数据库/E-R图","published":1,"updated":"2023-03-27T09:06:04.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml700b09kbmdnutelu7","content":"<h1 id=\"E-R图\"><a href=\"#E-R图\" class=\"headerlink\" title=\"E-R图\"></a>E-R图</h1><h2 id=\"关系表\"><a href=\"#关系表\" class=\"headerlink\" title=\"关系表\"></a>关系表</h2><p>联系的属性以及两个实体的主标识形成关系表</p>\n<p>关系表的主键为两个实体主标识的组合。</p>\n<h3 id=\"一对多的关系时可以不引入关系表。\"><a href=\"#一对多的关系时可以不引入关系表。\" class=\"headerlink\" title=\"一对多的关系时可以不引入关系表。\"></a>一对多的关系时可以不引入关系表。</h3><p>将多方的实体转换为关系表，然后将少的那一方的主标识放进来。</p>\n<p>多方表的外键是非多方实体的主标识。</p>\n<h3 id=\"一对一的关系不必引入关系表\"><a href=\"#一对一的关系不必引入关系表\" class=\"headerlink\" title=\"一对一的关系不必引入关系表\"></a>一对一的关系不必引入关系表</h3><h2 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h2><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>\n<h3 id=\"范式出现的目的\"><a href=\"#范式出现的目的\" class=\"headerlink\" title=\"范式出现的目的\"></a>范式出现的目的</h3><p>为了消除数据的冗余。</p>\n<h3 id=\"1NF第一范式\"><a href=\"#1NF第一范式\" class=\"headerlink\" title=\"1NF第一范式\"></a>1NF第一范式</h3><p>表中没有多值字段以及组合字段。</p>\n<h3 id=\"2NF第二范式\"><a href=\"#2NF第二范式\" class=\"headerlink\" title=\"2NF第二范式\"></a>2NF第二范式</h3><p>不存在非关键字段（不是主标识的都是非关键字段）对任一候选关键字段（约等于主标识）的部分的函数依赖。</p>\n<h3 id=\"3NF第三范式\"><a href=\"#3NF第三范式\" class=\"headerlink\" title=\"3NF第三范式\"></a>3NF第三范式</h3><ul>\n<li>没有关键字段传递依赖主键。</li>\n<li>非关键字段只依赖主键。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"E-R图\"><a href=\"#E-R图\" class=\"headerlink\" title=\"E-R图\"></a>E-R图</h1><h2 id=\"关系表\"><a href=\"#关系表\" class=\"headerlink\" title=\"关系表\"></a>关系表</h2><p>联系的属性以及两个实体的主标识形成关系表</p>\n<p>关系表的主键为两个实体主标识的组合。</p>\n<h3 id=\"一对多的关系时可以不引入关系表。\"><a href=\"#一对多的关系时可以不引入关系表。\" class=\"headerlink\" title=\"一对多的关系时可以不引入关系表。\"></a>一对多的关系时可以不引入关系表。</h3><p>将多方的实体转换为关系表，然后将少的那一方的主标识放进来。</p>\n<p>多方表的外键是非多方实体的主标识。</p>\n<h3 id=\"一对一的关系不必引入关系表\"><a href=\"#一对一的关系不必引入关系表\" class=\"headerlink\" title=\"一对一的关系不必引入关系表\"></a>一对一的关系不必引入关系表</h3><h2 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h2><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>\n<h3 id=\"范式出现的目的\"><a href=\"#范式出现的目的\" class=\"headerlink\" title=\"范式出现的目的\"></a>范式出现的目的</h3><p>为了消除数据的冗余。</p>\n<h3 id=\"1NF第一范式\"><a href=\"#1NF第一范式\" class=\"headerlink\" title=\"1NF第一范式\"></a>1NF第一范式</h3><p>表中没有多值字段以及组合字段。</p>\n<h3 id=\"2NF第二范式\"><a href=\"#2NF第二范式\" class=\"headerlink\" title=\"2NF第二范式\"></a>2NF第二范式</h3><p>不存在非关键字段（不是主标识的都是非关键字段）对任一候选关键字段（约等于主标识）的部分的函数依赖。</p>\n<h3 id=\"3NF第三范式\"><a href=\"#3NF第三范式\" class=\"headerlink\" title=\"3NF第三范式\"></a>3NF第三范式</h3><ul>\n<li>没有关键字段传递依赖主键。</li>\n<li>非关键字段只依赖主键。</li>\n</ul>\n"},{"_content":"1. Oracle体系结构\n\n   一个表空间可以建立多个用户、一个用户下可以建立多个表。\n\n   1. 实例：一个数据库可以有n个实例。\n\n   2. 用户：在实例下建立，是管理表的基本单位。\n\n   3. 表空间：对数据文件的逻辑映射。\n\n   4. 数据文件：.dbf、.ora文件。数据文件是数据库的物理存储单位。\n\n   5. 表：\n\n      ![image-20210325095107813](C:\\Users\\59221\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210325095107813.png)\n\n2. Oracle安装\n\n   1. XE版本（11gR2）下载地址：https://www.oracle.com/database/technologies/xe-prior-releases.html\n   2. 命令行登录：在命令行中输入sqlplus回车，按提示输入账号和密码。在使用sys用户登录时，密码格式为：密码 as sysdba。例如密码为root，则输入：root as sysdba\n   3. 查看实例名称：select instance_name from v$instance;\n   4. 查看所有表空间：select tablespace_name from dba_tablespaces; \n   5. 查看当前用户表空间：select default_tablespace from user_users;\n   6. 查看系统用户：select username from all_users;\n   7. 查看当前用户有多少表：select count(1) from user_tables;\n   8. 查看所有表的数量：select count(1) from all_tables;\n\n3. Oracle基本操作\n\n   ~~~sql\n   -- 创建表空间\n   -- 指定表空间名称，表空间是一个逻辑分区\n   -- 数据文件存放路径\n   -- 数据文件初始大小\n   -- 每次自动扩容10m\n   CREATE tablespace stx_24\n   datafile 'D:\\02_workspace\\03_dbData\\oracle\\stx_24.dbf'\n   SIZE 128m  \n   autoextend ON\n   NEXT 16m;  \n   \n   -- 删除表空间\n   DROP tablespace stx;\n   \n   -- 创建用户\n   -- identified by 指定密码\n   -- 指定用户的表空间\n   CREATE USER frank\n   IDENTIFIED BY frank\n   DEFAULT tablespace stx;\n   \n   -- 给用户授权\n   -- oracle 常用角色：\n   -- connect:连接角色，基本角色\n   -- resource:开发者角色\n   -- dba:超级管理员角色\n   GRANT dba TO frank;\n   \n   -- 删除用户\n   drop user frank;\n   \n   -- 创建表\n   CREATE TABLE FRANK.STUDENT (\n   \tID VARCHAR2(16),\n   \tUSERNAME VARCHAR2(16),\n   \tGENDER VARCHAR2(3)\n   )\n   TABLESPACE STX;\n   \n   \n   -- 修改oracle简洁版占用8080端口的问题\n   -- 在命令行中输入sqlplus, 以system账号登录\n   -- 查询当前端口：\n   select dbms_xdb.gethttpport() from dual;\n   -- 设置新端口：\n   exec dbms_xdb.sethttpport(9999); -- 将新端口设为9999\n   -- 设置后重启OracleXETNSListener、OracleServiceXE服务\n   ~~~\n\n4. **oracle 数据类型：**以11g为例\n\n   https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#SQLRF30020","source":"_posts/javaLearn/数据库/SQL语言准备工作.md","raw":"1. Oracle体系结构\n\n   一个表空间可以建立多个用户、一个用户下可以建立多个表。\n\n   1. 实例：一个数据库可以有n个实例。\n\n   2. 用户：在实例下建立，是管理表的基本单位。\n\n   3. 表空间：对数据文件的逻辑映射。\n\n   4. 数据文件：.dbf、.ora文件。数据文件是数据库的物理存储单位。\n\n   5. 表：\n\n      ![image-20210325095107813](C:\\Users\\59221\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210325095107813.png)\n\n2. Oracle安装\n\n   1. XE版本（11gR2）下载地址：https://www.oracle.com/database/technologies/xe-prior-releases.html\n   2. 命令行登录：在命令行中输入sqlplus回车，按提示输入账号和密码。在使用sys用户登录时，密码格式为：密码 as sysdba。例如密码为root，则输入：root as sysdba\n   3. 查看实例名称：select instance_name from v$instance;\n   4. 查看所有表空间：select tablespace_name from dba_tablespaces; \n   5. 查看当前用户表空间：select default_tablespace from user_users;\n   6. 查看系统用户：select username from all_users;\n   7. 查看当前用户有多少表：select count(1) from user_tables;\n   8. 查看所有表的数量：select count(1) from all_tables;\n\n3. Oracle基本操作\n\n   ~~~sql\n   -- 创建表空间\n   -- 指定表空间名称，表空间是一个逻辑分区\n   -- 数据文件存放路径\n   -- 数据文件初始大小\n   -- 每次自动扩容10m\n   CREATE tablespace stx_24\n   datafile 'D:\\02_workspace\\03_dbData\\oracle\\stx_24.dbf'\n   SIZE 128m  \n   autoextend ON\n   NEXT 16m;  \n   \n   -- 删除表空间\n   DROP tablespace stx;\n   \n   -- 创建用户\n   -- identified by 指定密码\n   -- 指定用户的表空间\n   CREATE USER frank\n   IDENTIFIED BY frank\n   DEFAULT tablespace stx;\n   \n   -- 给用户授权\n   -- oracle 常用角色：\n   -- connect:连接角色，基本角色\n   -- resource:开发者角色\n   -- dba:超级管理员角色\n   GRANT dba TO frank;\n   \n   -- 删除用户\n   drop user frank;\n   \n   -- 创建表\n   CREATE TABLE FRANK.STUDENT (\n   \tID VARCHAR2(16),\n   \tUSERNAME VARCHAR2(16),\n   \tGENDER VARCHAR2(3)\n   )\n   TABLESPACE STX;\n   \n   \n   -- 修改oracle简洁版占用8080端口的问题\n   -- 在命令行中输入sqlplus, 以system账号登录\n   -- 查询当前端口：\n   select dbms_xdb.gethttpport() from dual;\n   -- 设置新端口：\n   exec dbms_xdb.sethttpport(9999); -- 将新端口设为9999\n   -- 设置后重启OracleXETNSListener、OracleServiceXE服务\n   ~~~\n\n4. **oracle 数据类型：**以11g为例\n\n   https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#SQLRF30020","slug":"javaLearn/数据库/SQL语言准备工作","published":1,"date":"2023-03-21T05:46:06.342Z","updated":"2023-03-21T05:46:05.542Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml800b39kbm4a28gl9o","content":"<ol>\n<li><p>Oracle体系结构</p>\n<p>一个表空间可以建立多个用户、一个用户下可以建立多个表。</p>\n<ol>\n<li><p>实例：一个数据库可以有n个实例。</p>\n</li>\n<li><p>用户：在实例下建立，是管理表的基本单位。</p>\n</li>\n<li><p>表空间：对数据文件的逻辑映射。</p>\n</li>\n<li><p>数据文件：.dbf、.ora文件。数据文件是数据库的物理存储单位。</p>\n</li>\n<li><p>表：</p>\n<p><img src=\"C:\\Users\\59221\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210325095107813.png\" alt=\"image-20210325095107813\"></p>\n</li>\n</ol>\n</li>\n<li><p>Oracle安装</p>\n<ol>\n<li>XE版本（11gR2）下载地址：<a href=\"https://www.oracle.com/database/technologies/xe-prior-releases.html\">https://www.oracle.com/database/technologies/xe-prior-releases.html</a></li>\n<li>命令行登录：在命令行中输入sqlplus回车，按提示输入账号和密码。在使用sys用户登录时，密码格式为：密码 as sysdba。例如密码为root，则输入：root as sysdba</li>\n<li>查看实例名称：select instance_name from v$instance;</li>\n<li>查看所有表空间：select tablespace_name from dba_tablespaces; </li>\n<li>查看当前用户表空间：select default_tablespace from user_users;</li>\n<li>查看系统用户：select username from all_users;</li>\n<li>查看当前用户有多少表：select count(1) from user_tables;</li>\n<li>查看所有表的数量：select count(1) from all_tables;</li>\n</ol>\n</li>\n<li><p>Oracle基本操作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建表空间</span></span><br><span class=\"line\"><span class=\"comment\">-- 指定表空间名称，表空间是一个逻辑分区</span></span><br><span class=\"line\"><span class=\"comment\">-- 数据文件存放路径</span></span><br><span class=\"line\"><span class=\"comment\">-- 数据文件初始大小</span></span><br><span class=\"line\"><span class=\"comment\">-- 每次自动扩容10m</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">table</span>space stx_24</span><br><span class=\"line\">datafile <span class=\"string\">&#x27;D:\\02_workspace\\03_dbData\\oracle\\stx_24.dbf&#x27;</span></span><br><span class=\"line\">SIZE <span class=\"number\">128</span>m  </span><br><span class=\"line\">autoextend <span class=\"keyword\">ON</span></span><br><span class=\"line\">NEXT <span class=\"number\">16</span>m;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表空间</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> tablespace stx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建用户</span></span><br><span class=\"line\"><span class=\"comment\">-- identified by 指定密码</span></span><br><span class=\"line\"><span class=\"comment\">-- 指定用户的表空间</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> frank</span><br><span class=\"line\">IDENTIFIED <span class=\"keyword\">BY</span> frank</span><br><span class=\"line\"><span class=\"keyword\">DEFAULT</span> tablespace stx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 给用户授权</span></span><br><span class=\"line\"><span class=\"comment\">-- oracle 常用角色：</span></span><br><span class=\"line\"><span class=\"comment\">-- connect:连接角色，基本角色</span></span><br><span class=\"line\"><span class=\"comment\">-- resource:开发者角色</span></span><br><span class=\"line\"><span class=\"comment\">-- dba:超级管理员角色</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> dba <span class=\"keyword\">TO</span> frank;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除用户</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">user</span> frank;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建表</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> FRANK.STUDENT (</span><br><span class=\"line\">\tID VARCHAR2(<span class=\"number\">16</span>),</span><br><span class=\"line\">\tUSERNAME VARCHAR2(<span class=\"number\">16</span>),</span><br><span class=\"line\">\tGENDER VARCHAR2(<span class=\"number\">3</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\">TABLESPACE STX;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改oracle简洁版占用8080端口的问题</span></span><br><span class=\"line\"><span class=\"comment\">-- 在命令行中输入sqlplus, 以system账号登录</span></span><br><span class=\"line\"><span class=\"comment\">-- 查询当前端口：</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> dbms_xdb.gethttpport() <span class=\"keyword\">from</span> dual;</span><br><span class=\"line\"><span class=\"comment\">-- 设置新端口：</span></span><br><span class=\"line\"><span class=\"keyword\">exec</span> dbms_xdb.sethttpport(<span class=\"number\">9999</span>); <span class=\"comment\">-- 将新端口设为9999</span></span><br><span class=\"line\"><span class=\"comment\">-- 设置后重启OracleXETNSListener、OracleServiceXE服务</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>oracle 数据类型：</strong>以11g为例</p>\n<p><a href=\"https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#SQLRF30020\">https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#SQLRF30020</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>Oracle体系结构</p>\n<p>一个表空间可以建立多个用户、一个用户下可以建立多个表。</p>\n<ol>\n<li><p>实例：一个数据库可以有n个实例。</p>\n</li>\n<li><p>用户：在实例下建立，是管理表的基本单位。</p>\n</li>\n<li><p>表空间：对数据文件的逻辑映射。</p>\n</li>\n<li><p>数据文件：.dbf、.ora文件。数据文件是数据库的物理存储单位。</p>\n</li>\n<li><p>表：</p>\n<p><img src=\"C:\\Users\\59221\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210325095107813.png\" alt=\"image-20210325095107813\"></p>\n</li>\n</ol>\n</li>\n<li><p>Oracle安装</p>\n<ol>\n<li>XE版本（11gR2）下载地址：<a href=\"https://www.oracle.com/database/technologies/xe-prior-releases.html\">https://www.oracle.com/database/technologies/xe-prior-releases.html</a></li>\n<li>命令行登录：在命令行中输入sqlplus回车，按提示输入账号和密码。在使用sys用户登录时，密码格式为：密码 as sysdba。例如密码为root，则输入：root as sysdba</li>\n<li>查看实例名称：select instance_name from v$instance;</li>\n<li>查看所有表空间：select tablespace_name from dba_tablespaces; </li>\n<li>查看当前用户表空间：select default_tablespace from user_users;</li>\n<li>查看系统用户：select username from all_users;</li>\n<li>查看当前用户有多少表：select count(1) from user_tables;</li>\n<li>查看所有表的数量：select count(1) from all_tables;</li>\n</ol>\n</li>\n<li><p>Oracle基本操作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建表空间</span></span><br><span class=\"line\"><span class=\"comment\">-- 指定表空间名称，表空间是一个逻辑分区</span></span><br><span class=\"line\"><span class=\"comment\">-- 数据文件存放路径</span></span><br><span class=\"line\"><span class=\"comment\">-- 数据文件初始大小</span></span><br><span class=\"line\"><span class=\"comment\">-- 每次自动扩容10m</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">table</span>space stx_24</span><br><span class=\"line\">datafile <span class=\"string\">&#x27;D:\\02_workspace\\03_dbData\\oracle\\stx_24.dbf&#x27;</span></span><br><span class=\"line\">SIZE <span class=\"number\">128</span>m  </span><br><span class=\"line\">autoextend <span class=\"keyword\">ON</span></span><br><span class=\"line\">NEXT <span class=\"number\">16</span>m;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表空间</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> tablespace stx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建用户</span></span><br><span class=\"line\"><span class=\"comment\">-- identified by 指定密码</span></span><br><span class=\"line\"><span class=\"comment\">-- 指定用户的表空间</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> frank</span><br><span class=\"line\">IDENTIFIED <span class=\"keyword\">BY</span> frank</span><br><span class=\"line\"><span class=\"keyword\">DEFAULT</span> tablespace stx;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 给用户授权</span></span><br><span class=\"line\"><span class=\"comment\">-- oracle 常用角色：</span></span><br><span class=\"line\"><span class=\"comment\">-- connect:连接角色，基本角色</span></span><br><span class=\"line\"><span class=\"comment\">-- resource:开发者角色</span></span><br><span class=\"line\"><span class=\"comment\">-- dba:超级管理员角色</span></span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> dba <span class=\"keyword\">TO</span> frank;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除用户</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">user</span> frank;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建表</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> FRANK.STUDENT (</span><br><span class=\"line\">\tID VARCHAR2(<span class=\"number\">16</span>),</span><br><span class=\"line\">\tUSERNAME VARCHAR2(<span class=\"number\">16</span>),</span><br><span class=\"line\">\tGENDER VARCHAR2(<span class=\"number\">3</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\">TABLESPACE STX;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改oracle简洁版占用8080端口的问题</span></span><br><span class=\"line\"><span class=\"comment\">-- 在命令行中输入sqlplus, 以system账号登录</span></span><br><span class=\"line\"><span class=\"comment\">-- 查询当前端口：</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> dbms_xdb.gethttpport() <span class=\"keyword\">from</span> dual;</span><br><span class=\"line\"><span class=\"comment\">-- 设置新端口：</span></span><br><span class=\"line\"><span class=\"keyword\">exec</span> dbms_xdb.sethttpport(<span class=\"number\">9999</span>); <span class=\"comment\">-- 将新端口设为9999</span></span><br><span class=\"line\"><span class=\"comment\">-- 设置后重启OracleXETNSListener、OracleServiceXE服务</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>oracle 数据类型：</strong>以11g为例</p>\n<p><a href=\"https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#SQLRF30020\">https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements001.htm#SQLRF30020</a></p>\n</li>\n</ol>\n"},{"title":"JDBC","date":"2023-03-26T16:00:00.000Z","categroies":["后端"],"_content":"\n# JDBC基本使用\n\n- DQL　数据的查询语句\n- DML   数据的增删改查语句\n\n## JDBC的基础\n\njava数据库连接：\n\nJDBC是java的一组API。（由java JDK给我们提供的）\n\n步骤有以下几步：\n\n1. 连接数据库\n2. 执行数据库语句\n3. 获取并处理返回的数据\n\nJDBC是一种规范，不同数据库的厂商，根据这个规范制作了不同的驱动（Driver）。\n\nJDBC驱动是连接数据库的具体实现。\n\n**JDBC API包**\n- java.sql\n- javax.sql\n\n## 操作步骤\n\n1. 加载驱动\n\n```java\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");  // 加载驱动\n```\n\n这句代码我们需要异常捕获，因为这个驱动可能找不到，所以我们需要错误捕获。\n\n2. 创建连接\n\n```java\ncon = DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521:xe\", \"frank_24\", \"frank_24\");\n```\n\n使用`DriverManager`中`getConnection()`方法，传入三个参数：\n\n- url（JDBC进程的位置）\n- 用户名\n- 密码\n\n3. 创建数据库语句对象\n\n```java\nStatement st = con.createStatement();\n```\n\n4. 执行语句（DML：不需要处理结果集，DQL：处理结果集）\n\n```java\nString sql = \"delect * from T_STUDENT\";\nResultSet rs = st.executeQuery(sql);\n```\n\n5. 释放资源\n\n","source":"_posts/javaLearn/数据库/JDBC.md","raw":"---\ntitle: JDBC\ndate: [2023-3-27]\ntags: [java]\ncategroies: [后端]\n---\n\n# JDBC基本使用\n\n- DQL　数据的查询语句\n- DML   数据的增删改查语句\n\n## JDBC的基础\n\njava数据库连接：\n\nJDBC是java的一组API。（由java JDK给我们提供的）\n\n步骤有以下几步：\n\n1. 连接数据库\n2. 执行数据库语句\n3. 获取并处理返回的数据\n\nJDBC是一种规范，不同数据库的厂商，根据这个规范制作了不同的驱动（Driver）。\n\nJDBC驱动是连接数据库的具体实现。\n\n**JDBC API包**\n- java.sql\n- javax.sql\n\n## 操作步骤\n\n1. 加载驱动\n\n```java\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");  // 加载驱动\n```\n\n这句代码我们需要异常捕获，因为这个驱动可能找不到，所以我们需要错误捕获。\n\n2. 创建连接\n\n```java\ncon = DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521:xe\", \"frank_24\", \"frank_24\");\n```\n\n使用`DriverManager`中`getConnection()`方法，传入三个参数：\n\n- url（JDBC进程的位置）\n- 用户名\n- 密码\n\n3. 创建数据库语句对象\n\n```java\nStatement st = con.createStatement();\n```\n\n4. 执行语句（DML：不需要处理结果集，DQL：处理结果集）\n\n```java\nString sql = \"delect * from T_STUDENT\";\nResultSet rs = st.executeQuery(sql);\n```\n\n5. 释放资源\n\n","slug":"javaLearn/数据库/JDBC","published":1,"updated":"2023-03-27T12:00:39.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vml900b69kbm4fr1h2xs","content":"<h1 id=\"JDBC基本使用\"><a href=\"#JDBC基本使用\" class=\"headerlink\" title=\"JDBC基本使用\"></a>JDBC基本使用</h1><ul>\n<li>DQL　数据的查询语句</li>\n<li>DML   数据的增删改查语句</li>\n</ul>\n<h2 id=\"JDBC的基础\"><a href=\"#JDBC的基础\" class=\"headerlink\" title=\"JDBC的基础\"></a>JDBC的基础</h2><p>java数据库连接：</p>\n<p>JDBC是java的一组API。（由java JDK给我们提供的）</p>\n<p>步骤有以下几步：</p>\n<ol>\n<li>连接数据库</li>\n<li>执行数据库语句</li>\n<li>获取并处理返回的数据</li>\n</ol>\n<p>JDBC是一种规范，不同数据库的厂商，根据这个规范制作了不同的驱动（Driver）。</p>\n<p>JDBC驱动是连接数据库的具体实现。</p>\n<p><strong>JDBC API包</strong></p>\n<ul>\n<li>java.sql</li>\n<li>javax.sql</li>\n</ul>\n<h2 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h2><ol>\n<li>加载驱动</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);  <span class=\"comment\">// 加载驱动</span></span><br></pre></td></tr></table></figure>\n\n<p>这句代码我们需要异常捕获，因为这个驱动可能找不到，所以我们需要错误捕获。</p>\n<ol start=\"2\">\n<li>创建连接</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">con = DriverManager.getConnection(<span class=\"string\">&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;</span>, <span class=\"string\">&quot;frank_24&quot;</span>, <span class=\"string\">&quot;frank_24&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>DriverManager</code>中<code>getConnection()</code>方法，传入三个参数：</p>\n<ul>\n<li>url（JDBC进程的位置）</li>\n<li>用户名</li>\n<li>密码</li>\n</ul>\n<ol start=\"3\">\n<li>创建数据库语句对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Statement</span> <span class=\"variable\">st</span> <span class=\"operator\">=</span> con.createStatement();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>执行语句（DML：不需要处理结果集，DQL：处理结果集）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;delect * from T_STUDENT&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">ResultSet</span> <span class=\"variable\">rs</span> <span class=\"operator\">=</span> st.executeQuery(sql);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>释放资源</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JDBC基本使用\"><a href=\"#JDBC基本使用\" class=\"headerlink\" title=\"JDBC基本使用\"></a>JDBC基本使用</h1><ul>\n<li>DQL　数据的查询语句</li>\n<li>DML   数据的增删改查语句</li>\n</ul>\n<h2 id=\"JDBC的基础\"><a href=\"#JDBC的基础\" class=\"headerlink\" title=\"JDBC的基础\"></a>JDBC的基础</h2><p>java数据库连接：</p>\n<p>JDBC是java的一组API。（由java JDK给我们提供的）</p>\n<p>步骤有以下几步：</p>\n<ol>\n<li>连接数据库</li>\n<li>执行数据库语句</li>\n<li>获取并处理返回的数据</li>\n</ol>\n<p>JDBC是一种规范，不同数据库的厂商，根据这个规范制作了不同的驱动（Driver）。</p>\n<p>JDBC驱动是连接数据库的具体实现。</p>\n<p><strong>JDBC API包</strong></p>\n<ul>\n<li>java.sql</li>\n<li>javax.sql</li>\n</ul>\n<h2 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h2><ol>\n<li>加载驱动</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);  <span class=\"comment\">// 加载驱动</span></span><br></pre></td></tr></table></figure>\n\n<p>这句代码我们需要异常捕获，因为这个驱动可能找不到，所以我们需要错误捕获。</p>\n<ol start=\"2\">\n<li>创建连接</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">con = DriverManager.getConnection(<span class=\"string\">&quot;jdbc:oracle:thin:@localhost:1521:xe&quot;</span>, <span class=\"string\">&quot;frank_24&quot;</span>, <span class=\"string\">&quot;frank_24&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>DriverManager</code>中<code>getConnection()</code>方法，传入三个参数：</p>\n<ul>\n<li>url（JDBC进程的位置）</li>\n<li>用户名</li>\n<li>密码</li>\n</ul>\n<ol start=\"3\">\n<li>创建数据库语句对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Statement</span> <span class=\"variable\">st</span> <span class=\"operator\">=</span> con.createStatement();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>执行语句（DML：不需要处理结果集，DQL：处理结果集）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">sql</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;delect * from T_STUDENT&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">ResultSet</span> <span class=\"variable\">rs</span> <span class=\"operator\">=</span> st.executeQuery(sql);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>释放资源</li>\n</ol>\n"},{"title":"操作语句","date":"2023-03-20T16:00:00.000Z","categroies":["数据库"],"_content":"\n# SQL语句\n\n## 建表\n\n`CREATE tablespace 表名`\n\n```SQL\nCREATE tablespace stx //创建\ndatafile 'D:\\02_workspace\\03_dbData\\oracle\\stx.dbf'  // 创建地址\nSIZE 128m   // 指定创建大小\nautoextend ON  // \nNEXT 16m;  //\n\n```\n\n## 删除表空间\n\n`delete `\n\n### 创建用户\n\n```SQL\nCREATE USER project\nIDENTIFIED　BY root\nDEFAULT tablespace stx;\n```\n\n### 授权\n\n`GRANT dba TO frank_24`\n\n## 增删改查\n\n### 1.1查询语句\n\n- 第一种查询\n\n```SQL\n-- 查询所有学生信息\n-- 语法： SELECT 列名 from 表名\n```\n\n- 查询一个表中多个列的数据，可以使用`,`隔开。就像这样：\n\n```SQL\nSELECT stu_id,stu_name,collge FROM t_student;\n```\n\n- 查询所有信息\n查询表中的所有信息：使用`*`代替所有的列。\n\n```SQL\n-- 查询所有的数据\nSELECT * FROM T_STUDENT;\n```\n\n- 给数据列取别名\n\n第一种写法：\n\n```SQL\nSELECT 列名1 \"别名1\",列名2 \"别名2\" FROM T_STUDENT;\n```\n\n在列名之后加上一个空格，双引号，写上别名。\n\n第二种写法：\n\n```SQL\nSELECT  列名2 AS \"别名1\" ,列名1 AS \"别名2\" FROM T_STUDENT;\n```\n\n在列名之后加上一个空格，写上`as`关键字，后面跟上`\"别名\"`。\n\n- 查询系统时间\n\n```SQL\n-- dual 这是一张虚表\n\nSELECT SYSDATE FROM dual ;  // 查询系统时间\n```\n\n不知道查哪一张表时，就可以查询`dual`这张表。\n\n- 查询36*36等于多少\n\n```SQL\n-- 查询36*36等于多少\nSELECT 36*36 FROM dual ; // 1296\n```\n\n### 1.2条件查询\n\n```SQL\n-- 条件查询\n--SELECT 列名 from 表名 WHERE  条件\n```\n\n条件是一个是表达式。\n\n表达式可以这样写：`PROVINCE = '四川'`,`SCORE >= 80`。\n\n**查询以什么字段开头的数据：**\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE STU_NAME LIKE '曹%';\n```\n\n使用`like`关键字（模糊匹配），然后`%`表示占位符，不管多少个字符。\n\n例如：\n\n- `str%`:以str开头的数据\n- `%str%`：包含str的数据\n- `%str`：以str结尾的数据\n\n**查询指定长度的数据：**\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE STU_NAME LIKE '__';\n```\n\n(此时为两个下划线，表示查询长度为两个字符的数据)\n\n此时使用`_`来表示占位符，一个`_`表示一个字符长度。\n\n**如果有多个包含条件：**\n\n- 我们使用`AND`关键字连接条件：\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE COLLGE = '大数据与计算机科学学院' AND  MAJOR = '软件工程';\n```\n\n**如果查询多个并列条件：**\n\n- 第一种：我们使用`OR`关键字\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE COLLGE  = '外国语学院' OR COLLGE = '远景学院';\n```\n\n- 第二种：使用`in`关键字\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE COLLGE IN('外国语学院','远景学院');\n```\n\n**查询指定范围内的数据：**\n\n- 使用`AND`\n- 使用`BETWEEN  开始范围  AND  结束范围`:包含开始范围以及结束范围。\n```SQL\nSELECT * FROM T_STUDENT ts WHERE SCORE BETWEEN 80 AND 90;\n```\n\n**同一列表数据去重：**\n\n- 使用关键字`distinct`\n\n```sql\nSELECT DISTINCT  (PROVINCE) from T_STUDENT ts ;\n```\n\ndistinct(要去重的列)。\n\n**对结果进行排序**\n\n- 使用关键字`order by 列名 升序还是降序（默认升序asc,降序desc）`\n\n```sql\nSELECT STU_ID ,STU_NAME ,COLLGE,score  FROM T_STUDENT ts ORDER BY SCORE  asc;\n```\n\n- 对于有两种情况时：\n\n```sql\nSELECT * FROM T_STUDENT ts ORDER BY COLLGE , score DESC;\n```\n\n### 1.3聚合函数\n\n- 统计某列数据个数：`count(列名)`\n\n```sql\nSELECT  count(stu_name) FROM T_STUDENT ts ;\n```\n查询姓名这一列有多少个数据。\n\n- 求平均分avg(列名)\n- 求最大值max(列名)\n- \t求最小值min(列名)\n\n### 查询语句书写顺序\n\nSFWGHO\n\n1. select\n2. from\n3. where\n4. group\n5. having\n6. order\n\n### 1.4分组\n\n- group by 列名\n\n在使用group by时，select子句只能由以下部分组成：\n\n1.汇总函数\n2.GROUPBY中出现的列名\n3.1和2通过函数和表达式的结果\n\n```sql\nSELECT major,count(STU_ID) FROM T_STUDENT ts GROUP BY major ;\n```\n\n### 1.5HAVING\n\n在分组之前进行筛选，我们使用where,在分组之后我们进行筛选我们使用HAVING。\n\n例如：\n\n```SQL\nSELECT collge,count(STU_ID),avg(score) FROM T_STUDENT ts \nGROUP BY COLLGE \nHAVING COUNT(STU_ID) >= 2\nORDER BY avg(score) DESC;\n```\n\n## 连表查询\n\n### 插入语句\n\n语法： `insert into 表名（列名1，列名2，.....） values(值1，值2，值3......) `\n\n一种简介写法：\n\n列名省略，这样的话就需要给每一列添加值，并且添加值的顺序与列名顺序一致。\n\n\n```SQL\nINSERT INTO T_COLLEGE \nVALUES(0004,'外国语学院','曹寒梅');\n```\n\n### 修改语句\n\n语法： update 表名 set 列名1 = 值1,列2 = 值2 where 条件;\n\n### 删除语句\n\n语法： `delete from 表名 where 条件;`\n\n### 连表查询\n\n- sql89标准\n\n语法：\n```SQL\nSELECT stu_name,col_name FROM T_STUDENT ts,T_COLLEGE tc\nWHERE ts.col_id = tc.col_id;\n```\n\n- sql99标准\n\n```SQL\nSELECT stu_name ,collge FROM T_STUDENT ts INNER JOIN T_COLLEGE tc \nON ts.col_id = tc.col_id;\n```","source":"_posts/javaLearn/数据库/操作数据库.md","raw":"---\ntitle: 操作语句 \ndate: [2023-3-21]\ntags: [后端]\ncategroies: [数据库]\n---\n\n# SQL语句\n\n## 建表\n\n`CREATE tablespace 表名`\n\n```SQL\nCREATE tablespace stx //创建\ndatafile 'D:\\02_workspace\\03_dbData\\oracle\\stx.dbf'  // 创建地址\nSIZE 128m   // 指定创建大小\nautoextend ON  // \nNEXT 16m;  //\n\n```\n\n## 删除表空间\n\n`delete `\n\n### 创建用户\n\n```SQL\nCREATE USER project\nIDENTIFIED　BY root\nDEFAULT tablespace stx;\n```\n\n### 授权\n\n`GRANT dba TO frank_24`\n\n## 增删改查\n\n### 1.1查询语句\n\n- 第一种查询\n\n```SQL\n-- 查询所有学生信息\n-- 语法： SELECT 列名 from 表名\n```\n\n- 查询一个表中多个列的数据，可以使用`,`隔开。就像这样：\n\n```SQL\nSELECT stu_id,stu_name,collge FROM t_student;\n```\n\n- 查询所有信息\n查询表中的所有信息：使用`*`代替所有的列。\n\n```SQL\n-- 查询所有的数据\nSELECT * FROM T_STUDENT;\n```\n\n- 给数据列取别名\n\n第一种写法：\n\n```SQL\nSELECT 列名1 \"别名1\",列名2 \"别名2\" FROM T_STUDENT;\n```\n\n在列名之后加上一个空格，双引号，写上别名。\n\n第二种写法：\n\n```SQL\nSELECT  列名2 AS \"别名1\" ,列名1 AS \"别名2\" FROM T_STUDENT;\n```\n\n在列名之后加上一个空格，写上`as`关键字，后面跟上`\"别名\"`。\n\n- 查询系统时间\n\n```SQL\n-- dual 这是一张虚表\n\nSELECT SYSDATE FROM dual ;  // 查询系统时间\n```\n\n不知道查哪一张表时，就可以查询`dual`这张表。\n\n- 查询36*36等于多少\n\n```SQL\n-- 查询36*36等于多少\nSELECT 36*36 FROM dual ; // 1296\n```\n\n### 1.2条件查询\n\n```SQL\n-- 条件查询\n--SELECT 列名 from 表名 WHERE  条件\n```\n\n条件是一个是表达式。\n\n表达式可以这样写：`PROVINCE = '四川'`,`SCORE >= 80`。\n\n**查询以什么字段开头的数据：**\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE STU_NAME LIKE '曹%';\n```\n\n使用`like`关键字（模糊匹配），然后`%`表示占位符，不管多少个字符。\n\n例如：\n\n- `str%`:以str开头的数据\n- `%str%`：包含str的数据\n- `%str`：以str结尾的数据\n\n**查询指定长度的数据：**\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE STU_NAME LIKE '__';\n```\n\n(此时为两个下划线，表示查询长度为两个字符的数据)\n\n此时使用`_`来表示占位符，一个`_`表示一个字符长度。\n\n**如果有多个包含条件：**\n\n- 我们使用`AND`关键字连接条件：\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE COLLGE = '大数据与计算机科学学院' AND  MAJOR = '软件工程';\n```\n\n**如果查询多个并列条件：**\n\n- 第一种：我们使用`OR`关键字\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE COLLGE  = '外国语学院' OR COLLGE = '远景学院';\n```\n\n- 第二种：使用`in`关键字\n\n```SQL\nSELECT * FROM T_STUDENT ts WHERE COLLGE IN('外国语学院','远景学院');\n```\n\n**查询指定范围内的数据：**\n\n- 使用`AND`\n- 使用`BETWEEN  开始范围  AND  结束范围`:包含开始范围以及结束范围。\n```SQL\nSELECT * FROM T_STUDENT ts WHERE SCORE BETWEEN 80 AND 90;\n```\n\n**同一列表数据去重：**\n\n- 使用关键字`distinct`\n\n```sql\nSELECT DISTINCT  (PROVINCE) from T_STUDENT ts ;\n```\n\ndistinct(要去重的列)。\n\n**对结果进行排序**\n\n- 使用关键字`order by 列名 升序还是降序（默认升序asc,降序desc）`\n\n```sql\nSELECT STU_ID ,STU_NAME ,COLLGE,score  FROM T_STUDENT ts ORDER BY SCORE  asc;\n```\n\n- 对于有两种情况时：\n\n```sql\nSELECT * FROM T_STUDENT ts ORDER BY COLLGE , score DESC;\n```\n\n### 1.3聚合函数\n\n- 统计某列数据个数：`count(列名)`\n\n```sql\nSELECT  count(stu_name) FROM T_STUDENT ts ;\n```\n查询姓名这一列有多少个数据。\n\n- 求平均分avg(列名)\n- 求最大值max(列名)\n- \t求最小值min(列名)\n\n### 查询语句书写顺序\n\nSFWGHO\n\n1. select\n2. from\n3. where\n4. group\n5. having\n6. order\n\n### 1.4分组\n\n- group by 列名\n\n在使用group by时，select子句只能由以下部分组成：\n\n1.汇总函数\n2.GROUPBY中出现的列名\n3.1和2通过函数和表达式的结果\n\n```sql\nSELECT major,count(STU_ID) FROM T_STUDENT ts GROUP BY major ;\n```\n\n### 1.5HAVING\n\n在分组之前进行筛选，我们使用where,在分组之后我们进行筛选我们使用HAVING。\n\n例如：\n\n```SQL\nSELECT collge,count(STU_ID),avg(score) FROM T_STUDENT ts \nGROUP BY COLLGE \nHAVING COUNT(STU_ID) >= 2\nORDER BY avg(score) DESC;\n```\n\n## 连表查询\n\n### 插入语句\n\n语法： `insert into 表名（列名1，列名2，.....） values(值1，值2，值3......) `\n\n一种简介写法：\n\n列名省略，这样的话就需要给每一列添加值，并且添加值的顺序与列名顺序一致。\n\n\n```SQL\nINSERT INTO T_COLLEGE \nVALUES(0004,'外国语学院','曹寒梅');\n```\n\n### 修改语句\n\n语法： update 表名 set 列名1 = 值1,列2 = 值2 where 条件;\n\n### 删除语句\n\n语法： `delete from 表名 where 条件;`\n\n### 连表查询\n\n- sql89标准\n\n语法：\n```SQL\nSELECT stu_name,col_name FROM T_STUDENT ts,T_COLLEGE tc\nWHERE ts.col_id = tc.col_id;\n```\n\n- sql99标准\n\n```SQL\nSELECT stu_name ,collge FROM T_STUDENT ts INNER JOIN T_COLLEGE tc \nON ts.col_id = tc.col_id;\n```","slug":"javaLearn/数据库/操作数据库","published":1,"updated":"2023-03-28T13:36:42.443Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli00vmlc00bi9kbm66epcfes","content":"<h1 id=\"SQL语句\"><a href=\"#SQL语句\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h1><h2 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h2><p><code>CREATE tablespace 表名</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">table</span>space stx <span class=\"operator\">/</span><span class=\"operator\">/</span>创建</span><br><span class=\"line\">datafile <span class=\"string\">&#x27;D:\\02_workspace\\03_dbData\\oracle\\stx.dbf&#x27;</span>  <span class=\"operator\">/</span><span class=\"operator\">/</span> 创建地址</span><br><span class=\"line\">SIZE <span class=\"number\">128</span>m   <span class=\"operator\">/</span><span class=\"operator\">/</span> 指定创建大小</span><br><span class=\"line\">autoextend <span class=\"keyword\">ON</span>  <span class=\"operator\">/</span><span class=\"operator\">/</span> </span><br><span class=\"line\">NEXT <span class=\"number\">16</span>m;  <span class=\"operator\">/</span><span class=\"operator\">/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除表空间\"><a href=\"#删除表空间\" class=\"headerlink\" title=\"删除表空间\"></a>删除表空间</h2><p><code>delete </code></p>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> project</span><br><span class=\"line\">IDENTIFIED　<span class=\"keyword\">BY</span> root</span><br><span class=\"line\"><span class=\"keyword\">DEFAULT</span> tablespace stx;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h3><p><code>GRANT dba TO frank_24</code></p>\n<h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><h3 id=\"1-1查询语句\"><a href=\"#1-1查询语句\" class=\"headerlink\" title=\"1.1查询语句\"></a>1.1查询语句</h3><ul>\n<li>第一种查询</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询所有学生信息</span></span><br><span class=\"line\"><span class=\"comment\">-- 语法： SELECT 列名 from 表名</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询一个表中多个列的数据，可以使用<code>,</code>隔开。就像这样：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> stu_id,stu_name,collge <span class=\"keyword\">FROM</span> t_student;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询所有信息<br>查询表中的所有信息：使用<code>*</code>代替所有的列。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询所有的数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>给数据列取别名</li>\n</ul>\n<p>第一种写法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 列名<span class=\"number\">1</span> &quot;别名1&quot;,列名<span class=\"number\">2</span> &quot;别名2&quot; <span class=\"keyword\">FROM</span> T_STUDENT;</span><br></pre></td></tr></table></figure>\n\n<p>在列名之后加上一个空格，双引号，写上别名。</p>\n<p>第二种写法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  列名<span class=\"number\">2</span> <span class=\"keyword\">AS</span> &quot;别名1&quot; ,列名<span class=\"number\">1</span> <span class=\"keyword\">AS</span> &quot;别名2&quot; <span class=\"keyword\">FROM</span> T_STUDENT;</span><br></pre></td></tr></table></figure>\n\n<p>在列名之后加上一个空格，写上<code>as</code>关键字，后面跟上<code>&quot;别名&quot;</code>。</p>\n<ul>\n<li>查询系统时间</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- dual 这是一张虚表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SYSDATE <span class=\"keyword\">FROM</span> dual ;  <span class=\"operator\">/</span><span class=\"operator\">/</span> 查询系统时间</span><br></pre></td></tr></table></figure>\n\n<p>不知道查哪一张表时，就可以查询<code>dual</code>这张表。</p>\n<ul>\n<li>查询36*36等于多少</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询36*36等于多少</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"number\">36</span><span class=\"operator\">*</span><span class=\"number\">36</span> <span class=\"keyword\">FROM</span> dual ; <span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"number\">1296</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2条件查询\"><a href=\"#1-2条件查询\" class=\"headerlink\" title=\"1.2条件查询\"></a>1.2条件查询</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 条件查询</span></span><br><span class=\"line\"><span class=\"comment\">--SELECT 列名 from 表名 WHERE  条件</span></span><br></pre></td></tr></table></figure>\n\n<p>条件是一个是表达式。</p>\n<p>表达式可以这样写：<code>PROVINCE = &#39;四川&#39;</code>,<code>SCORE &gt;= 80</code>。</p>\n<p><strong>查询以什么字段开头的数据：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> STU_NAME <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;曹%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>like</code>关键字（模糊匹配），然后<code>%</code>表示占位符，不管多少个字符。</p>\n<p>例如：</p>\n<ul>\n<li><code>str%</code>:以str开头的数据</li>\n<li><code>%str%</code>：包含str的数据</li>\n<li><code>%str</code>：以str结尾的数据</li>\n</ul>\n<p><strong>查询指定长度的数据：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> STU_NAME <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;__&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>(此时为两个下划线，表示查询长度为两个字符的数据)</p>\n<p>此时使用<code>_</code>来表示占位符，一个<code>_</code>表示一个字符长度。</p>\n<p><strong>如果有多个包含条件：</strong></p>\n<ul>\n<li>我们使用<code>AND</code>关键字连接条件：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> COLLGE <span class=\"operator\">=</span> <span class=\"string\">&#x27;大数据与计算机科学学院&#x27;</span> <span class=\"keyword\">AND</span>  MAJOR <span class=\"operator\">=</span> <span class=\"string\">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>如果查询多个并列条件：</strong></p>\n<ul>\n<li>第一种：我们使用<code>OR</code>关键字</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> COLLGE  <span class=\"operator\">=</span> <span class=\"string\">&#x27;外国语学院&#x27;</span> <span class=\"keyword\">OR</span> COLLGE <span class=\"operator\">=</span> <span class=\"string\">&#x27;远景学院&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种：使用<code>in</code>关键字</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> COLLGE <span class=\"keyword\">IN</span>(<span class=\"string\">&#x27;外国语学院&#x27;</span>,<span class=\"string\">&#x27;远景学院&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>查询指定范围内的数据：</strong></p>\n<ul>\n<li>使用<code>AND</code></li>\n<li>使用<code>BETWEEN  开始范围  AND  结束范围</code>:包含开始范围以及结束范围。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> SCORE <span class=\"keyword\">BETWEEN</span> <span class=\"number\">80</span> <span class=\"keyword\">AND</span> <span class=\"number\">90</span>;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>同一列表数据去重：</strong></p>\n<ul>\n<li>使用关键字<code>distinct</code></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span>  (PROVINCE) <span class=\"keyword\">from</span> T_STUDENT ts ;</span><br></pre></td></tr></table></figure>\n\n<p>distinct(要去重的列)。</p>\n<p><strong>对结果进行排序</strong></p>\n<ul>\n<li>使用关键字<code>order by 列名 升序还是降序（默认升序asc,降序desc）</code></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> STU_ID ,STU_NAME ,COLLGE,score  <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SCORE  <span class=\"keyword\">asc</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于有两种情况时：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COLLGE , score <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3聚合函数\"><a href=\"#1-3聚合函数\" class=\"headerlink\" title=\"1.3聚合函数\"></a>1.3聚合函数</h3><ul>\n<li>统计某列数据个数：<code>count(列名)</code></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  <span class=\"built_in\">count</span>(stu_name) <span class=\"keyword\">FROM</span> T_STUDENT ts ;</span><br></pre></td></tr></table></figure>\n<p>查询姓名这一列有多少个数据。</p>\n<ul>\n<li>求平均分avg(列名)</li>\n<li>求最大值max(列名)</li>\n<li><pre><code>求最小值min(列名)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"查询语句书写顺序\"><a href=\"#查询语句书写顺序\" class=\"headerlink\" title=\"查询语句书写顺序\"></a>查询语句书写顺序</h3><p>SFWGHO</p>\n<ol>\n<li>select</li>\n<li>from</li>\n<li>where</li>\n<li>group</li>\n<li>having</li>\n<li>order</li>\n</ol>\n<h3 id=\"1-4分组\"><a href=\"#1-4分组\" class=\"headerlink\" title=\"1.4分组\"></a>1.4分组</h3><ul>\n<li>group by 列名</li>\n</ul>\n<p>在使用group by时，select子句只能由以下部分组成：</p>\n<p>1.汇总函数<br>2.GROUPBY中出现的列名<br>3.1和2通过函数和表达式的结果</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> major,<span class=\"built_in\">count</span>(STU_ID) <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> major ;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5HAVING\"><a href=\"#1-5HAVING\" class=\"headerlink\" title=\"1.5HAVING\"></a>1.5HAVING</h3><p>在分组之前进行筛选，我们使用where,在分组之后我们进行筛选我们使用HAVING。</p>\n<p>例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> collge,<span class=\"built_in\">count</span>(STU_ID),<span class=\"built_in\">avg</span>(score) <span class=\"keyword\">FROM</span> T_STUDENT ts </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> COLLGE </span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(STU_ID) <span class=\"operator\">&gt;=</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">avg</span>(score) <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连表查询\"><a href=\"#连表查询\" class=\"headerlink\" title=\"连表查询\"></a>连表查询</h2><h3 id=\"插入语句\"><a href=\"#插入语句\" class=\"headerlink\" title=\"插入语句\"></a>插入语句</h3><p>语法： <code>insert into 表名（列名1，列名2，.....） values(值1，值2，值3......) </code></p>\n<p>一种简介写法：</p>\n<p>列名省略，这样的话就需要给每一列添加值，并且添加值的顺序与列名顺序一致。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> T_COLLEGE </span><br><span class=\"line\"><span class=\"keyword\">VALUES</span>(<span class=\"number\">0004</span>,<span class=\"string\">&#x27;外国语学院&#x27;</span>,<span class=\"string\">&#x27;曹寒梅&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改语句\"><a href=\"#修改语句\" class=\"headerlink\" title=\"修改语句\"></a>修改语句</h3><p>语法： update 表名 set 列名1 &#x3D; 值1,列2 &#x3D; 值2 where 条件;</p>\n<h3 id=\"删除语句\"><a href=\"#删除语句\" class=\"headerlink\" title=\"删除语句\"></a>删除语句</h3><p>语法： <code>delete from 表名 where 条件;</code></p>\n<h3 id=\"连表查询-1\"><a href=\"#连表查询-1\" class=\"headerlink\" title=\"连表查询\"></a>连表查询</h3><ul>\n<li>sql89标准</li>\n</ul>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> stu_name,col_name <span class=\"keyword\">FROM</span> T_STUDENT ts,T_COLLEGE tc</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ts.col_id <span class=\"operator\">=</span> tc.col_id;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>sql99标准</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> stu_name ,collge <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> T_COLLEGE tc </span><br><span class=\"line\"><span class=\"keyword\">ON</span> ts.col_id <span class=\"operator\">=</span> tc.col_id;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SQL语句\"><a href=\"#SQL语句\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h1><h2 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h2><p><code>CREATE tablespace 表名</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">table</span>space stx <span class=\"operator\">/</span><span class=\"operator\">/</span>创建</span><br><span class=\"line\">datafile <span class=\"string\">&#x27;D:\\02_workspace\\03_dbData\\oracle\\stx.dbf&#x27;</span>  <span class=\"operator\">/</span><span class=\"operator\">/</span> 创建地址</span><br><span class=\"line\">SIZE <span class=\"number\">128</span>m   <span class=\"operator\">/</span><span class=\"operator\">/</span> 指定创建大小</span><br><span class=\"line\">autoextend <span class=\"keyword\">ON</span>  <span class=\"operator\">/</span><span class=\"operator\">/</span> </span><br><span class=\"line\">NEXT <span class=\"number\">16</span>m;  <span class=\"operator\">/</span><span class=\"operator\">/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除表空间\"><a href=\"#删除表空间\" class=\"headerlink\" title=\"删除表空间\"></a>删除表空间</h2><p><code>delete </code></p>\n<h3 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> project</span><br><span class=\"line\">IDENTIFIED　<span class=\"keyword\">BY</span> root</span><br><span class=\"line\"><span class=\"keyword\">DEFAULT</span> tablespace stx;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h3><p><code>GRANT dba TO frank_24</code></p>\n<h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><h3 id=\"1-1查询语句\"><a href=\"#1-1查询语句\" class=\"headerlink\" title=\"1.1查询语句\"></a>1.1查询语句</h3><ul>\n<li>第一种查询</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询所有学生信息</span></span><br><span class=\"line\"><span class=\"comment\">-- 语法： SELECT 列名 from 表名</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询一个表中多个列的数据，可以使用<code>,</code>隔开。就像这样：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> stu_id,stu_name,collge <span class=\"keyword\">FROM</span> t_student;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询所有信息<br>查询表中的所有信息：使用<code>*</code>代替所有的列。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询所有的数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>给数据列取别名</li>\n</ul>\n<p>第一种写法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 列名<span class=\"number\">1</span> &quot;别名1&quot;,列名<span class=\"number\">2</span> &quot;别名2&quot; <span class=\"keyword\">FROM</span> T_STUDENT;</span><br></pre></td></tr></table></figure>\n\n<p>在列名之后加上一个空格，双引号，写上别名。</p>\n<p>第二种写法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  列名<span class=\"number\">2</span> <span class=\"keyword\">AS</span> &quot;别名1&quot; ,列名<span class=\"number\">1</span> <span class=\"keyword\">AS</span> &quot;别名2&quot; <span class=\"keyword\">FROM</span> T_STUDENT;</span><br></pre></td></tr></table></figure>\n\n<p>在列名之后加上一个空格，写上<code>as</code>关键字，后面跟上<code>&quot;别名&quot;</code>。</p>\n<ul>\n<li>查询系统时间</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- dual 这是一张虚表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SYSDATE <span class=\"keyword\">FROM</span> dual ;  <span class=\"operator\">/</span><span class=\"operator\">/</span> 查询系统时间</span><br></pre></td></tr></table></figure>\n\n<p>不知道查哪一张表时，就可以查询<code>dual</code>这张表。</p>\n<ul>\n<li>查询36*36等于多少</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询36*36等于多少</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"number\">36</span><span class=\"operator\">*</span><span class=\"number\">36</span> <span class=\"keyword\">FROM</span> dual ; <span class=\"operator\">/</span><span class=\"operator\">/</span> <span class=\"number\">1296</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2条件查询\"><a href=\"#1-2条件查询\" class=\"headerlink\" title=\"1.2条件查询\"></a>1.2条件查询</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 条件查询</span></span><br><span class=\"line\"><span class=\"comment\">--SELECT 列名 from 表名 WHERE  条件</span></span><br></pre></td></tr></table></figure>\n\n<p>条件是一个是表达式。</p>\n<p>表达式可以这样写：<code>PROVINCE = &#39;四川&#39;</code>,<code>SCORE &gt;= 80</code>。</p>\n<p><strong>查询以什么字段开头的数据：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> STU_NAME <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;曹%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>like</code>关键字（模糊匹配），然后<code>%</code>表示占位符，不管多少个字符。</p>\n<p>例如：</p>\n<ul>\n<li><code>str%</code>:以str开头的数据</li>\n<li><code>%str%</code>：包含str的数据</li>\n<li><code>%str</code>：以str结尾的数据</li>\n</ul>\n<p><strong>查询指定长度的数据：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> STU_NAME <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;__&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>(此时为两个下划线，表示查询长度为两个字符的数据)</p>\n<p>此时使用<code>_</code>来表示占位符，一个<code>_</code>表示一个字符长度。</p>\n<p><strong>如果有多个包含条件：</strong></p>\n<ul>\n<li>我们使用<code>AND</code>关键字连接条件：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> COLLGE <span class=\"operator\">=</span> <span class=\"string\">&#x27;大数据与计算机科学学院&#x27;</span> <span class=\"keyword\">AND</span>  MAJOR <span class=\"operator\">=</span> <span class=\"string\">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>如果查询多个并列条件：</strong></p>\n<ul>\n<li>第一种：我们使用<code>OR</code>关键字</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> COLLGE  <span class=\"operator\">=</span> <span class=\"string\">&#x27;外国语学院&#x27;</span> <span class=\"keyword\">OR</span> COLLGE <span class=\"operator\">=</span> <span class=\"string\">&#x27;远景学院&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种：使用<code>in</code>关键字</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> COLLGE <span class=\"keyword\">IN</span>(<span class=\"string\">&#x27;外国语学院&#x27;</span>,<span class=\"string\">&#x27;远景学院&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>查询指定范围内的数据：</strong></p>\n<ul>\n<li>使用<code>AND</code></li>\n<li>使用<code>BETWEEN  开始范围  AND  结束范围</code>:包含开始范围以及结束范围。<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">WHERE</span> SCORE <span class=\"keyword\">BETWEEN</span> <span class=\"number\">80</span> <span class=\"keyword\">AND</span> <span class=\"number\">90</span>;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>同一列表数据去重：</strong></p>\n<ul>\n<li>使用关键字<code>distinct</code></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span>  (PROVINCE) <span class=\"keyword\">from</span> T_STUDENT ts ;</span><br></pre></td></tr></table></figure>\n\n<p>distinct(要去重的列)。</p>\n<p><strong>对结果进行排序</strong></p>\n<ul>\n<li>使用关键字<code>order by 列名 升序还是降序（默认升序asc,降序desc）</code></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> STU_ID ,STU_NAME ,COLLGE,score  <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SCORE  <span class=\"keyword\">asc</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对于有两种情况时：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> COLLGE , score <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3聚合函数\"><a href=\"#1-3聚合函数\" class=\"headerlink\" title=\"1.3聚合函数\"></a>1.3聚合函数</h3><ul>\n<li>统计某列数据个数：<code>count(列名)</code></li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span>  <span class=\"built_in\">count</span>(stu_name) <span class=\"keyword\">FROM</span> T_STUDENT ts ;</span><br></pre></td></tr></table></figure>\n<p>查询姓名这一列有多少个数据。</p>\n<ul>\n<li>求平均分avg(列名)</li>\n<li>求最大值max(列名)</li>\n<li><pre><code>求最小值min(列名)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"查询语句书写顺序\"><a href=\"#查询语句书写顺序\" class=\"headerlink\" title=\"查询语句书写顺序\"></a>查询语句书写顺序</h3><p>SFWGHO</p>\n<ol>\n<li>select</li>\n<li>from</li>\n<li>where</li>\n<li>group</li>\n<li>having</li>\n<li>order</li>\n</ol>\n<h3 id=\"1-4分组\"><a href=\"#1-4分组\" class=\"headerlink\" title=\"1.4分组\"></a>1.4分组</h3><ul>\n<li>group by 列名</li>\n</ul>\n<p>在使用group by时，select子句只能由以下部分组成：</p>\n<p>1.汇总函数<br>2.GROUPBY中出现的列名<br>3.1和2通过函数和表达式的结果</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> major,<span class=\"built_in\">count</span>(STU_ID) <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> major ;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5HAVING\"><a href=\"#1-5HAVING\" class=\"headerlink\" title=\"1.5HAVING\"></a>1.5HAVING</h3><p>在分组之前进行筛选，我们使用where,在分组之后我们进行筛选我们使用HAVING。</p>\n<p>例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> collge,<span class=\"built_in\">count</span>(STU_ID),<span class=\"built_in\">avg</span>(score) <span class=\"keyword\">FROM</span> T_STUDENT ts </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> COLLGE </span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"built_in\">COUNT</span>(STU_ID) <span class=\"operator\">&gt;=</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">avg</span>(score) <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"连表查询\"><a href=\"#连表查询\" class=\"headerlink\" title=\"连表查询\"></a>连表查询</h2><h3 id=\"插入语句\"><a href=\"#插入语句\" class=\"headerlink\" title=\"插入语句\"></a>插入语句</h3><p>语法： <code>insert into 表名（列名1，列名2，.....） values(值1，值2，值3......) </code></p>\n<p>一种简介写法：</p>\n<p>列名省略，这样的话就需要给每一列添加值，并且添加值的顺序与列名顺序一致。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> T_COLLEGE </span><br><span class=\"line\"><span class=\"keyword\">VALUES</span>(<span class=\"number\">0004</span>,<span class=\"string\">&#x27;外国语学院&#x27;</span>,<span class=\"string\">&#x27;曹寒梅&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"修改语句\"><a href=\"#修改语句\" class=\"headerlink\" title=\"修改语句\"></a>修改语句</h3><p>语法： update 表名 set 列名1 &#x3D; 值1,列2 &#x3D; 值2 where 条件;</p>\n<h3 id=\"删除语句\"><a href=\"#删除语句\" class=\"headerlink\" title=\"删除语句\"></a>删除语句</h3><p>语法： <code>delete from 表名 where 条件;</code></p>\n<h3 id=\"连表查询-1\"><a href=\"#连表查询-1\" class=\"headerlink\" title=\"连表查询\"></a>连表查询</h3><ul>\n<li>sql89标准</li>\n</ul>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> stu_name,col_name <span class=\"keyword\">FROM</span> T_STUDENT ts,T_COLLEGE tc</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> ts.col_id <span class=\"operator\">=</span> tc.col_id;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>sql99标准</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> stu_name ,collge <span class=\"keyword\">FROM</span> T_STUDENT ts <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> T_COLLEGE tc </span><br><span class=\"line\"><span class=\"keyword\">ON</span> ts.col_id <span class=\"operator\">=</span> tc.col_id;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cli00vmgh00059kbm01o3boy5","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmgp000d9kbmb2x050jq"},{"post_id":"cli00vmg200009kbmfyb6h1xs","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmgr000i9kbm80uyhh7b"},{"post_id":"cli00vmgj00069kbmexq3h40e","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmgv000l9kbm8yddhr4f"},{"post_id":"cli00vmgn000a9kbmcidaegzc","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmgw000p9kbmfyx46hmw"},{"post_id":"cli00vmga00019kbm6rwhfvpg","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmgz000s9kbm046l1vwe"},{"post_id":"cli00vmgf00049kbm2eog2czq","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmh5000w9kbmcq3egsft"},{"post_id":"cli00vmgo000c9kbm7iw55t95","category_id":"cli00vmgv000m9kbm129x4qxx","_id":"cli00vmh9000z9kbmg4hk0qf6"},{"post_id":"cli00vmgq000h9kbm554shub5","category_id":"cli00vmh0000t9kbm13p0dwkq","_id":"cli00vmhe00159kbmhijgedxw"},{"post_id":"cli00vmh7000y9kbm0nncfnnd","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmhf00199kbmd7n0fbe8"},{"post_id":"cli00vmgs000k9kbm7h5d2wsj","category_id":"cli00vmha00109kbm1jwshv6u","_id":"cli00vmhg001e9kbm1jfx1loq"},{"post_id":"cli00vmhd00149kbm0snsgjr8","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmhh001h9kbm6vq0db4n"},{"post_id":"cli00vmhe00189kbm8n42ea3k","category_id":"cli00vmgv000m9kbm129x4qxx","_id":"cli00vmhi001k9kbm5r39cmw4"},{"post_id":"cli00vmgw000o9kbm2dxg0x4v","category_id":"cli00vmha00109kbm1jwshv6u","_id":"cli00vmhj001o9kbm4nwjgy1i"},{"post_id":"cli00vmhg001f9kbm8pyyhnvf","category_id":"cli00vmgv000m9kbm129x4qxx","_id":"cli00vmhk001r9kbm3u131k3o"},{"post_id":"cli00vmhh001i9kbmgxitcs58","category_id":"cli00vmha00109kbm1jwshv6u","_id":"cli00vmhl001v9kbm18bfh5ov"},{"post_id":"cli00vmgx000r9kbm8ysn7cum","category_id":"cli00vmhg001d9kbm106u6jw4","_id":"cli00vmhl001y9kbm7i183m22"},{"post_id":"cli00vmhi001l9kbm7ckef7gr","category_id":"cli00vmha00109kbm1jwshv6u","_id":"cli00vmhn00219kbm08od926x"},{"post_id":"cli00vmhj001p9kbmazc0c0nb","category_id":"cli00vmha00109kbm1jwshv6u","_id":"cli00vmhn00249kbmfw6a67xp"},{"post_id":"cli00vmh3000v9kbmbzw82bmi","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmho00289kbm0j4scajv"},{"post_id":"cli00vmh3000v9kbmbzw82bmi","category_id":"cli00vmhi001m9kbma0pebyvo","_id":"cli00vmhq002c9kbmhh9p77pe"},{"post_id":"cli00vmhk001s9kbm4dwk7f98","category_id":"cli00vmha00109kbm1jwshv6u","_id":"cli00vmhr002f9kbmbar0bu6o"},{"post_id":"cli00vmhl001w9kbm7dlbdzgx","category_id":"cli00vmha00109kbm1jwshv6u","_id":"cli00vmhs002j9kbm1ggh834x"},{"post_id":"cli00vmhc00129kbm9dda1rxb","category_id":"cli00vmhk001t9kbm1h4zatlr","_id":"cli00vmht002m9kbm7ixt1v1v"},{"post_id":"cli00vmhm001z9kbm2l4mhoeo","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmhu002p9kbm2fhpfvx9"},{"post_id":"cli00vmhm001z9kbm2l4mhoeo","category_id":"cli00vmhi001m9kbma0pebyvo","_id":"cli00vmhv002t9kbmg1o7f7rv"},{"post_id":"cli00vmhn00229kbmbzqk7lnf","category_id":"cli00vmh0000t9kbm13p0dwkq","_id":"cli00vmhw002w9kbmf4fu1vos"},{"post_id":"cli00vmho00299kbm0iki0cjz","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmhx002z9kbmetj22e8r"},{"post_id":"cli00vmho00299kbm0iki0cjz","category_id":"cli00vmhi001m9kbma0pebyvo","_id":"cli00vmhy00339kbmgerr0tkj"},{"post_id":"cli00vmhq002d9kbm5iqv32wi","category_id":"cli00vmgd00029kbm0fm377m0","_id":"cli00vmhy00369kbm9lnp3c66"},{"post_id":"cli00vmhq002d9kbm5iqv32wi","category_id":"cli00vmhi001m9kbma0pebyvo","_id":"cli00vmi0003a9kbm0xywc1zs"},{"post_id":"cli00vmhr002g9kbm9lik6v5k","category_id":"cli00vmh0000t9kbm13p0dwkq","_id":"cli00vmi0003d9kbm6tvmez8p"},{"post_id":"cli00vmhn00259kbm79j3gyxe","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vmi2003h9kbm1fql8m95"},{"post_id":"cli00vmhs002k9kbm4b02hxsn","category_id":"cli00vmhk001t9kbm1h4zatlr","_id":"cli00vmi3003k9kbm6h23fp2g"},{"post_id":"cli00vmhw002x9kbmd1xy0gj6","category_id":"cli00vmhv002r9kbmh7xe5hoc","_id":"cli00vmi4003o9kbm3opa4g6z"},{"post_id":"cli00vmht002n9kbmdgrmac25","category_id":"cli00vmhv002r9kbmh7xe5hoc","_id":"cli00vmi5003r9kbmevns8keq"},{"post_id":"cli00vmhu002q9kbmd75i3o1f","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmi6003v9kbmf448hgdc"},{"post_id":"cli00vmhz00379kbm5lqlduez","category_id":"cli00vmhk001t9kbm1h4zatlr","_id":"cli00vmi8003y9kbmboy0cvbi"},{"post_id":"cli00vmhv002u9kbmgj0kcbnx","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmi800419kbm97ps9w31"},{"post_id":"cli00vmi2003i9kbmhy3xfv34","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmi900449kbmdr6oafn4"},{"post_id":"cli00vmhy00349kbmhoqa244t","category_id":"cli00vmi1003f9kbm792o8ug8","_id":"cli00vmia00479kbm3g4v1q54"},{"post_id":"cli00vmi3003l9kbmhbcfgvyp","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmib004a9kbm0s78eb4y"},{"post_id":"cli00vmi4003p9kbm1cm4h7c1","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmic004d9kbm9fgcfa2g"},{"post_id":"cli00vmi0003b9kbmbuord7kc","category_id":"cli00vmi1003f9kbm792o8ug8","_id":"cli00vmic004g9kbm1deye5ue"},{"post_id":"cli00vmi5003s9kbm6eyo425n","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmid004j9kbm4c2v51e2"},{"post_id":"cli00vmi6003w9kbm07c91pmz","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmie004m9kbm0m68af8e"},{"post_id":"cli00vmi0003e9kbm3li32a43","category_id":"cli00vmi5003t9kbmbe5v6rtq","_id":"cli00vmif004p9kbm4mpzhc4l"},{"post_id":"cli00vmi8003z9kbm5rzuc2jt","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmig004s9kbmgzbqhfw5"},{"post_id":"cli00vmi800429kbm06fs1n8k","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmii004w9kbmal4qgco2"},{"post_id":"cli00vmi900459kbm6wf05o6r","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmij004z9kbm96h35mfe"},{"post_id":"cli00vmia00489kbm7lac9cr6","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmik00529kbmakvscp6v"},{"post_id":"cli00vmib004b9kbmh0arcd84","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmil00559kbmbi1ogpyd"},{"post_id":"cli00vmic004e9kbmee9l23fn","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmim00589kbmgumw6232"},{"post_id":"cli00vmid004h9kbm3zcx5zvy","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmin005b9kbm0zzxcqk9"},{"post_id":"cli00vmid004k9kbmeqdgd1dn","category_id":"cli00vmhk001t9kbm1h4zatlr","_id":"cli00vmip005e9kbmf4csc4fj"},{"post_id":"cli00vmie004n9kbm7fv323qy","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmiq005h9kbmes2ocm07"},{"post_id":"cli00vmig004t9kbm5hz20ar6","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmir005k9kbmhnkietyo"},{"post_id":"cli00vmii004x9kbm64d6gruk","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmis005n9kbm6nd5ahpw"},{"post_id":"cli00vmij00509kbmhugy9634","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmis005q9kbm5qfbephz"},{"post_id":"cli00vmif004q9kbmhmcbbbo3","category_id":"cli00vmii004u9kbmbydag9eq","_id":"cli00vmiu005t9kbm5l6acu50"},{"post_id":"cli00vmik00539kbmd4bu7nyy","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmiv005w9kbmdezqe1nl"},{"post_id":"cli00vmil00569kbmhxoz2v1i","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmix005z9kbmaaufcpr9"},{"post_id":"cli00vmim00599kbm5we7eycm","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmiz00629kbmd4aggvrr"},{"post_id":"cli00vmio005c9kbm28349iv3","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj000659kbm7ra25vhx"},{"post_id":"cli00vmip005f9kbm8gqm8e9y","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj000699kbmgnr1h0et"},{"post_id":"cli00vmiq005i9kbm2pkb0u50","category_id":"cli00vmh0000t9kbm13p0dwkq","_id":"cli00vmj1006c9kbm60nd9u5n"},{"post_id":"cli00vmir005l9kbm3g2lhj63","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj2006f9kbm0i3u0o6c"},{"post_id":"cli00vmis005o9kbm5w2hb2mn","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj3006i9kbmd1sje4hi"},{"post_id":"cli00vmit005r9kbm9rra7iae","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj5006l9kbmd6vy2mvw"},{"post_id":"cli00vmiu005u9kbmbvj5fbw0","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj6006o9kbm1ey99eip"},{"post_id":"cli00vmiv005x9kbme87wa87e","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj7006r9kbm1hboe8pv"},{"post_id":"cli00vmiz00639kbm8fks0f5x","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj7006u9kbmcbg07413"},{"post_id":"cli00vmj000669kbm4umc7lsd","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj8006x9kbm0igeb81y"},{"post_id":"cli00vmj1006a9kbm6t5dfbzv","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmj900719kbmannh5dse"},{"post_id":"cli00vmix00609kbmbhw2ggco","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmja00749kbmeilnewf0"},{"post_id":"cli00vmix00609kbmbhw2ggco","category_id":"cli00vmj000679kbmaueqh1fo","_id":"cli00vmjc00789kbm50c10ir9"},{"post_id":"cli00vmj1006d9kbm9284h7x8","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmjd007b9kbm6bina614"},{"post_id":"cli00vmj2006g9kbm2mc1bpyg","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmje007f9kbmcnd5eqrs"},{"post_id":"cli00vmj3006j9kbmb0rgds3g","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmjf007i9kbm0r71876c"},{"post_id":"cli00vmj5006m9kbm35rt4hnt","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmjh007m9kbmdqeogx65"},{"post_id":"cli00vmj6006p9kbmakb36n27","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmji007p9kbmhhi03no1"},{"post_id":"cli00vmja00729kbm7id98gy4","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmji007t9kbm8omegen2"},{"post_id":"cli00vmja00729kbm7id98gy4","category_id":"cli00vmj9006z9kbmeu88bqq8","_id":"cli00vmjj007w9kbmdov1b8rn"},{"post_id":"cli00vmj7006s9kbm9wmm6swb","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmjl00809kbm3xytff65"},{"post_id":"cli00vmj7006s9kbm9wmm6swb","category_id":"cli00vmj9006z9kbmeu88bqq8","_id":"cli00vmjp00839kbm3fu40fo4"},{"post_id":"cli00vmjb00759kbm4vu2dx26","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmjr00879kbmf1ygbil1"},{"post_id":"cli00vmj8006v9kbm0kx55jfw","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmjt008a9kbm19s9affb"},{"post_id":"cli00vmj8006v9kbm0kx55jfw","category_id":"cli00vmj9006z9kbmeu88bqq8","_id":"cli00vmjw008d9kbmbudmg0hk"},{"post_id":"cli00vmj8006y9kbmg86m5yxs","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmjx008g9kbm780a737c"},{"post_id":"cli00vmj8006y9kbmg86m5yxs","category_id":"cli00vmj9006z9kbmeu88bqq8","_id":"cli00vmk3008k9kbm75m31uxj"},{"post_id":"cli00vmjc00799kbm6cy82ja9","category_id":"cli00vmhx00319kbmeiwr54ev","_id":"cli00vmk5008n9kbmausvej13"},{"post_id":"cli00vmjc00799kbm6cy82ja9","category_id":"cli00vmjg007k9kbm20204ejk","_id":"cli00vmk9008q9kbmeryy54v2"},{"post_id":"cli00vmji007q9kbmfotj5p8g","category_id":"cli00vmha00109kbm1jwshv6u","_id":"cli00vmkb008u9kbm1ff07z06"},{"post_id":"cli00vmjj007u9kbm1s2r2nlg","category_id":"cli00vmji007r9kbm3mbj9n9p","_id":"cli00vmkh008x9kbma5dg1zud"},{"post_id":"cli00vmje007g9kbm4xlz3ch3","category_id":"cli00vmji007r9kbm3mbj9n9p","_id":"cli00vmkj00929kbm0ke2dklb"},{"post_id":"cli00vmjj007x9kbm1por4r6y","category_id":"cli00vmji007r9kbm3mbj9n9p","_id":"cli00vmkl00959kbmees06jby"},{"post_id":"cli00vmjl00819kbmenn7f7xp","category_id":"cli00vmji007r9kbm3mbj9n9p","_id":"cli00vmkm00989kbm4c4tgx4o"},{"post_id":"cli00vmjg007j9kbmh0yy5q5g","category_id":"cli00vmji007r9kbm3mbj9n9p","_id":"cli00vmkn009c9kbm3ao1cvw2"},{"post_id":"cli00vmjr00889kbm6ngmae0j","category_id":"cli00vmhg001d9kbm106u6jw4","_id":"cli00vmko009f9kbm8mjag80q"},{"post_id":"cli00vmjh007n9kbmak0ndok8","category_id":"cli00vmji007r9kbm3mbj9n9p","_id":"cli00vmkp009i9kbmh9ryawnq"},{"post_id":"cli00vmjv008b9kbm2rm3e9v6","category_id":"cli00vmji007r9kbm3mbj9n9p","_id":"cli00vmkq009l9kbm86lmbz21"},{"post_id":"cli00vmk0008h9kbm65ixe2n6","category_id":"cli00vmii004u9kbmbydag9eq","_id":"cli00vmkr009o9kbmfoiqhq04"},{"post_id":"cli00vmk5008o9kbmfgiu0mnq","category_id":"cli00vmii004u9kbmbydag9eq","_id":"cli00vmks009r9kbmbyyx9rtf"},{"post_id":"cli00vmjw008e9kbm6aqw9nwr","category_id":"cli00vmk3008i9kbmhe036pag","_id":"cli00vmkt009u9kbm7gc03eih"},{"post_id":"cli00vmk9008r9kbm7tnw9vpe","category_id":"cli00vmii004u9kbmbydag9eq","_id":"cli00vmku009x9kbmajq46rtz"},{"post_id":"cli00vmk3008l9kbm62qwdkff","category_id":"cli00vmka008s9kbm5xvnht5f","_id":"cli00vmku00a09kbm6au88aiu"},{"post_id":"cli00vmkh008y9kbmbq3xdfme","category_id":"cli00vmii004u9kbmbydag9eq","_id":"cli00vmkv00a49kbm5qfi91dv"},{"post_id":"cli00vmkk00939kbm5ivn5425","category_id":"cli00vmka008s9kbm5xvnht5f","_id":"cli00vmkw00a79kbm571u9t2q"},{"post_id":"cli00vmkb008v9kbm4845gy8i","category_id":"cli00vmki008z9kbm8vpc5z3y","_id":"cli00vmkx00aa9kbm5qqh1ijv"},{"post_id":"cli00vmkm00999kbmg8sc4hhq","category_id":"cli00vmii004u9kbmbydag9eq","_id":"cli00vmky00ad9kbm4w3a8qn6"},{"post_id":"cli00vmko009g9kbm822r29n3","category_id":"cli00vmki008z9kbm8vpc5z3y","_id":"cli00vml000ag9kbmhzqgaqak"},{"post_id":"cli00vmkl00969kbm44ie9a0g","category_id":"cli00vmkn009a9kbmfdiidk47","_id":"cli00vml200aj9kbm5dzfabkf"},{"post_id":"cli00vmkp009j9kbm6eld93vh","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vml400an9kbm1tfeec9l"},{"post_id":"cli00vmkq009m9kbm519q6l0s","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vml500aq9kbmcpgc18l0"},{"post_id":"cli00vmkr009p9kbmcauegth7","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vml600at9kbm8s5u8hvn"},{"post_id":"cli00vmkt009v9kbm9zjp381u","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vml600aw9kbm58je80pp"},{"post_id":"cli00vmkv00a19kbm68gk9iag","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vml700az9kbm29m79qfw"},{"post_id":"cli00vmkw00a59kbm1uxb45ob","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vml800b29kbmagyk9vyt"},{"post_id":"cli00vmkw00a89kbm986j6yfy","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vml900b59kbm956vfzrb"},{"post_id":"cli00vmku009y9kbmhe4r1w9c","category_id":"cli00vmkv00a29kbmd5gmfksu","_id":"cli00vml900b89kbmesizew3i"},{"post_id":"cli00vmkx00ab9kbmfl4gdixr","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vmla00ba9kbmh16q5tlh"},{"post_id":"cli00vmky00ae9kbm18lraylx","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vmla00bb9kbmgyf6hp56"},{"post_id":"cli00vml200ak9kbmf6u57dqp","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vmla00bc9kbm69oa86hm"},{"post_id":"cli00vml400ao9kbm6vj4f1ez","category_id":"cli00vmhp002a9kbm2et767fa","_id":"cli00vmla00bd9kbmc9y7544c"},{"post_id":"cli00vml500ar9kbmb4gl9xke","category_id":"cli00vml300al9kbm7got0pgw","_id":"cli00vmla00be9kbm0ate7uqj"},{"post_id":"cli00vml000ah9kbm8pj08sv0","category_id":"cli00vml300al9kbm7got0pgw","_id":"cli00vmla00bf9kbm1uy3e3up"},{"post_id":"cli00vml600au9kbm97ru6a3n","category_id":"cli00vml300al9kbm7got0pgw","_id":"cli00vmla00bg9kbm0h180i41"},{"post_id":"cli00vml600ax9kbmfy2n7u7i","category_id":"cli00vml300al9kbm7got0pgw","_id":"cli00vmla00bh9kbm4jwf4zd6"}],"PostTag":[{"post_id":"cli00vmgh00059kbm01o3boy5","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmgm00099kbm3ahobxtr"},{"post_id":"cli00vmg200009kbmfyb6h1xs","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmgo000b9kbmgk6952li"},{"post_id":"cli00vmgj00069kbmexq3h40e","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmgq000g9kbmbh4r94fk"},{"post_id":"cli00vmgn000a9kbmcidaegzc","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmgs000j9kbm8uye5tr5"},{"post_id":"cli00vmga00019kbm6rwhfvpg","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmgv000n9kbmfiq1eve4"},{"post_id":"cli00vmgo000c9kbm7iw55t95","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmgx000q9kbmh6u7cade"},{"post_id":"cli00vmgq000h9kbm554shub5","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmh3000u9kbm7f7jcy5d"},{"post_id":"cli00vmgf00049kbm2eog2czq","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmh5000x9kbm4n14128j"},{"post_id":"cli00vmgs000k9kbm7h5d2wsj","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhb00119kbm27ooc75a"},{"post_id":"cli00vmgw000o9kbm2dxg0x4v","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhd00139kbm2eargitb"},{"post_id":"cli00vmgx000r9kbm8ysn7cum","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhe00169kbm15xi7ege"},{"post_id":"cli00vmh3000v9kbmbzw82bmi","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhf001a9kbmfnw88ona"},{"post_id":"cli00vmh7000y9kbm0nncfnnd","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhg001c9kbm6zyt7btr"},{"post_id":"cli00vmhc00129kbm9dda1rxb","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhh001g9kbm6bxn0n1u"},{"post_id":"cli00vmhd00149kbm0snsgjr8","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhi001j9kbm9kd1f4t3"},{"post_id":"cli00vmhe00189kbm8n42ea3k","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhj001n9kbm9bv469k4"},{"post_id":"cli00vmhg001f9kbm8pyyhnvf","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhk001q9kbm4hn1bvk5"},{"post_id":"cli00vmhh001i9kbmgxitcs58","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhl001u9kbm0opk9qd5"},{"post_id":"cli00vmhi001l9kbm7ckef7gr","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhl001x9kbm3ghi3abe"},{"post_id":"cli00vmhj001p9kbmazc0c0nb","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhm00209kbm3g8627cz"},{"post_id":"cli00vmhk001s9kbm4dwk7f98","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhn00239kbmgaw20rsr"},{"post_id":"cli00vmhl001w9kbm7dlbdzgx","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmho00279kbm305bgmiq"},{"post_id":"cli00vmhm001z9kbm2l4mhoeo","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhp002b9kbm3nzu6t4y"},{"post_id":"cli00vmho00299kbm0iki0cjz","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhr002e9kbmcmncf10o"},{"post_id":"cli00vmhq002d9kbm5iqv32wi","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhs002i9kbmdldf69hs"},{"post_id":"cli00vmhn00229kbmbzqk7lnf","tag_id":"cli00vmho00269kbmb1vkav5x","_id":"cli00vmht002l9kbm7ieog45f"},{"post_id":"cli00vmhr002g9kbm9lik6v5k","tag_id":"cli00vmho00269kbmb1vkav5x","_id":"cli00vmhu002o9kbmfvav0cqs"},{"post_id":"cli00vmhs002k9kbm4b02hxsn","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhv002s9kbm97fb4bp6"},{"post_id":"cli00vmhn00259kbm79j3gyxe","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmhw002v9kbmf5skgfcq"},{"post_id":"cli00vmht002n9kbmdgrmac25","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhx002y9kbme48a4pkr"},{"post_id":"cli00vmhu002q9kbmd75i3o1f","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhy00329kbm8q0qdegw"},{"post_id":"cli00vmhv002u9kbmgj0kcbnx","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhy00359kbmac00do70"},{"post_id":"cli00vmhw002x9kbmd1xy0gj6","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmhz00399kbmh53p8qyj"},{"post_id":"cli00vmhx00309kbm0hjv6zbo","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi0003c9kbmgotxbcd2"},{"post_id":"cli00vmhy00349kbmhoqa244t","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi2003g9kbmg7we0qyr"},{"post_id":"cli00vmhz00379kbm5lqlduez","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi3003j9kbman1ucy0n"},{"post_id":"cli00vmi0003b9kbmbuord7kc","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi4003n9kbme7qmbtbw"},{"post_id":"cli00vmi0003e9kbm3li32a43","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi5003q9kbmeg2xb24u"},{"post_id":"cli00vmi2003i9kbmhy3xfv34","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi6003u9kbm2nxuc3gs"},{"post_id":"cli00vmi3003l9kbmhbcfgvyp","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi7003x9kbm5z29eqiz"},{"post_id":"cli00vmi4003p9kbm1cm4h7c1","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi800409kbm15nbfi6x"},{"post_id":"cli00vmi5003s9kbm6eyo425n","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmi900439kbmgukdbnjd"},{"post_id":"cli00vmi6003w9kbm07c91pmz","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmia00469kbm5jdxgn31"},{"post_id":"cli00vmi8003z9kbm5rzuc2jt","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmib00499kbm6k2y0m73"},{"post_id":"cli00vmi800429kbm06fs1n8k","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmic004c9kbm4v0n51zq"},{"post_id":"cli00vmi900459kbm6wf05o6r","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmic004f9kbm0aing9s3"},{"post_id":"cli00vmia00489kbm7lac9cr6","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmid004i9kbm790o3ahj"},{"post_id":"cli00vmib004b9kbmh0arcd84","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmie004l9kbmdceb1br1"},{"post_id":"cli00vmic004e9kbmee9l23fn","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmif004o9kbm8yy21bn7"},{"post_id":"cli00vmid004h9kbm3zcx5zvy","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmig004r9kbmd4cgfmtx"},{"post_id":"cli00vmid004k9kbmeqdgd1dn","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmii004v9kbmhpjhc1qa"},{"post_id":"cli00vmie004n9kbm7fv323qy","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmij004y9kbmaos92bco"},{"post_id":"cli00vmif004q9kbmhmcbbbo3","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmik00519kbm4lyfagof"},{"post_id":"cli00vmig004t9kbm5hz20ar6","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmil00549kbmfel1hbcp"},{"post_id":"cli00vmii004x9kbm64d6gruk","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmim00579kbmere4769w"},{"post_id":"cli00vmij00509kbmhugy9634","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmin005a9kbm3zpxhifo"},{"post_id":"cli00vmik00539kbmd4bu7nyy","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmip005d9kbmdoudbuo6"},{"post_id":"cli00vmil00569kbmhxoz2v1i","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmiq005g9kbma9on6wmm"},{"post_id":"cli00vmim00599kbm5we7eycm","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmir005j9kbmdjybdwlg"},{"post_id":"cli00vmio005c9kbm28349iv3","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmis005m9kbmesjm77lw"},{"post_id":"cli00vmip005f9kbm8gqm8e9y","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmis005p9kbm6sv3esx5"},{"post_id":"cli00vmiq005i9kbm2pkb0u50","tag_id":"cli00vmho00269kbmb1vkav5x","_id":"cli00vmiu005s9kbm6wgm6t4j"},{"post_id":"cli00vmir005l9kbm3g2lhj63","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmiv005v9kbmex7q8b64"},{"post_id":"cli00vmis005o9kbm5w2hb2mn","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmix005y9kbm5xbz5suc"},{"post_id":"cli00vmit005r9kbm9rra7iae","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmiz00619kbm9lz99iyd"},{"post_id":"cli00vmiu005u9kbmbvj5fbw0","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmiz00649kbm5lc03hiu"},{"post_id":"cli00vmiv005x9kbme87wa87e","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj000689kbmhy652jl8"},{"post_id":"cli00vmix00609kbmbhw2ggco","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj1006b9kbmcm1m0d4g"},{"post_id":"cli00vmiz00639kbm8fks0f5x","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj2006e9kbmdths87pt"},{"post_id":"cli00vmj000669kbm4umc7lsd","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj3006h9kbmawbo9y4d"},{"post_id":"cli00vmj1006a9kbm6t5dfbzv","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj4006k9kbmh7a6473n"},{"post_id":"cli00vmj1006d9kbm9284h7x8","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj6006n9kbmgcjiex2m"},{"post_id":"cli00vmj2006g9kbm2mc1bpyg","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj7006q9kbm8jik1rso"},{"post_id":"cli00vmj3006j9kbmb0rgds3g","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj7006t9kbm7a7w9nfh"},{"post_id":"cli00vmj5006m9kbm35rt4hnt","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj8006w9kbm1qp268q2"},{"post_id":"cli00vmj6006p9kbmakb36n27","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmj900709kbmeqtkao1q"},{"post_id":"cli00vmj7006s9kbm9wmm6swb","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmja00739kbmgnlm26kv"},{"post_id":"cli00vmj8006v9kbm0kx55jfw","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjc00779kbm59244c0o"},{"post_id":"cli00vmj8006y9kbmg86m5yxs","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjd007a9kbm3crhgs69"},{"post_id":"cli00vmja00729kbm7id98gy4","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmje007e9kbm7xqg8eah"},{"post_id":"cli00vmjb00759kbm4vu2dx26","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjf007h9kbmgupiah2x"},{"post_id":"cli00vmjc00799kbm6cy82ja9","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjh007l9kbm4o8yeovp"},{"post_id":"cli00vmjd007c9kbme7dvbvq9","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjh007o9kbm82qm24v3"},{"post_id":"cli00vmje007g9kbm4xlz3ch3","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmji007s9kbm6b810jlz"},{"post_id":"cli00vmjg007j9kbmh0yy5q5g","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjj007v9kbma1od856m"},{"post_id":"cli00vmjh007n9kbmak0ndok8","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjk007z9kbm60nr6htf"},{"post_id":"cli00vmji007q9kbmfotj5p8g","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjo00829kbmdwif5gzi"},{"post_id":"cli00vmjj007u9kbm1s2r2nlg","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjq00869kbm85smbbii"},{"post_id":"cli00vmjj007x9kbm1por4r6y","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjt00899kbm8jnk46jt"},{"post_id":"cli00vmjl00819kbmenn7f7xp","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjw008c9kbmd9793f79"},{"post_id":"cli00vmjp00849kbmhwnp9vct","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmjx008f9kbmco20epbl"},{"post_id":"cli00vmjr00889kbm6ngmae0j","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmk3008j9kbm6nnt794y"},{"post_id":"cli00vmjv008b9kbm2rm3e9v6","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmk4008m9kbmhthc77e2"},{"post_id":"cli00vmjw008e9kbm6aqw9nwr","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmk9008p9kbmhcye09qq"},{"post_id":"cli00vmk0008h9kbm65ixe2n6","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmkb008t9kbmht196pws"},{"post_id":"cli00vmk3008l9kbm62qwdkff","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmkg008w9kbm78l2d0yn"},{"post_id":"cli00vmk5008o9kbmfgiu0mnq","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmkj00919kbmgj0y56m2"},{"post_id":"cli00vmk9008r9kbm7tnw9vpe","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmkk00949kbm993u1ikg"},{"post_id":"cli00vmkh008y9kbmbq3xdfme","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmkm00979kbme7yodkp8"},{"post_id":"cli00vmkk00939kbm5ivn5425","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmkn009b9kbm6ck8730e"},{"post_id":"cli00vmkl00969kbm44ie9a0g","tag_id":"cli00vmkj00909kbmfo1359o4","_id":"cli00vmko009e9kbm2y700srv"},{"post_id":"cli00vmkb008v9kbm4845gy8i","tag_id":"cli00vmkj00909kbmfo1359o4","_id":"cli00vmkp009h9kbm7mu61y62"},{"post_id":"cli00vmkm00999kbmg8sc4hhq","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vmkq009k9kbm3puf8jwj"},{"post_id":"cli00vmko009g9kbm822r29n3","tag_id":"cli00vmkj00909kbmfo1359o4","_id":"cli00vmkr009n9kbmbw55ewvr"},{"post_id":"cli00vmkp009j9kbm6eld93vh","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmks009q9kbm5mhactma"},{"post_id":"cli00vmkq009m9kbm519q6l0s","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmkt009t9kbmg8lj4mym"},{"post_id":"cli00vmkr009p9kbmcauegth7","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmkt009w9kbmbbq7d0y9"},{"post_id":"cli00vmkt009v9kbm9zjp381u","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmku009z9kbmh5rbh71w"},{"post_id":"cli00vmkv00a19kbm68gk9iag","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmkw00a69kbmg0ud1rag"},{"post_id":"cli00vmkw00a59kbm1uxb45ob","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmkx00a99kbmf5kye6sy"},{"post_id":"cli00vmkw00a89kbm986j6yfy","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmky00ac9kbm0s7aeg63"},{"post_id":"cli00vmku009y9kbmhe4r1w9c","tag_id":"cli00vmkv00a39kbm83tjbrrc","_id":"cli00vml000af9kbmdyts1xv6"},{"post_id":"cli00vmkx00ab9kbmfl4gdixr","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vml100ai9kbm188b1vh0"},{"post_id":"cli00vmky00ae9kbm18lraylx","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vml400am9kbm3d0shfoj"},{"post_id":"cli00vml000ah9kbm8pj08sv0","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vml500ap9kbmfw920xs9"},{"post_id":"cli00vml200ak9kbmf6u57dqp","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vml500as9kbmd8ov6602"},{"post_id":"cli00vml400ao9kbm6vj4f1ez","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vml600av9kbm36oq3gng"},{"post_id":"cli00vml500ar9kbmb4gl9xke","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vml700ay9kbm9vj3ekpp"},{"post_id":"cli00vml600au9kbm97ru6a3n","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vml800b19kbm37fs5mmd"},{"post_id":"cli00vml600ax9kbmfy2n7u7i","tag_id":"cli00vmgf00039kbmgs8qfuak","_id":"cli00vml900b49kbmejl2cd82"},{"post_id":"cli00vml700b09kbmdnutelu7","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vml900b79kbmdhv1g1us"},{"post_id":"cli00vml900b69kbm4fr1h2xs","tag_id":"cli00vmkv00a39kbm83tjbrrc","_id":"cli00vmla00b99kbmd86m5rcb"},{"post_id":"cli00vmlc00bi9kbm66epcfes","tag_id":"cli00vmhs002h9kbm77stexq5","_id":"cli00vmlc00bj9kbm79zz90sc"}],"Tag":[{"name":"前端","_id":"cli00vmgf00039kbmgs8qfuak"},{"name":"随笔","_id":"cli00vmho00269kbmb1vkav5x"},{"name":"后端","_id":"cli00vmhs002h9kbm77stexq5"},{"name":"计算机","_id":"cli00vmkj00909kbmfo1359o4"},{"name":"java","_id":"cli00vmkv00a39kbm83tjbrrc"}]}}